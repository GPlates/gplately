<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>gplately.plot API documentation</title>
<meta name="description" content="Tools for reconstructing and plotting geological features and feature data through time …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.plot</code></h1>
</header>
<section id="section-intro">
<p>Tools for reconstructing and plotting geological features and feature data through time.</p>
<p>Methods in <code>plot.py</code> reconstruct geological features using
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.reconstruct.html">pyGPlates' <code>reconstruct</code> function</a>,
turns them into plottable Shapely geometries, and plots them onto Cartopy GeoAxes using Shapely and GeoPandas.</p>
<h2 id="classes">Classes</h2>
<p>PlotTopologies</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gplately.plot.plot_subduction_teeth"><code class="name flex">
<span>def <span class="ident">plot_subduction_teeth</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add subduction teeth to a plot.</p>
<p>The subduction polarity used for subduction teeth can be specified
manually or detected automatically if <code>geometries</code> is a
<code>geopandas.GeoDataFrame</code> object with a <code>polarity</code> column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geometries</code></strong> :&ensp;<code>geopandas.GeoDataFrame, sequence</code> of <code>shapely geometries,</code> or <code>str</code></dt>
<dd>If a <code>geopandas.GeoDataFrame</code> is given, its geometry attribute
will be used. If <code>geometries</code> is a string, it must be the path to
a file, which will be loaded with <code>geopandas.read_file</code>. Otherwise,
<code>geometries</code> must be a sequence of shapely geometry objects (instances
of the <code>shapely.geometry.base.BaseGeometry</code> class).</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>The (approximate) width of the subduction teeth. If a projection is
used, this value will be in projected units.</dd>
<dt><strong><code>polarity</code></strong> :&ensp;<code>{"left", "l", "right", "r", None}</code>, default <code>None</code></dt>
<dd>The subduction polarity of the geometries. If no polarity is provided,
and <code>geometries</code> is a <code>geopandas.GeoDataFrame</code>, this function will
attempt to find a <code>polarity</code> column in the data frame and use the
values given there. If <code>polarity</code> is not manually specified and no
appropriate column can be found, an error will be raised.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, default <code>None</code></dt>
<dd>If provided, the height of the subduction teeth. As with <code>width</code>,
this value should be given in projected units. If no value is given,
the height of the teeth will be equal to 0.6 * <code>width</code>.</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code>, default <code>None</code></dt>
<dd>If provided, the spacing between the subduction teeth. As with
<code>width</code> and <code>height</code>, this value should be given in projected units.
If no value is given, <code>spacing</code> will default to <code>width</code>, producing
tightly packed subduction teeth.</dd>
<dt><strong><code>projection</code></strong> :&ensp;<code>cartopy.crs.Transform, "auto",</code> or <code>None</code>, default <code>"auto"</code></dt>
<dd>The projection of the plot. If the plot has no projection, this value
can be explicitly given as <code>None</code>. The default value is "auto", which
will acquire the projection automatically from the plot axes.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>cartopy.crs.Transform,</code> or <code>None</code>, default <code>None</code></dt>
<dd>If the plot is projected, a <code>transform</code> value is usually needed.
Frequently, the appropriate value is an instance of
<code>cartopy.crs.PlateCarree</code>.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes,</code> or <code>None</code>, default <code>None</code></dt>
<dd>The axes on which the subduction teeth will be drawn. By default,
the current axes will be acquired using <code>matplotlib.pyplot.gca</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any further keyword arguments will be passed to
<code>matplotlib.patches.Polygon</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>width</code> &lt;= 0, or if <code>polarity</code> is an invalid value or could not
be determined.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.shapelify_feature_lines"><code class="name flex">
<span>def <span class="ident">shapelify_feature_lines</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Shapely <code>MultiPolygon</code> or <code>MultiLineString</code> geometries from reconstructed feature polygons.</p>
<h2 id="notes">Notes</h2>
<p>Some Shapely polygons generated by <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> cut longitudes of 180
or -180 degrees. These features may appear unclosed at the dateline, so Shapely
"closes" these polygons by connecting any of their open ends with lines. These
lines may manifest on GeoAxes plots as horizontal lines that span the entire
global extent. To prevent this, <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> uses pyGPlates'
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
to split a feature polygon into multiple closed polygons if it happens to cut the antimeridian.
Another measure taken to ensure features are valid is to order exterior coordinates
of Shapely polygons anti-clockwise.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>iterable</code> of <code>&lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt;</code> or <code>&lt;GeometryOnSphere&gt;</code></dt>
<dd>Iterable containing reconstructed polygon features.</dd>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>all_geometries</code></strong> :&ensp;<code>list</code> of <code>shapely.geometry.BaseGeometry</code></dt>
<dd>Shapely geometries converted from the given reconstructed features. Any
geometries at the dateline are split.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>geometry.pygplates_to_shapely</code></dt>
<dd>convert PyGPlates geometry objects to
<code>Shapely geometries.</code></dd>
</dl></div>
</dd>
<dt id="gplately.plot.shapelify_feature_polygons"><code class="name flex">
<span>def <span class="ident">shapelify_feature_polygons</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Shapely <code>MultiPolygon</code> or <code>MultiLineString</code> geometries from reconstructed feature polygons.</p>
<h2 id="notes">Notes</h2>
<p>Some Shapely polygons generated by <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> cut longitudes of 180
or -180 degrees. These features may appear unclosed at the dateline, so Shapely
"closes" these polygons by connecting any of their open ends with lines. These
lines may manifest on GeoAxes plots as horizontal lines that span the entire
global extent. To prevent this, <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> uses pyGPlates'
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
to split a feature polygon into multiple closed polygons if it happens to cut the antimeridian.
Another measure taken to ensure features are valid is to order exterior coordinates
of Shapely polygons anti-clockwise.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>iterable</code> of <code>&lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt;</code> or <code>&lt;GeometryOnSphere&gt;</code></dt>
<dd>Iterable containing reconstructed polygon features.</dd>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>all_geometries</code></strong> :&ensp;<code>list</code> of <code>shapely.geometry.BaseGeometry</code></dt>
<dd>Shapely geometries converted from the given reconstructed features. Any
geometries at the dateline are split.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>geometry.pygplates_to_shapely</code></dt>
<dd>convert PyGPlates geometry objects to
<code>Shapely geometries.</code></dd>
</dl></div>
</dd>
<dt id="gplately.plot.shapelify_features"><code class="name flex">
<span>def <span class="ident">shapelify_features</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Shapely <code>MultiPolygon</code> or <code>MultiLineString</code> geometries from reconstructed feature polygons.</p>
<h2 id="notes">Notes</h2>
<p>Some Shapely polygons generated by <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> cut longitudes of 180
or -180 degrees. These features may appear unclosed at the dateline, so Shapely
"closes" these polygons by connecting any of their open ends with lines. These
lines may manifest on GeoAxes plots as horizontal lines that span the entire
global extent. To prevent this, <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> uses pyGPlates'
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
to split a feature polygon into multiple closed polygons if it happens to cut the antimeridian.
Another measure taken to ensure features are valid is to order exterior coordinates
of Shapely polygons anti-clockwise.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>iterable</code> of <code>&lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt;</code> or <code>&lt;GeometryOnSphere&gt;</code></dt>
<dd>Iterable containing reconstructed polygon features.</dd>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>all_geometries</code></strong> :&ensp;<code>list</code> of <code>shapely.geometry.BaseGeometry</code></dt>
<dd>Shapely geometries converted from the given reconstructed features. Any
geometries at the dateline are split.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>geometry.pygplates_to_shapely</code></dt>
<dd>convert PyGPlates geometry objects to
<code>Shapely geometries.</code></dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.plot.PlotTopologies"><code class="flex name class">
<span>class <span class="ident">PlotTopologies</span></span>
<span>(</span><span>plate_reconstruction, coastlines=None, continents=None, COBs=None, time=None, anchor_plate_id=0, plot_engine: <a title="gplately.mapping.plot_engine.PlotEngine" href="mapping/plot_engine.html#gplately.mapping.plot_engine.PlotEngine">PlotEngine</a> = &lt;gplately.mapping.cartopy_plot.CartopyPlotEngine object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>A class with tools to read, reconstruct and plot topology features at specific
reconstruction times.</p>
<p><code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is a shorthand for PyGPlates and Shapely functionalities that:</p>
<ul>
<li>Read features held in GPlates GPML (GPlates Markup Language) files and
ESRI shapefiles;</li>
<li>Reconstruct the locations of these features as they migrate through
geological time;</li>
<li>Turn these reconstructed features into Shapely geometries for plotting
on <code>cartopy.mpl.geoaxes.GeoAxes</code> or <code>cartopy.mpl.geoaxes.GeoAxesSubplot</code> map
Projections.</li>
</ul>
<p>To call the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object, supply:</p>
<ul>
<li>an instance of the GPlately <code>plate_reconstruction</code> object</li>
</ul>
<p>and optionally,</p>
<ul>
<li>a <code>coastline_filename</code></li>
<li>a <code>continent_filename</code></li>
<li>a <code>COB_filename</code></li>
<li>a reconstruction <code>time</code></li>
<li>an <code>anchor_plate_id</code></li>
</ul>
<p>For example:</p>
<pre><code># Calling the PlotTopologies object
gplot = gplately.plot.PlotTopologies(plate_reconstruction,
                                    coastline_filename=None,
                                    continent_filename=None,
                                    COB_filename=None,
                                    time=None,
                                    anchor_plate_id=0,
        )

# Setting a new reconstruction time
gplot.time = 20 # Ma
</code></pre>
<p>The <code>coastline_filename</code>, <code>continent_filename</code> and <code>COB_filename</code> can be single
strings to GPML and/or shapefiles, as well as instances of <code>pygplates.FeatureCollection</code>.
If using GPlately's <code>DataServer</code> object to source these files, they will be passed as
<code>pygplates.FeatureCollection</code> items.</p>
<p>Some features for plotting (like plate boundaries) are taken from the <code>PlateReconstruction</code>
object's<code>topology_features</code> attribute. They have already been reconstructed to the given
<code>time</code> using <a href="https://github.com/EarthByte/PlateTectonicTools">Plate Tectonic Tools</a>.
Simply provide a new reconstruction time by changing the <code>time</code> attribute, e.g.</p>
<pre><code>gplot.time = 20 # Ma
</code></pre>
<p>which will automatically reconstruct all topologies to the specified time.
You <strong>MUST</strong> set <code>gplot.time</code> before plotting anything.</p>
<p>A variety of geological features can be plotted on GeoAxes/GeoAxesSubplot maps
as Shapely <code>MultiLineString</code> or <code>MultiPolygon</code> geometries, including:</p>
<ul>
<li>subduction boundaries &amp; subduction polarity teeth</li>
<li>mid-ocean ridge boundaries</li>
<li>transform boundaries</li>
<li>miscellaneous boundaries</li>
<li>coastline polylines</li>
<li>continental polygons and</li>
<li>continent-ocean boundary polylines</li>
<li>topological plate velocity vector fields</li>
<li>netCDF4 MaskedArray or ndarray raster data:<ul>
<li>seafloor age grids</li>
<li>paleo-age grids</li>
<li>global relief (topography and bathymetry)</li>
</ul>
</li>
<li>assorted reconstructable feature data, for example:<ul>
<li>seafloor fabric</li>
<li>large igneous provinces</li>
<li>volcanic provinces</li>
</ul>
</li>
</ul>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>plate_reconstruction</code></strong> :&ensp;<code>instance</code> of <code>&lt;gplately.reconstruction.PlateReconstruction&gt;</code></dt>
<dd>The GPlately <code>PlateReconstruction</code> object will be used to access a plate
<code>rotation_model</code> and a set of <code>topology_features</code> which contains plate boundary
features like trenches, ridges and transforms.</dd>
<dt><strong><code>anchor_plate_id</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>The anchor plate ID used for reconstruction.</dd>
<dt><strong><code>base_projection</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.crs.{transform}&gt;</code>, default <code>&lt;cartopy.crs.PlateCarree&gt; object</code></dt>
<dd>where {transform} is the map Projection to use on the Cartopy GeoAxes.
By default, the base projection is set to cartopy.crs.PlateCarree. See the
<a href="https://scitools.org.uk/cartopy/docs/v0.15/crs/projections.html">Cartopy projection list</a>
for all supported Projection types.</dd>
<dt><strong><code>coastlines</code></strong> :&ensp;<code>str,</code> or <code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>The full string path to a coastline feature file. Coastline features can also
be passed as instances of the <code>pygplates.FeatureCollection</code> object (this is
the case if these features are sourced from the <code>DataServer</code> object).</dd>
<dt><strong><code>continents</code></strong> :&ensp;<code>str,</code> or <code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>The full string path to a continent feature file. Continent features can also
be passed as instances of the <code>pygplates.FeatureCollection</code> object (this is
the case if these features are sourced from the <code>DataServer</code> object).</dd>
<dt><strong><code>COBs</code></strong> :&ensp;<code>str,</code> or <code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>The full string path to a COB feature file. COB features can also be passed
as instances of the <code>pygplates.FeatureCollection</code> object (this is the case
if these features are sourced from the <code>DataServer</code> object).</dd>
<dt><strong><code>coastlines</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.ReconstructedFeatureGeometry&gt;</code></dt>
<dd>A list containing coastline features reconstructed to the specified <code>time</code> attribute.</dd>
<dt><strong><code>continents</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.ReconstructedFeatureGeometry&gt;</code></dt>
<dd>A list containing continent features reconstructed to the specified <code>time</code> attribute.</dd>
<dt><strong><code>COBs</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.ReconstructedFeatureGeometry&gt;</code></dt>
<dd>A list containing COB features reconstructed to the specified <code>time</code> attribute.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>The time (Ma) to reconstruct and plot geological features to.</dd>
<dt><strong><code>topologies</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>
<p>A list containing assorted topologies like:</p>
<ul>
<li>pygplates.FeatureType.gpml_topological_network</li>
<li>pygplates.FeatureType.gpml_oceanic_crust</li>
<li>pygplates.FeatureType.gpml_topological_slab_boundary</li>
<li>pygplates.FeatureType.gpml_topological_closed_plate_boundary</li>
</ul>
</dd>
<dt><strong><code>ridges</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing ridge and transform boundary sections of type
pygplates.FeatureType.gpml_mid_ocean_ridge</dd>
<dt><strong><code>transforms</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing transform boundary sections of type pygplates.FeatureType.gpml_transforms</dd>
<dt><strong><code>trenches</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing trench boundary sections of type pygplates.FeatureType.gpml_subduction_zone</dd>
<dt><strong><code>trench_left</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing left subduction boundary sections of type pygplates.FeatureType.gpml_subduction_zone</dd>
<dt><strong><code>trench_right</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing right subduction boundary sections of type pygplates.FeatureType.gpml_subduction_zone</dd>
<dt><strong><code>other</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing other geological features like unclassified features, extended continental crusts,
continental rifts, faults, orogenic belts, fracture zones, inferred paleo boundaries, terrane
boundaries and passive continental boundaries.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlotTopologies(object):
    &#34;&#34;&#34;A class with tools to read, reconstruct and plot topology features at specific
    reconstruction times.

    `PlotTopologies` is a shorthand for PyGPlates and Shapely functionalities that:

    * Read features held in GPlates GPML (GPlates Markup Language) files and
    ESRI shapefiles;
    * Reconstruct the locations of these features as they migrate through
    geological time;
    * Turn these reconstructed features into Shapely geometries for plotting
    on `cartopy.mpl.geoaxes.GeoAxes` or `cartopy.mpl.geoaxes.GeoAxesSubplot` map
    Projections.

    To call the `PlotTopologies` object, supply:

    * an instance of the GPlately `plate_reconstruction` object

    and optionally,

    * a `coastline_filename`
    * a `continent_filename`
    * a `COB_filename`
    * a reconstruction `time`
    * an `anchor_plate_id`

    For example:

        # Calling the PlotTopologies object
        gplot = gplately.plot.PlotTopologies(plate_reconstruction,
                                            coastline_filename=None,
                                            continent_filename=None,
                                            COB_filename=None,
                                            time=None,
                                            anchor_plate_id=0,
                )

        # Setting a new reconstruction time
        gplot.time = 20 # Ma

    The `coastline_filename`, `continent_filename` and `COB_filename` can be single
    strings to GPML and/or shapefiles, as well as instances of `pygplates.FeatureCollection`.
    If using GPlately&#39;s `DataServer` object to source these files, they will be passed as
    `pygplates.FeatureCollection` items.

    Some features for plotting (like plate boundaries) are taken from the `PlateReconstruction`
    object&#39;s`topology_features` attribute. They have already been reconstructed to the given
    `time` using [Plate Tectonic Tools](https://github.com/EarthByte/PlateTectonicTools).
    Simply provide a new reconstruction time by changing the `time` attribute, e.g.

        gplot.time = 20 # Ma

    which will automatically reconstruct all topologies to the specified time.
    You __MUST__ set `gplot.time` before plotting anything.

    A variety of geological features can be plotted on GeoAxes/GeoAxesSubplot maps
    as Shapely `MultiLineString` or `MultiPolygon` geometries, including:

    * subduction boundaries &amp; subduction polarity teeth
    * mid-ocean ridge boundaries
    * transform boundaries
    * miscellaneous boundaries
    * coastline polylines
    * continental polygons and
    * continent-ocean boundary polylines
    * topological plate velocity vector fields
    * netCDF4 MaskedArray or ndarray raster data:
        - seafloor age grids
        - paleo-age grids
        - global relief (topography and bathymetry)
    * assorted reconstructable feature data, for example:
        - seafloor fabric
        - large igneous provinces
        - volcanic provinces

    Attributes
    ----------
    plate_reconstruction : instance of &lt;gplately.reconstruction.PlateReconstruction&gt;
        The GPlately `PlateReconstruction` object will be used to access a plate
        `rotation_model` and a set of `topology_features` which contains plate boundary
        features like trenches, ridges and transforms.

    anchor_plate_id : int, default 0
        The anchor plate ID used for reconstruction.

    base_projection : instance of &lt;cartopy.crs.{transform}&gt;, default &lt;cartopy.crs.PlateCarree&gt; object
        where {transform} is the map Projection to use on the Cartopy GeoAxes.
        By default, the base projection is set to cartopy.crs.PlateCarree. See the
        [Cartopy projection list](https://scitools.org.uk/cartopy/docs/v0.15/crs/projections.html)
        for all supported Projection types.

    coastlines : str, or instance of &lt;pygplates.FeatureCollection&gt;
        The full string path to a coastline feature file. Coastline features can also
        be passed as instances of the `pygplates.FeatureCollection` object (this is
        the case if these features are sourced from the `DataServer` object).

    continents : str, or instance of &lt;pygplates.FeatureCollection&gt;
        The full string path to a continent feature file. Continent features can also
        be passed as instances of the `pygplates.FeatureCollection` object (this is
        the case if these features are sourced from the `DataServer` object).

    COBs : str, or instance of &lt;pygplates.FeatureCollection&gt;
        The full string path to a COB feature file. COB features can also be passed
        as instances of the `pygplates.FeatureCollection` object (this is the case
        if these features are sourced from the `DataServer` object).

    coastlines : iterable/list of &lt;pygplates.ReconstructedFeatureGeometry&gt;
        A list containing coastline features reconstructed to the specified `time` attribute.

    continents : iterable/list of &lt;pygplates.ReconstructedFeatureGeometry&gt;
        A list containing continent features reconstructed to the specified `time` attribute.

    COBs : iterable/list of &lt;pygplates.ReconstructedFeatureGeometry&gt;
        A list containing COB features reconstructed to the specified `time` attribute.

    time : float
        The time (Ma) to reconstruct and plot geological features to.

    topologies : iterable/list of &lt;pygplates.Feature&gt;
        A list containing assorted topologies like:

        - pygplates.FeatureType.gpml_topological_network
        - pygplates.FeatureType.gpml_oceanic_crust
        - pygplates.FeatureType.gpml_topological_slab_boundary
        - pygplates.FeatureType.gpml_topological_closed_plate_boundary

    ridges : iterable/list of &lt;pygplates.Feature&gt;
        A list containing ridge and transform boundary sections of type
        pygplates.FeatureType.gpml_mid_ocean_ridge

    transforms : iterable/list of &lt;pygplates.Feature&gt;
        A list containing transform boundary sections of type pygplates.FeatureType.gpml_transforms

    trenches : iterable/list of &lt;pygplates.Feature&gt;
        A list containing trench boundary sections of type pygplates.FeatureType.gpml_subduction_zone

    trench_left : iterable/list of &lt;pygplates.Feature&gt;
        A list containing left subduction boundary sections of type pygplates.FeatureType.gpml_subduction_zone

    trench_right : iterable/list of &lt;pygplates.Feature&gt;
        A list containing right subduction boundary sections of type pygplates.FeatureType.gpml_subduction_zone

    other : iterable/list of &lt;pygplates.Feature&gt;
        A list containing other geological features like unclassified features, extended continental crusts,
        continental rifts, faults, orogenic belts, fracture zones, inferred paleo boundaries, terrane
        boundaries and passive continental boundaries.

    &#34;&#34;&#34;

    def __init__(
        self,
        plate_reconstruction,
        coastlines=None,
        continents=None,
        COBs=None,
        time=None,
        anchor_plate_id=0,
        plot_engine: PlotEngine = CartopyPlotEngine(),
    ):
        self._plot_engine = plot_engine
        self.plate_reconstruction = plate_reconstruction

        if self.plate_reconstruction.topology_features is None:
            self.plate_reconstruction.topology_features = []
            logger.warning(&#34;Plate model does not have topology features.&#34;)

        self.base_projection = DEFAULT_CARTOPY_PROJECTION

        # store these for when time is updated
        # make sure these are initialised as FeatureCollection objects

        self._coastlines = _load_FeatureCollection(coastlines)
        self._continents = _load_FeatureCollection(continents)
        self._COBs = _load_FeatureCollection(COBs)

        self.coastlines = None
        self.continents = None
        self.COBs = None
        self._topological_plate_boundaries = None
        self._topologies = None
        self._ridges = []
        self._transforms = []

        self._anchor_plate_id = self._check_anchor_plate_id(anchor_plate_id)
        self._plot_engine = plot_engine

        self._time = None
        if time is not None:
            # setting time runs the update_time routine
            self.time = time

    def __reduce__(self):
        # Arguments for __init__.
        #
        # Only one argument is required by __init__, and that&#39;s a PlateReconstruction object (which&#39;ll get pickled).
        init_args = (self.plate_reconstruction,)

        # State for __setstate__.
        state = self.__dict__.copy()

        # Remove &#39;plate_reconstruction&#39; since that will get passed to __init__.
        del state[&#34;plate_reconstruction&#34;]

        # Remove the unpicklable entries.
        #
        # This includes pygplates reconstructed feature geometries and resolved topological geometries.
        # Note: PyGPlates features and features collections (and rotation models) can be pickled though.
        #
        # __setstate__ will call &#39;update_time()&#39; to generate these reconstructed/resolved geometries/features.
        # So we don&#39;t need to pickle them.
        # Note: Some of them we can pickle (eg, &#34;resolved features&#34;, which are of type pygplates.Feature) and
        #       some we cannot (like &#39;coastlines&#39; which are of type pygplates.ReconstructedFeatureGeometry).
        #       However, as mentioned, we won&#39;t pickle any of them (since taken care of by &#39;update_time()&#39;).
        for key in (
            &#34;coastlines&#34;,  # we&#39;re keeping &#34;_coastlines&#34; though (we need the original &#39;pygplates.Feature&#39;s to reconstruct with)
            &#34;continents&#34;,  # we&#39;re keeping &#34;_continents&#34; though (we need the original &#39;pygplates.Feature&#39;s to reconstruct with)
            &#34;COBs&#34;,  # we&#39;re keeping &#34;_COBs&#34; though (we need the original &#39;pygplates.Feature&#39;s to reconstruct with)
            &#34;_topological_plate_boundaries&#34;,
            &#34;_ridges&#34;,
            &#34;_ridges_do_not_use_for_now&#34;,
            &#34;_transforms&#34;,
            &#34;_transforms_do_not_use_for_now&#34;,
            &#34;trenches&#34;,
            &#34;trench_left&#34;,
            &#34;trench_right&#34;,
            &#34;other&#34;,
            &#34;_topologies&#34;,
            &#34;continental_rifts&#34;,
            &#34;faults&#34;,
            &#34;fracture_zones&#34;,
            &#34;inferred_paleo_boundaries&#34;,
            &#34;terrane_boundaries&#34;,
            &#34;transitional_crusts&#34;,
            &#34;orogenic_belts&#34;,
            &#34;sutures&#34;,
            &#34;continental_crusts&#34;,
            &#34;extended_continental_crusts&#34;,
            &#34;passive_continental_boundaries&#34;,
            &#34;slab_edges&#34;,
            &#34;unclassified_features&#34;,
        ):
            if key in state:  # in case some state has not been initialised yet
                del state[key]

        # Call __init__ so that we default initialise everything in a consistent state before __setstate__ gets called.
        # Note that this is the reason we implement __reduce__, instead of __getstate__ (where __init__ doesn&#39;t get called).
        #
        # If we don&#39;t do this then __setstate__ would need to stay in sync with __init__ (whenever it gets updated).
        return PlotTopologies, init_args, state

    def __setstate__(self, state):
        self.__dict__.update(state)

        # Restore the unpicklable entries.
        #
        # This includes pygplates reconstructed feature geometries and resolved topological geometries.
        # Note: PyGPlates features and features collections (and rotation models) can be pickled though.
        #
        # Re-generate the pygplates reconstructed feature geometries and resolved topological geometries
        # deleted from the state returned by __reduce__.
        if self.time is not None:
            self.update_time(self.time)

    @property
    def topological_plate_boundaries(self):
        if self._topological_plate_boundaries is None:
            if self.time is not None:
                self.update_time(self.time)
        return self._topological_plate_boundaries

    @property
    def topologies(self):
        self._resolve_both_boundaries_and_networks()
        return self._topologies

    @property
    def ridges(self):
        &#34;&#34;&#34;
        Mid-ocean ridge features (all the features which are labelled as gpml:MidOceanRidge in the model).
        &#34;&#34;&#34;
        logger.debug(
            &#34;The &#39;ridges&#39; property has been changed since GPlately 1.3.0. &#34;
            &#34;You need to check your workflow to make sure the new &#39;ridges&#39; property still suits your purpose. &#34;
            &#34;In earlier releases of GPlately, we used an algorithm to identify the &#39;ridges&#39; and &#39;transforms&#39; within the gpml:MidOceanRidge features. &#34;
            &#34;Unfortunately, the algorithm did not work very well. So we have removed the algorithm and now the &#39;ridges&#39; property contains all the features &#34;
            &#34;which are labelled as gpml:MidOceanRidge in the reconstruction model.&#34;
        )  # use logger.debug to make the message less aggressive
        return self._ridges

    @property
    def transforms(self):
        &#34;&#34;&#34;
        Transform boundary features (all the features which are labelled as gpml:Transform in the model).
        &#34;&#34;&#34;
        logger.debug(
            &#34;The &#39;transforms&#39; property has been changed since GPlately 1.3.0. &#34;
            &#34;You need to check your workflow to make sure the new &#39;transforms&#39; property still suits your purpose. &#34;
            &#34;In earlier releases of GPlately, we used an algorithm to identify the &#39;ridges&#39; and &#39;transforms&#39; within the gpml:MidOceanRidge features. &#34;
            &#34;Unfortunately, the algorithm did not work very well. So we have removed the algorithm and now the &#39;transforms&#39; property contains all the features &#34;
            &#34;which are labelled as gpml:Transform in the reconstruction model.&#34;
        )  # use logger.debug to make the message less aggressive
        return self._transforms

    @property
    def time(self):
        &#34;&#34;&#34;The reconstruction time.&#34;&#34;&#34;
        return self._time

    @time.setter
    def time(self, var):
        &#34;&#34;&#34;Allows the time attribute to be changed. Updates all instances of the time attribute in the object (e.g.
        reconstructions and resolving topologies will use this new time).

        Raises
        ------
        ValueError
            If the chosen reconstruction time is &lt;0 Ma.
        &#34;&#34;&#34;
        if var &lt; 0:
            raise ValueError(&#34;The &#39;time&#39; property must be greater than 0.&#34;)

        if self.time is None or (not math.isclose(var, self.time)):
            self.update_time(var)

    @property
    def anchor_plate_id(self):
        &#34;&#34;&#34;Anchor plate ID for reconstruction. Must be an integer &gt;= 0.&#34;&#34;&#34;
        return self._anchor_plate_id

    @anchor_plate_id.setter
    def anchor_plate_id(self, anchor_plate):
        self._anchor_plate_id = self._check_anchor_plate_id(anchor_plate)
        if self.time is not None:
            self.update_time(self.time)

    @staticmethod
    def _check_anchor_plate_id(id):
        id = int(id)
        if id &lt; 0:
            raise ValueError(&#34;Invalid anchor plate ID: {}&#34;.format(id))
        return id

    @validate_reconstruction_time
    @property
    def ridge_transforms(self):
        &#34;&#34;&#34;
        Deprecated! DO NOT USE!
        &#34;&#34;&#34;

        warnings.warn(
            &#34;Deprecated! DO NOT USE!&#34;
            &#34;The &#39;ridge_transforms&#39; property will be removed in the future GPlately releases. &#34;
            &#34;Update your workflow to use the &#39;ridges&#39; and &#39;transforms&#39; properties instead, &#34;
            &#34;otherwise your workflow will not work with the future GPlately releases.&#34;,
            DeprecationWarning,
            stacklevel=2,
        )
        logger.debug(
            &#34;The &#39;ridge_transforms&#39; property has been changed since GPlately 1.3.0. &#34;
            &#34;You need to check your workflow to make sure the new &#39;ridge_transforms&#39; property still suits your purpose. &#34;
            &#34;In earlier releases of GPlately, the &#39;ridge_transforms&#39; property contains only the features &#34;
            &#34;which are labelled as gpml:MidOceanRidge in the reconstruction model. &#34;
            &#34;Now, the &#39;ridge_transforms&#39; property contains both gpml:Transform and gpml:MidOceanRidge features.&#34;
        )
        return self._ridges + self._transforms

    def update_time(self, time):
        &#34;&#34;&#34;Re-reconstruct features and topologies to the time specified by the `PlotTopologies` `time` attribute
        whenever it or the anchor plate is updated.

        Notes
        -----
        The following `PlotTopologies` attributes are updated whenever a reconstruction `time` attribute is set:

        - resolved topology features (topological plates and networks)
        - ridge and transform boundary sections (resolved features)
        - ridge boundary sections (resolved features)
        - transform boundary sections (resolved features)
        - subduction boundary sections (resolved features)
        - left subduction boundary sections (resolved features)
        - right subduction boundary sections (resolved features)
        - other boundary sections (resolved features) that are not subduction zones or mid-ocean ridges
        (ridge/transform)

        Moreover, coastlines, continents and COBs are reconstructed to the new specified `time`.
        &#34;&#34;&#34;
        assert time is not None, &#34;time must be set to a valid reconstruction time&#34;

        #
        # NOTE: If you add a new data member here that&#39;s a pygplates reconstructable feature geometry or resolved topological geometry,
        #       then be sure to also include it in __getstate__/()__setstate__()
        #       (basically anything reconstructed or resolved by pygplates since those cannot be pickled).
        #

        self._time = float(time)
        (
            self._topological_plate_boundaries,
            self._ridges,
            self._ridges_do_not_use_for_now,  # the algorithm to separate ridges and transforms has not been ready yet
            self._transforms_do_not_use_for_now,
            self.trenches,
            self.trench_left,
            self.trench_right,
            self.other,
        ) = ptt.resolve_topologies.resolve_topologies_into_features(
            self.plate_reconstruction.rotation_model,
            self.plate_reconstruction.topology_features,
            self.time,
            anchor_plate_id=self.anchor_plate_id,
            # use ResolveTopologyType.boundary parameter to resolve rigid plate boundary only
            # because the Mid-ocean ridges(and transforms) should not contain lines from topological networks
            resolve_topology_types=pygplates.ResolveTopologyType.boundary,  # type: ignore
        )
        self._topologies = None

        # miscellaneous boundaries
        self.continental_rifts = []
        self.faults = []
        self.fracture_zones = []
        self.inferred_paleo_boundaries = []
        self.terrane_boundaries = []
        self.transitional_crusts = []
        self.orogenic_belts = []
        self.sutures = []
        self.continental_crusts = []
        self.extended_continental_crusts = []
        self.passive_continental_boundaries = []
        self.slab_edges = []
        self.unclassified_features = []

        self._transforms = []

        for topol in self.other:
            if topol.get_feature_type() == pygplates.FeatureType.gpml_continental_rift:  # type: ignore
                self.continental_rifts.append(topol)

            elif topol.get_feature_type() == pygplates.FeatureType.gpml_fault:  # type: ignore
                self.faults.append(topol)

            elif topol.get_feature_type() == pygplates.FeatureType.gpml_fracture_zone:  # type: ignore
                self.fracture_zones.append(topol)

            elif (
                topol.get_feature_type()
                == pygplates.FeatureType.gpml_inferred_paleo_boundary  # type: ignore
            ):
                self.inferred_paleo_boundaries.append(topol)

            elif (
                topol.get_feature_type() == pygplates.FeatureType.gpml_terrane_boundary  # type: ignore
            ):
                self.terrane_boundaries.append(topol)

            elif (
                topol.get_feature_type()
                == pygplates.FeatureType.gpml_transitional_crust  # type: ignore
            ):
                self.transitional_crusts.append(topol)

            elif topol.get_feature_type() == pygplates.FeatureType.gpml_orogenic_belt:  # type: ignore
                self.orogenic_belts.append(topol)

            elif topol.get_feature_type() == pygplates.FeatureType.gpml_suture:  # type: ignore
                self.sutures.append(topol)

            elif (
                topol.get_feature_type() == pygplates.FeatureType.gpml_continental_crust  # type: ignore
            ):
                self.continental_crusts.append(topol)

            elif (
                topol.get_feature_type()
                == pygplates.FeatureType.gpml_extended_continental_crust  # type: ignore
            ):
                self.extended_continental_crusts.append(topol)

            elif (
                topol.get_feature_type()
                == pygplates.FeatureType.gpml_passive_continental_boundary  # type: ignore
            ):
                self.passive_continental_boundaries.append(topol)

            elif topol.get_feature_type() == pygplates.FeatureType.gpml_slab_edge:  # type: ignore
                self.slab_edges.append(topol)

            elif topol.get_feature_type() == pygplates.FeatureType.gpml_transform:  # type: ignore
                self._transforms.append(topol)

            elif (
                topol.get_feature_type()
                == pygplates.FeatureType.gpml_unclassified_feature  # type: ignore
            ):
                self.unclassified_features.append(topol)

        # reconstruct other important polygons and lines
        if self._coastlines:
            self.coastlines = self.plate_reconstruction.reconstruct(
                self._coastlines,
                self.time,
                from_time=0,
                anchor_plate_id=self.anchor_plate_id,
            )

        if self._continents:
            self.continents = self.plate_reconstruction.reconstruct(
                self._continents,
                self.time,
                from_time=0,
                anchor_plate_id=self.anchor_plate_id,
            )

        if self._COBs:
            self.COBs = self.plate_reconstruction.reconstruct(
                self._COBs, self.time, from_time=0, anchor_plate_id=self.anchor_plate_id
            )

    # subduction teeth
    def _tessellate_triangles(
        self, features, tesselation_radians, triangle_base_length, triangle_aspect=1.0
    ):
        &#34;&#34;&#34;Places subduction teeth along subduction boundary line segments within a MultiLineString shapefile.

        Parameters
        ----------
        shapefilename  : str
            Path to shapefile containing the subduction boundary features

        tesselation_radians : float
            Parametrises subduction teeth density. Triangles are generated only along line segments with distances
            that exceed the given threshold tessellation_radians.

        triangle_base_length : float
            Length of teeth triangle base

        triangle_aspect : float, default=1.0
            Aspect ratio of teeth triangles. Ratio is 1.0 by default.

        Returns
        -------
        X_points : (n,3) array
            X points that define the teeth triangles
        Y_points : (n,3) array
            Y points that define the teeth triangles
        &#34;&#34;&#34;

        tesselation_degrees = np.degrees(tesselation_radians)
        triangle_pointsX = []
        triangle_pointsY = []

        date_line_wrapper = pygplates.DateLineWrapper()  # type: ignore

        for feature in features:
            cum_distance = 0.0

            for geometry in feature.get_geometries():
                wrapped_lines = date_line_wrapper.wrap(geometry)
                for line in wrapped_lines:
                    pts = np.array(
                        [
                            (p.get_longitude(), p.get_latitude())
                            for p in line.get_points()
                        ]
                    )

                    for p in range(0, len(pts) - 1):
                        A = pts[p]
                        B = pts[p + 1]

                        AB_dist = B - A
                        AB_norm = AB_dist / np.hypot(*AB_dist)
                        cum_distance += np.hypot(*AB_dist)

                        # create a new triangle if cumulative distance is exceeded.
                        if cum_distance &gt;= tesselation_degrees:
                            C = A + triangle_base_length * AB_norm

                            # find normal vector
                            AD_dist = np.array([AB_norm[1], -AB_norm[0]])
                            AD_norm = AD_dist / np.linalg.norm(AD_dist)

                            C0 = A + 0.5 * triangle_base_length * AB_norm

                            # project point along normal vector
                            D = C0 + triangle_base_length * triangle_aspect * AD_norm

                            triangle_pointsX.append([A[0], C[0], D[0]])
                            triangle_pointsY.append([A[1], C[1], D[1]])

                            cum_distance = 0.0

        return np.array(triangle_pointsX), np.array(triangle_pointsY)

    @validate_reconstruction_time
    def get_feature(
        self,
        feature,
        central_meridian=0.0,
        tessellate_degrees=None,
        validate_reconstruction_time=True,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed features.

        Notes
        -----
        The feature needed to produce the GeoDataFrame should already be constructed to a `time`.
        This function converts the feature into a set of Shapely geometries whose coordinates are
        passed to a geopandas GeoDataFrame.

        Parameters
        ----------
        feature : instance of &lt;pygplates.Feature&gt;
            A feature reconstructed to `time`.

        Returns
        -------
        gdf : instance of &lt;geopandas.GeoDataFrame&gt;
            A pandas.DataFrame that has a column with `feature` geometries.

        &#34;&#34;&#34;

        if feature is None:
            raise ValueError(
                &#34;The &#39;feature&#39; parameter is None. Make sure a valid `feature` object has been provided.&#34;
            )
        shp = shapelify_features(
            feature,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

        return gpd.GeoDataFrame({&#34;geometry&#34;: shp}, geometry=&#34;geometry&#34;, crs=&#34;EPSG:4326&#34;)  # type: ignore

    @append_docstring(PLOT_DOCSTRING.format(&#34;feature&#34;))
    def plot_feature(self, ax, feature, feature_name=&#34;&#34;, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot pygplates.FeatureCollection or pygplates.Feature onto a map.&#34;&#34;&#34;
        if not feature:
            logger.warning(
                f&#34;The given feature({feature_name}:{feature}) in model:{self.plate_reconstruction.plate_model_name} is empty and will not be plotted.&#34;
            )
            return ax
        else:
            if &#34;edgecolor&#34; not in kwargs.keys():
                kwargs[&#34;edgecolor&#34;] = color
            if &#34;facecolor&#34; not in kwargs.keys():
                kwargs[&#34;facecolor&#34;] = &#34;none&#34;
            return self._plot_feature(ax, partial(self.get_feature, feature), **kwargs)

    def _plot_feature(self, ax, get_feature_func, **kwargs) -&gt; None:
        if &#34;transform&#34; in kwargs.keys():
            warnings.warn(
                &#34;&#39;transform&#39; keyword argument is ignored by PlotTopologies&#34;,
                UserWarning,
            )
            kwargs.pop(&#34;transform&#34;)
        tessellate_degrees = kwargs.pop(&#34;tessellate_degrees&#34;, 1)
        central_meridian = kwargs.pop(&#34;central_meridian&#34;, None)
        if central_meridian is None:
            central_meridian = _meridian_from_ax(ax)

        if not callable(get_feature_func):
            raise Exception(&#34;The &#39;get_feature_func&#39; parameter must be callable.&#34;)
        gdf = get_feature_func(
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

        if not isinstance(gdf, gpd.GeoDataFrame):
            raise Exception(
                f&#34;Expecting a GeoDataFrame object, but the gdf is {type(gdf)}&#34;
            )

        if len(gdf) == 0:
            logger.debug(&#34;No feature found for plotting. Do nothing and return.&#34;)
            return ax

        self._plot_engine.plot_geo_data_frame(ax, gdf, **kwargs)

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;coastlines&#34;))
    def get_coastlines(self, central_meridian=0.0, tessellate_degrees=None):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed coastline polygons.&#34;&#34;&#34;
        return self.get_feature(
            self.coastlines,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;coastlines&#34;))
    def plot_coastlines(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed coastline polygons onto a standard map Projection.

        Notes
        -----
        The `coastlines` for plotting are accessed from the `PlotTopologies` object&#39;s `coastlines` attribute.
        These `coastlines` are reconstructed to the `time` passed to the `PlotTopologies` object and converted into Shapely polylines.
        The reconstructed `coastlines` are added onto the GeoAxes or GeoAxesSubplot map `ax` using GeoPandas.
        Map resentation details (e.g. facecolor, edgecolor, alpha…) are permitted as keyword arguments.
        &#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.coastlines,
            feature_name=&#34;coastlines&#34;,
            color=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;continents&#34;))
    def get_continents(self, central_meridian=0.0, tessellate_degrees=None):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed continental polygons.&#34;&#34;&#34;
        return self.get_feature(
            self.continents,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;continents&#34;))
    def plot_continents(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed continental polygons onto a standard map Projection.

        Notes
        -----
        The `continents` for plotting are accessed from the `PlotTopologies` object&#39;s `continents` attribute.
        These `continents` are reconstructed to the `time` passed to the `PlotTopologies` object and converted into Shapely polygons.
        The reconstructed `coastlines` are plotted onto the GeoAxes or GeoAxesSubplot map `ax` using GeoPandas.
        Map presentation details (e.g. facecolor, edgecolor, alpha…) are permitted as keyword arguments.
        &#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.continents,
            feature_name=&#34;continents&#34;,
            color=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;COBs&#34;))
    def get_continent_ocean_boundaries(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed continent-ocean boundary lines.&#34;&#34;&#34;
        return self.get_feature(
            self.COBs,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;continent ocean boundaries&#34;))
    def plot_continent_ocean_boundaries(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed continent-ocean boundary (COB) polygons onto a standard map Projection.

        Notes
        -----
        The `COBs` for plotting are accessed from the `PlotTopologies` object&#39;s
        `COBs` attribute. These `COBs` are reconstructed to the `time`
        passed to the `PlotTopologies` object and converted into Shapely polylines.
        The reconstructed `COBs` are plotted onto the GeoAxes or GeoAxesSubplot map
        `ax` using GeoPandas. Map presentation details (e.g. `facecolor`, `edgecolor`, `alpha`…)
        are permitted as keyword arguments.

        These COBs are transformed into shapely geometries and added onto the chosen map for a specific geological time
        (supplied to the PlotTopologies object). Map presentation details (e.g. facecolor, edgecolor, alpha…) are permitted.
        &#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.COBs,
            feature_name=&#34;continent_ocean_boundaries&#34;,
            color=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;ridges&#34;))
    def get_ridges(
        self,
        central_meridian=0.0,
        tessellate_degrees=1,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing the geometries of reconstructed mid-ocean ridge lines (gpml:MidOceanRidge).&#34;&#34;&#34;
        logger.debug(
            &#34;The &#39;get_ridges&#39; function has been changed since GPlately 1.3.0. &#34;
            &#34;You need to check your workflow to make sure the new &#39;get_ridges&#39; function still suits your purpose. &#34;
            &#34;In earlier releases of GPlately, we used an algorithm to identify the &#39;ridges&#39; and &#39;transforms&#39; within the gpml:MidOceanRidge features. &#34;
            &#34;Unfortunately, the algorithm did not work very well. So we have removed the algorithm and now the &#39;get_ridges&#39; function returns all the features &#34;
            &#34;which are labelled as gpml:MidOceanRidge in the reconstruction model.&#34;
        )  # use logger.debug to make the message less aggressive

        return self.get_feature(
            self.ridges,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @validate_topology_availability(&#34;ridges&#34;)
    @append_docstring(PLOT_DOCSTRING.format(&#34;ridges&#34;))
    def plot_ridges(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed mid-ocean ridge lines(gpml:MidOceanRidge) onto a map.

        Notes
        -----
        The `ridges` sections for plotting are accessed from the
        `PlotTopologies` object&#39;s `ridges` attribute. These `ridges`
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted
        into Shapely polylines. The reconstructed `ridges` are plotted onto the
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Note: The `ridges` geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
        by splitting a polyline into multiple polylines at the dateline. This is to avoid
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
        compatibility with Cartopy.
        &#34;&#34;&#34;

        logger.debug(
            &#34;The &#39;plot_ridges&#39; function has been changed since GPlately 1.3.0. &#34;
            &#34;You need to check your workflow to make sure the new &#39;plot_ridges&#39; function still suits your purpose. &#34;
            &#34;In earlier releases of GPlately, we used an algorithm to identify the &#39;ridges&#39; and &#39;transforms&#39; within the gpml:MidOceanRidge features. &#34;
            &#34;Unfortunately, the algorithm did not work very well. So we have removed the algorithm and now the &#39;plot_ridges&#39; function plots all the features &#34;
            &#34;which are labelled as gpml:MidOceanRidge in the reconstruction model.&#34;
        )  # use logger.debug to make the message less aggressive

        return self.plot_feature(
            ax,
            self._ridges,
            feature_name=&#34;ridges&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;trenches&#34;))
    def get_trenches(self, central_meridian=0.0, tessellate_degrees=1):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed trench lines.&#34;&#34;&#34;
        return self.get_feature(
            self.trenches,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    def get_ridges_and_transforms(self, central_meridian=0.0, tessellate_degrees=1):
        &#34;&#34;&#34;
        Deprecated! DO NOT USE.
        &#34;&#34;&#34;
        warnings.warn(
            &#34;Deprecated! The &#39;get_ridges_and_transforms&#39; function will be removed in the future GPlately releases. &#34;
            &#34;Update your workflow to use the &#39;get_ridges&#39; and &#39;get_transforms&#39; functions instead, &#34;
            &#34;otherwise your workflow will not work with the future GPlately releases.&#34;,
            DeprecationWarning,
            stacklevel=2,
        )
        logger.debug(
            &#34;The &#39;get_ridges_and_transforms&#39; function has been changed since GPlately 1.3.0. &#34;
            &#34;You need to check your workflow to make sure the new &#39;get_ridges_and_transforms&#39; function still suits your purpose. &#34;
            &#34;In earlier releases of GPlately, we used an algorithm to identify the &#39;ridges&#39; and &#39;transforms&#39; within the gpml:MidOceanRidge features. &#34;
            &#34;Unfortunately, the algorithm did not work very well. So we have removed the algorithm and now the &#39;get_ridges_and_transforms&#39; function returns all the features &#34;
            &#34;which are labelled as gpml:MidOceanRidge or gpml:Transform in the reconstruction model.&#34;
        )  # use logger.debug to make the message less aggressive

        return self.get_feature(
            self._ridges + self._transforms,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_topology_availability(&#34;trenches&#34;)
    @append_docstring(PLOT_DOCSTRING.format(&#34;trenches&#34;))
    def plot_trenches(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed subduction trench polylines onto a standard map
        Projection.

        Notes
        -----
        The trench sections for plotting are accessed from the
        `PlotTopologies` object&#39;s `trenches` attribute. These `trenches`
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted
        into Shapely polylines. The reconstructed `trenches` are plotted onto the
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Trench geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
        by splitting a polyline into multiple polylines at the dateline. This is to avoid
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
        compatibility with Cartopy.
        &#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.trenches,
            feature_name=&#34;trenches&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;other&#34;))
    def get_misc_boundaries(self, central_meridian=0.0, tessellate_degrees=1):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of other reconstructed lines.&#34;&#34;&#34;
        return self.get_feature(
            self.other,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;other&#34;))
    def plot_misc_boundaries(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed miscellaneous plate boundary polylines onto a standard
        map Projection.

        Notes
        -----
        The miscellaneous boundary sections for plotting are accessed from the
        `PlotTopologies` object&#39;s `other` attribute. These `other` boundaries
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted
        into Shapely polylines. The reconstructed `other` boundaries are plotted onto the
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Miscellaneous boundary geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
        by splitting a polyline into multiple polylines at the dateline. This is to avoid
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
        compatibility with Cartopy.
        &#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.other,
            feature_name=&#34;misc_boundaries&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    def plot_subduction_teeth_deprecated(
        self, ax, spacing=0.1, size=2.0, aspect=1, color=&#34;black&#34;, **kwargs
    ):
        &#34;&#34;&#34;Plot subduction teeth onto a standard map Projection.

        Notes
        -----
        Subduction teeth are tessellated from `PlotTopologies` object attributes `trench_left` and
        `trench_right`, and transformed into Shapely polygons for plotting.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        spacing : float, default=0.1
            The tessellation threshold (in radians). Parametrises subduction tooth density.
            Triangles are generated only along line segments with distances that exceed
            the given threshold ‘spacing’.

        size : float, default=2.0
            Length of teeth triangle base.

        aspect : float, default=1
            Aspect ratio of teeth triangles. Ratio is 1.0 by default.

        color : str, default=’black’
            The colour of the teeth. By default, it is set to black.

        **kwargs :
            Keyword arguments for parameters such as ‘alpha’, etc. for
            plotting subduction tooth polygons.
            See `Matplotlib` keyword arguments
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
            with subduction teeth plotted onto the chosen map projection.
        &#34;&#34;&#34;
        import shapely

        # add Subduction Teeth
        subd_xL, subd_yL = self._tessellate_triangles(
            self.trench_left,
            tesselation_radians=spacing,
            triangle_base_length=size,
            triangle_aspect=-aspect,
        )
        subd_xR, subd_yR = self._tessellate_triangles(
            self.trench_right,
            tesselation_radians=spacing,
            triangle_base_length=size,
            triangle_aspect=aspect,
        )

        teeth = []
        for tX, tY in zip(subd_xL, subd_yL):
            triangle_xy_points = np.c_[tX, tY]
            shp = shapely.geometry.Polygon(triangle_xy_points)
            teeth.append(shp)

        for tX, tY in zip(subd_xR, subd_yR):
            triangle_xy_points = np.c_[tX, tY]
            shp = shapely.geometry.Polygon(triangle_xy_points)
            teeth.append(shp)

        return ax.add_geometries(teeth, crs=self.base_projection, color=color, **kwargs)

    @validate_reconstruction_time
    def get_subduction_direction(self, central_meridian=0.0, tessellate_degrees=None):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of trench directions.

        Notes
        -----
        The `trench_left` and `trench_right` geometries needed to produce the GeoDataFrame are automatically
        constructed if the optional `time` parameter is passed to the `PlotTopologies` object before calling
        this function. `time` can be passed either when `PlotTopologies` is first called...

            gplot = gplately.PlotTopologies(..., time=100,...)

        or anytime afterwards, by setting:

            time = 100 #Ma
            gplot.time = time

        ...after which this function can be re-run. Once the `other` geometries are reconstructed, they are
        converted into Shapely features whose coordinates are passed to a geopandas GeoDataFrame.

        Returns
        -------
        gdf_left : instance of &lt;geopandas.GeoDataFrame&gt;
            A pandas.DataFrame that has a column with `trench_left` geometry.
        gdf_right : instance of &lt;geopandas.GeoDataFrame&gt;
            A pandas.DataFrame that has a column with `trench_right` geometry.

        Raises
        ------
        ValueError
            If the optional `time` parameter has not been passed to `PlotTopologies`. This is needed to construct
            `trench_left` or `trench_right` geometries to the requested `time` and thus populate the GeoDataFrame.
        &#34;&#34;&#34;
        if self.trench_left is None or self.trench_right is None:
            raise Exception(
                &#34;No subduction zone/trench data is found. Make sure the plate model has topology feature.&#34;
            )

        trench_left_features = shapelify_feature_lines(
            self.trench_left,
            tessellate_degrees=tessellate_degrees,
            central_meridian=central_meridian,
        )
        trench_right_features = shapelify_feature_lines(
            self.trench_right,
            tessellate_degrees=tessellate_degrees,
            central_meridian=central_meridian,
        )

        gdf_left = gpd.GeoDataFrame(
            {&#34;geometry&#34;: trench_left_features}, geometry=&#34;geometry&#34;, crs=&#34;EPSG:4326&#34;
        )  # type: ignore
        gdf_right = gpd.GeoDataFrame(
            {&#34;geometry&#34;: trench_right_features}, geometry=&#34;geometry&#34;, crs=&#34;EPSG:4326&#34;
        )  # type: ignore

        return gdf_left, gdf_right

    @validate_reconstruction_time
    @validate_topology_availability(&#34;Subduction Zones&#34;)
    def plot_subduction_teeth(
        self, ax, spacing=0.07, size=None, aspect=None, color=&#34;black&#34;, **kwargs
    ) -&gt; None:
        &#34;&#34;&#34;Plot subduction teeth onto a standard map Projection.

        Notes
        -----
        Subduction teeth are tessellated from `PlotTopologies` object attributes `trench_left` and
        `trench_right`, and transformed into Shapely polygons for plotting.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        spacing : float, default=0.07
            The tessellation threshold (in radians). Parametrises subduction tooth density.
            Triangles are generated only along line segments with distances that exceed
            the given threshold `spacing`.

        size : float, default=None
            Length of teeth triangle base (in radians). If kept at `None`, then
            `size = 0.5*spacing`.

        aspect : float, default=None
            Aspect ratio of teeth triangles. If kept at `None`, then `aspect = 2/3*size`.

        color : str, default=&#39;black&#39;
            The colour of the teeth. By default, it is set to black.

        **kwargs :
            Keyword arguments parameters such as `alpha`, etc.
            for plotting subduction tooth polygons.
            See `Matplotlib` keyword arguments
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).
        &#34;&#34;&#34;
        kwargs[&#34;spacing&#34;] = spacing
        kwargs[&#34;size&#34;] = size
        kwargs[&#34;aspect&#34;] = aspect

        central_meridian = _meridian_from_ax(ax)
        tessellate_degrees = np.rad2deg(spacing)
        gdf_subduction_left, gdf_subduction_right = self.get_subduction_direction(
            tessellate_degrees=tessellate_degrees, central_meridian=central_meridian
        )

        self._plot_engine.plot_subduction_zones(
            ax, gdf_subduction_left, gdf_subduction_right, color=color, **kwargs
        )

    def plot_plate_polygon_by_id(self, ax, plate_id, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot a plate polygon with an associated `plate_id` onto a standard map Projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        plate_id : int
            A plate ID that identifies the continental polygon to plot. See the
            [Global EarthByte plate IDs list](https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/SampleData/FeatureCollections/Rotations/Global_EarthByte_PlateIDs_20071218.pdf)
            for a full list of plate IDs to plot.

        **kwargs :
            Keyword arguments for map presentation parameters such as
            `alpha`, etc. for plotting the grid.
            See `Matplotlib`&#39;s `imshow` keyword arguments
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        &#34;&#34;&#34;
        features = []
        if self.topologies:
            features = (
                [
                    feature
                    for feature in self.topologies
                    if feature.get_reconstruction_plate_id() == plate_id
                ],
            )
        self.plot_feature(
            ax,
            features,
            color=color,
            **kwargs,
        )

    def plot_plate_id(self, *args, **kwargs):
        &#34;&#34;&#34;TODO: remove this function

        The function name plot_plate_id() is bad and should be changed.
        The new name is plot_plate_polygon_by_id().
        For backward compatibility, we allow users to use the old name in their legcy code for now.
        No new code should call this function.

        &#34;&#34;&#34;
        logger.warning(
            &#34;The class method plot_plate_id is deprecated and will be removed in the future soon. Use plot_plate_polygon_by_id instead.&#34;
        )
        return self.plot_plate_polygon_by_id(*args, **kwargs)

    def plot_grid(self, ax, grid, extent=[-180, 180, -90, 90], **kwargs):
        &#34;&#34;&#34;Plot a `MaskedArray` raster or grid onto a standard map Projection.

        Notes
        -----
        Uses Matplotlib&#39;s `imshow`
        [function](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        grid : MaskedArray or `gplately.grids.Raster`
            A `MaskedArray` with elements that define a grid. The number of rows in the raster
            corresponds to the number of latitudinal coordinates, while the number of raster
            columns corresponds to the number of longitudinal coordinates.

        extent : 1d array, default=[-180,180,-90,90]
            A four-element array to specify the [min lon, max lon, min lat, max lat] with
            which to constrain the grid image. If no extents are supplied, full global
            extent is assumed.

        **kwargs :
            Keyword arguments for map presentation parameters such as
            `alpha`, etc. for plotting the grid.
            See `Matplotlib`&#39;s `imshow` keyword arguments
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
            with the grid plotted onto the chosen map projection.
        &#34;&#34;&#34;
        # Override matplotlib default origin (&#39;upper&#39;)
        origin = kwargs.pop(&#34;origin&#34;, &#34;lower&#34;)

        from .grids import Raster

        if isinstance(grid, Raster):
            # extract extent and origin
            extent = grid.extent
            origin = grid.origin
            data = grid.data
        else:
            data = grid

        return ax.imshow(
            data,
            extent=extent,
            transform=self.base_projection,
            origin=origin,
            **kwargs,
        )

    def plot_grid_from_netCDF(self, ax, filename, **kwargs):
        &#34;&#34;&#34;Read a raster from a netCDF file, convert it to a `MaskedArray` and plot it
        onto a standard map Projection.

        Notes
        -----
        `plot_grid_from_netCDF` uses Matplotlib&#39;s `imshow`
        [function](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        filename : str
            Full path to a netCDF filename.

        **kwargs :
            Keyword arguments for map presentation parameters for
            plotting the grid. See `Matplotlib`&#39;s `imshow` keyword arguments
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
            with the netCDF grid plotted onto the chosen map projection.
        &#34;&#34;&#34;
        # Override matplotlib default origin (&#39;upper&#39;)
        origin = kwargs.pop(&#34;origin&#34;, &#34;lower&#34;)

        from .grids import read_netcdf_grid

        raster, lon_coords, lat_coords = read_netcdf_grid(filename, return_grids=True)
        extent = [lon_coords[0], lon_coords[-1], lat_coords[0], lat_coords[-1]]

        if lon_coords[0] &lt; lat_coords[-1]:
            origin = &#34;lower&#34;
        else:
            origin = &#34;upper&#34;

        return self.plot_grid(ax, raster, extent=extent, origin=origin, **kwargs)

    def plot_plate_motion_vectors(
        self, ax, spacingX=10, spacingY=10, normalise=False, **kwargs
    ):
        &#34;&#34;&#34;Calculate plate motion velocity vector fields at a particular geological time
        and plot them onto a standard map Projection.

        Notes
        -----
        `plot_plate_motion_vectors` generates a MeshNode domain of point features using
        given spacings in the X and Y directions (`spacingX` and `spacingY`). Each point in
        the domain is assigned a plate ID, and these IDs are used to obtain equivalent stage
        rotations of identified tectonic plates over a 5 Ma time interval. Each point and
        its stage rotation are used to calculate plate velocities at a particular geological
        time. Velocities for each domain point are represented in the north-east-down
        coordinate system and plotted on a GeoAxes.

        Vector fields can be optionally normalised by setting `normalise` to `True`. This
        makes vector arrow lengths uniform.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        spacingX : int, default=10
            The spacing in the X direction used to make the velocity domain point feature mesh.

        spacingY : int, default=10
            The spacing in the Y direction used to make the velocity domain point feature mesh.

        normalise : bool, default=False
            Choose whether to normalise the velocity magnitudes so that vector lengths are
            all equal.

        **kwargs :
            Keyword arguments for quiver presentation parameters for plotting
            the velocity vector field. See `Matplotlib` quiver keyword arguments
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.quiver.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
            with the velocity vector field plotted onto the chosen map projection.
        &#34;&#34;&#34;

        lons = np.arange(-180, 180 + spacingX, spacingX)
        lats = np.arange(-90, 90 + spacingY, spacingY)
        lonq, latq = np.meshgrid(lons, lats)

        # create a feature from all the points
        velocity_domain_features = ptt.velocity_tools.make_GPML_velocity_feature(
            lonq.ravel(), latq.ravel()
        )

        rotation_model = self.plate_reconstruction.rotation_model
        topology_features = self.plate_reconstruction.topology_features

        delta_time = 5.0
        all_velocities = ptt.velocity_tools.get_plate_velocities(
            velocity_domain_features,
            topology_features,
            rotation_model,
            self.time,
            delta_time,
            &#34;vector_comp&#34;,
        )

        X, Y, U, V = ptt.velocity_tools.get_x_y_u_v(lons, lats, all_velocities)

        if normalise:
            mag = np.hypot(U, V)
            mag[mag == 0] = 1
            U /= mag
            V /= mag

        with warnings.catch_warnings():
            warnings.simplefilter(&#34;ignore&#34;, UserWarning)
            quiver = ax.quiver(X, Y, U, V, transform=self.base_projection, **kwargs)
        return quiver

    def plot_pole(self, ax, lon, lat, a95, **kwargs):
        &#34;&#34;&#34;
        Plot pole onto a matplotlib axes.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        lon : float
            Longitudinal coordinate to place pole
        lat : float
            Latitudinal coordinate to place pole
        a95 : float
            The size of the pole (in degrees)

        Returns
        -------
        matplotlib.patches.Circle handle
        &#34;&#34;&#34;
        from matplotlib import patches as mpatches

        # Define the projection used to display the circle:
        proj1 = ccrs.Orthographic(central_longitude=lon, central_latitude=lat)

        def compute_radius(ortho, radius_degrees):
            phi1 = lat + radius_degrees if lat &lt;= 0 else lat - radius_degrees
            _, y1 = ortho.transform_point(lon, phi1, ccrs.PlateCarree())
            return abs(y1)

        r_ortho = compute_radius(proj1, a95)

        # adding a patch
        patch = ax.add_patch(
            mpatches.Circle(xy=(lon, lat), radius=r_ortho, transform=proj1, **kwargs)
        )
        return patch

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;continental rifts&#34;))
    def get_continental_rifts(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed contiental rift lines.&#34;&#34;&#34;
        return self.get_feature(
            self.continental_rifts,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;continental rifts&#34;))
    def plot_continental_rifts(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot continental rifts on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.continental_rifts,
            feature_name=&#34;continental_rifts&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;faults&#34;))
    def get_faults(self, central_meridian=0.0, tessellate_degrees=None):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed fault lines.&#34;&#34;&#34;
        return self.get_feature(
            self.faults,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;faults&#34;))
    def plot_faults(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot faults on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.faults,
            feature_name=&#34;faults&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;fracture zones&#34;))
    def get_fracture_zones(self, central_meridian=0.0, tessellate_degrees=None):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed fracture zone lines.&#34;&#34;&#34;
        return self.get_feature(
            self.fracture_zones,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;fracturezones&#34;))
    def plot_fracture_zones(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot fracture zones on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.fracture_zones,
            feature_name=&#34;fracture_zones&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;inferred paleo-boundaries&#34;))
    def get_inferred_paleo_boundaries(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed inferred paleo boundary lines.&#34;&#34;&#34;
        return self.get_feature(
            self.inferred_paleo_boundaries,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;inferred paleo-boundaries&#34;))
    def plot_inferred_paleo_boundaries(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot inferred paleo boundaries on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.inferred_paleo_boundaries,
            feature_name=&#34;inferred_paleo_boundaries&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;terrane boundaries&#34;))
    def get_terrane_boundaries(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed terrane boundary lines.&#34;&#34;&#34;
        return self.get_feature(
            self.terrane_boundaries,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;terrane boundaries&#34;))
    def plot_terrane_boundaries(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot terrane boundaries on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.terrane_boundaries,
            feature_name=&#34;terrane_boundaries&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;transitional crusts&#34;))
    def get_transitional_crusts(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed transitional crust lines.&#34;&#34;&#34;
        return self.get_feature(
            self.transitional_crusts,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;transitional crusts&#34;))
    def plot_transitional_crusts(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot transitional crust on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.transitional_crusts,
            feature_name=&#34;transitional_crusts&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;orogenic belts&#34;))
    def get_orogenic_belts(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed orogenic belt lines.&#34;&#34;&#34;
        return self.get_feature(
            self.orogenic_belts,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;orogenic belts&#34;))
    def plot_orogenic_belts(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot orogenic belts on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.orogenic_belts,
            feature_name=&#34;orogenic_belts&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;sutures&#34;))
    def get_sutures(self, central_meridian=0.0, tessellate_degrees=None):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed suture lines.&#34;&#34;&#34;
        return self.get_feature(
            self.sutures,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;sutures&#34;))
    def plot_sutures(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot sutures on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.sutures,
            feature_name=&#34;sutures&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;continental crusts&#34;))
    def get_continental_crusts(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed continental crust lines.&#34;&#34;&#34;
        return self.get_feature(
            self.continental_crusts,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;continental crusts&#34;))
    def plot_continental_crusts(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot continental crust lines on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.continental_crusts,
            feature_name=&#34;continental_crusts&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;extended continental crusts&#34;))
    def get_extended_continental_crusts(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed extended continental crust lines.&#34;&#34;&#34;
        return self.get_feature(
            self.extended_continental_crusts,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;extended continental crusts&#34;))
    def plot_extended_continental_crusts(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot extended continental crust lines on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.extended_continental_crusts,
            feature_name=&#34;extended_continental_crusts&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;passive continental boundaries&#34;))
    def get_passive_continental_boundaries(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed passive continental boundary lines.&#34;&#34;&#34;
        return self.get_feature(
            self.passive_continental_boundaries,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;passive continental boundaries&#34;))
    def plot_passive_continental_boundaries(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot passive continental boundaries on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.passive_continental_boundaries,
            feature_name=&#34;passive_continental_boundaries&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;slab edges&#34;))
    def get_slab_edges(self, central_meridian=0.0, tessellate_degrees=None):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed slab edge lines.&#34;&#34;&#34;
        return self.get_feature(
            self.slab_edges,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;slab edges&#34;))
    def plot_slab_edges(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot slab edges on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.slab_edges,
            feature_name=&#34;slab_edges&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;transforms&#34;))
    def get_transforms(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed transform lines(gpml:Transform).&#34;&#34;&#34;
        logger.debug(
            &#34;The &#39;get_transforms&#39; function has been changed since GPlately 1.3.0. &#34;
            &#34;You need to check your workflow to make sure the new &#39;get_transforms&#39; function still suits your purpose. &#34;
            &#34;In earlier releases of GPlately, we used an algorithm to identify the &#39;ridges&#39; and &#39;transforms&#39; within the gpml:MidOceanRidge features. &#34;
            &#34;Unfortunately, the algorithm did not work very well. So we have removed the algorithm and now the &#39;get_transforms&#39; function returns all the features &#34;
            &#34;which are labelled as gpml:Transform in the reconstruction model.&#34;
        )  # use logger.debug to make the message less aggressive

        return self.get_feature(
            self._transforms,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;transforms&#34;))
    def plot_transforms(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot transform boundaries(gpml:Transform) onto a map.&#34;&#34;&#34;

        logger.debug(
            &#34;The &#39;plot_transforms&#39; function has been changed since GPlately 1.3.0. &#34;
            &#34;You need to check your workflow to make sure the new &#39;plot_transforms&#39; function still suits your purpose. &#34;
            &#34;In earlier releases of GPlately, we used an algorithm to identify the &#39;ridges&#39; and &#39;transforms&#39; within the gpml:MidOceanRidge features. &#34;
            &#34;Unfortunately, the algorithm did not work very well. So we have removed the algorithm and now the &#39;plot_transforms&#39; function plots all the features &#34;
            &#34;which are labelled as gpml:Transform in the reconstruction model.&#34;
        )  # use logger.debug to make the message less aggressive

        return self.plot_feature(
            ax,
            self._transforms,
            feature_name=&#34;transforms&#34;,
            edgecolor=color,
            **kwargs,
        )

    def plot_ridges_and_transforms(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;
        Deprecated! DO NOT USE!
        &#34;&#34;&#34;
        warnings.warn(
            &#34;Deprecated! The &#39;plot_ridges_and_transforms&#39; function will be removed in the future GPlately releases. &#34;
            &#34;Update your workflow to use the &#39;plot_ridges&#39; and &#39;plot_transforms&#39; functions instead, &#34;
            &#34;otherwise your workflow will not work with the future GPlately releases.&#34;,
            DeprecationWarning,
            stacklevel=2,
        )
        logger.debug(
            &#34;The &#39;plot_ridges_and_transforms&#39; function has been changed since GPlately 1.3.0. &#34;
            &#34;You need to check your workflow to make sure the new &#39;plot_ridges_and_transforms&#39; function still suits your purpose. &#34;
            &#34;In earlier releases of GPlately, we used an algorithm to identify the &#39;ridges&#39; and &#39;transforms&#39; within the gpml:MidOceanRidge features. &#34;
            &#34;Unfortunately, the algorithm did not work very well. So we have removed the algorithm and now the &#39;plot_ridges_and_transforms&#39; function plots all the features &#34;
            &#34;which are labelled as gpml:Transform or gpml:MidOceanRidge in the reconstruction model.&#34;
        )  # use logger.debug to make the message less aggressive

        self.plot_ridges(ax, color=color, **kwargs)
        self.plot_transforms(ax, color=color, **kwargs)

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;unclassified features&#34;))
    def get_unclassified_features(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed unclassified feature lines.&#34;&#34;&#34;
        return self.get_feature(
            self.unclassified_features,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_reconstruction_time
    @append_docstring(PLOT_DOCSTRING.format(&#34;unclassified features&#34;))
    def plot_unclassified_features(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot GPML unclassified features on a standard map projection.&#34;&#34;&#34;
        return self.plot_feature(
            ax,
            self.unclassified_features,
            feature_name=&#34;unclassified_features&#34;,
            facecolor=&#34;none&#34;,
            edgecolor=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;topologies&#34;))
    def get_all_topologies(
        self,
        central_meridian=0.0,
        tessellate_degrees=1,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed unclassified feature lines.&#34;&#34;&#34;

        # get plate IDs and feature types to add to geodataframe
        plate_IDs = []
        feature_types = []
        feature_names = []
        all_topologies = []

        if self.topologies:
            all_topologies = shapelify_features(
                self.topologies,
                central_meridian=central_meridian,
                tessellate_degrees=tessellate_degrees,
            )
            for topo in self.topologies:
                ft_type = topo.get_feature_type()

                plate_IDs.append(topo.get_reconstruction_plate_id())
                feature_types.append(ft_type)
                feature_names.append(ft_type.get_name())

        gdf = gpd.GeoDataFrame(
            {
                &#34;geometry&#34;: all_topologies,
                &#34;reconstruction_plate_ID&#34;: plate_IDs,
                &#34;feature_type&#34;: feature_types,
                &#34;feature_name&#34;: feature_names,
            },
            geometry=&#34;geometry&#34;,
            crs=&#34;EPSG:4326&#34;,
        )  # type: ignore
        return gdf

    @validate_topology_availability(&#34;all topologies&#34;)
    @append_docstring(PLOT_DOCSTRING.format(&#34;topologies&#34;))
    def plot_all_topologies(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot topological polygons and networks on a standard map projection.&#34;&#34;&#34;
        if &#34;edgecolor&#34; not in kwargs.keys():
            kwargs[&#34;edgecolor&#34;] = color
        if &#34;facecolor&#34; not in kwargs.keys():
            kwargs[&#34;facecolor&#34;] = &#34;none&#34;

        return self._plot_feature(
            ax,
            self.get_all_topologies,
            **kwargs,
        )

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;topologies&#34;))
    def get_all_topological_sections(
        self,
        central_meridian=0.0,
        tessellate_degrees=1,
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries ofresolved topological sections.&#34;&#34;&#34;

        # get plate IDs and feature types to add to geodataframe
        geometries = []
        plate_IDs = []
        feature_types = []
        feature_names = []
        for topo in [
            *self.ridges,
            *self.trenches,
            *self.trench_left,
            *self.trench_right,
            *self.other,
        ]:
            converted = shapelify_features(
                topo,
                central_meridian=central_meridian,
                tessellate_degrees=tessellate_degrees,
            )
            if not isinstance(converted, BaseGeometry):
                if len(converted) &gt; 1:
                    tmp = []
                    for i in converted:
                        if isinstance(i, BaseMultipartGeometry):
                            tmp.extend(list(i.geoms))
                        else:
                            tmp.append(i)
                    converted = tmp
                    del tmp
                    converted = linemerge(converted)
                elif len(converted) == 1:
                    converted = converted[0]
                else:
                    continue
            geometries.append(converted)
            plate_IDs.append(topo.get_reconstruction_plate_id())
            feature_types.append(topo.get_feature_type())
            feature_names.append(topo.get_name())

        gdf = gpd.GeoDataFrame(
            {
                &#34;geometry&#34;: geometries,
                &#34;reconstruction_plate_ID&#34;: plate_IDs,
                &#34;feature_type&#34;: feature_types,
                &#34;feature_name&#34;: feature_names,
            },
            geometry=&#34;geometry&#34;,
            crs=&#34;EPSG:4326&#34;,
        )  # type: ignore
        return gdf

    @validate_topology_availability(&#34;all topological sections&#34;)
    @append_docstring(PLOT_DOCSTRING.format(&#34;topologies&#34;))
    def plot_all_topological_sections(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot all topologies on a standard map projection.&#34;&#34;&#34;

        return self._plot_feature(
            ax,
            self.get_all_topological_sections,
            color=color,
            **kwargs,
        )

    @validate_reconstruction_time
    def _resolve_both_boundaries_and_networks(self):
        &#34;&#34;&#34;need to resolve_topologies for both rigid boundaries and networks if not done yet&#34;&#34;&#34;
        if self._topologies is None:
            resolved_topologies = []
            shared_boundary_sections = []
            pygplates.resolve_topologies(  # type: ignore
                self.plate_reconstruction.topology_features,
                self.plate_reconstruction.rotation_model,
                resolved_topologies,
                self.time,
                shared_boundary_sections,
                anchor_plate_id=self.anchor_plate_id,
            )
            self._topologies = [t.get_resolved_feature() for t in resolved_topologies]

    @validate_reconstruction_time
    @append_docstring(GET_DATE_DOCSTRING.format(&#34;topological plate boundaries&#34;))
    def get_topological_plate_boundaries(
        self, central_meridian=0.0, tessellate_degrees=1
    ):
        &#34;&#34;&#34;Create a geopandas.GeoDataFrame object containing geometries of reconstructed rigid topological plate boundaries.&#34;&#34;&#34;
        return self.get_feature(
            self._topological_plate_boundaries,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )

    @validate_topology_availability(&#34;topological plate boundaries&#34;)
    @append_docstring(PLOT_DOCSTRING.format(&#34;topological plate boundaries&#34;))
    def plot_topological_plate_boundaries(self, ax, color=&#34;black&#34;, **kwargs):
        return self.plot_feature(
            ax,
            self._topological_plate_boundaries,
            feature_name=&#34;topological plate boundaries&#34;,
            color=color,
            **kwargs,
        )

    @validate_reconstruction_time
    @property
    def misc_transforms(self):
        &#34;&#34;&#34;
        Deprecated! DO NOT USE.
        &#34;&#34;&#34;
        warnings.warn(
            &#34;Deprecated! The &#39;misc_transforms&#39; property will be removed in the future GPlately releases. &#34;
            &#34;Update your workflow to use the &#39;transforms&#39; property instead, &#34;
            &#34;otherwise your workflow will not work with the future GPlately releases.&#34;,
            DeprecationWarning,
            stacklevel=2,
        )
        return self._transforms

    def plot_misc_transforms(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;
        Deprecated! DO NOT USE.
        &#34;&#34;&#34;
        warnings.warn(
            &#34;Deprecated! The &#39;plot_misc_transforms&#39; function will be removed in the future GPlately releases. &#34;
            &#34;Update your workflow to use the &#39;plot_transforms&#39; function instead, &#34;
            &#34;otherwise your workflow will not work with the future GPlately releases.&#34;,
            DeprecationWarning,
            stacklevel=2,
        )
        self.plot_transforms(ax=ax, color=color, **kwargs)

    def get_misc_transforms(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
    ):
        &#34;&#34;&#34;
        Deprecated! DO NOT USE.
        &#34;&#34;&#34;
        warnings.warn(
            &#34;Deprecated! The &#39;get_misc_transforms&#39; function will be removed in the future GPlately releases. &#34;
            &#34;Update your workflow to use the &#39;get_transforms&#39; function instead, &#34;
            &#34;otherwise your workflow will not work with the future GPlately releases.&#34;,
            DeprecationWarning,
            stacklevel=2,
        )
        return self.get_transforms(
            central_meridian=central_meridian, tessellate_degrees=tessellate_degrees
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="gplately.plot.PlotTopologies.anchor_plate_id"><code class="name">prop <span class="ident">anchor_plate_id</span></code></dt>
<dd>
<div class="desc"><p>Anchor plate ID for reconstruction. Must be an integer &gt;= 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def anchor_plate_id(self):
    &#34;&#34;&#34;Anchor plate ID for reconstruction. Must be an integer &gt;= 0.&#34;&#34;&#34;
    return self._anchor_plate_id</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.misc_transforms"><code class="name">prop <span class="ident">misc_transforms</span></code></dt>
<dd>
<div class="desc"><p>Deprecated! DO NOT USE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_reconstruction_time
@property
def misc_transforms(self):
    &#34;&#34;&#34;
    Deprecated! DO NOT USE.
    &#34;&#34;&#34;
    warnings.warn(
        &#34;Deprecated! The &#39;misc_transforms&#39; property will be removed in the future GPlately releases. &#34;
        &#34;Update your workflow to use the &#39;transforms&#39; property instead, &#34;
        &#34;otherwise your workflow will not work with the future GPlately releases.&#34;,
        DeprecationWarning,
        stacklevel=2,
    )
    return self._transforms</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.ridge_transforms"><code class="name">prop <span class="ident">ridge_transforms</span></code></dt>
<dd>
<div class="desc"><p>Deprecated! DO NOT USE!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_reconstruction_time
@property
def ridge_transforms(self):
    &#34;&#34;&#34;
    Deprecated! DO NOT USE!
    &#34;&#34;&#34;

    warnings.warn(
        &#34;Deprecated! DO NOT USE!&#34;
        &#34;The &#39;ridge_transforms&#39; property will be removed in the future GPlately releases. &#34;
        &#34;Update your workflow to use the &#39;ridges&#39; and &#39;transforms&#39; properties instead, &#34;
        &#34;otherwise your workflow will not work with the future GPlately releases.&#34;,
        DeprecationWarning,
        stacklevel=2,
    )
    logger.debug(
        &#34;The &#39;ridge_transforms&#39; property has been changed since GPlately 1.3.0. &#34;
        &#34;You need to check your workflow to make sure the new &#39;ridge_transforms&#39; property still suits your purpose. &#34;
        &#34;In earlier releases of GPlately, the &#39;ridge_transforms&#39; property contains only the features &#34;
        &#34;which are labelled as gpml:MidOceanRidge in the reconstruction model. &#34;
        &#34;Now, the &#39;ridge_transforms&#39; property contains both gpml:Transform and gpml:MidOceanRidge features.&#34;
    )
    return self._ridges + self._transforms</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.ridges"><code class="name">prop <span class="ident">ridges</span></code></dt>
<dd>
<div class="desc"><p>Mid-ocean ridge features (all the features which are labelled as gpml:MidOceanRidge in the model).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ridges(self):
    &#34;&#34;&#34;
    Mid-ocean ridge features (all the features which are labelled as gpml:MidOceanRidge in the model).
    &#34;&#34;&#34;
    logger.debug(
        &#34;The &#39;ridges&#39; property has been changed since GPlately 1.3.0. &#34;
        &#34;You need to check your workflow to make sure the new &#39;ridges&#39; property still suits your purpose. &#34;
        &#34;In earlier releases of GPlately, we used an algorithm to identify the &#39;ridges&#39; and &#39;transforms&#39; within the gpml:MidOceanRidge features. &#34;
        &#34;Unfortunately, the algorithm did not work very well. So we have removed the algorithm and now the &#39;ridges&#39; property contains all the features &#34;
        &#34;which are labelled as gpml:MidOceanRidge in the reconstruction model.&#34;
    )  # use logger.debug to make the message less aggressive
    return self._ridges</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.time"><code class="name">prop <span class="ident">time</span></code></dt>
<dd>
<div class="desc"><p>The reconstruction time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time(self):
    &#34;&#34;&#34;The reconstruction time.&#34;&#34;&#34;
    return self._time</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.topological_plate_boundaries"><code class="name">prop <span class="ident">topological_plate_boundaries</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def topological_plate_boundaries(self):
    if self._topological_plate_boundaries is None:
        if self.time is not None:
            self.update_time(self.time)
    return self._topological_plate_boundaries</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.topologies"><code class="name">prop <span class="ident">topologies</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def topologies(self):
    self._resolve_both_boundaries_and_networks()
    return self._topologies</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.transforms"><code class="name">prop <span class="ident">transforms</span></code></dt>
<dd>
<div class="desc"><p>Transform boundary features (all the features which are labelled as gpml:Transform in the model).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transforms(self):
    &#34;&#34;&#34;
    Transform boundary features (all the features which are labelled as gpml:Transform in the model).
    &#34;&#34;&#34;
    logger.debug(
        &#34;The &#39;transforms&#39; property has been changed since GPlately 1.3.0. &#34;
        &#34;You need to check your workflow to make sure the new &#39;transforms&#39; property still suits your purpose. &#34;
        &#34;In earlier releases of GPlately, we used an algorithm to identify the &#39;ridges&#39; and &#39;transforms&#39; within the gpml:MidOceanRidge features. &#34;
        &#34;Unfortunately, the algorithm did not work very well. So we have removed the algorithm and now the &#39;transforms&#39; property contains all the features &#34;
        &#34;which are labelled as gpml:Transform in the reconstruction model.&#34;
    )  # use logger.debug to make the message less aggressive
    return self._transforms</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gplately.plot.PlotTopologies.get_all_topological_sections"><code class="name flex">
<span>def <span class="ident">get_all_topological_sections</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries ofresolved topological sections.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>topologies</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>topologies</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>topologies</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>topologies</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_all_topologies"><code class="name flex">
<span>def <span class="ident">get_all_topologies</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed unclassified feature lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>topologies</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>topologies</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>topologies</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>topologies</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_coastlines"><code class="name flex">
<span>def <span class="ident">get_coastlines</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed coastline polygons.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>coastlines</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>coastlines</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>coastlines</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>coastlines</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_continent_ocean_boundaries"><code class="name flex">
<span>def <span class="ident">get_continent_ocean_boundaries</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed continent-ocean boundary lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>COBs</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>COBs</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>COBs</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>COBs</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_continental_crusts"><code class="name flex">
<span>def <span class="ident">get_continental_crusts</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed continental crust lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>continental crusts</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>continental crusts</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>continental crusts</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>continental crusts</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_continental_rifts"><code class="name flex">
<span>def <span class="ident">get_continental_rifts</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed contiental rift lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>continental rifts</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>continental rifts</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>continental rifts</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>continental rifts</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_continents"><code class="name flex">
<span>def <span class="ident">get_continents</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed continental polygons.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>continents</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>continents</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>continents</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>continents</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_extended_continental_crusts"><code class="name flex">
<span>def <span class="ident">get_extended_continental_crusts</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed extended continental crust lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>extended continental crusts</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>extended continental crusts</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>extended continental crusts</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>extended continental crusts</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_faults"><code class="name flex">
<span>def <span class="ident">get_faults</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed fault lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>faults</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>faults</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>faults</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>faults</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_feature"><code class="name flex">
<span>def <span class="ident">get_feature</span></span>(<span>self, feature, central_meridian=0.0, tessellate_degrees=None, validate_reconstruction_time=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed features.</p>
<h2 id="notes">Notes</h2>
<p>The feature needed to produce the GeoDataFrame should already be constructed to a <code>time</code>.
This function converts the feature into a set of Shapely geometries whose coordinates are
passed to a geopandas GeoDataFrame.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A feature reconstructed to <code>time</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gdf</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame&gt;</code></dt>
<dd>A pandas.DataFrame that has a column with <code>feature</code> geometries.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_fracture_zones"><code class="name flex">
<span>def <span class="ident">get_fracture_zones</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed fracture zone lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>fracture zones</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>fracture zones</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>fracture zones</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>fracture zones</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_inferred_paleo_boundaries"><code class="name flex">
<span>def <span class="ident">get_inferred_paleo_boundaries</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed inferred paleo boundary lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>inferred paleo-boundaries</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>inferred paleo-boundaries</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>inferred paleo-boundaries</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>inferred paleo-boundaries</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_misc_boundaries"><code class="name flex">
<span>def <span class="ident">get_misc_boundaries</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of other reconstructed lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>other</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>other</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>other</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>other</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_misc_transforms"><code class="name flex">
<span>def <span class="ident">get_misc_transforms</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated! DO NOT USE.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_orogenic_belts"><code class="name flex">
<span>def <span class="ident">get_orogenic_belts</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed orogenic belt lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>orogenic belts</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>orogenic belts</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>orogenic belts</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>orogenic belts</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_passive_continental_boundaries"><code class="name flex">
<span>def <span class="ident">get_passive_continental_boundaries</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed passive continental boundary lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>passive continental boundaries</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>passive continental boundaries</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>passive continental boundaries</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>passive continental boundaries</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_ridges"><code class="name flex">
<span>def <span class="ident">get_ridges</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing the geometries of reconstructed mid-ocean ridge lines (gpml:MidOceanRidge).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>ridges</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>ridges</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>ridges</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>ridges</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_ridges_and_transforms"><code class="name flex">
<span>def <span class="ident">get_ridges_and_transforms</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated! DO NOT USE.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_slab_edges"><code class="name flex">
<span>def <span class="ident">get_slab_edges</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed slab edge lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>slab edges</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>slab edges</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>slab edges</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>slab edges</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_subduction_direction"><code class="name flex">
<span>def <span class="ident">get_subduction_direction</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of trench directions.</p>
<h2 id="notes">Notes</h2>
<p>The <code>trench_left</code> and <code>trench_right</code> geometries needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling
this function. <code>time</code> can be passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 #Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>other</code> geometries are reconstructed, they are
converted into Shapely features whose coordinates are passed to a geopandas GeoDataFrame.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gdf_left</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame&gt;</code></dt>
<dd>A pandas.DataFrame that has a column with <code>trench_left</code> geometry.</dd>
<dt><strong><code>gdf_right</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame&gt;</code></dt>
<dd>A pandas.DataFrame that has a column with <code>trench_right</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct
<code>trench_left</code> or <code>trench_right</code> geometries to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_sutures"><code class="name flex">
<span>def <span class="ident">get_sutures</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed suture lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>sutures</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>sutures</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>sutures</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>sutures</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_terrane_boundaries"><code class="name flex">
<span>def <span class="ident">get_terrane_boundaries</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed terrane boundary lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>terrane boundaries</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>terrane boundaries</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>terrane boundaries</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>terrane boundaries</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_topological_plate_boundaries"><code class="name flex">
<span>def <span class="ident">get_topological_plate_boundaries</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed rigid topological plate boundaries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>topological plate boundaries</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>topological plate boundaries</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>topological plate boundaries</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>topological plate boundaries</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_transforms"><code class="name flex">
<span>def <span class="ident">get_transforms</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed transform lines(gpml:Transform).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>transforms</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>transforms</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>transforms</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>transforms</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_transitional_crusts"><code class="name flex">
<span>def <span class="ident">get_transitional_crusts</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed transitional crust lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>transitional crusts</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>transitional crusts</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>transitional crusts</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>transitional crusts</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_trenches"><code class="name flex">
<span>def <span class="ident">get_trenches</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed trench lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>trenches</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>trenches</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>trenches</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>trenches</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.get_unclassified_features"><code class="name flex">
<span>def <span class="ident">get_unclassified_features</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a geopandas.GeoDataFrame object containing geometries of reconstructed unclassified feature lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>A pandas.DataFrame that has a column with <code>unclassified features</code> geometry.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optional <code>time</code> parameter has not been passed to
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code>. This is needed to construct <code>unclassified features</code>
to the requested <code>time</code> and thus populate the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The <code>unclassified features</code> needed to produce the GeoDataFrame are automatically
constructed if the optional <code>time</code> parameter is passed to the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object before calling this function. <code>time</code> can be
passed either when <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is first called&hellip;</p>
<pre><code>gplot = gplately.PlotTopologies(..., time=100,...)
</code></pre>
<p>or anytime afterwards, by setting:</p>
<pre><code>time = 100 # Ma
gplot.time = time
</code></pre>
<p>&hellip;after which this function can be re-run. Once the <code>unclassified features</code>
are reconstructed, they are converted into Shapely lines whose
coordinates are passed to a geopandas GeoDataFrame.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_all_topological_sections"><code class="name flex">
<span>def <span class="ident">plot_all_topological_sections</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all topologies on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>topologies</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>topologies</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>topologies</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_all_topologies"><code class="name flex">
<span>def <span class="ident">plot_all_topologies</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot topological polygons and networks on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>topologies</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>topologies</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>topologies</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_coastlines"><code class="name flex">
<span>def <span class="ident">plot_coastlines</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed coastline polygons onto a standard map Projection.</p>
<h2 id="notes">Notes</h2>
<p>The <code>coastlines</code> for plotting are accessed from the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's <code>coastlines</code> attribute.
These <code>coastlines</code> are reconstructed to the <code>time</code> passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted into Shapely polylines.
The reconstructed <code>coastlines</code> are added onto the GeoAxes or GeoAxesSubplot map <code>ax</code> using GeoPandas.
Map resentation details (e.g. facecolor, edgecolor, alpha…) are permitted as keyword arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>coastlines</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>coastlines</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>coastlines</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_continent_ocean_boundaries"><code class="name flex">
<span>def <span class="ident">plot_continent_ocean_boundaries</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed continent-ocean boundary (COB) polygons onto a standard map Projection.</p>
<h2 id="notes">Notes</h2>
<p>The <code>COBs</code> for plotting are accessed from the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's
<code>COBs</code> attribute. These <code>COBs</code> are reconstructed to the <code>time</code>
passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted into Shapely polylines.
The reconstructed <code>COBs</code> are plotted onto the GeoAxes or GeoAxesSubplot map
<code>ax</code> using GeoPandas. Map presentation details (e.g. <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>…)
are permitted as keyword arguments.</p>
<p>These COBs are transformed into shapely geometries and added onto the chosen map for a specific geological time
(supplied to the PlotTopologies object). Map presentation details (e.g. facecolor, edgecolor, alpha…) are permitted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>continent ocean boundaries</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>continent ocean boundaries</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>continent ocean boundaries</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_continental_crusts"><code class="name flex">
<span>def <span class="ident">plot_continental_crusts</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot continental crust lines on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>continental crusts</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>continental crusts</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>continental crusts</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_continental_rifts"><code class="name flex">
<span>def <span class="ident">plot_continental_rifts</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot continental rifts on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>continental rifts</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>continental rifts</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>continental rifts</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_continents"><code class="name flex">
<span>def <span class="ident">plot_continents</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed continental polygons onto a standard map Projection.</p>
<h2 id="notes">Notes</h2>
<p>The <code>continents</code> for plotting are accessed from the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's <code>continents</code> attribute.
These <code>continents</code> are reconstructed to the <code>time</code> passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted into Shapely polygons.
The reconstructed <code>coastlines</code> are plotted onto the GeoAxes or GeoAxesSubplot map <code>ax</code> using GeoPandas.
Map presentation details (e.g. facecolor, edgecolor, alpha…) are permitted as keyword arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>continents</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>continents</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>continents</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_extended_continental_crusts"><code class="name flex">
<span>def <span class="ident">plot_extended_continental_crusts</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot extended continental crust lines on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>extended continental crusts</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>extended continental crusts</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>extended continental crusts</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_faults"><code class="name flex">
<span>def <span class="ident">plot_faults</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot faults on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>faults</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>faults</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>faults</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_feature"><code class="name flex">
<span>def <span class="ident">plot_feature</span></span>(<span>self, ax, feature, feature_name='', color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot pygplates.FeatureCollection or pygplates.Feature onto a map.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>feature</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>feature</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>feature</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_fracture_zones"><code class="name flex">
<span>def <span class="ident">plot_fracture_zones</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot fracture zones on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>fracturezones</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>fracturezones</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>fracturezones</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_grid"><code class="name flex">
<span>def <span class="ident">plot_grid</span></span>(<span>self, ax, grid, extent=[-180, 180, -90, 90], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a <code>MaskedArray</code> raster or grid onto a standard map Projection.</p>
<h2 id="notes">Notes</h2>
<p>Uses Matplotlib's <code>imshow</code>
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html">function</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>MaskedArray</code> or <code><a title="gplately.grids.Raster" href="grids.html#gplately.grids.Raster">Raster</a></code></dt>
<dd>A <code>MaskedArray</code> with elements that define a grid. The number of rows in the raster
corresponds to the number of latitudinal coordinates, while the number of raster
columns corresponds to the number of longitudinal coordinates.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>1d array</code>, default=<code>[-180,180,-90,90]</code></dt>
<dd>A four-element array to specify the [min lon, max lon, min lat, max lat] with
which to constrain the grid image. If no extents are supplied, full global
extent is assumed.</dd>
</dl>
<p>**kwargs :
Keyword arguments for map presentation parameters such as
<code>alpha</code>, etc. for plotting the grid.
See <code>Matplotlib</code>'s <code>imshow</code> keyword arguments
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with the grid plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_grid_from_netCDF"><code class="name flex">
<span>def <span class="ident">plot_grid_from_netCDF</span></span>(<span>self, ax, filename, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a raster from a netCDF file, convert it to a <code>MaskedArray</code> and plot it
onto a standard map Projection.</p>
<h2 id="notes">Notes</h2>
<p><code>plot_grid_from_netCDF</code> uses Matplotlib's <code>imshow</code>
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html">function</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Full path to a netCDF filename.</dd>
</dl>
<p>**kwargs :
Keyword arguments for map presentation parameters for
plotting the grid. See <code>Matplotlib</code>'s <code>imshow</code> keyword arguments
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with the netCDF grid plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_inferred_paleo_boundaries"><code class="name flex">
<span>def <span class="ident">plot_inferred_paleo_boundaries</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot inferred paleo boundaries on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>inferred paleo-boundaries</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>inferred paleo-boundaries</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>inferred paleo-boundaries</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_misc_boundaries"><code class="name flex">
<span>def <span class="ident">plot_misc_boundaries</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed miscellaneous plate boundary polylines onto a standard
map Projection.</p>
<h2 id="notes">Notes</h2>
<p>The miscellaneous boundary sections for plotting are accessed from the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's <code>other</code> attribute. These <code>other</code> boundaries
are reconstructed to the <code>time</code> passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted
into Shapely polylines. The reconstructed <code>other</code> boundaries are plotted onto the
GeoAxes or GeoAxesSubplot map <code>ax</code> using GeoPandas. Map presentation details
(e.g. <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>…) are permitted as keyword arguments.</p>
<p>Miscellaneous boundary geometries are wrapped to the dateline using
pyGPlates' <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
by splitting a polyline into multiple polylines at the dateline. This is to avoid
horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
compatibility with Cartopy.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>other</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>other</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>other</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_misc_transforms"><code class="name flex">
<span>def <span class="ident">plot_misc_transforms</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated! DO NOT USE.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_orogenic_belts"><code class="name flex">
<span>def <span class="ident">plot_orogenic_belts</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot orogenic belts on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>orogenic belts</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>orogenic belts</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>orogenic belts</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_passive_continental_boundaries"><code class="name flex">
<span>def <span class="ident">plot_passive_continental_boundaries</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot passive continental boundaries on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>passive continental boundaries</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>passive continental boundaries</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>passive continental boundaries</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_plate_id"><code class="name flex">
<span>def <span class="ident">plot_plate_id</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO: remove this function</p>
<p>The function name plot_plate_id() is bad and should be changed.
The new name is plot_plate_polygon_by_id().
For backward compatibility, we allow users to use the old name in their legcy code for now.
No new code should call this function.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_plate_motion_vectors"><code class="name flex">
<span>def <span class="ident">plot_plate_motion_vectors</span></span>(<span>self, ax, spacingX=10, spacingY=10, normalise=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate plate motion velocity vector fields at a particular geological time
and plot them onto a standard map Projection.</p>
<h2 id="notes">Notes</h2>
<p><code>plot_plate_motion_vectors</code> generates a MeshNode domain of point features using
given spacings in the X and Y directions (<code>spacingX</code> and <code>spacingY</code>). Each point in
the domain is assigned a plate ID, and these IDs are used to obtain equivalent stage
rotations of identified tectonic plates over a 5 Ma time interval. Each point and
its stage rotation are used to calculate plate velocities at a particular geological
time. Velocities for each domain point are represented in the north-east-down
coordinate system and plotted on a GeoAxes.</p>
<p>Vector fields can be optionally normalised by setting <code>normalise</code> to <code>True</code>. This
makes vector arrow lengths uniform.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>spacingX</code></strong> :&ensp;<code>int</code>, default=<code>10</code></dt>
<dd>The spacing in the X direction used to make the velocity domain point feature mesh.</dd>
<dt><strong><code>spacingY</code></strong> :&ensp;<code>int</code>, default=<code>10</code></dt>
<dd>The spacing in the Y direction used to make the velocity domain point feature mesh.</dd>
<dt><strong><code>normalise</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Choose whether to normalise the velocity magnitudes so that vector lengths are
all equal.</dd>
</dl>
<p>**kwargs :
Keyword arguments for quiver presentation parameters for plotting
the velocity vector field. See <code>Matplotlib</code> quiver keyword arguments
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.quiver.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with the velocity vector field plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_plate_polygon_by_id"><code class="name flex">
<span>def <span class="ident">plot_plate_polygon_by_id</span></span>(<span>self, ax, plate_id, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a plate polygon with an associated <code>plate_id</code> onto a standard map Projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>plate_id</code></strong> :&ensp;<code>int</code></dt>
<dd>A plate ID that identifies the continental polygon to plot. See the
<a href="https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/SampleData/FeatureCollections/Rotations/Global_EarthByte_PlateIDs_20071218.pdf">Global EarthByte plate IDs list</a>
for a full list of plate IDs to plot.</dd>
</dl>
<p>**kwargs :
Keyword arguments for map presentation parameters such as
<code>alpha</code>, etc. for plotting the grid.
See <code>Matplotlib</code>'s <code>imshow</code> keyword arguments
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html">here</a>.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_pole"><code class="name flex">
<span>def <span class="ident">plot_pole</span></span>(<span>self, ax, lon, lat, a95, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot pole onto a matplotlib axes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitudinal coordinate to place pole</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>Latitudinal coordinate to place pole</dd>
<dt><strong><code>a95</code></strong> :&ensp;<code>float</code></dt>
<dd>The size of the pole (in degrees)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.patches.Circle handle</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_ridges"><code class="name flex">
<span>def <span class="ident">plot_ridges</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed mid-ocean ridge lines(gpml:MidOceanRidge) onto a map.</p>
<h2 id="notes">Notes</h2>
<p>The <code>ridges</code> sections for plotting are accessed from the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's <code>ridges</code> attribute. These <code>ridges</code>
are reconstructed to the <code>time</code> passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted
into Shapely polylines. The reconstructed <code>ridges</code> are plotted onto the
GeoAxes or GeoAxesSubplot map <code>ax</code> using GeoPandas. Map presentation details
(e.g. <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>…) are permitted as keyword arguments.</p>
<p>Note: The <code>ridges</code> geometries are wrapped to the dateline using
pyGPlates' <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
by splitting a polyline into multiple polylines at the dateline. This is to avoid
horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
compatibility with Cartopy.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>ridges</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>ridges</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>ridges</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_ridges_and_transforms"><code class="name flex">
<span>def <span class="ident">plot_ridges_and_transforms</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated! DO NOT USE!</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_slab_edges"><code class="name flex">
<span>def <span class="ident">plot_slab_edges</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot slab edges on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>slab edges</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>slab edges</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>slab edges</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_subduction_teeth"><code class="name flex">
<span>def <span class="ident">plot_subduction_teeth</span></span>(<span>self, ax, spacing=0.07, size=None, aspect=None, color='black', **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Plot subduction teeth onto a standard map Projection.</p>
<h2 id="notes">Notes</h2>
<p>Subduction teeth are tessellated from <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object attributes <code>trench_left</code> and
<code>trench_right</code>, and transformed into Shapely polygons for plotting.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code>, default=<code>0.07</code></dt>
<dd>The tessellation threshold (in radians). Parametrises subduction tooth density.
Triangles are generated only along line segments with distances that exceed
the given threshold <code>spacing</code>.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code>, default=<code>None</code></dt>
<dd>Length of teeth triangle base (in radians). If kept at <code>None</code>, then
<code>size = 0.5*spacing</code>.</dd>
<dt><strong><code>aspect</code></strong> :&ensp;<code>float</code>, default=<code>None</code></dt>
<dd>Aspect ratio of teeth triangles. If kept at <code>None</code>, then <code>aspect = 2/3*size</code>.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>'black'</code></dt>
<dd>The colour of the teeth. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments parameters such as <code>alpha</code>, etc.
for plotting subduction tooth polygons.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_subduction_teeth_deprecated"><code class="name flex">
<span>def <span class="ident">plot_subduction_teeth_deprecated</span></span>(<span>self, ax, spacing=0.1, size=2.0, aspect=1, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot subduction teeth onto a standard map Projection.</p>
<h2 id="notes">Notes</h2>
<p>Subduction teeth are tessellated from <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object attributes <code>trench_left</code> and
<code>trench_right</code>, and transformed into Shapely polygons for plotting.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code>, default=<code>0.1</code></dt>
<dd>The tessellation threshold (in radians). Parametrises subduction tooth density.
Triangles are generated only along line segments with distances that exceed
the given threshold ‘spacing’.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code>, default=<code>2.0</code></dt>
<dd>Length of teeth triangle base.</dd>
<dt><strong><code>aspect</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>Aspect ratio of teeth triangles. Ratio is 1.0 by default.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the teeth. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as ‘alpha’, etc. for
plotting subduction tooth polygons.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with subduction teeth plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_sutures"><code class="name flex">
<span>def <span class="ident">plot_sutures</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot sutures on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>sutures</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>sutures</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>sutures</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_terrane_boundaries"><code class="name flex">
<span>def <span class="ident">plot_terrane_boundaries</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot terrane boundaries on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>terrane boundaries</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>terrane boundaries</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>terrane boundaries</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_topological_plate_boundaries"><code class="name flex">
<span>def <span class="ident">plot_topological_plate_boundaries</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>topological plate boundaries</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>topological plate boundaries</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>topological plate boundaries</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_transforms"><code class="name flex">
<span>def <span class="ident">plot_transforms</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot transform boundaries(gpml:Transform) onto a map.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>transforms</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>transforms</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>transforms</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_transitional_crusts"><code class="name flex">
<span>def <span class="ident">plot_transitional_crusts</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot transitional crust on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>transitional crusts</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>transitional crusts</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>transitional crusts</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_trenches"><code class="name flex">
<span>def <span class="ident">plot_trenches</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed subduction trench polylines onto a standard map
Projection.</p>
<h2 id="notes">Notes</h2>
<p>The trench sections for plotting are accessed from the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's <code>trenches</code> attribute. These <code>trenches</code>
are reconstructed to the <code>time</code> passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted
into Shapely polylines. The reconstructed <code>trenches</code> are plotted onto the
GeoAxes or GeoAxesSubplot map <code>ax</code> using GeoPandas. Map presentation details
(e.g. <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>…) are permitted as keyword arguments.</p>
<p>Trench geometries are wrapped to the dateline using
pyGPlates' <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
by splitting a polyline into multiple polylines at the dateline. This is to avoid
horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
compatibility with Cartopy.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>trenches</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>trenches</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>trenches</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_unclassified_features"><code class="name flex">
<span>def <span class="ident">plot_unclassified_features</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot GPML unclassified features on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the <code>unclassified features</code> lines. By default, it is set to black.</dd>
</dl>
<p>**kwargs :
Keyword arguments for parameters such as <code>alpha</code>, etc. for plotting <code>unclassified features</code> geometries.
See <code>Matplotlib</code> keyword arguments <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with <code>unclassified features</code> features plotted onto the chosen map projection.</dd>
</dl></div>
</dd>
<dt id="gplately.plot.PlotTopologies.update_time"><code class="name flex">
<span>def <span class="ident">update_time</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-reconstruct features and topologies to the time specified by the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> <code>time</code> attribute
whenever it or the anchor plate is updated.</p>
<h2 id="notes">Notes</h2>
<p>The following <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> attributes are updated whenever a reconstruction <code>time</code> attribute is set:</p>
<ul>
<li>resolved topology features (topological plates and networks)</li>
<li>ridge and transform boundary sections (resolved features)</li>
<li>ridge boundary sections (resolved features)</li>
<li>transform boundary sections (resolved features)</li>
<li>subduction boundary sections (resolved features)</li>
<li>left subduction boundary sections (resolved features)</li>
<li>right subduction boundary sections (resolved features)</li>
<li>other boundary sections (resolved features) that are not subduction zones or mid-ocean ridges
(ridge/transform)</li>
</ul>
<p>Moreover, coastlines, continents and COBs are reconstructed to the new specified <code>time</code>.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="GPlately logo" height="172" width="205">
</a>
</header>
<div class="toc">
<ul>
<li><a href="#classes">Classes</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gplately.plot.plot_subduction_teeth" href="#gplately.plot.plot_subduction_teeth">plot_subduction_teeth</a></code></li>
<li><code><a title="gplately.plot.shapelify_feature_lines" href="#gplately.plot.shapelify_feature_lines">shapelify_feature_lines</a></code></li>
<li><code><a title="gplately.plot.shapelify_feature_polygons" href="#gplately.plot.shapelify_feature_polygons">shapelify_feature_polygons</a></code></li>
<li><code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code></h4>
<ul class="">
<li><code><a title="gplately.plot.PlotTopologies.anchor_plate_id" href="#gplately.plot.PlotTopologies.anchor_plate_id">anchor_plate_id</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_all_topological_sections" href="#gplately.plot.PlotTopologies.get_all_topological_sections">get_all_topological_sections</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_all_topologies" href="#gplately.plot.PlotTopologies.get_all_topologies">get_all_topologies</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_coastlines" href="#gplately.plot.PlotTopologies.get_coastlines">get_coastlines</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_continent_ocean_boundaries" href="#gplately.plot.PlotTopologies.get_continent_ocean_boundaries">get_continent_ocean_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_continental_crusts" href="#gplately.plot.PlotTopologies.get_continental_crusts">get_continental_crusts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_continental_rifts" href="#gplately.plot.PlotTopologies.get_continental_rifts">get_continental_rifts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_continents" href="#gplately.plot.PlotTopologies.get_continents">get_continents</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_extended_continental_crusts" href="#gplately.plot.PlotTopologies.get_extended_continental_crusts">get_extended_continental_crusts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_faults" href="#gplately.plot.PlotTopologies.get_faults">get_faults</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_feature" href="#gplately.plot.PlotTopologies.get_feature">get_feature</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_fracture_zones" href="#gplately.plot.PlotTopologies.get_fracture_zones">get_fracture_zones</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_inferred_paleo_boundaries" href="#gplately.plot.PlotTopologies.get_inferred_paleo_boundaries">get_inferred_paleo_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_misc_boundaries" href="#gplately.plot.PlotTopologies.get_misc_boundaries">get_misc_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_misc_transforms" href="#gplately.plot.PlotTopologies.get_misc_transforms">get_misc_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_orogenic_belts" href="#gplately.plot.PlotTopologies.get_orogenic_belts">get_orogenic_belts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_passive_continental_boundaries" href="#gplately.plot.PlotTopologies.get_passive_continental_boundaries">get_passive_continental_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_ridges" href="#gplately.plot.PlotTopologies.get_ridges">get_ridges</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_ridges_and_transforms" href="#gplately.plot.PlotTopologies.get_ridges_and_transforms">get_ridges_and_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_slab_edges" href="#gplately.plot.PlotTopologies.get_slab_edges">get_slab_edges</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_subduction_direction" href="#gplately.plot.PlotTopologies.get_subduction_direction">get_subduction_direction</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_sutures" href="#gplately.plot.PlotTopologies.get_sutures">get_sutures</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_terrane_boundaries" href="#gplately.plot.PlotTopologies.get_terrane_boundaries">get_terrane_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_topological_plate_boundaries" href="#gplately.plot.PlotTopologies.get_topological_plate_boundaries">get_topological_plate_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_transforms" href="#gplately.plot.PlotTopologies.get_transforms">get_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_transitional_crusts" href="#gplately.plot.PlotTopologies.get_transitional_crusts">get_transitional_crusts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_trenches" href="#gplately.plot.PlotTopologies.get_trenches">get_trenches</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.get_unclassified_features" href="#gplately.plot.PlotTopologies.get_unclassified_features">get_unclassified_features</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.misc_transforms" href="#gplately.plot.PlotTopologies.misc_transforms">misc_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_all_topological_sections" href="#gplately.plot.PlotTopologies.plot_all_topological_sections">plot_all_topological_sections</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_all_topologies" href="#gplately.plot.PlotTopologies.plot_all_topologies">plot_all_topologies</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_coastlines" href="#gplately.plot.PlotTopologies.plot_coastlines">plot_coastlines</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_continent_ocean_boundaries" href="#gplately.plot.PlotTopologies.plot_continent_ocean_boundaries">plot_continent_ocean_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_continental_crusts" href="#gplately.plot.PlotTopologies.plot_continental_crusts">plot_continental_crusts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_continental_rifts" href="#gplately.plot.PlotTopologies.plot_continental_rifts">plot_continental_rifts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_continents" href="#gplately.plot.PlotTopologies.plot_continents">plot_continents</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_extended_continental_crusts" href="#gplately.plot.PlotTopologies.plot_extended_continental_crusts">plot_extended_continental_crusts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_faults" href="#gplately.plot.PlotTopologies.plot_faults">plot_faults</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_feature" href="#gplately.plot.PlotTopologies.plot_feature">plot_feature</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_fracture_zones" href="#gplately.plot.PlotTopologies.plot_fracture_zones">plot_fracture_zones</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_grid" href="#gplately.plot.PlotTopologies.plot_grid">plot_grid</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_grid_from_netCDF" href="#gplately.plot.PlotTopologies.plot_grid_from_netCDF">plot_grid_from_netCDF</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_inferred_paleo_boundaries" href="#gplately.plot.PlotTopologies.plot_inferred_paleo_boundaries">plot_inferred_paleo_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_misc_boundaries" href="#gplately.plot.PlotTopologies.plot_misc_boundaries">plot_misc_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_misc_transforms" href="#gplately.plot.PlotTopologies.plot_misc_transforms">plot_misc_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_orogenic_belts" href="#gplately.plot.PlotTopologies.plot_orogenic_belts">plot_orogenic_belts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_passive_continental_boundaries" href="#gplately.plot.PlotTopologies.plot_passive_continental_boundaries">plot_passive_continental_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_plate_id" href="#gplately.plot.PlotTopologies.plot_plate_id">plot_plate_id</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_plate_motion_vectors" href="#gplately.plot.PlotTopologies.plot_plate_motion_vectors">plot_plate_motion_vectors</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_plate_polygon_by_id" href="#gplately.plot.PlotTopologies.plot_plate_polygon_by_id">plot_plate_polygon_by_id</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_pole" href="#gplately.plot.PlotTopologies.plot_pole">plot_pole</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_ridges" href="#gplately.plot.PlotTopologies.plot_ridges">plot_ridges</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_ridges_and_transforms" href="#gplately.plot.PlotTopologies.plot_ridges_and_transforms">plot_ridges_and_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_slab_edges" href="#gplately.plot.PlotTopologies.plot_slab_edges">plot_slab_edges</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_subduction_teeth" href="#gplately.plot.PlotTopologies.plot_subduction_teeth">plot_subduction_teeth</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_subduction_teeth_deprecated" href="#gplately.plot.PlotTopologies.plot_subduction_teeth_deprecated">plot_subduction_teeth_deprecated</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_sutures" href="#gplately.plot.PlotTopologies.plot_sutures">plot_sutures</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_terrane_boundaries" href="#gplately.plot.PlotTopologies.plot_terrane_boundaries">plot_terrane_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_topological_plate_boundaries" href="#gplately.plot.PlotTopologies.plot_topological_plate_boundaries">plot_topological_plate_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_transforms" href="#gplately.plot.PlotTopologies.plot_transforms">plot_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_transitional_crusts" href="#gplately.plot.PlotTopologies.plot_transitional_crusts">plot_transitional_crusts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_trenches" href="#gplately.plot.PlotTopologies.plot_trenches">plot_trenches</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_unclassified_features" href="#gplately.plot.PlotTopologies.plot_unclassified_features">plot_unclassified_features</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.ridge_transforms" href="#gplately.plot.PlotTopologies.ridge_transforms">ridge_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.ridges" href="#gplately.plot.PlotTopologies.ridges">ridges</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.time" href="#gplately.plot.PlotTopologies.time">time</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.topological_plate_boundaries" href="#gplately.plot.PlotTopologies.topological_plate_boundaries">topological_plate_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.topologies" href="#gplately.plot.PlotTopologies.topologies">topologies</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.transforms" href="#gplately.plot.PlotTopologies.transforms">transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.update_time" href="#gplately.plot.PlotTopologies.update_time">update_time</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
