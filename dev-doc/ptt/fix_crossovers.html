<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>gplately.ptt.fix_crossovers API documentation</title>
<meta name="description" content="Copyright (C) 2014 The University of Sydney, Australia â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.ptt.fix_crossovers</code></h1>
</header>
<section id="section-intro">
<p>Copyright (C) 2014 The University of Sydney, Australia</p>
<p>This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License
for more details.</p>
<p>You should have received a copy of the GNU General Public License along
with this program; if not, write to Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Copyright (C) 2014 The University of Sydney, Australia
    
    This program is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License, version 2, as published by
    the Free Software Foundation.
    
    This program is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
&#34;&#34;&#34;

from __future__ import print_function

import argparse
import os.path
import sys

import pygplates

DEFAULT_OUTPUT_FILENAME_SUFFIX = &#34;_fixed_crossovers&#34;


def _fix_crossovers(
    rotation_feature_collections,
    crossover_threshold_degrees,
    crossover_type_function,
    ignore_moving_plates,
    debug,
):
    crossover_filter = None
    # Ignore a subset of moving plates if requested.
    if ignore_moving_plates:
        crossover_filter = (
            lambda crossover: crossover.moving_plate_id not in ignore_moving_plates
        )

    # Synchronise crossovers.
    crossover_results = []
    synchronise_crossovers_success = pygplates.synchronise_crossovers(
        rotation_feature_collections,
        crossover_filter,
        crossover_threshold_degrees,
        crossover_type_function,
        crossover_results,
    )

    # Print debug output if requested.
    if debug:
        num_crossovers_error = 0
        num_crossovers_ignored = 0
        num_crossovers_passed = 0
        num_crossovers_corrected = 0

        for crossover_result in crossover_results:
            crossover = crossover_result[0]
            result = crossover_result[1]

            if crossover.type == pygplates.CrossoverType.synch_old_crossover_and_stages:
                type_str = &#34;synch old crossover and stages&#34;
            elif crossover.type == pygplates.CrossoverType.synch_old_crossover_only:
                type_str = &#34;synch old crossover only&#34;
            elif (
                crossover.type
                == pygplates.CrossoverType.synch_young_crossover_and_stages
            ):
                type_str = &#34;synch young crossover and stages&#34;
            elif crossover.type == pygplates.CrossoverType.synch_young_crossover_only:
                type_str = &#34;synch young crossover only&#34;
            elif crossover.type == pygplates.CrossoverType.ignore:
                type_str = &#34;ignore&#34;
            else:
                type_str = &#34;unknown&#34;

            if result == pygplates.CrossoverResult.not_synchronised:
                num_crossovers_passed += 1
                result_str = &#34;passed&#34;
            elif result == pygplates.CrossoverResult.synchronised:
                num_crossovers_corrected += 1
                result_str = &#34;corrected&#34;
            elif result == pygplates.CrossoverResult.ignored:
                num_crossovers_ignored += 1
                result_str = &#34;ignored&#34;
            else:
                num_crossovers_error += 1
                result_str = &#34;error&#34;

            print(
                &#34;Time({0}), moving_pid({1}), young_fixed_pid({2}), old_fixed_pid({3}), type({4}): {5}&#34;.format(
                    crossover.time,
                    crossover.moving_plate_id,
                    crossover.young_crossover_fixed_plate_id,
                    crossover.old_crossover_fixed_plate_id,
                    type_str,
                    result_str,
                )
            )

        print(&#34;Results:&#34;)
        print(&#34;  Total number of crossovers = {0}&#34;.format(len(crossover_results)))
        print(&#34;  Total errors = {0}&#34;.format(num_crossovers_error))
        print(&#34;  Total ignored = {0}&#34;.format(num_crossovers_ignored))
        print(&#34;  Total passed = {0}&#34;.format(num_crossovers_passed))
        print(&#34;  Total corrected = {0}&#34;.format(num_crossovers_corrected))

    return synchronise_crossovers_success


def parse_positive_number(value_string):
    &#34;&#34;&#34;parse and return a positive number&#34;&#34;&#34;
    try:
        value = float(value_string)
    except ValueError:
        raise argparse.ArgumentTypeError(&#34;%s is not a number&#34; % value_string)

    if value &lt; 0:
        raise argparse.ArgumentTypeError(&#34;%g is not a positive number&#34; % value)

    return value


def add_arguments(parser: argparse.ArgumentParser):
    &#34;&#34;&#34;add command line argument parser&#34;&#34;&#34;

    parser.formatter_class = argparse.RawDescriptionHelpFormatter
    parser.description = __description__

    parser.set_defaults(func=main)

    parser.add_argument(
        &#34;-d&#34;, &#34;--debug&#34;, action=&#34;store_true&#34;, help=&#34;Print debug output.&#34;
    )
    parser.add_argument(
        &#34;-c&#34;,
        &#34;--crossover_threshold_degrees&#34;,
        type=parse_positive_number,
        help=&#34;If specified then crossovers are fixed only if post-crossover rotation latitude, &#34;
        &#34;longitude or angle differ from those in pre-crossover rotation by the specified amount &#34;
        &#34;(in degrees). This is useful for some PLATES rotation files that are typically accurate &#34;
        &#34;to 2 decimal places (or threshold of 0.01).&#34;,
    )

    # Can specify only one of &#39;-x&#39; or &#39;-g&#39;.
    crossover_type_group = parser.add_mutually_exclusive_group()
    crossover_type_group.add_argument(
        &#34;-x&#34;,
        &#34;--default_xo_ys&#34;,
        action=&#34;store_true&#34;,
        dest=&#34;crossover_type_default_xo_ys&#34;,
        help=&#34;If specified, then if a crossover&#39;s type is unknown it will default to &#34;
        &#39;&#34;synch old crossover and stages&#34;, which is equivalent to the &#34;@xo_ys&#34; comment tag.&#39;,
    )
    crossover_type_group.add_argument(
        &#34;-g&#34;,
        &#34;--default_xo_ig&#34;,
        action=&#34;store_true&#34;,
        dest=&#34;crossover_type_default_xo_ig&#34;,
        help=&#34;If specified, then if a crossover&#39;s type is unknown it will default to &#34;
        &#39;ignoring the crossover, which is equivalent to the &#34;@xo_ig&#34; comment tag.&#39;,
    )

    parser.add_argument(
        &#34;-i&#34;,
        &#34;--ignore_moving_plates&#34;,
        type=parse_positive_number,
        nargs=&#34;+&#34;,
        metavar=&#34;MOVING_PLATE_ID&#34;,
        help=&#34;If specified then is a list of moving plate ids to ignore when fixing crossovers.&#34;,
    )
    parser.add_argument(
        &#34;-s&#34;,
        &#34;--output_filename_suffix&#34;,
        type=str,
        default=&#34;{0}&#34;.format(DEFAULT_OUTPUT_FILENAME_SUFFIX),
        help=&#34;The suffix to append to each input rotation filename to get each output rotation &#34;
        &#34;filename - the default suffix is &#39;{0}&#39;&#34;.format(DEFAULT_OUTPUT_FILENAME_SUFFIX),
    )

    parser.add_argument(
        &#34;input_rotation_filenames&#34;,
        type=str,
        nargs=&#34;+&#34;,
        metavar=&#34;input_rotation_filename&#34;,
        help=&#34;One or more input rotation filenames (original files).&#34;,
    )


__description__ = &#34;&#34;&#34;Loads one or more input rotation files, fixes any crossovers and saves the rotations to \
output rotation files.

    The name of each output file is the associated input filename with a suffix appended. For example:
       &#39;rotations/input_rotations.rot&#39; -&gt; &#39;rotations/input_rotations{0}.rot&#39;

    The method used to synchronise a crossover depends on following strings found in each &#39;young&#39;
    crossover pole:
      * @xo_ig : Ignore the crossover. Has the same effect as not specifying any tag, except
                 it avoids a warning/error message. All finite rotations in the young and old
                 crossover sequences are preserved.
      * @xo_ys : All finite rotations in the old crossover sequence will be synchronised
                 (such that old stage rotations are preserved). All finite rotations in the
                 young crossover sequence are preserved.
      * @xo_yf : Only the crossover finite rotation in the old crossover sequence will be
                 synchronised (such that the older finite rotations are preserved).
                 All finite rotations in the young crossover sequence are preserved.
      * @xo_os : All finite rotations in the young crossover sequence will be synchronised
                 (such that young stage rotations are preserved). All finite rotations in
                 old crossover sequence are preserved. Note: This can result in non-zero
                 finite rotations at present day if the younger sequence includes present day.
      * @xo_of : Only the crossover finite rotation in the young crossover sequence will be
                 synchronised (such that the younger finite rotations are preserved).
                 All finite rotations in the old crossover sequence are preserved.
    
    ...if any of the above tags are missing in a crossover then it will not be processed and
    a warning/error message will be printed.
    However the &#39;-x&#39; or &#39;-g&#39; option can optionally be used to default to @xo_ys or @xo_ig behaviour
    (respectively) for each crossover that does not have any of the above text strings (see below).

    NOTE: Separate the positional and optional arguments with &#39;--&#39; (workaround for bug in argparse module).
    For example...

    %(prog)s -d -c 0.01 -i 201 701 -- input_rotations1.rot input_rotations2.rot
    &#34;&#34;&#34;.format(
    DEFAULT_OUTPUT_FILENAME_SUFFIX
)


def main(args):
    # Check the imported pygplates version.
    required_version = pygplates.Version(12)
    if (
        not hasattr(pygplates, &#34;Version&#34;)
        or pygplates.Version.get_imported_version() &lt; required_version
    ):
        print(
            &#34;{0}: Error - imported pygplates version {1} but version {2} or greater is required&#34;.format(
                os.path.basename(__file__),
                pygplates.Version.get_imported_version(),
                required_version,
            ),
            file=sys.stderr,
        )
        sys.exit(1)

    file_registry = pygplates.FeatureCollectionFileFormatRegistry()

    # Read/parse the input rotation feature collections.
    rotation_feature_collections = [
        file_registry.read(input_rotation_filename)
        for input_rotation_filename in args.input_rotation_filenames
    ]

    # Whether to crossover types should default to &#39;@xo_ys&#39; or &#39;@xo_ig&#39; if type not found...
    if args.crossover_type_default_xo_ys:
        crossover_type_function = (
            pygplates.CrossoverTypeFunction.type_from_xo_tags_in_comment_default_xo_ys
        )
    elif args.crossover_type_default_xo_ig:
        crossover_type_function = (
            pygplates.CrossoverTypeFunction.type_from_xo_tags_in_comment_default_xo_ig
        )
    else:
        crossover_type_function = (
            pygplates.CrossoverTypeFunction.type_from_xo_tags_in_comment
        )

    # Fix crossovers.
    # If any errors occurred we will still write to the output files.
    if not _fix_crossovers(
        rotation_feature_collections,
        args.crossover_threshold_degrees,
        crossover_type_function,
        args.ignore_moving_plates,
        args.debug,
    ):
        print(
            &#34;Warning: One or more crossovers were not processed since unable to determine crossover &#34;
            &#34;correction method or infinite cycle detected.&#34;,
            file=sys.stderr,
        )

    # Write the modified rotation feature collections to disk.
    for rotation_feature_collection_index in range(len(rotation_feature_collections)):
        rotation_feature_collection = rotation_feature_collections[
            rotation_feature_collection_index
        ]

        # Each output filename is the input filename with a suffix appended.
        input_rotation_filename = args.input_rotation_filenames[
            rotation_feature_collection_index
        ]
        filename_root, filename_ext = os.path.splitext(input_rotation_filename)
        output_rotation_filename = &#34;&#34;.join(
            (filename_root, args.output_filename_suffix, filename_ext)
        )

        file_registry.write(rotation_feature_collection, output_rotation_filename)


if __name__ == &#34;__main__&#34;:
    # The command-line parser.
    parser = argparse.ArgumentParser(
        description=__description__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    # add arguments
    add_arguments(parser)

    # Parse command-line options.
    args = parser.parse_args()

    # call main function
    main(args)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gplately.ptt.fix_crossovers.add_arguments"><code class="name flex">
<span>def <span class="ident">add_arguments</span></span>(<span>parser:Â argparse.ArgumentParser)</span>
</code></dt>
<dd>
<div class="desc"><p>add command line argument parser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_arguments(parser: argparse.ArgumentParser):
    &#34;&#34;&#34;add command line argument parser&#34;&#34;&#34;

    parser.formatter_class = argparse.RawDescriptionHelpFormatter
    parser.description = __description__

    parser.set_defaults(func=main)

    parser.add_argument(
        &#34;-d&#34;, &#34;--debug&#34;, action=&#34;store_true&#34;, help=&#34;Print debug output.&#34;
    )
    parser.add_argument(
        &#34;-c&#34;,
        &#34;--crossover_threshold_degrees&#34;,
        type=parse_positive_number,
        help=&#34;If specified then crossovers are fixed only if post-crossover rotation latitude, &#34;
        &#34;longitude or angle differ from those in pre-crossover rotation by the specified amount &#34;
        &#34;(in degrees). This is useful for some PLATES rotation files that are typically accurate &#34;
        &#34;to 2 decimal places (or threshold of 0.01).&#34;,
    )

    # Can specify only one of &#39;-x&#39; or &#39;-g&#39;.
    crossover_type_group = parser.add_mutually_exclusive_group()
    crossover_type_group.add_argument(
        &#34;-x&#34;,
        &#34;--default_xo_ys&#34;,
        action=&#34;store_true&#34;,
        dest=&#34;crossover_type_default_xo_ys&#34;,
        help=&#34;If specified, then if a crossover&#39;s type is unknown it will default to &#34;
        &#39;&#34;synch old crossover and stages&#34;, which is equivalent to the &#34;@xo_ys&#34; comment tag.&#39;,
    )
    crossover_type_group.add_argument(
        &#34;-g&#34;,
        &#34;--default_xo_ig&#34;,
        action=&#34;store_true&#34;,
        dest=&#34;crossover_type_default_xo_ig&#34;,
        help=&#34;If specified, then if a crossover&#39;s type is unknown it will default to &#34;
        &#39;ignoring the crossover, which is equivalent to the &#34;@xo_ig&#34; comment tag.&#39;,
    )

    parser.add_argument(
        &#34;-i&#34;,
        &#34;--ignore_moving_plates&#34;,
        type=parse_positive_number,
        nargs=&#34;+&#34;,
        metavar=&#34;MOVING_PLATE_ID&#34;,
        help=&#34;If specified then is a list of moving plate ids to ignore when fixing crossovers.&#34;,
    )
    parser.add_argument(
        &#34;-s&#34;,
        &#34;--output_filename_suffix&#34;,
        type=str,
        default=&#34;{0}&#34;.format(DEFAULT_OUTPUT_FILENAME_SUFFIX),
        help=&#34;The suffix to append to each input rotation filename to get each output rotation &#34;
        &#34;filename - the default suffix is &#39;{0}&#39;&#34;.format(DEFAULT_OUTPUT_FILENAME_SUFFIX),
    )

    parser.add_argument(
        &#34;input_rotation_filenames&#34;,
        type=str,
        nargs=&#34;+&#34;,
        metavar=&#34;input_rotation_filename&#34;,
        help=&#34;One or more input rotation filenames (original files).&#34;,
    )</code></pre>
</details>
</dd>
<dt id="gplately.ptt.fix_crossovers.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(args):
    # Check the imported pygplates version.
    required_version = pygplates.Version(12)
    if (
        not hasattr(pygplates, &#34;Version&#34;)
        or pygplates.Version.get_imported_version() &lt; required_version
    ):
        print(
            &#34;{0}: Error - imported pygplates version {1} but version {2} or greater is required&#34;.format(
                os.path.basename(__file__),
                pygplates.Version.get_imported_version(),
                required_version,
            ),
            file=sys.stderr,
        )
        sys.exit(1)

    file_registry = pygplates.FeatureCollectionFileFormatRegistry()

    # Read/parse the input rotation feature collections.
    rotation_feature_collections = [
        file_registry.read(input_rotation_filename)
        for input_rotation_filename in args.input_rotation_filenames
    ]

    # Whether to crossover types should default to &#39;@xo_ys&#39; or &#39;@xo_ig&#39; if type not found...
    if args.crossover_type_default_xo_ys:
        crossover_type_function = (
            pygplates.CrossoverTypeFunction.type_from_xo_tags_in_comment_default_xo_ys
        )
    elif args.crossover_type_default_xo_ig:
        crossover_type_function = (
            pygplates.CrossoverTypeFunction.type_from_xo_tags_in_comment_default_xo_ig
        )
    else:
        crossover_type_function = (
            pygplates.CrossoverTypeFunction.type_from_xo_tags_in_comment
        )

    # Fix crossovers.
    # If any errors occurred we will still write to the output files.
    if not _fix_crossovers(
        rotation_feature_collections,
        args.crossover_threshold_degrees,
        crossover_type_function,
        args.ignore_moving_plates,
        args.debug,
    ):
        print(
            &#34;Warning: One or more crossovers were not processed since unable to determine crossover &#34;
            &#34;correction method or infinite cycle detected.&#34;,
            file=sys.stderr,
        )

    # Write the modified rotation feature collections to disk.
    for rotation_feature_collection_index in range(len(rotation_feature_collections)):
        rotation_feature_collection = rotation_feature_collections[
            rotation_feature_collection_index
        ]

        # Each output filename is the input filename with a suffix appended.
        input_rotation_filename = args.input_rotation_filenames[
            rotation_feature_collection_index
        ]
        filename_root, filename_ext = os.path.splitext(input_rotation_filename)
        output_rotation_filename = &#34;&#34;.join(
            (filename_root, args.output_filename_suffix, filename_ext)
        )

        file_registry.write(rotation_feature_collection, output_rotation_filename)</code></pre>
</details>
</dd>
<dt id="gplately.ptt.fix_crossovers.parse_positive_number"><code class="name flex">
<span>def <span class="ident">parse_positive_number</span></span>(<span>value_string)</span>
</code></dt>
<dd>
<div class="desc"><p>parse and return a positive number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_positive_number(value_string):
    &#34;&#34;&#34;parse and return a positive number&#34;&#34;&#34;
    try:
        value = float(value_string)
    except ValueError:
        raise argparse.ArgumentTypeError(&#34;%s is not a number&#34; % value_string)

    if value &lt; 0:
        raise argparse.ArgumentTypeError(&#34;%g is not a positive number&#34; % value)

    return value</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="GPlately logo" height="172" width="205">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately.ptt" href="index.html">gplately.ptt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gplately.ptt.fix_crossovers.add_arguments" href="#gplately.ptt.fix_crossovers.add_arguments">add_arguments</a></code></li>
<li><code><a title="gplately.ptt.fix_crossovers.main" href="#gplately.ptt.fix_crossovers.main">main</a></code></li>
<li><code><a title="gplately.ptt.fix_crossovers.parse_positive_number" href="#gplately.ptt.fix_crossovers.parse_positive_number">parse_positive_number</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>