<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>gplately.ptt.utils.points_spatial_tree API documentation</title>
<meta name="description" content="Spatial tree for points (pygplates.PointOnSphere) â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.ptt.utils.points_spatial_tree</code></h1>
</header>
<section id="section-intro">
<p>Spatial tree for points (pygplates.PointOnSphere).
</p>
<p>Can be used to speed up point-in-polygon and minimum distance queries
from points to arbitrary geometries.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.ptt.utils.points_spatial_tree.PointsSpatialTree"><code class="flex name class">
<span>class <span class="ident">PointsSpatialTree</span></span>
<span>(</span><span>points, subdivision_depth=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a spatial tree from a sequence of points up to a maximum tree depth.</p>
<p>points: a sequence of 'pygplates.PointOnSphere'.</p>
<p>subdivision_depth: The depth of the internal lat/lon quad tree.
The lat/lon width of a leaf quad tree node is (90 / (2^subdivision_depth)) degrees.
Generally the denser the 'points' the larger the depth should be.
Setting this value too high causes unnecessary time to be spent generating a deep quad tree.
Setting this value too low reduces the culling/querying efficiency of the quad tree.
However a value of 4 seems to work quite well for a uniform lat/lon spacing of 'points' of 1 degree
and below without the cost of generating a deep quad tree.
So most of the time the subdivision depth can be left at its default value.</p>
<p>Raises ValueError if 'subdivision_depth' is not in the range [0, 100].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PointsSpatialTree(object):

    def __init__(self, points, subdivision_depth=DEFAULT_SUBDIVISION_DEPTH):
        &#34;&#34;&#34;
        Construct a spatial tree from a sequence of points up to a maximum tree depth.

        points: a sequence of &#39;pygplates.PointOnSphere&#39;.

        subdivision_depth: The depth of the internal lat/lon quad tree.
                           The lat/lon width of a leaf quad tree node is (90 / (2^subdivision_depth)) degrees.
                           Generally the denser the &#39;points&#39; the larger the depth should be.
                           Setting this value too high causes unnecessary time to be spent generating a deep quad tree.
                           Setting this value too low reduces the culling/querying efficiency of the quad tree.
                           However a value of 4 seems to work quite well for a uniform lat/lon spacing of &#39;points&#39; of 1 degree
                           and below without the cost of generating a deep quad tree.
                           So most of the time the subdivision depth can be left at its default value.

        Raises ValueError if &#39;subdivision_depth&#39; is not in the range [0, 100].
        &#34;&#34;&#34;

        if subdivision_depth &lt; 0:
            raise ValueError(&#34;Subdivision depth must be a non-negative value.&#34;)
        elif subdivision_depth &gt; 100:
            raise ValueError(&#34;Subdivision depth is too large (should be 100 or less).&#34;)

        # Each root quad tree node is quadrant of the globe (square in lat/lon space of size 90 x 90 degrees).
        # So there are 8 of them.
        # We&#39;ll only create them as needed.
        self._root_nodes = [None] * 8

        # Place each point in a quad tree leaf node.
        for point_index, point in enumerate(points):
            point_lat, point_lon = point.to_lat_lon()

            # Get root node that current point is in.
            if point_lat &lt; 0:
                root_node_lat_index = 0
            else:
                root_node_lat_index = 1

            if point_lon &lt; 0:
                if point_lon &lt; -90:
                    root_node_lon_index = 0
                else:
                    root_node_lon_index = 1
            else:
                if point_lon &lt; 90:
                    root_node_lon_index = 2
                else:
                    root_node_lon_index = 3

            root_node_index = 4 * root_node_lat_index + root_node_lon_index
            root_node = self._root_nodes[root_node_index]

            is_north_hemisphere = root_node_lat_index == 1
            root_node_half_width_degrees = 45.0
            root_node_centre_lon = (
                -180 + 90 * root_node_lon_index + root_node_half_width_degrees
            )
            root_node_centre_lat = (
                -90 + 90 * root_node_lat_index + root_node_half_width_degrees
            )

            # Create root node if first time visited.
            if root_node is None:
                root_node = PointsSpatialTreeNode(
                    root_node_centre_lon,
                    root_node_centre_lat,
                    root_node_half_width_degrees,
                    is_north_hemisphere,
                )
                self._root_nodes[root_node_index] = root_node

            # Iterate through the subdivision levels and place current point in the correct quad tree leaf node.
            node = root_node
            node_half_width_degrees = root_node_half_width_degrees
            node_centre_lon = root_node_centre_lon
            node_centre_lat = root_node_centre_lat
            for level in range(0, subdivision_depth):

                child_node_half_width_degrees = node_half_width_degrees / 2.0

                if point_lat &lt; node_centre_lat:
                    child_node_lat_offset = 0
                    child_node_centre_lat = (
                        node_centre_lat - child_node_half_width_degrees
                    )
                else:
                    child_node_lat_offset = 1
                    child_node_centre_lat = (
                        node_centre_lat + child_node_half_width_degrees
                    )

                if point_lon &lt; node_centre_lon:
                    child_node_lon_offset = 0
                    child_node_centre_lon = (
                        node_centre_lon - child_node_half_width_degrees
                    )
                else:
                    child_node_lon_offset = 1
                    child_node_centre_lon = (
                        node_centre_lon + child_node_half_width_degrees
                    )

                # The current node is an internal node (because it will have child nodes).
                # Create a list of child nodes if first time visiting node.
                if node._child_nodes is None:
                    # Only create each child node as needed.
                    node._child_nodes = [None] * 4

                child_node_index = 2 * child_node_lat_offset + child_node_lon_offset
                child_node = node._child_nodes[child_node_index]

                if child_node is None:
                    child_node = PointsSpatialTreeNode(
                        child_node_centre_lon,
                        child_node_centre_lat,
                        child_node_half_width_degrees,
                        is_north_hemisphere,
                    )
                    node._child_nodes[child_node_index] = child_node

                # Child node becomes parent node in next iteration.
                node = child_node
                node_half_width_degrees = child_node_half_width_degrees
                node_centre_lon = child_node_centre_lon
                node_centre_lat = child_node_centre_lat

            # Reached leaf node (end of subdivision).
            # Create a list of point indices if first time visiting node.
            if node._point_indices is None:
                node._point_indices = []

            # Add the current point (index) to the leaf node.
            node._point_indices.append(point_index)

    def get_root_nodes(self):
        &#34;&#34;&#34;
        Return any root nodes that have points in their subtree.

        There are a maximum of 8 root nodes.

        Returns: A list of Node.
        &#34;&#34;&#34;

        return [root_node for root_node in self._root_nodes if root_node is not None]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gplately.ptt.utils.points_spatial_tree.PointsSpatialTree.get_root_nodes"><code class="name flex">
<span>def <span class="ident">get_root_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return any root nodes that have points in their subtree.</p>
<p>There are a maximum of 8 root nodes.</p>
<p>Returns: A list of Node.</p></div>
</dd>
</dl>
</dd>
<dt id="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode"><code class="flex name class">
<span>class <span class="ident">PointsSpatialTreeNode</span></span>
<span>(</span><span>centre_lon, centre_lat, half_width_degrees, is_north_hemisphere)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PointsSpatialTreeNode(object):
    def __init__(self, centre_lon, centre_lat, half_width_degrees, is_north_hemisphere):
        # Parameters to describe location and extents of this node.
        self._centre_lon = centre_lon
        self._centre_lat = centre_lat
        self._half_width_degrees = half_width_degrees
        self._is_north_hemisphere = is_north_hemisphere

        # We&#39;ll create the bounding polygon/circle when/if they are requested.
        self._bounding_polygon = None
        self._bounding_circle = None

        # If an internal quad tree node then &#39;_child_nodes&#39; will be a list of
        # 4 child quad tree nodes and &#39;_point_indices&#39; will be None.
        # Otherwise quad tree node is a leaf node where &#39;point_indices&#39; is a list of points and
        # &#39;child_nodes&#39; will be None.
        self._child_nodes = None
        self._point_indices = None

    def get_bounding_polygon(self):
        &#34;&#34;&#34;
        Returns a polygon that bounds the current node.

        The returned polygon is guaranteed to contain all points in this node (and any child nodes, etc).
        However it is not guaranteed to contain the bounding circle.

        Returns: pygplates.PolygonOnSphere
        &#34;&#34;&#34;

        if self._bounding_polygon is None:
            self._create_bounding_polygon()

        return self._bounding_polygon

    def get_bounding_circle(self):
        &#34;&#34;&#34;
        Returns a small circle that bounds the current node.

        The returned small circle is guaranteed to contain all points in this node (and any child nodes, etc).
        However it is not guaranteed to contain the bounding polygon.

        Returns: The centre of small circle and its radius (in radians) as the 2-tuple of type (pygplates.PointOnSphere, float).
        &#34;&#34;&#34;

        if self._bounding_circle is None:
            self._create_bounding_circle()

        return self._bounding_circle

    def is_leaf_node(self):
        &#34;&#34;&#34;
        Returns True if this node is a leaf node.

        A leaf node has indices into the sequence of points passed into
        spatial tree constructor - see &#39;get_point_indices()&#39;.
        But it does not have any child nodes.
        &#34;&#34;&#34;

        return self._point_indices is not None

    def is_internal_node(self):
        &#34;&#34;&#34;
        Returns True if this node is an internal node.

        An internal node has child nodes - see &#39;get_child_nodes()&#39;.
        But it does not have any point indices.
        &#34;&#34;&#34;

        return self._child_nodes is not None

    def get_child_nodes(self):
        &#34;&#34;&#34;
        Return any child nodes that have points in their subtree.

        There are a maximum of 4 child nodes.

        Should only be called if &#39;is_internal_node()&#39; returns True.

        Returns: A list of Node.
        &#34;&#34;&#34;

        return [
            child_node for child_node in self._child_nodes if child_node is not None
        ]

    def get_point_indices(self):
        &#34;&#34;&#34;
        Return indices of points that exist in this leaf node.

        The indices refer to the sequence of points passed into spatial tree constructor.

        Should only be called if &#39;is_leaf_node()&#39; returns True.

        Returns: A list of int.
        &#34;&#34;&#34;

        return self._point_indices

    def _create_bounding_polygon(self):

        # Create the points of the polygon bounding the current quad tree node.
        bounding_polygon_points = []

        left_lon = self._centre_lon - self._half_width_degrees
        right_lon = self._centre_lon + self._half_width_degrees
        bottom_lat = self._centre_lat - self._half_width_degrees
        top_lat = self._centre_lat + self._half_width_degrees

        # Northern and southern hemispheres handled separately.
        if self._is_north_hemisphere:
            # Northern hemisphere.
            left_boundary = pygplates.PolylineOnSphere([(0, left_lon), (90, left_lon)])
            right_boundary = pygplates.PolylineOnSphere(
                [(0, right_lon), (90, right_lon)]
            )

            # Midpoint of small circle arc bounding the bottom of quad tree node.
            bottom_mid_point = pygplates.PointOnSphere(
                bottom_lat, 0.5 * (left_lon + right_lon)
            )

            # Find the great circle (rotation) that passes through the bottom midpoint (and is oriented towards North pole).
            bottom_great_circle_rotation_axis = pygplates.Vector3D.cross(
                bottom_mid_point.to_xyz(),
                pygplates.Vector3D.cross(
                    pygplates.PointOnSphere.north_pole.to_xyz(),
                    bottom_mid_point.to_xyz(),
                ),
            ).to_normalised()
            bottom_great_circle_rotation = pygplates.FiniteRotation(
                bottom_great_circle_rotation_axis.to_xyz(), 0.5 * math.pi
            )

            # Intersect great circle bottom boundary with left and right boundaries to find bottom-left and bottom-right points.
            # The bottom boundary is actually a small circle (due to lat/lon grid), but since we need to use *great* circle arcs
            # in our geometries we need to be a bit loose with our bottom boundary otherwise it will go inside the quad tree node.
            bottom_boundary = pygplates.PolylineOnSphere(
                [
                    bottom_great_circle_rotation * bottom_mid_point,
                    bottom_mid_point,
                    bottom_great_circle_rotation.get_inverse() * bottom_mid_point,
                ]
            )
            _, _, bottom_left_point = pygplates.GeometryOnSphere.distance(
                bottom_boundary, left_boundary, return_closest_positions=True
            )
            _, _, bottom_right_point = pygplates.GeometryOnSphere.distance(
                bottom_boundary, right_boundary, return_closest_positions=True
            )

            bounding_polygon_points.append(bottom_left_point)
            bounding_polygon_points.append(bottom_right_point)

            bounding_polygon_points.append(pygplates.PointOnSphere(top_lat, right_lon))
            bounding_polygon_points.append(pygplates.PointOnSphere(top_lat, left_lon))
        else:
            # Southern hemisphere.
            left_boundary = pygplates.PolylineOnSphere([(0, left_lon), (-90, left_lon)])
            right_boundary = pygplates.PolylineOnSphere(
                [(0, right_lon), (-90, right_lon)]
            )

            # Midpoint of small circle arc bounding the top of quad tree node.
            top_mid_point = pygplates.PointOnSphere(
                top_lat, 0.5 * (left_lon + right_lon)
            )

            # Find the great circle (rotation) that passes through the top midpoint (and is oriented towards North pole).
            top_great_circle_rotation_axis = pygplates.Vector3D.cross(
                top_mid_point.to_xyz(),
                pygplates.Vector3D.cross(
                    pygplates.PointOnSphere.north_pole.to_xyz(), top_mid_point.to_xyz()
                ),
            ).to_normalised()
            top_great_circle_rotation = pygplates.FiniteRotation(
                top_great_circle_rotation_axis.to_xyz(), 0.5 * math.pi
            )

            # Intersect great circle top boundary with left and right boundaries to find top-left and top-right points.
            # The top boundary is actually a small circle (due to lat/lon grid), but since we need to use *great* circle arcs
            # in our geometries we need to be a bit loose with our top boundary otherwise it will go inside the quad tree node.
            top_boundary = pygplates.PolylineOnSphere(
                [
                    top_great_circle_rotation * top_mid_point,
                    top_mid_point,
                    top_great_circle_rotation.get_inverse() * top_mid_point,
                ]
            )
            _, _, top_left_point = pygplates.GeometryOnSphere.distance(
                top_boundary, left_boundary, return_closest_positions=True
            )
            _, _, top_right_point = pygplates.GeometryOnSphere.distance(
                top_boundary, right_boundary, return_closest_positions=True
            )

            bounding_polygon_points.append(top_left_point)
            bounding_polygon_points.append(top_right_point)

            bounding_polygon_points.append(
                pygplates.PointOnSphere(bottom_lat, right_lon)
            )
            bounding_polygon_points.append(
                pygplates.PointOnSphere(bottom_lat, left_lon)
            )

        self._bounding_polygon = pygplates.PolygonOnSphere(bounding_polygon_points)

    def _create_bounding_circle(self):

        bound_circle_centre = pygplates.PointOnSphere(
            self._centre_lat, self._centre_lon
        )

        left_lon = self._centre_lon - self._half_width_degrees
        right_lon = self._centre_lon + self._half_width_degrees
        bottom_lat = self._centre_lat - self._half_width_degrees
        top_lat = self._centre_lat + self._half_width_degrees

        # The small circle that bound the four corner points will also bound the associated lat/lon box.
        # This is because the small circle centre will be inside the box and the small circle curvature
        # is greater than all four sides of the box (two great circle arcs and two small circle arcs).
        dist_to_bottom_left = pygplates.GeometryOnSphere.distance(
            bound_circle_centre, pygplates.PointOnSphere(bottom_lat, left_lon)
        )
        dist_to_bottom_right = pygplates.GeometryOnSphere.distance(
            bound_circle_centre, pygplates.PointOnSphere(bottom_lat, right_lon)
        )
        dist_to_top_left = pygplates.GeometryOnSphere.distance(
            bound_circle_centre, pygplates.PointOnSphere(top_lat, left_lon)
        )
        dist_to_top_right = pygplates.GeometryOnSphere.distance(
            bound_circle_centre, pygplates.PointOnSphere(top_lat, right_lon)
        )

        bounding_circle_radius_radians = max(
            dist_to_bottom_left,
            dist_to_bottom_right,
            dist_to_top_left,
            dist_to_top_right,
        )

        self._bounding_circle = (bound_circle_centre, bounding_circle_radius_radians)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_bounding_circle"><code class="name flex">
<span>def <span class="ident">get_bounding_circle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a small circle that bounds the current node.</p>
<p>The returned small circle is guaranteed to contain all points in this node (and any child nodes, etc).
However it is not guaranteed to contain the bounding polygon.</p>
<p>Returns: The centre of small circle and its radius (in radians) as the 2-tuple of type (pygplates.PointOnSphere, float).</p></div>
</dd>
<dt id="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_bounding_polygon"><code class="name flex">
<span>def <span class="ident">get_bounding_polygon</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a polygon that bounds the current node.</p>
<p>The returned polygon is guaranteed to contain all points in this node (and any child nodes, etc).
However it is not guaranteed to contain the bounding circle.</p>
<p>Returns: pygplates.PolygonOnSphere</p></div>
</dd>
<dt id="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_child_nodes"><code class="name flex">
<span>def <span class="ident">get_child_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return any child nodes that have points in their subtree.</p>
<p>There are a maximum of 4 child nodes.</p>
<p>Should only be called if 'is_internal_node()' returns True.</p>
<p>Returns: A list of Node.</p></div>
</dd>
<dt id="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_point_indices"><code class="name flex">
<span>def <span class="ident">get_point_indices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return indices of points that exist in this leaf node.</p>
<p>The indices refer to the sequence of points passed into spatial tree constructor.</p>
<p>Should only be called if 'is_leaf_node()' returns True.</p>
<p>Returns: A list of int.</p></div>
</dd>
<dt id="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.is_internal_node"><code class="name flex">
<span>def <span class="ident">is_internal_node</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if this node is an internal node.</p>
<p>An internal node has child nodes - see 'get_child_nodes()'.
But it does not have any point indices.</p></div>
</dd>
<dt id="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.is_leaf_node"><code class="name flex">
<span>def <span class="ident">is_leaf_node</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if this node is a leaf node.</p>
<p>A leaf node has indices into the sequence of points passed into
spatial tree constructor - see 'get_point_indices()'.
But it does not have any child nodes.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="GPlately logo" height="172" width="205">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately.ptt.utils" href="index.html">gplately.ptt.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.ptt.utils.points_spatial_tree.PointsSpatialTree" href="#gplately.ptt.utils.points_spatial_tree.PointsSpatialTree">PointsSpatialTree</a></code></h4>
<ul class="">
<li><code><a title="gplately.ptt.utils.points_spatial_tree.PointsSpatialTree.get_root_nodes" href="#gplately.ptt.utils.points_spatial_tree.PointsSpatialTree.get_root_nodes">get_root_nodes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode" href="#gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode">PointsSpatialTreeNode</a></code></h4>
<ul class="">
<li><code><a title="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_bounding_circle" href="#gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_bounding_circle">get_bounding_circle</a></code></li>
<li><code><a title="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_bounding_polygon" href="#gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_bounding_polygon">get_bounding_polygon</a></code></li>
<li><code><a title="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_child_nodes" href="#gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_child_nodes">get_child_nodes</a></code></li>
<li><code><a title="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_point_indices" href="#gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.get_point_indices">get_point_indices</a></code></li>
<li><code><a title="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.is_internal_node" href="#gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.is_internal_node">is_internal_node</a></code></li>
<li><code><a title="gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.is_leaf_node" href="#gplately.ptt.utils.points_spatial_tree.PointsSpatialTreeNode.is_leaf_node">is_leaf_node</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
