<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.0">
<title>gplately.geometry API documentation</title>
<meta name="description" content="Tools for converting PyGPlates or GPlately geometries to Shapely geometries for mapping (and vice versa) â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.geometry</code></h1>
</header>
<section id="section-intro">
<p>Tools for converting PyGPlates or GPlately geometries to Shapely geometries for mapping (and vice versa). </p>
<p>Supported PyGPlates geometries inherit from the following classes:</p>
<ul>
<li>
<p><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.geometryonsphere">pygplates.GeometryOnSphere</a>: This
class has the following derived GeometryOnSphere classes:</p>
<ul>
<li><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.pointonsphere#pygplates.PointOnSphere">pygplates.PointOnSphere</a></li>
<li><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.multipointonsphere#pygplates.MultiPointOnSphere">pygplates.MultiPointOnSphere</a></li>
<li><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.polylineonsphere#pygplates.PolylineOnSphere">pygplates.PolylineOnSphere</a></li>
<li><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.polygononsphere#pygplates.PolygonOnSphere">pygplates.PolygonOnSphere</a></li>
</ul>
</li>
<li>
<p><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.latlonpoint">pygplates.LatLonPoint</a></p>
</li>
<li><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.reconstructedfeaturegeometry">pygplates.ReconstructedFeatureGeometry</a></li>
<li><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.resolvedtopologicalline">pygplates.ResolvedTopologicalLine</a></li>
<li><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.resolvedtopologicalboundary">pygplates.ResolvedTopologicalBoundary</a></li>
<li><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.resolvedtopologicalnetwork">pygplates.ResolvedTopologicalNetwork</a></li>
</ul>
<p>Note: GPlately geometries derive from the <code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code> and <code>pygplates.GeometryOnSphere</code> base classes. </p>
<p>Supported Shapely geometric objects include:</p>
<ul>
<li><strong>Point</strong>: a single point in 2D space with coordinate tuple (x,y) or 3D space with coordinate tuple (x,y,z).</li>
<li><strong>LineString</strong>: a sequence of points joined together to form a line (a list of point coordinate tuples).</li>
<li><strong>Polygon</strong>: a sequence of points joined together to form the outer ring of a filled area, or a hole (a list of at least
three point coordinate tuples).</li>
</ul>
<p>Also supported are collections of geometric objects, such as:</p>
<ul>
<li><strong>MultiPoint</strong>: a list of <strong>Point</strong> objects (a list of point coordinate tuples).</li>
<li><strong>MultiLineString</strong>: a list of <strong>LineString</strong> objects (a list containing lists of point coordinate tuples).</li>
<li><strong>MultiPolygon</strong>:
a list of <strong>Polygon</strong> objects (a list containing lists of point coordinate tuples that define exterior rings and/or holes).</li>
</ul>
<p><strong>Converting PyGPlates geometries into Shapely geometries</strong> involves:</p>
<ul>
<li><strong>wrapping geometries at the dateline</strong>: this involves splitting a polygon, MultiPolygon, line segment or MultiLine segment between
connecting points at the dateline. This is to ensure the geometry's points are joined along the short path rather than
the long path horizontally across the 2D map projection display.</li>
<li><strong>ordering geometries counter-clockwise</strong></li>
</ul>
<p>Input PyGPlates geometries are converted to the following Shapely geometries:</p>
<ul>
<li><code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code> or <code><a title="gplately.geometry.LatLonPoint" href="#gplately.geometry.LatLonPoint">LatLonPoint</a></code>: <code>Point</code></li>
<li><code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code>: <code>MultiPoint</code></li>
<li><code><a title="gplately.geometry.PolylineOnSphere" href="#gplately.geometry.PolylineOnSphere">PolylineOnSphere</a></code>: <code>LineString</code> or <code>MultiLineString</code></li>
<li><code><a title="gplately.geometry.PolygonOnSphere" href="#gplately.geometry.PolygonOnSphere">PolygonOnSphere</a></code>: <code>Polygon</code> or <code>MultiPolygon</code></li>
</ul>
<p><strong>Converting Shapely geometries into PyGPlates geometries</strong>:
Input Shapely geometries are converted to the following PyGPlates geometries:</p>
<ul>
<li><code>Point</code>: <code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code></li>
<li><code>MultiPoint</code>: <code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code></li>
<li><code>LineString</code>: <code><a title="gplately.geometry.PolylineOnSphere" href="#gplately.geometry.PolylineOnSphere">PolylineOnSphere</a></code></li>
<li><code>LinearRing</code> or <code>Polygon</code>: <code><a title="gplately.geometry.PolygonOnSphere" href="#gplately.geometry.PolygonOnSphere">PolygonOnSphere</a></code></li>
</ul>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gplately.geometry.pygplates_to_shapely"><code class="name flex">
<span>def <span class="ident">pygplates_to_shapely</span></span>(<span>geometry, central_meridian=0.0, tessellate_degrees=None, validate=False, force_ccw=False, explode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert one or more PyGPlates or GPlately geometries to Shapely format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geometry</code></strong> :&ensp;<code>pygplates.GeometryOnSphere</code> or <code>pygplates.LatLonPoint</code> or <code>list</code></dt>
<dd>The geometry or geometries to convert.</dd>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code>, default<code>: 0.0</code></dt>
<dd>The central meridian around which to wrap geometries;
geometries will be split at the antimeridian.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>If provided, the geometry will be tessellated to this resolution prior to conversion.</dd>
<dt><strong><code>validate</code></strong> :&ensp;<code>bool</code>, default<code>: False</code></dt>
<dd>Attempt to ensure output geometry is valid by applying a buffer of 0.</dd>
<dt><strong><code>force_ccw</code></strong> :&ensp;<code>bool</code>, default<code>: False</code></dt>
<dd>Ensure the coordinates of the output geometry are counter-clockwise(only applies to polygons).</dd>
<dt><strong><code>explode</code></strong> :&ensp;<code>bool</code>, default<code>: False</code></dt>
<dd>Convert multi-part output geometries to multiple single-part geometries.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output_geometry</code></strong> :&ensp;<code>shapely.geometry.base.BaseGeometry</code> or <code>list</code></dt>
<dd>Converted Shapely geometry or geometries.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If a single input geometry was passed, <code>output_geometry</code> will be a
subclass of <code>shapely.geometry.base.BaseGeometry</code>. Otherwise,
<code>output_geometry</code> will be a list of the same length as the input.</p>
<p>Input geometries that were split while wrapping around
<code>central_meridian</code> will produce multi-part output geometries, unless <code>explode=True</code> is specified.</p>
<p>Input geometry types are converted as follows:
- <code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code> or <code><a title="gplately.geometry.LatLonPoint" href="#gplately.geometry.LatLonPoint">LatLonPoint</a></code>:
<code>Point</code>
- <code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code>:
<code>MultiPoint</code>
- <code><a title="gplately.geometry.PolylineOnSphere" href="#gplately.geometry.PolylineOnSphere">PolylineOnSphere</a></code>:
<code>LineString</code> or
<code>MultiLineString</code>
- <code><a title="gplately.geometry.PolygonOnSphere" href="#gplately.geometry.PolygonOnSphere">PolygonOnSphere</a></code>:
<code>Polygon</code> or
<code>MultiPolygon</code></p></div>
</dd>
<dt id="gplately.geometry.shapely_to_pygplates"><code class="name flex">
<span>def <span class="ident">shapely_to_pygplates</span></span>(<span>geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert one or more Shapely geometries to gplately format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geometry</code></strong> :&ensp;<code>shapely.geometry.base.BaseGeometry</code> or <code>list</code></dt>
<dd>The geometry or geometries to convert.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output_geometry</code></strong> :&ensp;<code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code> or <code>list</code></dt>
<dd>Converted gplately geometry or geometries.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If a single input geometry was passed, <code>output_geometry</code> will be a subclass of <code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code>.
Otherwise, <code>output_geometry</code> will be a list of <code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code>, of the same length as the input.</p>
<p>Input geometry types are converted as follows:
- <code>Point</code>: <code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code>
- <code>MultiPoint</code>: <code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code>
- <code>LineString</code>: <code><a title="gplately.geometry.PolylineOnSphere" href="#gplately.geometry.PolylineOnSphere">PolylineOnSphere</a></code>
- <code>LinearRing</code> or <code>Polygon</code>: <code><a title="gplately.geometry.PolygonOnSphere" href="#gplately.geometry.PolygonOnSphere">PolygonOnSphere</a></code></p>
<p>Multi-part input geometry types other than <code>MultiPoint</code> will be treated
as an iterable of their component single-part geometries.</p></div>
</dd>
<dt id="gplately.geometry.wrap_geometries"><code class="name flex">
<span>def <span class="ident">wrap_geometries</span></span>(<span>geometries, central_meridian=0.0, tessellate_degrees=None, validate=False, force_ccw=False, explode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrap one or more Shapely geometries around a central meridian.</p>
<p>Wrapped geometries will be split at the antimeridian.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geometry</code></strong> :&ensp;<code>shapely.geometry.base.BaseGeometry</code> or <code>list</code></dt>
<dd>The geometry or geometries to wrap.</dd>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code>, default<code>: 0.0</code></dt>
<dd>The central meridian around which to wrap geometries;
geometries will be split at the antimeridian.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>If provided, the geometry will be tessellated to this resolution prior to wrapping.</dd>
<dt><strong><code>validate</code></strong> :&ensp;<code>bool</code>, default<code>: False</code></dt>
<dd>Attempt to ensure output geometry is valid by applying a buffer of 0.</dd>
<dt><strong><code>force_ccw</code></strong> :&ensp;<code>bool</code>, default<code>: False</code></dt>
<dd>Ensure the coordinates of the output geometry are counter-clockwise(only applies to polygons).</dd>
<dt><strong><code>explode</code></strong> :&ensp;<code>bool</code>, default<code>: False</code></dt>
<dd>Convert multi-part output geometries to multiple single-part geometries.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output_geometries</code></strong> :&ensp;<code>shapely.geometry.base.BaseGeometry</code> or <code>list</code></dt>
<dd>Wrapped Shapely geometry or geometries.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If a single input geometry was passed, <code>output_geometry</code> will be a
subclass of <code>shapely.geometry.base.BaseGeometry</code>.
Otherwise, <code>output_geometry</code> will be a list of the same length as the input, unless <code>explode=True</code> is specified.</p>
<p>Input geometries that were split while wrapping around
<code>central_meridian</code> will produce multi-part output geometries, unless <code>explode=True</code> is specified.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.geometry.GeometryOnSphere"><code class="flex name class">
<span>class <span class="ident">GeometryOnSphere</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to mix in <code>to_shapely</code> method to all GPlately geometry classes.</p>
<p>All GPlately geometry classes inherit from this class, in addition
to their PyGPlates base class.</p>
<p>Raises an exception
This class cannot be instantiated from Python</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeometryOnSphere(pygplates.GeometryOnSphere):
    &#34;&#34;&#34;Class to mix in `to_shapely` method to all GPlately geometry classes.

    All GPlately geometry classes inherit from this class, in addition
    to their PyGPlates base class.
    &#34;&#34;&#34;

    def to_shapely(
        self,
        central_meridian=0.0,
        tessellate_degrees=None,
        validate=False,
        force_ccw=False,
        explode=False,
    ):
        &#34;&#34;&#34;Convert to Shapely geometry.

        See Also
        --------
        pygplates_to_shapely : Equivalent function.
        &#34;&#34;&#34;
        return pygplates_to_shapely(
            self,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
            validate=validate,
            force_ccw=force_ccw,
            explode=explode,
        )

    @classmethod
    def from_shapely(cls, geom):
        converted = shapely_to_pygplates(geom)
        return cls(converted)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.GeometryOnSphere</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></li>
<li><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></li>
<li><a title="gplately.geometry.PolygonOnSphere" href="#gplately.geometry.PolygonOnSphere">PolygonOnSphere</a></li>
<li><a title="gplately.geometry.PolylineOnSphere" href="#gplately.geometry.PolylineOnSphere">PolylineOnSphere</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="gplately.geometry.GeometryOnSphere.from_shapely"><code class="name flex">
<span>def <span class="ident">from_shapely</span></span>(<span>geom)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gplately.geometry.GeometryOnSphere.to_shapely"><code class="name flex">
<span>def <span class="ident">to_shapely</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None, validate=False, force_ccw=False, explode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert to Shapely geometry.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="gplately.geometry.pygplates_to_shapely" href="#gplately.geometry.pygplates_to_shapely">pygplates_to_shapely()</a></code></dt>
<dd>Equivalent function.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="gplately.geometry.LatLonPoint"><code class="flex name class">
<span>class <span class="ident">LatLonPoint</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>GPlately equivalent of <code>pygplates.LatLonPoint</code>, incorporating
<code>to_shapely</code> method</p>
<p><strong>init</strong>(latitude, longitude)
Create a <em>LatLonPoint</em> instance from a <em>latitude</em> and <em>longitude</em>.</p>
<p>:param latitude: the latitude (in degrees)
:type latitude: float
:param longitude: the longitude (in degrees)
:type longitude: float
:raises: InvalidLatLonError if <em>latitude</em> or <em>longitude</em> is invalid</p>
<p>::</p>
<pre><code>point = pygplates.LatLonPoint(latitude, longitude)
</code></pre>
<p>!!! note "Note:&ensp;<em>latitude</em> must satisfy :meth:<code>is_valid_latitude</code> and <em>longitude</em> must satisfy :meth:<code>is_valid_longitude</code>, otherwise <em>InvalidLatLonError</em> will be raised."</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LatLonPoint(pygplates.LatLonPoint):
    &#34;&#34;&#34;GPlately equivalent of `pygplates.LatLonPoint`, incorporating
    `to_shapely` method
    &#34;&#34;&#34;

    def to_shapely(self, central_meridian=0.0, tessellate_degrees=None):
        return pygplates_to_shapely(
            self,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.LatLonPoint</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gplately.geometry.LatLonPoint.to_shapely"><code class="name flex">
<span>def <span class="ident">to_shapely</span></span>(<span>self, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="gplately.geometry.MultiPointOnSphere"><code class="flex name class">
<span>class <span class="ident">MultiPointOnSphere</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>GPlately equivalent of <code>pygplates.MultiPointOnSphere</code>, incorporating
<code>to_shapely</code> method</p>
<p><strong>init</strong>(&hellip;)
A <em>MultiPointOnSphere</em> object can be constructed in more than one way&hellip;</p>
<p><strong>init</strong>(points)
Create a multi-point from a sequence of (x,y,z) or (latitude,longitude) points.</p>
<p>:param points: A sequence of (x,y,z) points, or (latitude,longitude) points (in degrees).
:type points: Any sequence of :class:<code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code> or :class:<code><a title="gplately.geometry.LatLonPoint" href="#gplately.geometry.LatLonPoint">LatLonPoint</a></code> or tuple (float,float,float) or tuple (float,float)
:raises: InvalidLatLonError if any <em>latitude</em> or <em>longitude</em> is invalid
:raises: ViolatedUnitVectorInvariantError if any (x,y,z) is not unit magnitude
:raises: InsufficientPointsForMultiPointConstructionError if point sequence is empty</p>
<p>!!! note "Note:&ensp;The sequence must contain at least one point, otherwise <em>InsufficientPointsForMultiPointConstructionError</em> will be raised."</p>
<p>The following example shows a few different ways to create a :class:<code>multi-point&lt;MultiPointOnSphere&gt;</code>:
::</p>
<pre><code>points = []
points.append(pygplates.PointOnSphere(...))
points.append(pygplates.PointOnSphere(...))
points.append(pygplates.PointOnSphere(...))
multi_point = pygplates.MultiPointOnSphere(points)

points = []
points.append((lat1,lon1))
points.append((lat2,lon2))
points.append((lat3,lon3))
multi_point = pygplates.MultiPointOnSphere(points)

points = []
points.append([x1,y1,z1])
points.append([x2,y2,z2])
points.append([x3,y3,z3])
multi_point = pygplates.MultiPointOnSphere(points)
</code></pre>
<p>If you have latitude/longitude values but they are not a sequence of tuples or if the latitude/longitude order is swapped then the following examples demonstrate how you could restructure them:
::</p>
<pre><code># Flat lat/lon array.
points = numpy.array([lat1, lon1, lat2, lon2, lat3, lon3])
multi_point = pygplates.MultiPointOnSphere(zip(points[::2],points[1::2]))

# Flat lon/lat list (ie, different latitude/longitude order).
points = [lon1, lat1, lon2, lat2, lon3, lat3]
multi_point = pygplates.MultiPointOnSphere(zip(points[1::2],points[::2]))

# Separate lat/lon arrays.
lats = numpy.array([lat1, lat2, lat3])
lons = numpy.array([lon1, lon2, lon3])
multi_point = pygplates.MultiPointOnSphere(zip(lats,lons))

# Lon/lat list of tuples (ie, different latitude/longitude order).
points = [(lon1, lat1), (lon2, lat2), (lon3, lat3)]
multi_point = pygplates.MultiPointOnSphere([(lat,lon) for lon, lat in points])
</code></pre>
<p><strong>init</strong>(geometry)
Create a multipoint from a :class:<code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code>.</p>
<p>:param geometry: The point, multi-point, polyline or polygon geometry to convert from.
:type geometry: :class:<code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code></p>
<p>To create a MultiPointOnSphere from any geometry type:
::</p>
<pre><code>multipoint = pygplates.MultiPointOnSphere(geometry)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiPointOnSphere(pygplates.MultiPointOnSphere, GeometryOnSphere):
    &#34;&#34;&#34;GPlately equivalent of `pygplates.MultiPointOnSphere`, incorporating
    `to_shapely` method
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.MultiPointOnSphere</li>
<li><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></li>
<li>pygplates.GeometryOnSphere</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></b></code>:
<ul class="hlist">
<li><code><a title="gplately.geometry.GeometryOnSphere.to_shapely" href="#gplately.geometry.GeometryOnSphere.to_shapely">to_shapely</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gplately.geometry.PointOnSphere"><code class="flex name class">
<span>class <span class="ident">PointOnSphere</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>GPlately equivalent of <code>pygplates.PointOnSphere</code>, incorporating <code>to_shapely</code> method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PointOnSphere(pygplates.PointOnSphere, GeometryOnSphere):
    &#34;&#34;&#34;GPlately equivalent of `pygplates.PointOnSphere`, incorporating
    `to_shapely` method
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.PointOnSphere</li>
<li><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></li>
<li>pygplates.GeometryOnSphere</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></b></code>:
<ul class="hlist">
<li><code><a title="gplately.geometry.GeometryOnSphere.to_shapely" href="#gplately.geometry.GeometryOnSphere.to_shapely">to_shapely</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gplately.geometry.PolygonOnSphere"><code class="flex name class">
<span>class <span class="ident">PolygonOnSphere</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>GPlately equivalent of <code>pygplates.PolygonOnSphere</code>, incorporating
<code>to_shapely</code> method</p>
<p><strong>init</strong>(&hellip;)
A <em>PolygonOnSphere</em> object can be constructed in more than one way&hellip;</p>
<p><strong>init</strong>(points)
Create a polygon from a sequence of (x,y,z) or (latitude,longitude) points.</p>
<p>:param points: A sequence of (x,y,z) points, or (latitude,longitude) points (in degrees).
:type points: Any sequence of :class:<code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code> or :class:<code><a title="gplately.geometry.LatLonPoint" href="#gplately.geometry.LatLonPoint">LatLonPoint</a></code> or tuple (float,float,float) or tuple (float,float)
:raises: InvalidLatLonError if any <em>latitude</em> or <em>longitude</em> is invalid
:raises: ViolatedUnitVectorInvariantError if any (x,y,z) is not unit magnitude
:raises: InvalidPointsForPolygonConstructionError if sequence has less than three points or if any two points (adjacent in the <em>points</em> sequence) are antipodal to each other (on opposite sides of the globe)</p>
<p>!!! note "Note:&ensp;The sequence must contain at least three points in order to be a valid polygon, otherwise <em>InvalidPointsForPolygonConstructionError</em> will be raised."</p>
<p>During creation, a :class:<code>GreatCircleArc</code> is created between each adjacent pair of of points in <em>points</em> - see :meth:<code>get_segments</code>. The last arc is created between the last and first points to close the loop of the polygon. For this reason you do <em>not</em> need to ensure that the first and last points have the same position (although it's not an error if this is the case because the final arc will then just have a zero length).</p>
<p>It is <em>not</em> an error for adjacent points in the sequence to be coincident. In this case each :class:<code>GreatCircleArc</code> between two such adjacent points will have zero length (:meth:<code>GreatCircleArc.is_zero_length</code> will return <code>True</code>) and will have no rotation axis (:meth:<code>GreatCircleArc.get_rotation_axis</code> will raise an error).</p>
<p>The following example shows a few different ways to create a :class:<code>polygon&lt;PolygonOnSphere&gt;</code>:
::</p>
<pre><code>points = []
points.append(pygplates.PointOnSphere(...))
points.append(pygplates.PointOnSphere(...))
points.append(pygplates.PointOnSphere(...))
polygon = pygplates.PolygonOnSphere(points)

points = []
points.append((lat1,lon1))
points.append((lat2,lon2))
points.append((lat3,lon3))
polygon = pygplates.PolygonOnSphere(points)

points = []
points.append([x1,y1,z1])
points.append([x2,y2,z2])
points.append([x3,y3,z3])
polygon = pygplates.PolygonOnSphere(points)
</code></pre>
<p>If you have latitude/longitude values but they are not a sequence of tuples or if the latitude/longitude order is swapped then the following examples demonstrate how you could restructure them:
::</p>
<pre><code># Flat lat/lon array.
points = numpy.array([lat1, lon1, lat2, lon2, lat3, lon3])
polygon = pygplates.PolygonOnSphere(zip(points[::2],points[1::2]))

# Flat lon/lat list (ie, different latitude/longitude order).
points = [lon1, lat1, lon2, lat2, lon3, lat3]
polygon = pygplates.PolygonOnSphere(zip(points[1::2],points[::2]))

# Separate lat/lon arrays.
lats = numpy.array([lat1, lat2, lat3])
lons = numpy.array([lon1, lon2, lon3])
polygon = pygplates.PolygonOnSphere(zip(lats,lons))

# Lon/lat list of tuples (ie, different latitude/longitude order).
points = [(lon1, lat1), (lon2, lat2), (lon3, lat3)]
polygon = pygplates.PolygonOnSphere([(lat,lon) for lon, lat in points])
</code></pre>
<p><strong>init</strong>(geometry, [allow_one_or_two_points=True])
Create a polygon from a :class:<code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code>.</p>
<p>:param geometry: The point, multi-point, polyline or polygon geometry to convert from.
:type geometry: :class:<code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code>
:param allow_one_or_two_points: Whether <em>geometry</em> is allowed to be a :class:<code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code> or a :class:<code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code> containing only one or two points - if allowed then one of those points is duplicated since a PolygonOnSphere requires at least three points - default is <code>True</code>.
:type allow_one_or_two_points: bool
:raises: InvalidPointsForPolygonConstructionError if <em>geometry</em> is a :class:<code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code>, or a :class:<code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code> with one or two points (and <em>allow_one_or_two_points</em> is <code>False</code>), or if any two consecutive points in a :class:<code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code> are antipodal to each other (on opposite sides of the globe)</p>
<p>If <em>allow_one_or_two_points</em> is <code>True</code> then <em>geometry</em> can be :class:<code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code>, :class:<code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code>, :class:<code><a title="gplately.geometry.PolylineOnSphere" href="#gplately.geometry.PolylineOnSphere">PolylineOnSphere</a></code> or :class:<code><a title="gplately.geometry.PolygonOnSphere" href="#gplately.geometry.PolygonOnSphere">PolygonOnSphere</a></code>. However if <em>allow_one_or_two_points</em> is <code>False</code> then <em>geometry</em> must be a :class:<code><a title="gplately.geometry.PolygonOnSphere" href="#gplately.geometry.PolygonOnSphere">PolygonOnSphere</a></code>, or a :class:<code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code> or :class:<code><a title="gplately.geometry.PolylineOnSphere" href="#gplately.geometry.PolylineOnSphere">PolylineOnSphere</a></code> containing at least three points to avoid raising <em>InvalidPointsForPolygonConstructionError</em>.</p>
<p>During creation, a :class:<code>GreatCircleArc</code> is created between each adjacent pair of geometry points - see :meth:<code>get_segments</code>.</p>
<p>It is <em>not</em> an error for adjacent points in a geometry sequence to be coincident. In this case each :class:<code>GreatCircleArc</code> between two such adjacent points will have zero length (:meth:<code>GreatCircleArc.is_zero_length</code> will return <code>True</code>) and will have no rotation axis (:meth:<code>GreatCircleArc.get_rotation_axis</code> will raise an error). However if two such adjacent points are antipodal (on opposite sides of the globe) then InvalidPointsForPolygonConstructionError will be raised</p>
<p>To create a PolygonOnSphere from any geometry type:
::</p>
<pre><code>polygon = pygplates.PolygonOnSphere(geometry)
</code></pre>
<p>To create a PolygonOnSphere from any geometry containing at least three points:
::</p>
<pre><code>try:
    polygon = pygplates.PolygonOnSphere(geometry, allow_one_or_two_points=False)
except pygplates.InvalidPointsForPolygonConstructionError:
    ... # Handle failure to convert 'geometry' to a PolygonOnSphere.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolygonOnSphere(pygplates.PolygonOnSphere, GeometryOnSphere):
    &#34;&#34;&#34;GPlately equivalent of `pygplates.PolygonOnSphere`, incorporating
    `to_shapely` method
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.PolygonOnSphere</li>
<li><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></li>
<li>pygplates.GeometryOnSphere</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></b></code>:
<ul class="hlist">
<li><code><a title="gplately.geometry.GeometryOnSphere.to_shapely" href="#gplately.geometry.GeometryOnSphere.to_shapely">to_shapely</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gplately.geometry.PolylineOnSphere"><code class="flex name class">
<span>class <span class="ident">PolylineOnSphere</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>GPlately equivalent of <code>pygplates.PolylineOnSphere</code>, incorporating
<code>to_shapely</code> method</p>
<p><strong>init</strong>(&hellip;)
A <em>PolylineOnSphere</em> object can be constructed in more than one way&hellip;</p>
<p><strong>init</strong>(points)
Create a polyline from a sequence of (x,y,z) or (latitude,longitude) points.</p>
<p>:param points: A sequence of (x,y,z) points, or (latitude,longitude) points (in degrees).
:type points: Any sequence of :class:<code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code> or :class:<code><a title="gplately.geometry.LatLonPoint" href="#gplately.geometry.LatLonPoint">LatLonPoint</a></code> or tuple (float,float,float) or tuple (float,float)
:raises: InvalidLatLonError if any <em>latitude</em> or <em>longitude</em> is invalid
:raises: ViolatedUnitVectorInvariantError if any (x,y,z) is not unit magnitude
:raises: InvalidPointsForPolylineConstructionError if sequence has less than two points or if any two points (adjacent in the <em>points</em> sequence) are antipodal to each other (on opposite sides of the globe)</p>
<p>!!! note "Note:&ensp;The sequence must contain at least two points in order to be a valid polyline, otherwise <em>InvalidPointsForPolylineConstructionError</em> will be raised."</p>
<p>During creation, a :class:<code>GreatCircleArc</code> is created between each adjacent pair of points in <em>points</em> - see :meth:<code>get_segments</code>.</p>
<p>It is <em>not</em> an error for adjacent points in the sequence to be coincident. In this case each :class:<code>GreatCircleArc</code> between two such adjacent points will have zero length (:meth:<code>GreatCircleArc.is_zero_length</code> will return <code>True</code>) and will have no rotation axis (:meth:<code>GreatCircleArc.get_rotation_axis</code> will raise an error). However if two such adjacent points are antipodal (on opposite sides of the globe) then InvalidPointsForPolylineConstructionError will be raised.</p>
<p>The following example shows a few different ways to create a :class:<code>polyline&lt;PolylineOnSphere&gt;</code>:
::</p>
<pre><code>points = []
points.append(pygplates.PointOnSphere(...))
points.append(pygplates.PointOnSphere(...))
points.append(pygplates.PointOnSphere(...))
polyline = pygplates.PolylineOnSphere(points)

points = []
points.append((lat1,lon1))
points.append((lat2,lon2))
points.append((lat3,lon3))
polyline = pygplates.PolylineOnSphere(points)

points = []
points.append([x1,y1,z1])
points.append([x2,y2,z2])
points.append([x3,y3,z3])
polyline = pygplates.PolylineOnSphere(points)
</code></pre>
<p>If you have latitude/longitude values but they are not a sequence of tuples or if the latitude/longitude order is swapped then the following examples demonstrate how you could restructure them:
::</p>
<pre><code># Flat lat/lon array.
points = numpy.array([lat1, lon1, lat2, lon2, lat3, lon3])
polyline = pygplates.PolylineOnSphere(zip(points[::2],points[1::2]))

# Flat lon/lat list (ie, different latitude/longitude order).
points = [lon1, lat1, lon2, lat2, lon3, lat3]
polyline = pygplates.PolylineOnSphere(zip(points[1::2],points[::2]))

# Separate lat/lon arrays.
lats = numpy.array([lat1, lat2, lat3])
lons = numpy.array([lon1, lon2, lon3])
polyline = pygplates.PolylineOnSphere(zip(lats,lons))

# Lon/lat list of tuples (ie, different latitude/longitude order).
points = [(lon1, lat1), (lon2, lat2), (lon3, lat3)]
polyline = pygplates.PolylineOnSphere([(lat,lon) for lon, lat in points])
</code></pre>
<p><strong>init</strong>(geometry, [allow_one_point=True])
Create a polyline from a :class:<code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code>.</p>
<p>:param geometry: The point, multi-point, polyline or polygon geometry to convert from.
:type geometry: :class:<code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code>
:param allow_one_point: Whether <em>geometry</em> is allowed to be a :class:<code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code> or a :class:<code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code> containing only a single point - if allowed then that single point is duplicated since a PolylineOnSphere requires at least two points - default is <code>True</code>.
:type allow_one_point: bool
:raises: InvalidPointsForPolylineConstructionError if <em>geometry</em> is a :class:<code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code> (and <em>allow_one_point</em> is <code>False</code>), or a :class:<code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code> with one point (and <em>allow_one_point</em> is <code>False</code>), or if any two consecutive points in a :class:<code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code> are antipodal to each other (on opposite sides of the globe)</p>
<p>If <em>allow_one_point</em> is <code>True</code> then <em>geometry</em> can be :class:<code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code>, :class:<code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code>, :class:<code><a title="gplately.geometry.PolylineOnSphere" href="#gplately.geometry.PolylineOnSphere">PolylineOnSphere</a></code> or :class:<code><a title="gplately.geometry.PolygonOnSphere" href="#gplately.geometry.PolygonOnSphere">PolygonOnSphere</a></code>. However if <em>allow_one_point</em> is <code>False</code> then <em>geometry</em> must be a :class:<code><a title="gplately.geometry.PolylineOnSphere" href="#gplately.geometry.PolylineOnSphere">PolylineOnSphere</a></code>, or a :class:<code><a title="gplately.geometry.PolygonOnSphere" href="#gplately.geometry.PolygonOnSphere">PolygonOnSphere</a></code>, or a :class:<code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code> containing at least two points to avoid raising <em>InvalidPointsForPolylineConstructionError</em>.</p>
<p>During creation, a :class:<code>GreatCircleArc</code> is created between each adjacent pair of geometry points - see :meth:<code>get_segments</code>.</p>
<p>It is <em>not</em> an error for adjacent points in a geometry sequence to be coincident. In this case each :class:<code>GreatCircleArc</code> between two such adjacent points will have zero length (:meth:<code>GreatCircleArc.is_zero_length</code> will return <code>True</code>) and will have no rotation axis (:meth:<code>GreatCircleArc.get_rotation_axis</code> will raise an error). However if two such adjacent points are antipodal (on opposite sides of the globe) then InvalidPointsForPolylineConstructionError will be raised</p>
<p>To create a PolylineOnSphere from any geometry type:
::</p>
<pre><code>polyline = pygplates.PolylineOnSphere(geometry)
</code></pre>
<p>To create a PolylineOnSphere from any geometry containing at least two points:
::</p>
<pre><code>try:
    polyline = pygplates.PolylineOnSphere(geometry, allow_one_point=False)
except pygplates.InvalidPointsForPolylineConstructionError:
    ... # Handle failure to convert 'geometry' to a PolylineOnSphere.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolylineOnSphere(pygplates.PolylineOnSphere, GeometryOnSphere):
    &#34;&#34;&#34;GPlately equivalent of `pygplates.PolylineOnSphere`, incorporating
    `to_shapely` method
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.PolylineOnSphere</li>
<li><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></li>
<li>pygplates.GeometryOnSphere</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></b></code>:
<ul class="hlist">
<li><code><a title="gplately.geometry.GeometryOnSphere.to_shapely" href="#gplately.geometry.GeometryOnSphere.to_shapely">to_shapely</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="GPlately logo" height="172" width="205">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gplately.geometry.pygplates_to_shapely" href="#gplately.geometry.pygplates_to_shapely">pygplates_to_shapely</a></code></li>
<li><code><a title="gplately.geometry.shapely_to_pygplates" href="#gplately.geometry.shapely_to_pygplates">shapely_to_pygplates</a></code></li>
<li><code><a title="gplately.geometry.wrap_geometries" href="#gplately.geometry.wrap_geometries">wrap_geometries</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.geometry.GeometryOnSphere" href="#gplately.geometry.GeometryOnSphere">GeometryOnSphere</a></code></h4>
<ul class="">
<li><code><a title="gplately.geometry.GeometryOnSphere.from_shapely" href="#gplately.geometry.GeometryOnSphere.from_shapely">from_shapely</a></code></li>
<li><code><a title="gplately.geometry.GeometryOnSphere.to_shapely" href="#gplately.geometry.GeometryOnSphere.to_shapely">to_shapely</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.geometry.LatLonPoint" href="#gplately.geometry.LatLonPoint">LatLonPoint</a></code></h4>
<ul class="">
<li><code><a title="gplately.geometry.LatLonPoint.to_shapely" href="#gplately.geometry.LatLonPoint.to_shapely">to_shapely</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.geometry.MultiPointOnSphere" href="#gplately.geometry.MultiPointOnSphere">MultiPointOnSphere</a></code></h4>
</li>
<li>
<h4><code><a title="gplately.geometry.PointOnSphere" href="#gplately.geometry.PointOnSphere">PointOnSphere</a></code></h4>
</li>
<li>
<h4><code><a title="gplately.geometry.PolygonOnSphere" href="#gplately.geometry.PolygonOnSphere">PolygonOnSphere</a></code></h4>
</li>
<li>
<h4><code><a title="gplately.geometry.PolylineOnSphere" href="#gplately.geometry.PolylineOnSphere">PolylineOnSphere</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.0</a>.</p>
</footer>
</body>
</html>
