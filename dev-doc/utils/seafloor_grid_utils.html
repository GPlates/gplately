<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>gplately.utils.seafloor_grid_utils API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.utils.seafloor_grid_utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -------------------------------------------------------------------------
# Auxiliary functions for SeafloorGrid

import numpy as np
import pygplates

from .. import ptt


def create_icosahedral_mesh(refinement_levels):
    &#34;&#34;&#34;Define a global point mesh with Stripy&#39;s
    [icosahedral triangulated mesh](https://github.com/underworldcode/stripy/blob/294354c00dd72e085a018e69c345d9353c6fafef/stripy/spherical_meshes.py#L27)
    and turn all mesh domains into pyGPlates MultiPointOnSphere types.

    This global mesh will be masked with a set of continental or COB terrane
    polygons to define the ocean basin at a given reconstruction time.
    The `refinement_levels` integer is proportional to the resolution of the
    mesh and the ocean/continent boundary.

    Parameters
    ----------
    refinement_levels : int
        Refine the number of points in the triangulation. The larger the
        refinement level, the sharper the ocean basin resolution.

    Returns
    -------
    multi_point : instance of &lt;pygplates.MultiPointOnSphere&gt;
        The longitues and latitudes that make up the icosahedral ocean mesh
        collated into a MultiPointOnSphere object.
    icosahedral_global_mesh : instance of &lt;stripy.spherical_meshes.icosahedral_mesh&gt;
        The original global icosahedral triangulated mesh.
    &#34;&#34;&#34;
    import stripy

    # Create the ocean basin mesh using Stripy&#39;s icosahedral spherical mesh
    icosahedral_global_mesh = stripy.spherical_meshes.icosahedral_mesh(
        refinement_levels, include_face_points=False, trisection=False, tree=False
    )
    # Get lons and lats of mesh, and turn them into a MultiPointOnSphere
    lats_arr = np.rad2deg(icosahedral_global_mesh.lats)
    lons_arr = np.rad2deg(icosahedral_global_mesh.lons)
    multi_point = pygplates.MultiPointOnSphere(zip(lats_arr, lons_arr))

    return multi_point, icosahedral_global_mesh


def ensure_polygon_geometry(reconstructed_polygons, rotation_model, time):
    &#34;&#34;&#34;Ensure COB terrane/continental polygon geometries are polygons
    with reconstruction plate IDs and valid times.

    Notes
    -----
    This step must be done so that the initial set of ocean basin points
    (the Stripy icosahedral mesh) can be partitioned into plates using
    each reconstruction plate ID for the given plate `model`.

    This allows for an oceanic point-in-continental
    polygon query for every identified plate ID. See documentation for
    `point_in_polygon_routine` for more details.

    `ensure_polygon_geometry` works as follows:
    COB terrane/continental polygons are assumed to have been reconstructed
    already in `reconstructed_polygons` (a list of
    type &lt;pygplates.ReconstructedFeatureGeometry&gt;). The list contents are
    turned into a &lt;pygplates.FeatureCollection&gt; to be ascribed a
    `PolygonOnSphere` geometry, a reconstruction plate ID, and a valid time.
    Once finished, this feature collection is turned back into a list of
    instance &lt;pygplates.ReconstructedFeatureGeometry&gt; and returned.

    This revert must be completed for compatibility with the subsequent
    point-in-polygon routine.

    Parameters
    ----------
    reconstructed_polygons : list of instance &lt;pygplates.ReconstructedFeatureGeometry&gt;
        If used in `SeafloorGrid`, these are automatically obtained from the
        `PlotTopologies.continents` attribute (the reconstructed continental
        polygons at the current reconstruction time).

    rotation_model : instance of &lt;pygplates.RotationModel&gt;
        A parameter for turning the &lt;pygplates.FeatureCollection&gt; back into a
        list of instance &lt;pygplates.ReconstructedFeatureGeometry&gt; for
        compatibility with the point-in-polygon routine.

    &#34;&#34;&#34;
    continent_FeatCol = []
    # self._PlotTopologies_object.continents
    for n in reconstructed_polygons:
        continent_FeatCol.append(n.get_feature())

    polygon_feats = pygplates.FeatureCollection(continent_FeatCol)

    # From GPRM&#39;s force_polygon_geometries(); set feature attributes
    # like valid times and plate IDs to each masking polygon
    polygons = []
    for feature in polygon_feats:
        for geom in feature.get_all_geometries():
            polygon = pygplates.Feature(feature.get_feature_type())
            polygon.set_geometry(pygplates.PolygonOnSphere(geom))
            polygon.set_reconstruction_plate_id(feature.get_reconstruction_plate_id())
            # Avoid features in COBTerranes with invalid time
            if feature.get_valid_time()[0] &gt;= feature.get_valid_time()[1]:
                polygon.set_valid_time(
                    feature.get_valid_time()[0], feature.get_valid_time()[1]
                )
                polygons.append(polygon)
    cobter_polygon_features = pygplates.FeatureCollection(polygons)

    # Turn the feature collection back into ReconstructedFeatureGeometry
    # objects otherwise it will not work with PIP
    reconstructed_cobter_polygons = []
    pygplates.reconstruct(
        cobter_polygon_features, rotation_model, reconstructed_cobter_polygons, time
    )
    return reconstructed_cobter_polygons


def point_in_polygon_routine(multi_point, COB_polygons):
    &#34;&#34;&#34;Perform Plate Tectonic Tools&#39; point in polygon routine to partition
    points in a `multi_point` MultiPointOnSphere feature based on whether
    they are inside or outside the polygons in `COB_polygons`.

    Notes
    -----
    Assuming the `COB_polygons` have passed through `ensure_polygon_geometry`,
    each polygon should have a plate ID assigned to it.

    This PIP routine serves two purposes for `SeafloorGrid`:

    1) It identifies continental regions in the icosahedral global mesh
    MultiPointOnSphere feature and &#39;erases&#39; in-continent oceanic points
    for the construction of a continental mask at each timestep;

    2) It identifies oceanic points in the icosahedral global mesh.
    These points will be passed to a function that calculates each point&#39;s
    proximity to its nearest MOR segment (if any) within the polygonal domain
    of its allocated plate ID. Each distance is divided by half the
    `initial_ocean_mean_spreading_rate` (an attribute of `SeafloorGrids`) to
    determine a simplified seafloor age for each point.

    Number 2) only happens once at the start of the gridding process to
    momentarily fill the gridding region with initial ocean points that have
    set ages (albeit not from a plate model file). After multiple time steps
    of reconstruction, the ocean basin will be filled with new points (with
    plate-model prescribed ages) that emerge from ridge topologies.


    Returns
    -------
    pygplates.MultiPointOnSphere(points_in_arr) : instance &lt;pygplates.MultiPointOnSphere&gt;
        Point features that are within COB terrane polygons.
    pygplates.MultiPointOnSphere(points_out_arr) : instance &lt;pygplates.MultiPointOnSphere&gt;
        Point features that are outside COB terrane polygons.
    zvals : list
        A binary list. If an entry is == 0, its corresponing point in the
        MultiPointOnSphere object is on the ocean. If == 1, the point is
        in the COB terrane polygon.
    &#34;&#34;&#34;
    # Convert MultiPointOnSphere to array of PointOnSphere
    multi_point = np.array(multi_point.get_points(), dtype=&#34;object&#34;)

    # Collect reconstructed geometries of continental polygons
    polygons = np.empty(len(COB_polygons), dtype=&#34;object&#34;)
    for ind, i in enumerate(COB_polygons):
        if isinstance(i, pygplates.ReconstructedFeatureGeometry):
            geom = i.get_reconstructed_geometry()
        elif isinstance(i, pygplates.GeometryOnSphere):
            geom = i
        else:  # e.g. ndarray of coordinates
            geom = pygplates.PolygonOnSphere(i)
        polygons[ind] = geom
    proxies = np.ones(polygons.size)

    pip_result = ptt.utils.points_in_polygons.find_polygons(
        multi_point, polygons, proxies, all_polygons=False
    )  # 1 for points in polygons, None for points outside
    zvals = np.array(
        pip_result,
        dtype=&#34;float&#34;,
    ).ravel()
    zvals[np.isnan(zvals)] = 0.0
    zvals = zvals.astype(&#34;int&#34;)
    points_in_arr = multi_point[zvals == 1]
    points_out_arr = multi_point[zvals != 1]

    return (
        pygplates.MultiPointOnSphere(points_in_arr),
        pygplates.MultiPointOnSphere(points_out_arr),
        zvals,
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gplately.utils.seafloor_grid_utils.create_icosahedral_mesh"><code class="name flex">
<span>def <span class="ident">create_icosahedral_mesh</span></span>(<span>refinement_levels)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a global point mesh with Stripy's
<a href="https://github.com/underworldcode/stripy/blob/294354c00dd72e085a018e69c345d9353c6fafef/stripy/spherical_meshes.py#L27">icosahedral triangulated mesh</a>
and turn all mesh domains into pyGPlates MultiPointOnSphere types.</p>
<p>This global mesh will be masked with a set of continental or COB terrane
polygons to define the ocean basin at a given reconstruction time.
The <code>refinement_levels</code> integer is proportional to the resolution of the
mesh and the ocean/continent boundary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>refinement_levels</code></strong> :&ensp;<code>int</code></dt>
<dd>Refine the number of points in the triangulation. The larger the
refinement level, the sharper the ocean basin resolution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>multi_point</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.MultiPointOnSphere&gt;</code></dt>
<dd>The longitues and latitudes that make up the icosahedral ocean mesh
collated into a MultiPointOnSphere object.</dd>
<dt><strong><code>icosahedral_global_mesh</code></strong> :&ensp;<code>instance</code> of <code>&lt;stripy.spherical_meshes.icosahedral_mesh&gt;</code></dt>
<dd>The original global icosahedral triangulated mesh.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_icosahedral_mesh(refinement_levels):
    &#34;&#34;&#34;Define a global point mesh with Stripy&#39;s
    [icosahedral triangulated mesh](https://github.com/underworldcode/stripy/blob/294354c00dd72e085a018e69c345d9353c6fafef/stripy/spherical_meshes.py#L27)
    and turn all mesh domains into pyGPlates MultiPointOnSphere types.

    This global mesh will be masked with a set of continental or COB terrane
    polygons to define the ocean basin at a given reconstruction time.
    The `refinement_levels` integer is proportional to the resolution of the
    mesh and the ocean/continent boundary.

    Parameters
    ----------
    refinement_levels : int
        Refine the number of points in the triangulation. The larger the
        refinement level, the sharper the ocean basin resolution.

    Returns
    -------
    multi_point : instance of &lt;pygplates.MultiPointOnSphere&gt;
        The longitues and latitudes that make up the icosahedral ocean mesh
        collated into a MultiPointOnSphere object.
    icosahedral_global_mesh : instance of &lt;stripy.spherical_meshes.icosahedral_mesh&gt;
        The original global icosahedral triangulated mesh.
    &#34;&#34;&#34;
    import stripy

    # Create the ocean basin mesh using Stripy&#39;s icosahedral spherical mesh
    icosahedral_global_mesh = stripy.spherical_meshes.icosahedral_mesh(
        refinement_levels, include_face_points=False, trisection=False, tree=False
    )
    # Get lons and lats of mesh, and turn them into a MultiPointOnSphere
    lats_arr = np.rad2deg(icosahedral_global_mesh.lats)
    lons_arr = np.rad2deg(icosahedral_global_mesh.lons)
    multi_point = pygplates.MultiPointOnSphere(zip(lats_arr, lons_arr))

    return multi_point, icosahedral_global_mesh</code></pre>
</details>
</dd>
<dt id="gplately.utils.seafloor_grid_utils.ensure_polygon_geometry"><code class="name flex">
<span>def <span class="ident">ensure_polygon_geometry</span></span>(<span>reconstructed_polygons, rotation_model, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure COB terrane/continental polygon geometries are polygons
with reconstruction plate IDs and valid times.</p>
<h2 id="notes">Notes</h2>
<p>This step must be done so that the initial set of ocean basin points
(the Stripy icosahedral mesh) can be partitioned into plates using
each reconstruction plate ID for the given plate <code>model</code>.</p>
<p>This allows for an oceanic point-in-continental
polygon query for every identified plate ID. See documentation for
<code><a title="gplately.utils.seafloor_grid_utils.point_in_polygon_routine" href="#gplately.utils.seafloor_grid_utils.point_in_polygon_routine">point_in_polygon_routine()</a></code> for more details.</p>
<p><code><a title="gplately.utils.seafloor_grid_utils.ensure_polygon_geometry" href="#gplately.utils.seafloor_grid_utils.ensure_polygon_geometry">ensure_polygon_geometry()</a></code> works as follows:
COB terrane/continental polygons are assumed to have been reconstructed
already in <code>reconstructed_polygons</code> (a list of
type <pygplates.ReconstructedFeatureGeometry>). The list contents are
turned into a <pygplates.FeatureCollection> to be ascribed a
<code>PolygonOnSphere</code> geometry, a reconstruction plate ID, and a valid time.
Once finished, this feature collection is turned back into a list of
instance <pygplates.ReconstructedFeatureGeometry> and returned.</p>
<p>This revert must be completed for compatibility with the subsequent
point-in-polygon routine.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reconstructed_polygons</code></strong> :&ensp;<code>list</code> of <code>instance &lt;pygplates.ReconstructedFeatureGeometry&gt;</code></dt>
<dd>If used in <code>SeafloorGrid</code>, these are automatically obtained from the
<code>PlotTopologies.continents</code> attribute (the reconstructed continental
polygons at the current reconstruction time).</dd>
<dt><strong><code>rotation_model</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.RotationModel&gt;</code></dt>
<dd>A parameter for turning the <pygplates.FeatureCollection> back into a
list of instance <pygplates.ReconstructedFeatureGeometry> for
compatibility with the point-in-polygon routine.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_polygon_geometry(reconstructed_polygons, rotation_model, time):
    &#34;&#34;&#34;Ensure COB terrane/continental polygon geometries are polygons
    with reconstruction plate IDs and valid times.

    Notes
    -----
    This step must be done so that the initial set of ocean basin points
    (the Stripy icosahedral mesh) can be partitioned into plates using
    each reconstruction plate ID for the given plate `model`.

    This allows for an oceanic point-in-continental
    polygon query for every identified plate ID. See documentation for
    `point_in_polygon_routine` for more details.

    `ensure_polygon_geometry` works as follows:
    COB terrane/continental polygons are assumed to have been reconstructed
    already in `reconstructed_polygons` (a list of
    type &lt;pygplates.ReconstructedFeatureGeometry&gt;). The list contents are
    turned into a &lt;pygplates.FeatureCollection&gt; to be ascribed a
    `PolygonOnSphere` geometry, a reconstruction plate ID, and a valid time.
    Once finished, this feature collection is turned back into a list of
    instance &lt;pygplates.ReconstructedFeatureGeometry&gt; and returned.

    This revert must be completed for compatibility with the subsequent
    point-in-polygon routine.

    Parameters
    ----------
    reconstructed_polygons : list of instance &lt;pygplates.ReconstructedFeatureGeometry&gt;
        If used in `SeafloorGrid`, these are automatically obtained from the
        `PlotTopologies.continents` attribute (the reconstructed continental
        polygons at the current reconstruction time).

    rotation_model : instance of &lt;pygplates.RotationModel&gt;
        A parameter for turning the &lt;pygplates.FeatureCollection&gt; back into a
        list of instance &lt;pygplates.ReconstructedFeatureGeometry&gt; for
        compatibility with the point-in-polygon routine.

    &#34;&#34;&#34;
    continent_FeatCol = []
    # self._PlotTopologies_object.continents
    for n in reconstructed_polygons:
        continent_FeatCol.append(n.get_feature())

    polygon_feats = pygplates.FeatureCollection(continent_FeatCol)

    # From GPRM&#39;s force_polygon_geometries(); set feature attributes
    # like valid times and plate IDs to each masking polygon
    polygons = []
    for feature in polygon_feats:
        for geom in feature.get_all_geometries():
            polygon = pygplates.Feature(feature.get_feature_type())
            polygon.set_geometry(pygplates.PolygonOnSphere(geom))
            polygon.set_reconstruction_plate_id(feature.get_reconstruction_plate_id())
            # Avoid features in COBTerranes with invalid time
            if feature.get_valid_time()[0] &gt;= feature.get_valid_time()[1]:
                polygon.set_valid_time(
                    feature.get_valid_time()[0], feature.get_valid_time()[1]
                )
                polygons.append(polygon)
    cobter_polygon_features = pygplates.FeatureCollection(polygons)

    # Turn the feature collection back into ReconstructedFeatureGeometry
    # objects otherwise it will not work with PIP
    reconstructed_cobter_polygons = []
    pygplates.reconstruct(
        cobter_polygon_features, rotation_model, reconstructed_cobter_polygons, time
    )
    return reconstructed_cobter_polygons</code></pre>
</details>
</dd>
<dt id="gplately.utils.seafloor_grid_utils.point_in_polygon_routine"><code class="name flex">
<span>def <span class="ident">point_in_polygon_routine</span></span>(<span>multi_point, COB_polygons)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform Plate Tectonic Tools' point in polygon routine to partition
points in a <code>multi_point</code> MultiPointOnSphere feature based on whether
they are inside or outside the polygons in <code>COB_polygons</code>.</p>
<h2 id="notes">Notes</h2>
<p>Assuming the <code>COB_polygons</code> have passed through <code><a title="gplately.utils.seafloor_grid_utils.ensure_polygon_geometry" href="#gplately.utils.seafloor_grid_utils.ensure_polygon_geometry">ensure_polygon_geometry()</a></code>,
each polygon should have a plate ID assigned to it.</p>
<p>This PIP routine serves two purposes for <code>SeafloorGrid</code>:</p>
<p>1) It identifies continental regions in the icosahedral global mesh
MultiPointOnSphere feature and 'erases' in-continent oceanic points
for the construction of a continental mask at each timestep;</p>
<p>2) It identifies oceanic points in the icosahedral global mesh.
These points will be passed to a function that calculates each point's
proximity to its nearest MOR segment (if any) within the polygonal domain
of its allocated plate ID. Each distance is divided by half the
<code>initial_ocean_mean_spreading_rate</code> (an attribute of <code>SeafloorGrids</code>) to
determine a simplified seafloor age for each point.</p>
<p>Number 2) only happens once at the start of the gridding process to
momentarily fill the gridding region with initial ocean points that have
set ages (albeit not from a plate model file). After multiple time steps
of reconstruction, the ocean basin will be filled with new points (with
plate-model prescribed ages) that emerge from ridge topologies.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pygplates.MultiPointOnSphere(points_in_arr) : instance &lt;pygplates.MultiPointOnSphere&gt;</code></dt>
<dd>Point features that are within COB terrane polygons.</dd>
<dt><code>pygplates.MultiPointOnSphere(points_out_arr) : instance &lt;pygplates.MultiPointOnSphere&gt;</code></dt>
<dd>Point features that are outside COB terrane polygons.</dd>
<dt><strong><code>zvals</code></strong> :&ensp;<code>list</code></dt>
<dd>A binary list. If an entry is == 0, its corresponing point in the
MultiPointOnSphere object is on the ocean. If == 1, the point is
in the COB terrane polygon.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point_in_polygon_routine(multi_point, COB_polygons):
    &#34;&#34;&#34;Perform Plate Tectonic Tools&#39; point in polygon routine to partition
    points in a `multi_point` MultiPointOnSphere feature based on whether
    they are inside or outside the polygons in `COB_polygons`.

    Notes
    -----
    Assuming the `COB_polygons` have passed through `ensure_polygon_geometry`,
    each polygon should have a plate ID assigned to it.

    This PIP routine serves two purposes for `SeafloorGrid`:

    1) It identifies continental regions in the icosahedral global mesh
    MultiPointOnSphere feature and &#39;erases&#39; in-continent oceanic points
    for the construction of a continental mask at each timestep;

    2) It identifies oceanic points in the icosahedral global mesh.
    These points will be passed to a function that calculates each point&#39;s
    proximity to its nearest MOR segment (if any) within the polygonal domain
    of its allocated plate ID. Each distance is divided by half the
    `initial_ocean_mean_spreading_rate` (an attribute of `SeafloorGrids`) to
    determine a simplified seafloor age for each point.

    Number 2) only happens once at the start of the gridding process to
    momentarily fill the gridding region with initial ocean points that have
    set ages (albeit not from a plate model file). After multiple time steps
    of reconstruction, the ocean basin will be filled with new points (with
    plate-model prescribed ages) that emerge from ridge topologies.


    Returns
    -------
    pygplates.MultiPointOnSphere(points_in_arr) : instance &lt;pygplates.MultiPointOnSphere&gt;
        Point features that are within COB terrane polygons.
    pygplates.MultiPointOnSphere(points_out_arr) : instance &lt;pygplates.MultiPointOnSphere&gt;
        Point features that are outside COB terrane polygons.
    zvals : list
        A binary list. If an entry is == 0, its corresponing point in the
        MultiPointOnSphere object is on the ocean. If == 1, the point is
        in the COB terrane polygon.
    &#34;&#34;&#34;
    # Convert MultiPointOnSphere to array of PointOnSphere
    multi_point = np.array(multi_point.get_points(), dtype=&#34;object&#34;)

    # Collect reconstructed geometries of continental polygons
    polygons = np.empty(len(COB_polygons), dtype=&#34;object&#34;)
    for ind, i in enumerate(COB_polygons):
        if isinstance(i, pygplates.ReconstructedFeatureGeometry):
            geom = i.get_reconstructed_geometry()
        elif isinstance(i, pygplates.GeometryOnSphere):
            geom = i
        else:  # e.g. ndarray of coordinates
            geom = pygplates.PolygonOnSphere(i)
        polygons[ind] = geom
    proxies = np.ones(polygons.size)

    pip_result = ptt.utils.points_in_polygons.find_polygons(
        multi_point, polygons, proxies, all_polygons=False
    )  # 1 for points in polygons, None for points outside
    zvals = np.array(
        pip_result,
        dtype=&#34;float&#34;,
    ).ravel()
    zvals[np.isnan(zvals)] = 0.0
    zvals = zvals.astype(&#34;int&#34;)
    points_in_arr = multi_point[zvals == 1]
    points_out_arr = multi_point[zvals != 1]

    return (
        pygplates.MultiPointOnSphere(points_in_arr),
        pygplates.MultiPointOnSphere(points_out_arr),
        zvals,
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="GPlately logo" height="172" width="205">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately.utils" href="index.html">gplately.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gplately.utils.seafloor_grid_utils.create_icosahedral_mesh" href="#gplately.utils.seafloor_grid_utils.create_icosahedral_mesh">create_icosahedral_mesh</a></code></li>
<li><code><a title="gplately.utils.seafloor_grid_utils.ensure_polygon_geometry" href="#gplately.utils.seafloor_grid_utils.ensure_polygon_geometry">ensure_polygon_geometry</a></code></li>
<li><code><a title="gplately.utils.seafloor_grid_utils.point_in_polygon_routine" href="#gplately.utils.seafloor_grid_utils.point_in_polygon_routine">point_in_polygon_routine</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>