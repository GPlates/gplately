<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>gplately.utils API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.utils</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="gplately.utils.crustal_production" href="crustal_production.html">gplately.utils.crustal_production</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gplately.utils.create_icosahedral_mesh"><code class="name flex">
<span>def <span class="ident">create_icosahedral_mesh</span></span>(<span>refinement_levels)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a global point mesh with Stripy's
<a href="https://github.com/underworldcode/stripy/blob/294354c00dd72e085a018e69c345d9353c6fafef/stripy/spherical_meshes.py#L27">icosahedral triangulated mesh</a>
and turn all mesh domains into pyGPlates MultiPointOnSphere types.</p>
<p>This global mesh will be masked with a set of continental or COB terrane
polygons to define the ocean basin at a given reconstruction time.
The <code>refinement_levels</code> integer is proportional to the resolution of the
mesh and the ocean/continent boundary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>refinement_levels</code></strong> :&ensp;<code>int</code></dt>
<dd>Refine the number of points in the triangulation. The larger the
refinement level, the sharper the ocean basin resolution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>multi_point</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.MultiPointOnSphere&gt;</code></dt>
<dd>The longitues and latitudes that make up the icosahedral ocean mesh
collated into a MultiPointOnSphere object.</dd>
<dt><strong><code>icosahedral_global_mesh</code></strong> :&ensp;<code>instance</code> of <code>&lt;stripy.spherical_meshes.icosahedral_mesh&gt;</code></dt>
<dd>The original global icosahedral triangulated mesh.</dd>
</dl></div>
</dd>
<dt id="gplately.utils.ensure_polygon_geometry"><code class="name flex">
<span>def <span class="ident">ensure_polygon_geometry</span></span>(<span>reconstructed_polygons, rotation_model, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure COB terrane/continental polygon geometries are polygons
with reconstruction plate IDs and valid times.</p>
<h2 id="notes">Notes</h2>
<p>This step must be done so that the initial set of ocean basin points
(the Stripy icosahedral mesh) can be partitioned into plates using
each reconstruction plate ID for the given plate <code>model</code>.</p>
<p>This allows for an oceanic point-in-continental
polygon query for every identified plate ID. See documentation for
<code><a title="gplately.utils.point_in_polygon_routine" href="#gplately.utils.point_in_polygon_routine">point_in_polygon_routine()</a></code> for more details.</p>
<p><code><a title="gplately.utils.ensure_polygon_geometry" href="#gplately.utils.ensure_polygon_geometry">ensure_polygon_geometry()</a></code> works as follows:
COB terrane/continental polygons are assumed to have been reconstructed
already in <code>reconstructed_polygons</code> (a list of
type <pygplates.ReconstructedFeatureGeometry>). The list contents are
turned into a <pygplates.FeatureCollection> to be ascribed a
<code>PolygonOnSphere</code> geometry, a reconstruction plate ID, and a valid time.
Once finished, this feature collection is turned back into a list of
instance <pygplates.ReconstructedFeatureGeometry> and returned.</p>
<p>This revert must be completed for compatibility with the subsequent
point-in-polygon routine.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reconstructed_polygons</code></strong> :&ensp;<code>list</code> of <code>instance &lt;pygplates.ReconstructedFeatureGeometry&gt;</code></dt>
<dd>If used in <code>SeafloorGrid</code>, these are automatically obtained from the
<code>PlotTopologies.continents</code> attribute (the reconstructed continental
polygons at the current reconstruction time).</dd>
<dt><strong><code>rotation_model</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.RotationModel&gt;</code></dt>
<dd>A parameter for turning the <pygplates.FeatureCollection> back into a
list of instance <pygplates.ReconstructedFeatureGeometry> for
compatibility with the point-in-polygon routine.</dd>
</dl></div>
</dd>
<dt id="gplately.utils.get_geometries"><code class="name flex">
<span>def <span class="ident">get_geometries</span></span>(<span>filename, buffer=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a file and return feature geometries.</p>
<p>If <code>geopandas</code> is available, it will be used to read the file,
returning a <code>geopandas.GeoSeries</code>. If <code>geopandas</code> is not found,
only shapefiles can be read, and a list of <code>shapely</code> geometries
will be returned instead of a <code>geopandas.GeoSeries</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file to be read.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>geometries</code></strong> :&ensp;<code>list</code> or <code>geopandas.GeoSeries</code></dt>
<dd><code>shapely</code> geometries that define the feature geometry held in the
shapefile.</dd>
</dl></div>
</dd>
<dt id="gplately.utils.get_valid_geometries"><code class="name flex">
<span>def <span class="ident">get_valid_geometries</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a file and return valid feature geometries.</p>
<p>If <code>geopandas</code> is available, it will be used to read the file,
returning a <code>geopandas.GeoSeries</code>. If <code>geopandas</code> is not found,
only shapefiles can be read, and a list of <code>shapely</code> geometries
will be returned instead of a <code>geopandas.GeoSeries</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file to be read.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>geometries</code></strong> :&ensp;<code>list</code> or <code>geopandas.GeoSeries</code></dt>
<dd>Valid <code>shapely</code> geometries that define the feature geometry held in the
shapefile.</dd>
</dl></div>
</dd>
<dt id="gplately.utils.plot_subduction_teeth"><code class="name flex">
<span>def <span class="ident">plot_subduction_teeth</span></span>(<span>geometries, width, polarity=None, height=None, spacing=None, projection='auto', transform=None, ax=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add subduction teeth to a plot.</p>
<p>The subduction polarity used for subduction teeth can be specified
manually or detected automatically if <code>geometries</code> is a
<code>geopandas.GeoDataFrame</code> object with a <code>polarity</code> column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geometries</code></strong> :&ensp;<code>geopandas.GeoDataFrame, sequence</code> of <code>shapely geometries,</code> or <code>str</code></dt>
<dd>If a <code>geopandas.GeoDataFrame</code> is given, its geometry attribute
will be used. If <code>geometries</code> is a string, it must be the path to
a file, which will be loaded with <code>geopandas.read_file</code>. Otherwise,
<code>geometries</code> must be a sequence of shapely geometry objects (instances
of the <code>shapely.geometry.base.BaseGeometry</code> class).</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>The (approximate) width of the subduction teeth. If a projection is
used, this value will be in projected units.</dd>
<dt><strong><code>polarity</code></strong> :&ensp;<code>{"left", "l", "right", "r", None}</code>, default <code>None</code></dt>
<dd>The subduction polarity of the geometries. If no polarity is provided,
and <code>geometries</code> is a <code>geopandas.GeoDataFrame</code>, this function will
attempt to find a <code>polarity</code> column in the data frame and use the
values given there. If <code>polarity</code> is not manually specified and no
appropriate column can be found, an error will be raised.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, default <code>None</code></dt>
<dd>If provided, the height of the subduction teeth. As with <code>width</code>,
this value should be given in projected units. If no value is given,
the height of the teeth will be equal to 0.6 * <code>width</code>.</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code>, default <code>None</code></dt>
<dd>If provided, the spacing between the subduction teeth. As with
<code>width</code> and <code>height</code>, this value should be given in projected units.
If no value is given, <code>spacing</code> will default to <code>width</code>, producing
tightly packed subduction teeth.</dd>
<dt><strong><code>projection</code></strong> :&ensp;<code>cartopy.crs.Transform, "auto",</code> or <code>None</code>, default <code>"auto"</code></dt>
<dd>The projection of the plot. If the plot has no projection, this value
can be explicitly given as <code>None</code>. The default value is "auto", which
will acquire the projection automatically from the plot axes.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>cartopy.crs.Transform,</code> or <code>None</code>, default <code>None</code></dt>
<dd>If the plot is projected, a <code>transform</code> value is usually needed.
Frequently, the appropriate value is an instance of
<code>cartopy.crs.PlateCarree</code>.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes,</code> or <code>None</code>, default <code>None</code></dt>
<dd>The axes on which the subduction teeth will be drawn. By default,
the current axes will be acquired using <code>matplotlib.pyplot.gca</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any further keyword arguments will be passed to
<code>matplotlib.patches.Polygon</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>width</code> &lt;= 0, or if <code>polarity</code> is an invalid value or could not
be determined.</dd>
</dl></div>
</dd>
<dt id="gplately.utils.point_in_polygon_routine"><code class="name flex">
<span>def <span class="ident">point_in_polygon_routine</span></span>(<span>multi_point, COB_polygons)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform Plate Tectonic Tools' point in polygon routine to partition
points in a <code>multi_point</code> MultiPointOnSphere feature based on whether
they are inside or outside the polygons in <code>COB_polygons</code>.</p>
<h2 id="notes">Notes</h2>
<p>Assuming the <code>COB_polygons</code> have passed through <code><a title="gplately.utils.ensure_polygon_geometry" href="#gplately.utils.ensure_polygon_geometry">ensure_polygon_geometry()</a></code>,
each polygon should have a plate ID assigned to it.</p>
<p>This PIP routine serves two purposes for <code>SeafloorGrid</code>:</p>
<p>1) It identifies continental regions in the icosahedral global mesh
MultiPointOnSphere feature and 'erases' in-continent oceanic points
for the construction of a continental mask at each timestep;</p>
<p>2) It identifies oceanic points in the icosahedral global mesh.
These points will be passed to a function that calculates each point's
proximity to its nearest MOR segment (if any) within the polygonal domain
of its allocated plate ID. Each distance is divided by half the
<code>initial_ocean_mean_spreading_rate</code> (an attribute of <code>SeafloorGrids</code>) to
determine a simplified seafloor age for each point.</p>
<p>Number 2) only happens once at the start of the gridding process to
momentarily fill the gridding region with initial ocean points that have
set ages (albeit not from a plate model file). After multiple time steps
of reconstruction, the ocean basin will be filled with new points (with
plate-model prescribed ages) that emerge from ridge topologies.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pygplates.MultiPointOnSphere(points_in_arr) : instance &lt;pygplates.MultiPointOnSphere&gt;</code></dt>
<dd>Point features that are within COB terrane polygons.</dd>
<dt><code>pygplates.MultiPointOnSphere(points_out_arr) : instance &lt;pygplates.MultiPointOnSphere&gt;</code></dt>
<dd>Point features that are outside COB terrane polygons.</dd>
<dt><strong><code>zvals</code></strong> :&ensp;<code>list</code></dt>
<dd>A binary list. If an entry is == 0, its corresponing point in the
MultiPointOnSphere object is on the ocean. If == 1, the point is
in the COB terrane polygon.</dd>
</dl></div>
</dd>
<dt id="gplately.utils.shapelify_features"><code class="name flex">
<span>def <span class="ident">shapelify_features</span></span>(<span>features, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Shapely <code>MultiPolygon</code> or <code>MultiLineString</code> geometries from reconstructed feature polygons.</p>
<h2 id="notes">Notes</h2>
<p>Some Shapely polygons generated by <code><a title="gplately.utils.shapelify_features" href="#gplately.utils.shapelify_features">shapelify_features()</a></code> cut longitudes of 180
or -180 degrees. These features may appear unclosed at the dateline, so Shapely
"closes" these polygons by connecting any of their open ends with lines. These
lines may manifest on GeoAxes plots as horizontal lines that span the entire
global extent. To prevent this, <code><a title="gplately.utils.shapelify_features" href="#gplately.utils.shapelify_features">shapelify_features()</a></code> uses pyGPlates'
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
to split a feature polygon into multiple closed polygons if it happens to cut the antimeridian.
Another measure taken to ensure features are valid is to order exterior coordinates
of Shapely polygons anti-clockwise.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>iterable</code> of <code>&lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt;</code> or <code>&lt;GeometryOnSphere&gt;</code></dt>
<dd>Iterable containing reconstructed polygon features.</dd>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>all_geometries</code></strong> :&ensp;<code>list</code> of <code>shapely.geometry.BaseGeometry</code></dt>
<dd>Shapely geometries converted from the given reconstructed features. Any
geometries at the dateline are split.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>geometry.pygplates_to_shapely</code></dt>
<dd>convert PyGPlates geometry objects to
<code>Shapely geometries.</code></dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.utils.ContinentCollision"><code class="flex name class">
<span>class <span class="ident">ContinentCollision</span></span>
<span>(</span><span>grd_output_dir, chain_collision_detection=&lt;gplately.utils.seafloor_grid_utils.DefaultCollision object&gt;, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Continental collision detection function class (the function is the '<strong>call</strong>' method).</p>
<p>grd_output_dir: The directory containing the continental grids.</p>
<p>chain_collision_detection: Another collision detection class/function to reference if we find no collision.
If None then no collision detection is chained. Defaults to the default collision detection.</p>
<p>verbose: Print progress messages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContinentCollision(object):
    &#34;&#34;&#34;
    Continental collision detection function class (the function is the &#39;__call__&#39; method).
    &#34;&#34;&#34;

    def __init__(
        self,
        grd_output_dir,
        chain_collision_detection=DEFAULT_COLLISION,
        verbose=False,
    ):
        &#34;&#34;&#34;
        grd_output_dir: The directory containing the continental grids.

        chain_collision_detection: Another collision detection class/function to reference if we find no collision.
                                   If None then no collision detection is chained. Defaults to the default collision detection.

        verbose: Print progress messages
        &#34;&#34;&#34;

        self.grd_output_dir = grd_output_dir
        self.chain_collision_detection = chain_collision_detection
        self.verbose = verbose

        # Load a new grid each time the reconstruction time changes.
        self.grid_time = None

    @property
    def grid_time(self):
        return self._grid_time

    @grid_time.setter
    def grid_time(self, time):
        from ..grids import read_netcdf_grid

        if time is None:
            self._grid_time = time
        else:
            filename = &#34;{:s}&#34;.format(self.grd_output_dir.format(time))
            if self.verbose:
                print(
                    &#34;Points masked against grid: {0}&#34;.format(os.path.basename(filename))
                )
            gridZ, gridX, gridY = read_netcdf_grid(filename, return_grids=True)
            self.gridZ = gridZ
            self.ni, self.nj = gridZ.shape
            self.xmin = np.nanmin(gridX)
            self.xmax = np.nanmax(gridX)
            self.ymin = np.nanmin(gridY)
            self.ymax = np.nanmax(gridY)
            self._grid_time = float(time)

    def __call__(
        self,
        rotation_model,
        time,
        reconstruction_time_interval,
        prev_point,
        curr_point,
        prev_topology_plate_id,
        prev_resolved_plate_boundary,
        curr_topology_plate_id,
        curr_resolved_plate_boundary,
    ):
        &#34;&#34;&#34;
        Returns True if a collision with a continent was detected, or returns result of
        chained collision detection if &#39;self.chain_collision_detection&#39; is not None.
        &#34;&#34;&#34;
        # Load the grid for the current time if encountering a new time.
        if time != self.grid_time:
            self.grid_time = time
            self.continent_deletion_count = 0

        # Sample mask grid, which is one over continents and zero over oceans.
        point_lat, point_lon = curr_point.to_lat_lon()
        point_i = (self.ni - 1) * ((point_lat - self.ymin) / (self.ymax - self.ymin))
        point_j = (self.nj - 1) * ((point_lon - self.xmin) / (self.xmax - self.xmin))
        point_i_uint = np.rint(point_i).astype(np.uint)
        point_j_uint = np.rint(point_j).astype(np.uint)
        try:
            mask_value = self.gridZ[point_i_uint, point_j_uint]
        except IndexError:
            point_i = np.clip(np.rint(point_i), 0, self.ni - 1).astype(np.int_)
            point_j = np.clip(np.rint(point_j), 0, self.nj - 1).astype(np.int_)
            mask_value = self.gridZ[point_i, point_j]
        if mask_value &gt;= 0.5:
            # Detected a collision.
            self.continent_deletion_count += 1
            return True

        # We didn&#39;t find a collision, so ask the chained collision detection if it did (if we have anything chained).
        if self.chain_collision_detection:
            return self.chain_collision_detection(
                rotation_model,
                time,
                reconstruction_time_interval,
                prev_point,
                curr_point,
                prev_topology_plate_id,
                prev_resolved_plate_boundary,
                curr_topology_plate_id,
                curr_resolved_plate_boundary,
            )

        return False</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="gplately.utils.ContinentCollision.grid_time"><code class="name">prop <span class="ident">grid_time</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid_time(self):
    return self._grid_time</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gplately.utils.DefaultCollision"><code class="flex name class">
<span>class <span class="ident">DefaultCollision</span></span>
<span>(</span><span>global_collision_parameters=(7.0, 10.0), feature_specific_collision_parameters=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Default collision detection function class (the function is the '<strong>call</strong>' method).</p>
<p>global_collision_parameters: The collision parameters to use for any feature type not specified in 'feature_specific_collision_parameters'.
Should be a 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my).
The first threshold parameter means:
A point that transitions from one plate to another can disappear if the change in velocity exceeds this threshold.
The second threshold parameter means:
Only those transitioning points exceeding the threshold velocity delta and that are close enough to a plate boundary can disappear.
The distance is proportional to the relative velocity (change in velocity), plus a constant offset based on the threshold distance to boundary
to account for plate boundaries that change shape significantly from one time step to the next
(note that some boundaries are meant to do this and others are a result of digitisation).
The actual distance threshold used is (threshold_distance_to_boundary + relative_velocity) * time_interval
Defaults to parameters used in GPlates 2.0, if not specified.</p>
<p>feature_specific_collision_parameters: Optional sequence of collision parameters specific to feature types.
If specified then should be a sequence of 2-tuples, with each 2-tuple specifying (feature_type, collision_parameters).
And where each 'collision_parameters' is a 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my).
See 'global_collision_parameters' for details on these thresholds.
Any feature type not specified here defaults to using 'global_collision_parameters'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DefaultCollision(object):
    &#34;&#34;&#34;
    Default collision detection function class (the function is the &#39;__call__&#39; method).
    &#34;&#34;&#34;

    DEFAULT_GLOBAL_COLLISION_PARAMETERS = (7.0, 10.0)
    &#34;&#34;&#34;
    Default collision parameters for all feature types.

    This is a 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my):
    Here we default to the same constants used internally in GPlates 2.0 (ie, 7.0 and 10.0).
    &#34;&#34;&#34;

    def __init__(
        self,
        global_collision_parameters=DEFAULT_GLOBAL_COLLISION_PARAMETERS,
        feature_specific_collision_parameters=None,
    ):
        &#34;&#34;&#34;
        global_collision_parameters: The collision parameters to use for any feature type not specified in &#39;feature_specific_collision_parameters&#39;.
                                     Should be a 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my).
                                     The first threshold parameter means:
                                        A point that transitions from one plate to another can disappear if the change in velocity exceeds this threshold.
                                     The second threshold parameter means:
                                        Only those transitioning points exceeding the threshold velocity delta and that are close enough to a plate boundary can disappear.
                                        The distance is proportional to the relative velocity (change in velocity), plus a constant offset based on the threshold distance to boundary
                                        to account for plate boundaries that change shape significantly from one time step to the next
                                        (note that some boundaries are meant to do this and others are a result of digitisation).
                                        The actual distance threshold used is (threshold_distance_to_boundary + relative_velocity) * time_interval
                                     Defaults to parameters used in GPlates 2.0, if not specified.

        feature_specific_collision_parameters: Optional sequence of collision parameters specific to feature types.
                                               If specified then should be a sequence of 2-tuples, with each 2-tuple specifying (feature_type, collision_parameters).
                                               And where each &#39;collision_parameters&#39; is a 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my).
                                                   See &#39;global_collision_parameters&#39; for details on these thresholds.
                                               Any feature type not specified here defaults to using &#39;global_collision_parameters&#39;.
        &#34;&#34;&#34;

        # Convert list of (feature_type, collision_parameters) tuples to a dictionary.
        if feature_specific_collision_parameters:
            self.feature_specific_collision_parameters = dict(
                feature_specific_collision_parameters
            )
        else:
            self.feature_specific_collision_parameters = dict()
        # Fallback for any feature type not specified in the optional feature-specific list.
        self.global_collision_parameters = global_collision_parameters

        # Used to improve performance by caching velocity stage rotations in a dict (for a specific reconstruction time).
        self.velocity_stage_rotation_dict = {}
        self.velocity_stage_rotation_time = None

    def __call__(
        self,
        rotation_model,
        time,
        reconstruction_time_interval,
        prev_point,
        curr_point,
        prev_topology_plate_id,
        prev_resolved_plate_boundary,
        curr_topology_plate_id,
        curr_resolved_plate_boundary,
    ):
        &#34;&#34;&#34;
        Returns True if a collision was detected.

        If transitioning from a rigid plate to another rigid plate with a different plate ID then
        calculate the difference in velocities and continue testing as follows
        (otherwise, if there&#39;s no transition, then the point is still active)...

        If the velocity difference is below a threshold then we assume the previous plate was split,
        or two plates joined. In this case the point has not subducted (forward in time) or
        been consumed by a mid-ocean (backward in time) and hence is still active.

        If the velocity difference is large enough then we see if the distance of the *previous* position
        to the polygon boundary (of rigid plate containing it) exceeds a threshold.
        If the distance exceeds the threshold then the point is far enough away from the boundary that it
        cannot be subducted or consumed by it and hence the point is still active.
        However if the point is close enough then we assume the point was subducted/consumed
        (remember that the point switched plate IDs).
        Also note that the threshold distance increases according to the velocity difference to account for fast
        moving points (that would otherwise tunnel through the boundary and accrete onto the other plate).
        The reason for testing the distance from the *previous* point, and not from the *current* point, is:

          (i)  A topological boundary may *appear* near the current point (such as a plate split at the current time)
               and we don&#39;t want that split to consume the current point regardless of the velocity difference.
               It won&#39;t get consumed because the *previous* point was not near a boundary (because before split happened).
               If the velocity difference is large enough then it might cause the current point to transition to the
               adjacent split plate in the *next* time step (and that&#39;s when it should get consumed, not in the current time step).
               An example of this is a mid-ocean ridge suddenly appearing (going forward in time).

          (ii) A topological boundary may *disappear* near the current point (such as a plate merge at the current time)
               and we want that merge to consume the current point if the velocity difference is large enough.
               In this case the *previous* point is near a boundary (because before plate merged) and hence can be
               consumed (provided velocity difference is large enough). And since the boundary existed in the previous
               time step, it will affect position of the current point (and whether it gets consumed or not).
               An example of this is a mid-ocean ridge suddenly disappearing (going backward in time).

        ...note that items (i) and (ii) above apply both going forward and backward in time.
        &#34;&#34;&#34;

        # See if a collision occurred.
        if (
            curr_topology_plate_id != prev_topology_plate_id
            and prev_topology_plate_id is not None
            and curr_topology_plate_id is not None
        ):
            #
            # Speed up by caching velocity stage rotations in a dict.
            #
            if time != self.velocity_stage_rotation_time:
                # We&#39;ve just switched to a new time so clear the cache.
                #
                # We only cache stage rotations for a specific time.
                # We only really need to cache different plate IDs at the same &#39;time&#39;, so this avoids caching for all times
                # (which would also require including &#39;time&#39; in the key) and using memory unnecessarily.
                self.velocity_stage_rotation_dict.clear()
                self.velocity_stage_rotation_time = time
            prev_location_velocity_stage_rotation = (
                self.velocity_stage_rotation_dict.get(prev_topology_plate_id)
            )
            if not prev_location_velocity_stage_rotation:
                prev_location_velocity_stage_rotation = rotation_model.get_rotation(
                    time + 1, prev_topology_plate_id, time
                )
                self.velocity_stage_rotation_dict[prev_topology_plate_id] = (
                    prev_location_velocity_stage_rotation
                )
            curr_location_velocity_stage_rotation = (
                self.velocity_stage_rotation_dict.get(curr_topology_plate_id)
            )
            if not curr_location_velocity_stage_rotation:
                curr_location_velocity_stage_rotation = rotation_model.get_rotation(
                    time + 1, curr_topology_plate_id, time
                )
                self.velocity_stage_rotation_dict[curr_topology_plate_id] = (
                    curr_location_velocity_stage_rotation
                )

            # Note that even though the current point is not inside the previous boundary (because different plate ID), we can still
            # calculate a velocity using its plate ID (because we really should use the same point in our velocity comparison).
            prev_location_velocity = pygplates.calculate_velocities(
                (curr_point,),
                prev_location_velocity_stage_rotation,
                1,
                pygplates.VelocityUnits.kms_per_my,
            )[0]
            curr_location_velocity = pygplates.calculate_velocities(
                (curr_point,),
                curr_location_velocity_stage_rotation,
                1,
                pygplates.VelocityUnits.kms_per_my,
            )[0]

            delta_velocity = curr_location_velocity - prev_location_velocity
            delta_velocity_magnitude = delta_velocity.get_magnitude()

            # If we have feature-specific collision parameters then iterate over the boundary sub-segments of the *previous* topological boundary
            # and test proximity to each sub-segment individually (with sub-segment feature type specific collision parameters).
            # Otherwise just test proximity to the entire boundary polygon using the global collision parameters.
            if self.feature_specific_collision_parameters:
                for (
                    prev_boundary_sub_segment
                ) in prev_resolved_plate_boundary.get_boundary_sub_segments():
                    # Use feature-specific collision parameters if found (falling back to global collision parameters).
                    (
                        threshold_velocity_delta,
                        threshold_distance_to_boundary_per_my,
                    ) = self.feature_specific_collision_parameters.get(
                        prev_boundary_sub_segment.get_feature().get_feature_type(),
                        # Default to global collision parameters if no collision parameters specified for sub-segment&#39;s feature type...
                        self.global_collision_parameters,
                    )

                    # Since each feature type could use different collision parameters we must use the current boundary sub-segment instead of the boundary polygon.
                    if self._detect_collision_using_collision_parameters(
                        reconstruction_time_interval,
                        delta_velocity_magnitude,
                        prev_point,
                        prev_boundary_sub_segment.get_resolved_geometry(),
                        threshold_velocity_delta,
                        threshold_distance_to_boundary_per_my,
                    ):
                        # Detected a collision.
                        return True
            else:
                # No feature-specific collision parameters so use global fallback.
                (
                    threshold_velocity_delta,
                    threshold_distance_to_boundary_per_my,
                ) = self.global_collision_parameters

                # Since all feature types use the same collision parameters we can use the boundary polygon instead of iterating over its sub-segments.
                if self._detect_collision_using_collision_parameters(
                    reconstruction_time_interval,
                    delta_velocity_magnitude,
                    prev_point,
                    prev_resolved_plate_boundary.get_resolved_boundary(),
                    threshold_velocity_delta,
                    threshold_distance_to_boundary_per_my,
                ):
                    # Detected a collision.
                    return True

        return False

    def _detect_collision_using_collision_parameters(
        self,
        reconstruction_time_interval,
        delta_velocity_magnitude,
        prev_point,
        prev_boundary_geometry,
        threshold_velocity_delta,
        threshold_distance_to_boundary_per_my,
    ):
        if delta_velocity_magnitude &gt; threshold_velocity_delta:
            # Add the minimum distance threshold to the delta velocity threshold.
            # The delta velocity threshold only allows those points that are close enough to the boundary to reach
            # it given their current relative velocity.
            # The minimum distance threshold accounts for sudden changes in the shape of a plate boundary
            # which are no supposed to represent a new or shifted boundary but are just a result of the topology
            # builder/user digitising a new boundary line that differs noticeably from that of the previous time period.
            distance_threshold_radians = (
                (threshold_distance_to_boundary_per_my + delta_velocity_magnitude)
                * reconstruction_time_interval
                / pygplates.Earth.equatorial_radius_in_kms
            )
            distance_threshold_radians = min(distance_threshold_radians, math.pi)
            distance_threshold_radians = max(distance_threshold_radians, 0.0)

            distance = pygplates.GeometryOnSphere.distance(
                prev_point,
                prev_boundary_geometry,
                distance_threshold_radians=float(distance_threshold_radians),
            )
            if distance is not None:
                # Detected a collision.
                return True

        return False</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gplately.utils.DefaultCollision.DEFAULT_GLOBAL_COLLISION_PARAMETERS"><code class="name">var <span class="ident">DEFAULT_GLOBAL_COLLISION_PARAMETERS</span></code></dt>
<dd>
<div class="desc"><p>Default collision parameters for all feature types.</p>
<p>This is a 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my):
Here we default to the same constants used internally in GPlates 2.0 (ie, 7.0 and 10.0).</p></div>
</dd>
</dl>
</dd>
<dt id="gplately.utils.ReconstructByTopologies"><code class="flex name class">
<span>class <span class="ident">ReconstructByTopologies</span></span>
<span>(</span><span>rotation_features_or_model, topology_features, reconstruction_begin_time, reconstruction_end_time, reconstruction_time_interval, points, point_begin_times=None, point_end_times=None, point_plate_ids=None, detect_collisions=&lt;gplately.utils.seafloor_grid_utils.DefaultCollision object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to reconstruct geometries using topologies.</p>
<p>Currently only points are supported.</p>
<p>use_plate_partitioner: If True then use pygplates.PlatePartitioner to partition points,
otherwise use faster points_in_polygons.find_polygons().</p>
<p>rotation_features_or_model: Rotation model or feature collection(s), or list of features, or filename(s).</p>
<p>topology_features: Topology feature collection(s), or list of features, or filename(s) or any combination of those.</p>
<p>detect_collisions: Collision detection function, or None. Defaults to DEFAULT_COLLISION.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReconstructByTopologies(object):
    &#34;&#34;&#34;
    Class to reconstruct geometries using topologies.

    Currently only points are supported.

    use_plate_partitioner: If True then use pygplates.PlatePartitioner to partition points,
                           otherwise use faster points_in_polygons.find_polygons().
    &#34;&#34;&#34;

    use_plate_partitioner = False

    def __init__(
        self,
        rotation_features_or_model,
        topology_features,
        reconstruction_begin_time,
        reconstruction_end_time,
        reconstruction_time_interval,
        points,
        point_begin_times=None,
        point_end_times=None,
        point_plate_ids=None,
        detect_collisions=DEFAULT_COLLISION,
    ):
        &#34;&#34;&#34;
        rotation_features_or_model: Rotation model or feature collection(s), or list of features, or filename(s).

        topology_features: Topology feature collection(s), or list of features, or filename(s) or any combination of those.

        detect_collisions: Collision detection function, or None. Defaults to DEFAULT_COLLISION.
        &#34;&#34;&#34;

        # Turn rotation data into a RotationModel (if not already).
        if not isinstance(rotation_features_or_model, pygplates.RotationModel):
            rotation_model = pygplates.RotationModel(rotation_features_or_model)
        else:
            rotation_model = rotation_features_or_model
        self.rotation_model = rotation_model

        # Turn topology data into a list of features (if not already).
        self.topology_features = pygplates.FeaturesFunctionArgument(
            topology_features
        ).get_features()

        # Set up an array of reconstruction times covering the reconstruction time span.
        self.reconstruction_begin_time = reconstruction_begin_time
        self.reconstruction_end_time = reconstruction_end_time
        if reconstruction_time_interval &lt;= 0.0:
            raise ValueError(&#34;&#39;reconstruction_time_interval&#39; must be positive.&#34;)
        # Reconstruction can go forward or backward in time.
        if self.reconstruction_begin_time &gt; self.reconstruction_end_time:
            self.reconstruction_time_step = -reconstruction_time_interval
        else:
            self.reconstruction_time_step = reconstruction_time_interval
        # Get number of times including end time if time span is a multiple of time step.
        # The &#39;1&#39; is because, for example, 2 time intervals is 3 times.
        # The &#39;1e-6&#39; deals with limited floating-point precision, eg, we want (3.0 - 0.0) / 1.0 to be 3.0 and not 2.999999 (which gets truncated to 2).
        self.num_times = 1 + int(
            math.floor(
                1e-6
                + float(self.reconstruction_end_time - self.reconstruction_begin_time)
                / self.reconstruction_time_step
            )
        )
        # It&#39;s possible the time step is larger than the time span, in which case we change it to equal the time span.
        # This guarantees there&#39;ll be at least one time step (which has two times; one at either end of interval).
        if self.num_times == 1:
            self.num_times = 2
            self.reconstruction_time_step = (
                self.reconstruction_end_time - self.reconstruction_begin_time
            )
        self.reconstruction_time_interval = math.fabs(self.reconstruction_time_step)

        self.last_time_index = self.num_times - 1

        self.points = points
        self.num_points = len(points)

        # Use the specified point begin times if provided (otherwise use &#39;inf&#39;).
        self.point_begin_times = point_begin_times
        if self.point_begin_times is None:
            self.point_begin_times = [float(&#34;inf&#34;)] * self.num_points
        elif len(self.point_begin_times) != self.num_points:
            raise ValueError(
                &#34;Length of &#39;point_begin_times&#39; must match length of &#39;points&#39;.&#34;
            )

        # Use the specified point end times if provided (otherwise use &#39;-inf&#39;).
        self.point_end_times = point_end_times
        if self.point_end_times is None:
            self.point_end_times = [float(&#34;-inf&#34;)] * self.num_points
        elif len(self.point_end_times) != self.num_points:
            raise ValueError(
                &#34;Length of &#39;point_end_times&#39; must match length of &#39;points&#39;.&#34;
            )

        # Use the specified point plate IDs if provided (otherwise use &#39;0&#39;).
        # These plate IDs are only used when a point falls outside all resolved topologies during a time step.
        self.point_plate_ids = point_plate_ids
        if self.point_plate_ids is None:
            self.point_plate_ids = [0] * self.num_points
        elif len(self.point_plate_ids) != self.num_points:
            raise ValueError(
                &#34;Length of &#39;point_plate_ids&#39; must match length of &#39;points&#39;.&#34;
            )

        self.detect_collisions = detect_collisions

    def reconstruct(self):
        # Initialise the reconstruction.
        self.begin_reconstruction()

        # Loop over the reconstruction times until reached end of the reconstruction time span, or
        # all points have entered their valid time range *and* either exited their time range or
        # have been deactivated (subducted forward in time or consumed by MOR backward in time).
        while self.reconstruct_to_next_time():
            pass

        return self.get_active_current_points()

    def begin_reconstruction(self):
        self.current_time_index = 0

        # Set up point arrays.
        # Store active and inactive points here (inactive points have None in corresponding entries).
        self.prev_points = [None] * self.num_points
        self.curr_points = [None] * self.num_points
        self.next_points = [None] * self.num_points

        # Each point can only get activated once (after deactivation it cannot be reactivated).
        self.point_has_been_activated = [False] * self.num_points
        self.num_activated_points = 0

        # Set up topology arrays (corresponding to active/inactive points at same indices).
        self.prev_topology_plate_ids = [None] * self.num_points
        self.curr_topology_plate_ids = [None] * self.num_points
        self.prev_resolved_plate_boundaries = [None] * self.num_points
        self.curr_resolved_plate_boundaries = [None] * self.num_points

        # Array to store indices of points found in continents
        self.in_continent_indices = [None] * self.num_points
        self.in_continent_points = [None] * self.num_points

        self.deletedpoints = []

        self._activate_deactivate_points()
        self._find_resolved_topologies_containing_points()

    def get_current_time(self):
        return (
            self.reconstruction_begin_time
            + self.current_time_index * self.reconstruction_time_step
        )

    def get_all_current_points(self):
        return self.curr_points

    def get_active_current_points(self):
        # Return only the active points (the ones that are not None).
        return [point for point in self.get_all_current_points() if point is not None]

    def get_in_continent_indices(self):
        return self.in_continent_points, self.in_continent_indices

    def reconstruct_to_next_time(self):
        # If we&#39;re at the last time then there is no next time to reconstruct to.
        if self.current_time_index == self.last_time_index:
            return False

        # If all points have been previously activated, but none are currently active then we&#39;re finished.
        # This means all points have entered their valid time range *and* either exited their time range or
        # have been deactivated (subducted forward in time or consumed by MOR backward in time).
        if self.num_activated_points == self.num_points and not any(self.curr_points):
            return False

        # Cache stage rotations by plate ID.
        # Use different dicts since using different rotation models and time steps, etc.
        reconstruct_stage_rotation_dict = {}

        current_time = self.get_current_time()

        # Iterate over all points to reconstruct them to the next time step.
        for point_index in range(self.num_points):
            curr_point = self.curr_points[point_index]
            if curr_point is None:
                # Current point is not currently active.
                # So we cannot reconstruct to next time.
                self.next_points[point_index] = None
                continue

            # Get plate ID of resolved topology containing current point
            # (this was determined in last call to &#39;_find_resolved_topologies_containing_points()&#39;).
            curr_plate_id = self.curr_topology_plate_ids[point_index]
            if curr_plate_id is None:
                # Current point is currently active but it fell outside all resolved polygons.
                # So instead we just reconstruct using its plate ID (that was manually assigned by the user/caller).
                curr_plate_id = self.point_plate_ids[point_index]

            # Get the stage rotation that will move the point from where it is at the current time to its
            # location at the next time step, based on the plate id that contains the point at the current time.

            # Speed up by caching stage rotations in a dict.
            stage_rotation = reconstruct_stage_rotation_dict.get(curr_plate_id)
            if not stage_rotation:
                stage_rotation = self.rotation_model.get_rotation(
                    # Positive/negative time step means reconstructing backward/forward in time.
                    current_time + self.reconstruction_time_step,
                    curr_plate_id,
                    current_time,
                )
                reconstruct_stage_rotation_dict[curr_plate_id] = stage_rotation

            # Use the stage rotation to reconstruct the tracked point from position at current time
            # to position at the next time step.
            self.next_points[point_index] = stage_rotation * curr_point

        #
        # Set up for next loop iteration.
        #
        # Rotate previous, current and next point arrays.
        # The new previous will be the old current.
        # The new current will be the old next.
        # The new next will be the old previous (but values are ignored and overridden in next time step; just re-using its memory).
        self.prev_points, self.curr_points, self.next_points = (
            self.curr_points,
            self.next_points,
            self.prev_points,
        )
        # Swap previous and current topology arrays.
        # The new previous will be the old current.
        # The new current will be the old previous (but values are ignored and overridden in next time step; just re-using its memory).
        self.prev_topology_plate_ids, self.curr_topology_plate_ids = (
            self.curr_topology_plate_ids,
            self.prev_topology_plate_ids,
        )
        self.prev_resolved_plate_boundaries, self.curr_resolved_plate_boundaries = (
            self.curr_resolved_plate_boundaries,
            self.prev_resolved_plate_boundaries,
        )

        # Move the current time to the next time.
        self.current_time_index += 1
        current_time = self.get_current_time()

        self._activate_deactivate_points()
        self._find_resolved_topologies_containing_points()

        # Iterate over all points to detect collisions.
        if self.detect_collisions:
            for point_index in range(self.num_points):
                prev_point = self.prev_points[point_index]
                curr_point = self.curr_points[point_index]
                if prev_point is None or curr_point is None:
                    # If current point is not currently active then no need to detect a collision for it (to deactivate it).
                    # Also previous point might just have been activated now, at end of current time step, and hence
                    # not active at beginning of time step.
                    continue

                # Get plate IDs of resolved topology containing previous and current point
                # (this was determined in last call to &#39;_find_resolved_topologies_containing_points()&#39;).
                #
                # Note that could be None, so the collision detection needs to handle that.
                prev_plate_id = self.prev_topology_plate_ids[point_index]
                curr_plate_id = self.curr_topology_plate_ids[point_index]

                # Detect collisions at the end of the current time step since we need previous, and current, points and topologies.
                # De-activate point (in &#39;curr_points&#39;) if subducted (forward in time) or consumed back into MOR (backward in time).
                if self.detect_collisions(
                    self.rotation_model,
                    current_time,
                    self.reconstruction_time_interval,
                    prev_point,
                    curr_point,
                    prev_plate_id,
                    self.prev_resolved_plate_boundaries[point_index],
                    curr_plate_id,
                    self.curr_resolved_plate_boundaries[point_index],
                ):
                    # An inactive point in &#39;curr_points&#39; becomes None.
                    # It may have been reconstructed from the previous time step to a valid position
                    # but now we override that result as inactive.
                    self.curr_points[point_index] = None
                    # self.curr_points.remove(self.curr_points[point_index])
                    self.deletedpoints.append(point_index)

        # We successfully reconstructed to the next time.
        return True

    def _activate_deactivate_points(self):
        current_time = self.get_current_time()

        # Iterate over all points and activate/deactivate as necessary depending on each point&#39;s valid time range.
        for point_index in range(self.num_points):
            if self.curr_points[point_index] is None:
                if not self.point_has_been_activated[point_index]:
                    # Point is not active and has never been activated, so see if can activate it.
                    if (
                        current_time &lt;= self.point_begin_times[point_index]
                        and current_time &gt;= self.point_end_times[point_index]
                    ):
                        # The initial point is assumed to be the position at the current time
                        # which is typically the point&#39;s begin time (approximately).
                        # But it could be the beginning of the reconstruction time span (specified in constructor)
                        # if that falls in the middle of the point&#39;s valid time range - in this case the
                        # initial point position is assumed to be in a position that is some time *after*
                        # it appeared (at its begin time) - and this can happen, for example, if you have a
                        # uniform grids of points at some intermediate time and want to see how they
                        # reconstruct to either a younger or older time (remembering that points can
                        # be subducted forward in time and consumed back into a mid-ocean ridge going
                        # backward in time).
                        self.curr_points[point_index] = self.points[point_index]
                        self.point_has_been_activated[point_index] = True
                        self.num_activated_points += 1
            else:
                # Point is active, so see if can deactivate it.
                if not (
                    current_time &lt;= self.point_begin_times[point_index]
                    and current_time &gt;= self.point_end_times[point_index]
                ):
                    self.curr_points[point_index] = None

    def _find_resolved_topologies_containing_points(self):

        current_time = self.get_current_time()

        # Resolve the plate polygons for the current time.
        resolved_topologies = []
        pygplates.resolve_topologies(
            self.topology_features,
            self.rotation_model,
            resolved_topologies,
            current_time,
        )

        if ReconstructByTopologies.use_plate_partitioner:
            # Create a plate partitioner from the resolved polygons.
            plate_partitioner = pygplates.PlatePartitioner(
                resolved_topologies, self.rotation_model
            )
        else:
            # Some of &#39;curr_points&#39; will be None so &#39;curr_valid_points&#39; contains only the valid (not None)
            # points, and &#39;curr_valid_points_indices&#39; is the same length as &#39;curr_points&#39; but indexes into
            # &#39;curr_valid_points&#39; so we can quickly find which point (and hence which resolved topology)
            # in &#39;curr_valid_points&#39; is associated with the a particular point in &#39;curr_points&#39;.
            curr_valid_points = []
            curr_valid_points_indices = [None] * self.num_points
            for point_index, curr_point in enumerate(self.curr_points):
                if curr_point is not None:
                    curr_valid_points_indices[point_index] = len(curr_valid_points)
                    curr_valid_points.append(curr_point)
            # For each valid current point find the resolved topology containing it.
            resolved_topologies_containing_curr_valid_points = (
                _ptt.utils.points_in_polygons.find_polygons(
                    curr_valid_points,
                    [
                        resolved_topology.get_resolved_boundary()
                        for resolved_topology in resolved_topologies
                    ],
                    resolved_topologies,
                )
            )

        # Iterate over all points.
        for point_index, curr_point in enumerate(self.curr_points):
            if curr_point is None:
                # Current point is not currently active - so skip it.
                self.curr_topology_plate_ids[point_index] = None
                self.curr_resolved_plate_boundaries[point_index] = None
                continue

            # Find the plate id of the polygon that contains &#39;curr_point&#39;.
            if ReconstructByTopologies.use_plate_partitioner:
                curr_polygon = plate_partitioner.partition_point(curr_point)
            else:
                curr_polygon = resolved_topologies_containing_curr_valid_points[
                    # Index back into &#39;curr_valid_points&#39; and hence also into
                    # &#39;resolved_topologies_containing_curr_valid_points&#39;.
                    curr_valid_points_indices[point_index]
                ]
            self.curr_resolved_plate_boundaries[point_index] = curr_polygon

            # If the polygon is None, that means (presumably) that it fell into a crack between
            # topologies. So it will be skipped and thrown away from future iterations.
            if curr_polygon is None:
                self.curr_topology_plate_ids[point_index] = None
                continue

            # Set the plate ID of resolved topology containing current point.
            self.curr_topology_plate_ids[point_index] = (
                curr_polygon.get_feature().get_reconstruction_plate_id()
            )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gplately.utils.ReconstructByTopologies.use_plate_partitioner"><code class="name">var <span class="ident">use_plate_partitioner</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gplately.utils.ReconstructByTopologies.begin_reconstruction"><code class="name flex">
<span>def <span class="ident">begin_reconstruction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gplately.utils.ReconstructByTopologies.get_active_current_points"><code class="name flex">
<span>def <span class="ident">get_active_current_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gplately.utils.ReconstructByTopologies.get_all_current_points"><code class="name flex">
<span>def <span class="ident">get_all_current_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gplately.utils.ReconstructByTopologies.get_current_time"><code class="name flex">
<span>def <span class="ident">get_current_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gplately.utils.ReconstructByTopologies.get_in_continent_indices"><code class="name flex">
<span>def <span class="ident">get_in_continent_indices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gplately.utils.ReconstructByTopologies.reconstruct"><code class="name flex">
<span>def <span class="ident">reconstruct</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gplately.utils.ReconstructByTopologies.reconstruct_to_next_time"><code class="name flex">
<span>def <span class="ident">reconstruct_to_next_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="GPlately logo" height="172" width="205">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="../index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="gplately.utils.crustal_production" href="crustal_production.html">gplately.utils.crustal_production</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gplately.utils.create_icosahedral_mesh" href="#gplately.utils.create_icosahedral_mesh">create_icosahedral_mesh</a></code></li>
<li><code><a title="gplately.utils.ensure_polygon_geometry" href="#gplately.utils.ensure_polygon_geometry">ensure_polygon_geometry</a></code></li>
<li><code><a title="gplately.utils.get_geometries" href="#gplately.utils.get_geometries">get_geometries</a></code></li>
<li><code><a title="gplately.utils.get_valid_geometries" href="#gplately.utils.get_valid_geometries">get_valid_geometries</a></code></li>
<li><code><a title="gplately.utils.plot_subduction_teeth" href="#gplately.utils.plot_subduction_teeth">plot_subduction_teeth</a></code></li>
<li><code><a title="gplately.utils.point_in_polygon_routine" href="#gplately.utils.point_in_polygon_routine">point_in_polygon_routine</a></code></li>
<li><code><a title="gplately.utils.shapelify_features" href="#gplately.utils.shapelify_features">shapelify_features</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.utils.ContinentCollision" href="#gplately.utils.ContinentCollision">ContinentCollision</a></code></h4>
<ul class="">
<li><code><a title="gplately.utils.ContinentCollision.grid_time" href="#gplately.utils.ContinentCollision.grid_time">grid_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.utils.DefaultCollision" href="#gplately.utils.DefaultCollision">DefaultCollision</a></code></h4>
<ul class="">
<li><code><a title="gplately.utils.DefaultCollision.DEFAULT_GLOBAL_COLLISION_PARAMETERS" href="#gplately.utils.DefaultCollision.DEFAULT_GLOBAL_COLLISION_PARAMETERS">DEFAULT_GLOBAL_COLLISION_PARAMETERS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.utils.ReconstructByTopologies" href="#gplately.utils.ReconstructByTopologies">ReconstructByTopologies</a></code></h4>
<ul class="">
<li><code><a title="gplately.utils.ReconstructByTopologies.begin_reconstruction" href="#gplately.utils.ReconstructByTopologies.begin_reconstruction">begin_reconstruction</a></code></li>
<li><code><a title="gplately.utils.ReconstructByTopologies.get_active_current_points" href="#gplately.utils.ReconstructByTopologies.get_active_current_points">get_active_current_points</a></code></li>
<li><code><a title="gplately.utils.ReconstructByTopologies.get_all_current_points" href="#gplately.utils.ReconstructByTopologies.get_all_current_points">get_all_current_points</a></code></li>
<li><code><a title="gplately.utils.ReconstructByTopologies.get_current_time" href="#gplately.utils.ReconstructByTopologies.get_current_time">get_current_time</a></code></li>
<li><code><a title="gplately.utils.ReconstructByTopologies.get_in_continent_indices" href="#gplately.utils.ReconstructByTopologies.get_in_continent_indices">get_in_continent_indices</a></code></li>
<li><code><a title="gplately.utils.ReconstructByTopologies.reconstruct" href="#gplately.utils.ReconstructByTopologies.reconstruct">reconstruct</a></code></li>
<li><code><a title="gplately.utils.ReconstructByTopologies.reconstruct_to_next_time" href="#gplately.utils.ReconstructByTopologies.reconstruct_to_next_time">reconstruct_to_next_time</a></code></li>
<li><code><a title="gplately.utils.ReconstructByTopologies.use_plate_partitioner" href="#gplately.utils.ReconstructByTopologies.use_plate_partitioner">use_plate_partitioner</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
