<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>gplately.oceans API documentation</title>
<meta name="description" content="A module to generate grids of seafloor age, seafloor spreading rate
and other oceanic data from the `gplately.PlateReconstruction` and
…">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.oceans</code></h1>
</header>
<section id="section-intro">
<p>A module to generate grids of seafloor age, seafloor spreading rate
and other oceanic data from the <code><a title="gplately.PlateReconstruction" href="index.html#gplately.PlateReconstruction">PlateReconstruction</a></code> and
<code><a title="gplately.plot.PlotTopologies" href="plot.html#gplately.plot.PlotTopologies">PlotTopologies</a></code> objects. </p>
<p>Gridding methods in this module have been adapted from Simon Williams'
development repository for an
<a href="https://github.com/siwill22/agegrid-0.1">auto-age-gridding workflow</a>, and are kept
within the <code><a title="gplately.oceans.SeafloorGrid" href="#gplately.oceans.SeafloorGrid">SeafloorGrid</a></code> object.</p>
<p>The sample jupyter notebook
<a href="https://github.com/GPlates/gplately/blob/master/Notebooks/10-SeafloorGrids.ipynb">10-SeafloorGrid</a>
demonstrates how the functionalities within <code><a title="gplately.oceans.SeafloorGrid" href="#gplately.oceans.SeafloorGrid">SeafloorGrid</a></code> work. Below you can find
documentation for each of <code><a title="gplately.oceans.SeafloorGrid" href="#gplately.oceans.SeafloorGrid">SeafloorGrid</a></code>'s functions.</p>
<h2 id="seafloorgrid-methodology"><code><a title="gplately.oceans.SeafloorGrid" href="#gplately.oceans.SeafloorGrid">SeafloorGrid</a></code> Methodology</h2>
<p>There are two main steps that <code><a title="gplately.oceans.SeafloorGrid" href="#gplately.oceans.SeafloorGrid">SeafloorGrid</a></code> follows to generate grids:</p>
<ol>
<li>Preparation for reconstruction by topologies</li>
<li>Reconstruction by topologies</li>
</ol>
<p>The preparation step involves building a:</p>
<ul>
<li>global domain of initial points that populate the seafloor at <code>max_time</code>, </li>
<li>continental mask that separates ocean points from continent regions per timestep, and</li>
<li>set of points that emerge to the left and right of mid-ocean
ridge segments per timestep, as well as the z-value to allocate to these
points.</li>
</ul>
<p>First, the global domain of initial points is created using
<a href="https://github.com/underworldcode/stripy/blob/master/stripy/spherical_meshes.py#L27">stripy's</a>
icosahedral triangulated mesh. The number of points in this mesh can be
controlled using a <code>refinement_levels</code> integer (the larger this integer,
the more resolved the continent masks will be). </p>
<p><img alt="RefinementLevels" src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/pdoc_Files/seafloorgrid_refinement.png"></p>
<p>These points are spatially partitioned by plate ID so they can be passed
into a
<a href="https://gplates.github.io/gplately/oceans.html#gplately.oceans.point_in_polygon_routine">point-in-polygon routine</a>.
This identifies points that lie within
continental polygon boundaries and those that are in the ocean. From this,
<a href="https://gplates.github.io/gplately/oceans.html#gplately.oceans.SeafloorGrid.build_all_continental_masks">continental masks are built</a>
per timestep, and the initial seed points are
allocated ages at the first reconstruction timestep <code>max_time</code>. Each point's
initial age is calculated by dividing its proximity to the nearest
MOR segment by half its assumed spreading rate. This spreading rate
(<code>initial_ocean_mean_spreading_rate</code>) is assumed to be uniform for all points.</p>
<p>These initial points momentarily fill the global ocean basin, and all have uniform spreading rates.
Thus, the spreading rate grid at <code>max_time</code> will be uniformly populated with the <code>initial_ocean_mean_spreading_rate</code> (mm/yr).
The age grid at <code>max_time</code> will look like a series of smooth, linear age gradients clearly partitioned by
tectonic plates with unique plate IDs:</p>
<p><img alt="MaxTimeGrids" src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/pdoc_Files/max_time_grids.png"></p>
<p><a href="https://gplates.github.io/gplately/oceans.html#gplately.oceans.SeafloorGrid.build_all_MOR_seedpoints">Ridge "line" topologies</a>
are resolved at each reconstruction time step and partitioned
into segments with a valid stage rotation. Each segment is further divided into points
at a specified ridge sampling spacing (<code>ridge_sampling</code>). Each point is
ascribed a latitude, longitude, spreading rate and age (from plate reconstruction
model files, as opposed to ages of the initial ocean mesh points), a point index
and the general z-value that will be gridded onto it. </p>
<p><img alt="NewRidgePoints" src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/pdoc_Files/new_ridge_points.png"></p>
<p>Reconstruction by topologies involves determining which points are active and
inactive (collided with a continent or subducted at a trench) for each reconstruction
time step. This is done using a hidden object in <code>PlateReconstruction</code> called
<code>ReconstructByTopologies</code>.</p>
<p>If an ocean point with a certain velocity on one plate ID transitions into another
rigid plate ID at another timestep (with another velocity), the velocity difference
between both plates is calculated. The point may have subducted/collided with a continent
if this velocity difference is higher than a specified velocity threshold (which can be
controlled with <code>subduction_collision_parameters</code>). To ascertain whether the point
should be deactivated, a displacement test is conducted. If the proximity of the
point's previous time position to the polygon boundary it is approaching is higher than
a set distance threshold, then the point is far enough away from the boundary that it
cannot be subducted or consumed by it, and hence the point is still active. Otherwise,
it is deemed inactive and deleted from the ocean basin mesh. </p>
<p>With each reconstruction time step, points from mid-ocean ridges (which have more
accurate spreading rates and attributed valid times) will spread across the ocean
floor. Eventually, points will be pushed into continental boundaries or subduction
zones, where they are deleted. Ideally, all initial ocean points (from the Stripy
icosahedral mesh) should be deleted over time. However, not all will be deleted -
such points typically reside near continental boundaries. This happens if the
emerged ridge points do not spread far enough to "phase out" these points at
collision regions - likely due to insufficient reconstruction detail. These
undeleted points form artefacts of anomalously high seafloor age that append
over the reconstruction time range. </p>
<p>Once reconstruction by topologies determines the ocean basin snapshot per timestep,
a data frame of all longitudes, latitudes, seafloor ages, spreading rates and any other
attributed z values will be written to a gridding input file per timestep.</p>
<p>Each active longitude, latitude and chosen z value (identified by a gridding input file
column index integer, i.e. <code>2</code> is seafloor age) is gridded using nearest-neighbour
interpolation and written to a netCDF4 format.</p>
<h2 id="classes">Classes</h2>
<ul>
<li>SeafloorGrid</li>
</ul>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gplately.oceans.create_icosahedral_mesh"><code class="name flex">
<span>def <span class="ident">create_icosahedral_mesh</span></span>(<span>refinement_levels)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a global point mesh with Stripy's
<a href="https://github.com/underworldcode/stripy/blob/294354c00dd72e085a018e69c345d9353c6fafef/stripy/spherical_meshes.py#L27">icosahedral triangulated mesh</a>
and turn all mesh domains into pyGPlates MultiPointOnSphere types.</p>
<p>This global mesh will be masked with a set of continental or COB terrane
polygons to define the ocean basin at a given reconstruction time.
The <code>refinement_levels</code> integer is proportional to the resolution of the
mesh and the ocean/continent boundary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>refinement_levels</code></strong> :&ensp;<code>int</code></dt>
<dd>Refine the number of points in the triangulation. The larger the
refinement level, the sharper the ocean basin resolution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>multi_point</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.MultiPointOnSphere&gt;</code></dt>
<dd>The longitues and latitudes that make up the icosahedral ocean mesh
collated into a MultiPointOnSphere object.</dd>
<dt><strong><code>icosahedral_global_mesh</code></strong> :&ensp;<code>instance</code> of <code>&lt;stripy.spherical_meshes.icosahedral_mesh&gt;</code></dt>
<dd>The original global icosahedral triangulated mesh.</dd>
</dl></div>
</dd>
<dt id="gplately.oceans.ensure_polygon_geometry"><code class="name flex">
<span>def <span class="ident">ensure_polygon_geometry</span></span>(<span>reconstructed_polygons, rotation_model, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure COB terrane/continental polygon geometries are polygons
with reconstruction plate IDs and valid times.</p>
<h2 id="notes">Notes</h2>
<p>This step must be done so that the initial set of ocean basin points
(the Stripy icosahedral mesh) can be partitioned into plates using
each reconstruction plate ID for the given plate <code>model</code>.</p>
<p>This allows for an oceanic point-in-continental
polygon query for every identified plate ID. See documentation for
<code><a title="gplately.oceans.point_in_polygon_routine" href="#gplately.oceans.point_in_polygon_routine">point_in_polygon_routine()</a></code> for more details.</p>
<p><code><a title="gplately.oceans.ensure_polygon_geometry" href="#gplately.oceans.ensure_polygon_geometry">ensure_polygon_geometry()</a></code> works as follows:
COB terrane/continental polygons are assumed to have been reconstructed
already in <code>reconstructed_polygons</code> (a list of
type <pygplates.ReconstructedFeatureGeometry>). The list contents are
turned into a <pygplates.FeatureCollection> to be ascribed a
<code>PolygonOnSphere</code> geometry, a reconstruction plate ID, and a valid time.
Once finished, this feature collection is turned back into a list of
instance <pygplates.ReconstructedFeatureGeometry> and returned.</p>
<p>This revert must be completed for compatibility with the subsequent
point-in-polygon routine.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reconstructed_polygons</code></strong> :&ensp;<code>list</code> of <code>instance &lt;pygplates.ReconstructedFeatureGeometry&gt;</code></dt>
<dd>If used in <code><a title="gplately.oceans.SeafloorGrid" href="#gplately.oceans.SeafloorGrid">SeafloorGrid</a></code>, these are automatically obtained from the
<code>PlotTopologies.continents</code> attribute (the reconstructed continental
polygons at the current reconstruction time).</dd>
<dt><strong><code>rotation_model</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.RotationModel&gt;</code></dt>
<dd>A parameter for turning the <pygplates.FeatureCollection> back into a
list of instance <pygplates.ReconstructedFeatureGeometry> for
compatibility with the point-in-polygon routine.</dd>
</dl></div>
</dd>
<dt id="gplately.oceans.point_in_polygon_routine"><code class="name flex">
<span>def <span class="ident">point_in_polygon_routine</span></span>(<span>multi_point, COB_polygons)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform Plate Tectonic Tools' point in polygon routine to partition
points in a <code>multi_point</code> MultiPointOnSphere feature based on whether
they are inside or outside the polygons in <code>COB_polygons</code>.</p>
<h2 id="notes">Notes</h2>
<p>Assuming the <code>COB_polygons</code> have passed through <code><a title="gplately.oceans.ensure_polygon_geometry" href="#gplately.oceans.ensure_polygon_geometry">ensure_polygon_geometry()</a></code>,
each polygon should have a plate ID assigned to it.</p>
<p>This PIP routine serves two purposes for <code><a title="gplately.oceans.SeafloorGrid" href="#gplately.oceans.SeafloorGrid">SeafloorGrid</a></code>:</p>
<p>1) It identifies continental regions in the icosahedral global mesh
MultiPointOnSphere feature and 'erases' in-continent oceanic points
for the construction of a continental mask at each timestep;</p>
<p>2) It identifies oceanic points in the icosahedral global mesh.
These points will be passed to a function that calculates each point's
proximity to its nearest MOR segment (if any) within the polygonal domain
of its allocated plate ID. Each distance is divided by half the
<code>initial_ocean_mean_spreading_rate</code> (an attribute of <code>SeafloorGrids</code>) to
determine a simplified seafloor age for each point.</p>
<p>Number 2) only happens once at the start of the gridding process to
momentarily fill the gridding region with initial ocean points that have
set ages (albeit not from a plate model file). After multiple time steps
of reconstruction, the ocean basin will be filled with new points (with
plate-model prescribed ages) that emerge from ridge topologies.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pygplates.MultiPointOnSphere(points_in_arr) : instance &lt;pygplates.MultiPointOnSphere&gt;</code></dt>
<dd>Point features that are within COB terrane polygons.</dd>
<dt><code>pygplates.MultiPointOnSphere(points_out_arr) : instance &lt;pygplates.MultiPointOnSphere&gt;</code></dt>
<dd>Point features that are outside COB terrane polygons.</dd>
<dt><strong><code>zvals</code></strong> :&ensp;<code>list</code></dt>
<dd>A binary list. If an entry is == 0, its corresponing point in the
MultiPointOnSphere object is on the ocean. If == 1, the point is
in the COB terrane polygon.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.oceans.SeafloorGrid"><code class="flex name class">
<span>class <span class="ident">SeafloorGrid</span></span>
<span>(</span><span>PlateReconstruction_object, PlotTopologies_object, max_time: Union[float, int], min_time: Union[float, int], ridge_time_step: Union[float, int], save_directory: Union[str, pathlib.Path] = 'seafloor-grid-output', file_collection: str = '', refinement_levels: int = 5, ridge_sampling: float = 0.5, extent: Tuple[float] = (-180, 180, -90, 90), grid_spacing: float = 0.1, subduction_collision_parameters=(5.0, 10.0), initial_ocean_mean_spreading_rate: float = 75.0, resume_from_checkpoints=False, zval_names: List[str] = ['SPREADING_RATE'], continent_mask_filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to generate grids that track data atop global ocean basin points
(which emerge from mid ocean ridges) through geological time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>PlateReconstruction_object</code></strong> :&ensp;<code>instance</code> of <code>&lt;gplately.PlateReconstruction&gt;</code></dt>
<dd>A GPlately PlateReconstruction object with a <pygplates.RotationModel> and
a <pygplates.FeatureCollection> containing topology features.</dd>
<dt><strong><code>PlotTopologies_object</code></strong> :&ensp;<code>instance</code> of <code>&lt;gplately.PlotTopologies&gt;</code></dt>
<dd>A GPlately PlotTopologies object with a continental polygon or COB terrane
polygon file to mask grids with.</dd>
<dt><strong><code>max_time</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum time for age gridding.</dd>
<dt><strong><code>min_time</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum time for age gridding.</dd>
<dt><strong><code>ridge_time_step</code></strong> :&ensp;<code>float</code></dt>
<dd>The delta time for resolving ridges (and thus age gridding).</dd>
<dt><strong><code>save_directory</code></strong> :&ensp;<code>str</code>, default <code>None'</code></dt>
<dd>The top-level directory to save all outputs to.</dd>
<dt><strong><code>file_collection</code></strong> :&ensp;<code>str</code>, default <code>""</code></dt>
<dd>A string to identify the plate model used (will be automated later).</dd>
<dt><strong><code>refinement_levels</code></strong> :&ensp;<code>int</code>, default <code>5</code></dt>
<dd>Control the number of points in the icosahedral mesh (higher integer
means higher resolution of continent masks).</dd>
<dt><strong><code>ridge_sampling</code></strong> :&ensp;<code>float</code>, default <code>0.5</code></dt>
<dd>Spatial resolution (in degrees) at which points that emerge from ridges are tessellated.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>tuple</code> of <code>float</code>, default <code>(-180.,180.,-90.,90.)</code></dt>
<dd>A tuple containing the mininum longitude, maximum longitude, minimum latitude and
maximum latitude extents for all masking and final grids.</dd>
<dt><strong><code>grid_spacing</code></strong> :&ensp;<code>float</code>, default <code>0.1</code></dt>
<dd>The degree spacing/interval with which to space grid points across all masking and
final grids. If <code>grid_spacing</code> is provided, all grids will use it. If not,
<code>grid_spacing</code> defaults to 0.1.</dd>
<dt><strong><code>subduction_collision_parameters</code></strong> :&ensp;<code>len-2 tuple</code> of <code>float</code>, default <code>(5.0, 10.0)</code></dt>
<dd>A 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my)</dd>
<dt>initial_ocean_mean_spreading_rate : float, default 75.</dt>
<dt>A spreading rate to uniformly allocate to points that define the initial ocean</dt>
<dt>basin. These points will have inaccurate ages, but most of them will be phased</dt>
<dt>out after points with plate-model prescribed ages emerge from ridges and spread</dt>
<dt>to push them towards collision boundaries (where they are deleted).</dt>
<dt><strong><code>resume_from_checkpoints</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to <code>True</code>, and the gridding preparation stage (continental masking and/or
ridge seed building) is interrupted, SeafloorGrids will resume gridding preparation
from the last successful preparation time.
If set to <code>False</code>, SeafloorGrids will automatically overwrite all files in
<code>save_directory</code> if re-run after interruption, or normally re-run, thus beginning
gridding preparation from scratch. <code>False</code> will be useful if data allocated to the
MOR seed points need to be augmented.</dd>
<dt><strong><code>zval_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list containing string labels for the z values to attribute to points.
Will be used as column headers for z value point dataframes.</dd>
<dt><strong><code>continent_mask_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>An optional parameter pointing to the full path to a continental mask for each timestep.
Assuming the time is in the filename, i.e. "/path/to/continent_mask_0Ma.nc", it should be
passed as "/path/to/continent_mask_{}Ma.nc" with curly brackets. Include decimal formatting if needed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SeafloorGrid(object):
    &#34;&#34;&#34;A class to generate grids that track data atop global ocean basin points
    (which emerge from mid ocean ridges) through geological time.

    Parameters
    ----------
    PlateReconstruction_object : instance of &lt;gplately.PlateReconstruction&gt;
        A GPlately PlateReconstruction object with a &lt;pygplates.RotationModel&gt; and
        a &lt;pygplates.FeatureCollection&gt; containing topology features.
    PlotTopologies_object : instance of &lt;gplately.PlotTopologies&gt;
        A GPlately PlotTopologies object with a continental polygon or COB terrane
        polygon file to mask grids with.
    max_time : float
        The maximum time for age gridding.
    min_time : float
        The minimum time for age gridding.
    ridge_time_step : float
        The delta time for resolving ridges (and thus age gridding).
    save_directory : str, default None&#39;
        The top-level directory to save all outputs to.
    file_collection : str, default &#34;&#34;
        A string to identify the plate model used (will be automated later).
    refinement_levels : int, default 5
        Control the number of points in the icosahedral mesh (higher integer
        means higher resolution of continent masks).
    ridge_sampling : float, default 0.5
        Spatial resolution (in degrees) at which points that emerge from ridges are tessellated.
    extent : tuple of float, default (-180.,180.,-90.,90.)
        A tuple containing the mininum longitude, maximum longitude, minimum latitude and
        maximum latitude extents for all masking and final grids.
    grid_spacing : float, default 0.1
        The degree spacing/interval with which to space grid points across all masking and
        final grids. If `grid_spacing` is provided, all grids will use it. If not,
        `grid_spacing` defaults to 0.1.
    subduction_collision_parameters : len-2 tuple of float, default (5.0, 10.0)
        A 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my)
    initial_ocean_mean_spreading_rate : float, default 75.
        A spreading rate to uniformly allocate to points that define the initial ocean
        basin. These points will have inaccurate ages, but most of them will be phased
        out after points with plate-model prescribed ages emerge from ridges and spread
        to push them towards collision boundaries (where they are deleted).
    resume_from_checkpoints : bool, default False
        If set to `True`, and the gridding preparation stage (continental masking and/or
        ridge seed building) is interrupted, SeafloorGrids will resume gridding preparation
        from the last successful preparation time.
        If set to `False`, SeafloorGrids will automatically overwrite all files in
        `save_directory` if re-run after interruption, or normally re-run, thus beginning
        gridding preparation from scratch. `False` will be useful if data allocated to the
        MOR seed points need to be augmented.
    zval_names : list of str
        A list containing string labels for the z values to attribute to points.
        Will be used as column headers for z value point dataframes.
    continent_mask_filename : str
        An optional parameter pointing to the full path to a continental mask for each timestep.
        Assuming the time is in the filename, i.e. &#34;/path/to/continent_mask_0Ma.nc&#34;, it should be
        passed as &#34;/path/to/continent_mask_{}Ma.nc&#34; with curly brackets. Include decimal formatting if needed.
    &#34;&#34;&#34;

    def __init__(
        self,
        PlateReconstruction_object,
        PlotTopologies_object,
        max_time: Union[float, int],
        min_time: Union[float, int],
        ridge_time_step: Union[float, int],
        save_directory: Union[str, Path] = &#34;seafloor-grid-output&#34;,
        file_collection: str = &#34;&#34;,
        refinement_levels: int = 5,
        ridge_sampling: float = 0.5,
        extent: Tuple[float] = (-180, 180, -90, 90),
        grid_spacing: float = 0.1,
        subduction_collision_parameters=(5.0, 10.0),
        initial_ocean_mean_spreading_rate: float = 75.0,
        resume_from_checkpoints=False,
        zval_names: List[str] = [&#34;SPREADING_RATE&#34;],
        continent_mask_filename=None,
    ):

        # Provides a rotation model, topology features and reconstruction time for the SeafloorGrid
        self.PlateReconstruction_object = PlateReconstruction_object
        self.rotation_model = self.PlateReconstruction_object.rotation_model
        self.topology_features = self.PlateReconstruction_object.topology_features
        self._PlotTopologies_object = PlotTopologies_object
        self.topological_model = pygplates.TopologicalModel(
            self.topology_features, self.rotation_model
        )

        self.file_collection = file_collection

        if continent_mask_filename:
            # Filename for continental masks that the user can provide instead of building it here
            self.continent_mask_filepath = continent_mask_filename
            self.continent_mask_is_provided = True
        else:
            self.continent_mask_is_provided = False

        self._setup_output_paths(save_directory)

        # Topological parameters
        self.refinement_levels = refinement_levels
        self.ridge_sampling = ridge_sampling
        self.subduction_collision_parameters = subduction_collision_parameters
        self.initial_ocean_mean_spreading_rate = initial_ocean_mean_spreading_rate

        # Gridding parameters
        self.extent = extent

        self._set_grid_resolution(grid_spacing)

        self.resume_from_checkpoints = resume_from_checkpoints

        # Temporal parameters
        self._max_time = max_time
        self._min_time = min_time
        self._ridge_time_step = ridge_time_step
        self._times = np.arange(
            self._max_time, self._min_time - 0.1, -self._ridge_time_step
        )

        # ensure the time for continental masking is consistent.
        self._PlotTopologies_object.time = self._max_time

        # Essential features and meshes for the SeafloorGrid
        self.continental_polygons = ensure_polygon_geometry(
            self._PlotTopologies_object.continents, self.rotation_model, self._max_time
        )
        self._PlotTopologies_object.continents = PlotTopologies_object.continents
        (
            self.icosahedral_multi_point,
            self.icosahedral_global_mesh,
        ) = create_icosahedral_mesh(self.refinement_levels)

        # Z value parameters
        self.zval_names = zval_names
        self.default_column_headers = [
            &#34;CURRENT_LONGITUDES&#34;,
            &#34;CURRENT_LATITUDES&#34;,
            &#34;SEAFLOOR_AGE&#34;,
            &#34;BIRTH_LAT_SNAPSHOT&#34;,
            &#34;POINT_ID_SNAPSHOT&#34;,
        ]
        self.total_column_headers = self.default_column_headers + self.zval_names

    def _map_res_to_node_percentage(self, continent_mask_filename):
        &#34;&#34;&#34;Determine which percentage to use to scale the continent mask resolution at max time&#34;&#34;&#34;
        maskY, maskX = grids.read_netcdf_grid(
            continent_mask_filename.format(self._max_time)
        ).shape

        mask_deg = _pixels2deg(maskX, self.extent[0], self.extent[1])

        if mask_deg &lt;= 0.1:
            percentage = 0.1
        elif mask_deg &lt;= 0.25:
            percentage = 0.3
        elif mask_deg &lt;= 0.5:
            percentage = 0.5
        elif mask_deg &lt; 0.75:
            percentage = 0.6
        elif mask_deg &gt;= 1:
            percentage = 0.75
        return mask_deg, percentage

    def _setup_output_paths(self, save_directory):
        &#34;&#34;&#34;create various folders for output files&#34;&#34;&#34;
        self.save_directory = Path(save_directory)

        # zvalue files
        self.zvalues_directory = os.path.join(self.save_directory, &#34;zvalues&#34;)
        Path(self.zvalues_directory).mkdir(parents=True, exist_ok=True)
        zvalues_file_basename = &#34;point_data_dataframe_{:0.2f}Ma.npz&#34;
        if self.file_collection:
            zvalues_file_basename = self.file_collection + &#34;_&#34; + zvalues_file_basename
        self.zvalues_file_basepath = os.path.join(
            self.zvalues_directory, zvalues_file_basename
        )

        # middle ocean ridge files
        self.mid_ocean_ridges_dir = os.path.join(
            self.save_directory, &#34;middle_ocean_ridges&#34;
        )
        Path(self.mid_ocean_ridges_dir).mkdir(parents=True, exist_ok=True)
        if self.file_collection:
            self.mid_ocean_ridges_file_path = os.path.join(
                self.mid_ocean_ridges_dir,
                self.file_collection + &#34;_&#34; + MOR_PKL_FILE_NAME,
            )
        else:
            self.mid_ocean_ridges_file_path = os.path.join(
                self.mid_ocean_ridges_dir, MOR_PKL_FILE_NAME
            )

        # continent mask files
        # only generate continent mask files if user does not provide them
        if not self.continent_mask_is_provided:
            self.continent_mask_directory = os.path.join(
                self.save_directory, &#34;continent_mask&#34;
            )
            Path(self.continent_mask_directory).mkdir(parents=True, exist_ok=True)
            continent_mask_file_basename = &#34;continent_mask_{:0.2f}Ma.nc&#34;
            if self.file_collection:
                continent_mask_file_basename = (
                    self.file_collection + &#34;_&#34; + continent_mask_file_basename
                )
            self.continent_mask_filepath = os.path.join(
                self.continent_mask_directory, continent_mask_file_basename
            )

        # sample points files
        self.sample_points_dir = os.path.join(self.save_directory, &#34;sample_points&#34;)
        Path(self.sample_points_dir).mkdir(parents=True, exist_ok=True)
        if self.file_collection:
            self.sample_points_file_path = os.path.join(
                self.sample_points_dir,
                self.file_collection + &#34;_&#34; + SAMPLE_POINTS_PKL_FILE_NAME,
            )

        else:
            self.sample_points_file_path = os.path.join(
                self.sample_points_dir, SAMPLE_POINTS_PKL_FILE_NAME
            )

        # gridding input files
        self.gridding_input_directory = os.path.join(
            self.save_directory, &#34;gridding_input&#34;
        )
        Path(self.gridding_input_directory).mkdir(parents=True, exist_ok=True)
        gridding_input_basename = &#34;gridding_input_{:0.2f}Ma.npz&#34;
        if self.file_collection:
            gridding_input_basename = (
                self.file_collection + &#34;_&#34; + gridding_input_basename
            )
        self.gridding_input_filepath = os.path.join(
            self.gridding_input_directory, gridding_input_basename
        )

    def _set_grid_resolution(self, grid_spacing=0.1):
        &#34;&#34;&#34;determine the output grid resolution&#34;&#34;&#34;
        if not grid_spacing:
            grid_spacing = 0.1
        # A list of degree spacings that allow an even division of the global lat-lon extent.
        divisible_degree_spacings = [0.1, 0.25, 0.5, 0.75, 1.0]

        # If the provided degree spacing is in the list of permissible spacings, use it
        # and prepare the number of pixels in x and y (spacingX and spacingY)
        if grid_spacing in divisible_degree_spacings:
            self.grid_spacing = grid_spacing
            self.spacingX = _deg2pixels(grid_spacing, self.extent[0], self.extent[1])
            self.spacingY = _deg2pixels(grid_spacing, self.extent[2], self.extent[3])

        # If the provided spacing is &gt;&gt;1 degree, use 1 degree
        elif grid_spacing &gt;= divisible_degree_spacings[-1]:
            self.grid_spacing = divisible_degree_spacings[-1]
            self.spacingX = _deg2pixels(
                divisible_degree_spacings[-1], self.extent[0], self.extent[1]
            )
            self.spacingY = _deg2pixels(
                divisible_degree_spacings[-1], self.extent[2], self.extent[3]
            )

            with warnings.catch_warnings():
                warnings.simplefilter(&#34;always&#34;)
                warnings.warn(
                    f&#34;The provided grid_spacing of {grid_spacing} is quite large. To preserve the grid resolution, a {self.grid_spacing} degree spacing has been employed instead.&#34;
                )

        # If the provided degree spacing is not in the list of permissible spacings, but below
        # a degree, find the closest permissible degree spacing. Use this and find
        # spacingX and spacingY.
        else:
            for divisible_degree_spacing in divisible_degree_spacings:
                # The tolerance is half the difference between consecutive divisible spacings.
                # Max is 1 degree for now - other integers work but may provide too little of a
                # grid resolution.
                if abs(grid_spacing - divisible_degree_spacing) &lt;= 0.125:
                    new_deg_res = divisible_degree_spacing
                    self.grid_spacing = new_deg_res
                    self.spacingX = _deg2pixels(
                        new_deg_res, self.extent[0], self.extent[1]
                    )
                    self.spacingY = _deg2pixels(
                        new_deg_res, self.extent[2], self.extent[3]
                    )

            with warnings.catch_warnings():
                warnings.simplefilter(&#34;always&#34;)
                warnings.warn(
                    f&#34;The provided grid_spacing of {grid_spacing} does not cleanly divide into the global extent. A degree spacing of {self.grid_spacing} has been employed instead.&#34;
                )

    # Allow SeafloorGrid time to be updated, and to update the internally-used
    # PlotTopologies&#39; time attribute too. If PlotTopologies is used outside the
    # object, its `time` attribute is not updated.
    @property
    def max_time(self):
        &#34;&#34;&#34;The reconstruction time.&#34;&#34;&#34;
        return self._max_time

    @property
    def PlotTopologiesTime(self):
        return self._PlotTopologies_object.time

    @max_time.setter
    def max_time(self, var):
        if var &gt;= 0:
            self.update_time(var)
        else:
            raise ValueError(&#34;Enter a valid time &gt;= 0&#34;)

    def update_time(self, max_time):
        self._max_time = float(max_time)
        self._PlotTopologies_object.time = float(max_time)

    def _collect_point_data_in_dataframe(self, feature_collection, zval_ndarray, time):
        &#34;&#34;&#34;At a given timestep, create a pandas dataframe holding all attributes of point features.

        Rather than store z values as shapefile attributes, store them in a dataframe indexed by feature ID.
        &#34;&#34;&#34;
        return _collect_point_data_in_dataframe(
            self.zvalues_file_basepath,
            feature_collection,
            self.zval_names,
            zval_ndarray,
            time,
        )

    def _generate_ocean_points(self):
        &#34;&#34;&#34;generate ocean points by using the icosahedral mesh&#34;&#34;&#34;
        # Ensure COB terranes at max time have reconstruction IDs and valid times
        COB_polygons = ensure_polygon_geometry(
            self._PlotTopologies_object.continents,
            self.rotation_model,
            self._max_time,
        )

        # zval is a binary array encoding whether a point
        # coordinate is within a COB terrane polygon or not.
        # Use the icosahedral mesh MultiPointOnSphere attribute
        _, ocean_basin_point_mesh, zvals = point_in_polygon_routine(
            self.icosahedral_multi_point, COB_polygons
        )

        # Plates to partition with
        plate_partitioner = pygplates.PlatePartitioner(
            COB_polygons,
            self.rotation_model,
        )

        # Plate partition the ocean basin points
        meshnode_feature = pygplates.Feature(
            pygplates.FeatureType.create_from_qualified_string(&#34;gpml:MeshNode&#34;)
        )
        meshnode_feature.set_geometry(
            ocean_basin_point_mesh
            # multi_point
        )
        ocean_basin_meshnode = pygplates.FeatureCollection(meshnode_feature)

        paleogeography = plate_partitioner.partition_features(
            ocean_basin_meshnode,
            partition_return=pygplates.PartitionReturn.separate_partitioned_and_unpartitioned,
            properties_to_copy=[pygplates.PropertyName.gpml_shapefile_attributes],
        )
        return paleogeography[1]  # points in oceans

    def _get_ocean_points_from_continent_mask(self):
        &#34;&#34;&#34;get the ocean points from continent mask grid&#34;&#34;&#34;
        max_time_cont_mask = grids.Raster(
            self.continent_mask_filepath.format(self._max_time)
        )
        # If the user provides a continental mask filename, we need to downsize the mask
        # resolution for when we create the initial ocean mesh. The mesh does not need to be high-res.
        # If the input grid is at 0.5 degree uniform spacing, then the input
        # grid is 7x more populated than a 6-level stripy icosahedral mesh and
        # using this resolution for the initial ocean mesh will dramatically slow down reconstruction by topologies.
        # Scale down the resolution based on the input mask resolution
        _, percentage = self._map_res_to_node_percentage(self.continent_mask_filepath)
        max_time_cont_mask.resize(
            int(max_time_cont_mask.shape[0] * percentage),
            int(max_time_cont_mask.shape[1] * percentage),
            inplace=True,
        )

        lat = np.linspace(-90, 90, max_time_cont_mask.shape[0])
        lon = np.linspace(-180, 180, max_time_cont_mask.shape[1])

        llon, llat = np.meshgrid(lon, lat)

        mask_inds = np.where(max_time_cont_mask.data.flatten() == 0)
        mask_vals = max_time_cont_mask.data.flatten()
        mask_lon = llon.flatten()[mask_inds]
        mask_lat = llat.flatten()[mask_inds]

        ocean_pt_feature = pygplates.Feature()
        ocean_pt_feature.set_geometry(
            pygplates.MultiPointOnSphere(zip(mask_lat, mask_lon))
        )
        return [ocean_pt_feature]

    def create_initial_ocean_seed_points(self):
        &#34;&#34;&#34;Create the initial ocean basin seed point domain (at `max_time` only)
        using Stripy&#39;s icosahedral triangulation with the specified `self.refinement_levels`.

        The ocean mesh starts off as a global-spanning Stripy icosahedral mesh.
        `create_initial_ocean_seed_points` passes the automatically-resolved-to-current-time
        continental polygons from the `PlotTopologies_object`&#39;s `continents` attribute
        (which can be from a COB terrane file or a continental polygon file) into
        Plate Tectonic Tools&#39; point-in-polygon routine. It identifies ocean basin points that lie:
        * outside the polygons (for the ocean basin point domain)
        * inside the polygons (for the continental mask)

        Points from the mesh outside the continental polygons make up the ocean basin seed
        point mesh. The masked mesh is outputted as a compressed GPML (GPMLZ) file with
        the filename: &#34;ocean_basin_seed_points_{}Ma.gpmlz&#34; if a `save_directory` is passed.
        Otherwise, the mesh is returned as a pyGPlates FeatureCollection object.

        Notes
        -----
        This point mesh represents ocean basin seafloor that was produced
        before `SeafloorGrid.max_time`, and thus has unknown properties like valid
        time and spreading rate. As time passes, the plate reconstruction model sees
        points emerging from MORs. These new points spread to occupy the ocean basins,
        moving the initial filler points closer to subduction zones and continental
        polygons with which they can collide. If a collision is detected by
        `PlateReconstruction`s `ReconstructByTopologies` object, these points are deleted.

        Ideally, if a reconstruction tree spans a large time range, **all** initial mesh
        points would collide with a continent or be subducted, leaving behind a mesh of
        well-defined MOR-emerged ocean basin points that data can be attributed to.
        However, some of these initial points situated close to contiental boundaries are
        retained through time - these form point artefacts with anomalously high ages. Even
        deep-time plate models (e.g. 1 Ga) will have these artefacts - removing them would
        require more detail to be added to the reconstruction model.

        Returns
        -------
        ocean_basin_point_mesh : pygplates.FeatureCollection
            A feature collection of pygplates.PointOnSphere objects on the ocean basin.
        &#34;&#34;&#34;

        if (
            os.path.isfile(self.continent_mask_filepath.format(self._max_time))
            and self.continent_mask_is_provided
        ):
            # If a set of continent masks was passed, we can use max_time&#39;s continental
            # mask to build the initial profile of seafloor age.
            ocean_points = self._get_ocean_points_from_continent_mask()
        else:
            ocean_points = self._generate_ocean_points()

        # Now that we have ocean points...
        # Determine age of ocean basin points using their proximity to MOR features
        # and an assumed globally-uniform ocean basin mean spreading rate.
        # We need resolved topologies at the `max_time` to pass into the proximity function
        resolved_topologies = []
        shared_boundary_sections = []
        pygplates.resolve_topologies(
            self.topology_features,
            self.rotation_model,
            resolved_topologies,
            self._max_time,
            shared_boundary_sections,
        )
        pX, pY, pZ = tools.find_distance_to_nearest_ridge(
            resolved_topologies,
            shared_boundary_sections,
            ocean_points,
        )

        # Divide spreading rate by 2 to use half the mean spreading rate
        pAge = np.array(pZ) / (self.initial_ocean_mean_spreading_rate / 2.0)

        self._update_current_active_points(
            pX,
            pY,
            pAge + self._max_time,
            [0] * len(pX),
            [self.initial_ocean_mean_spreading_rate] * len(pX),
        )
        self.initial_ocean_point_df = self.current_active_points_df

        # the code below is for debug purpose only
        if get_debug_level() &gt; 100:
            initial_ocean_point_features = []
            for point in zip(pX, pY, pAge):
                point_feature = pygplates.Feature()
                point_feature.set_geometry(pygplates.PointOnSphere(point[1], point[0]))

                # Add &#39;time&#39; to the age at the time of computation, to get the valid time in Ma
                point_feature.set_valid_time(point[2] + self._max_time, -1)

                # For now: custom zvals are added as shapefile attributes - will attempt pandas data frames
                # point_feature = set_shapefile_attribute(point_feature, self.initial_ocean_mean_spreading_rate, &#34;SPREADING_RATE&#34;)  # Seems like static data
                initial_ocean_point_features.append(point_feature)

            basename = &#34;ocean_basin_seed_points_{}_RLs_{}Ma.gpmlz&#34;.format(
                self.refinement_levels,
                self._max_time,
            )
            if self.file_collection:
                basename = &#34;{}_{}&#34;.format(self.file_collection, basename)
            initial_ocean_feature_collection = pygplates.FeatureCollection(
                initial_ocean_point_features
            )
            initial_ocean_feature_collection.write(
                os.path.join(self.save_directory, basename)
            )

            # save the zvalue(spreading rate) of the initial ocean points to file &#34;point_data_dataframe_{max_time}Ma.npz&#34;
            self._collect_point_data_in_dataframe(
                initial_ocean_feature_collection,
                np.array(
                    [self.initial_ocean_mean_spreading_rate] * len(pX)
                ),  # for now, spreading rate is one zvalue for initial ocean points. will other zvalues need to have a generalised workflow?
                self._max_time,
            )

    def build_all_MOR_seedpoints(self):
        &#34;&#34;&#34;Resolve mid-ocean ridges for all times between `min_time` and `max_time`, divide them
        into points that make up their shared sub-segments. Rotate these points to the left
        and right of the ridge using their stage rotation so that they spread from the ridge.

        Z-value allocation to each point is done here. In future, a function (like
        the spreading rate function) to calculate general z-data will be an input parameter.

        Notes
        -----
        If MOR seed point building is interrupted, progress is safeguarded as long as
        `resume_from_checkpoints` is set to `True`.

        This assumes that points spread from ridges symmetrically, with the exception of
        large ridge jumps at successive timesteps. Therefore, z-values allocated to ridge-emerging
        points will appear symmetrical until changes in spreading ridge geometries create
        asymmetries.

        In future, this will have a checkpoint save feature so that execution
        (which occurs during preparation for ReconstructByTopologies and can take several hours)
        can be safeguarded against run interruptions.

        References
        ----------
        get_mid_ocean_ridge_seedpoints() has been adapted from
        https://github.com/siwill22/agegrid-0.1/blob/master/automatic_age_grid_seeding.py#L117.
        &#34;&#34;&#34;
        overwrite = True
        if self.resume_from_checkpoints:
            overwrite = False

        try:
            num_cpus = multiprocessing.cpu_count() - 1
        except NotImplementedError:
            num_cpus = 1

        if num_cpus &gt; 1:
            with multiprocessing.Pool(num_cpus) as pool:
                pool.map(
                    partial(
                        _generate_mid_ocean_ridge_points,
                        delta_time=self._ridge_time_step,
                        mid_ocean_ridges_file_path=self.mid_ocean_ridges_file_path,
                        rotation_model=self.rotation_model,
                        topology_features=self.topology_features,
                        zvalues_file_basepath=self.zvalues_file_basepath,
                        zval_names=self.zval_names,
                        ridge_sampling=self.ridge_sampling,
                        overwrite=overwrite,
                    ),
                    self._times[1:],
                )
        else:
            for time in self._times[1:]:
                _generate_mid_ocean_ridge_points(
                    time,
                    self.mid_ocean_ridges_file_path,
                    self.rotation_model,
                    self.topology_features,
                    self.zvalues_file_basepath,
                    self.zval_names,
                    overwrite=overwrite,
                )

    def _create_continental_mask(self, time_array):
        &#34;&#34;&#34;Create a continental mask for each timestep.&#34;&#34;&#34;
        if time_array[0] != self._max_time:
            print(
                &#34;Masking interrupted - resuming continental mask building at {} Ma!&#34;.format(
                    time_array[0]
                )
            )

        for time in time_array:
            mask_fn = self.continent_mask_filepath.format(time)
            if os.path.isfile(mask_fn):
                logger.info(
                    f&#34;Continent mask file exists and will not create again.\n{mask_fn}&#34;
                )
                continue

            self._PlotTopologies_object.time = time
            geoms = self._PlotTopologies_object.continents
            final_grid = grids.rasterise(
                geoms,
                key=1.0,
                shape=(self.spacingY, self.spacingX),
                extent=self.extent,
                origin=&#34;lower&#34;,
            )
            final_grid[np.isnan(final_grid)] = 0.0

            grids.write_netcdf_grid(
                self.continent_mask_filepath.format(time),
                final_grid.astype(&#34;i1&#34;),
                extent=[-180, 180, -90, 90],
                fill_value=None,
            )
            logger.info(f&#34;Finished building a continental mask at {time} Ma!&#34;)

        return

    def _build_continental_mask(self, time: float, overwrite=False):
        &#34;&#34;&#34;Create a continental mask for a given time.&#34;&#34;&#34;
        mask_fn = self.continent_mask_filepath.format(time)
        if os.path.isfile(mask_fn) and not overwrite:
            logger.info(
                f&#34;Continent mask file exists and will not create again.\n{mask_fn}&#34;
            )
            return

        self._PlotTopologies_object.time = time
        final_grid = grids.rasterise(
            self._PlotTopologies_object.continents,
            key=1.0,
            shape=(self.spacingY, self.spacingX),
            extent=self.extent,
            origin=&#34;lower&#34;,
        )
        final_grid[np.isnan(final_grid)] = 0.0

        grids.write_netcdf_grid(
            self.continent_mask_filepath.format(time),
            final_grid.astype(&#34;i1&#34;),
            extent=[-180, 180, -90, 90],
            fill_value=None,
        )
        logger.info(f&#34;Finished building a continental mask at {time} Ma!&#34;)

    def build_all_continental_masks(self, use_continent_contouring=True):
        &#34;&#34;&#34;Create a continental mask to define the ocean basin for all times between `min_time` and `max_time`.

        Notes
        -----
        Continental masking progress is safeguarded if ever masking is interrupted,
        provided that `resume_from_checkpoints` is set to `True`.

        The continental masks will be saved to f&#34;continent_mask_{time}Ma.nc&#34; as compressed netCDF4 files.
        &#34;&#34;&#34;
        if not self.continent_mask_is_provided:
            overwrite = True
            if self.resume_from_checkpoints:
                overwrite = False
            if use_continent_contouring:
                try:
                    num_cpus = multiprocessing.cpu_count() - 1
                except NotImplementedError:
                    num_cpus = 1

                if num_cpus &gt; 1:
                    with multiprocessing.Pool(num_cpus) as pool:
                        pool.map(
                            partial(
                                _build_continental_mask_with_contouring,
                                continent_mask_filepath=self.continent_mask_filepath,
                                rotation_model=self.rotation_model,
                                continent_features=self._PlotTopologies_object._continents,
                                overwrite=overwrite,
                            ),
                            self._times,
                        )
                else:
                    for time in self._times:
                        self._build_continental_mask_with_contouring(time, overwrite)
            else:
                for time in self._times:
                    self._build_continental_mask(time, overwrite)

    def _extract_zvalues_from_npz_to_ndarray(self, featurecollection, time):
        # NPZ file of seedpoint z values that emerged at this time
        loaded_npz = np.load(self.zvalues_file_basepath.format(time))

        curr_zvalues = np.empty([len(featurecollection), len(self.zval_names)])
        for i in range(len(self.zval_names)):
            # Account for the 0th index being for point feature IDs
            curr_zvalues[:, i] = np.array(loaded_npz[&#34;arr_{}&#34;.format(i)])

        return curr_zvalues

    def prepare_for_reconstruction_by_topologies(self):
        &#34;&#34;&#34;Prepare three main auxiliary files for seafloor data gridding:
        * Initial ocean seed points (at `max_time`)
        * Continental masks (from `max_time` to `min_time`)
        * MOR points (from `max_time` to `min_time`)

        Returns lists of all attributes for the initial ocean point mesh and
        all ridge points for all times in the reconstruction time array.
        &#34;&#34;&#34;

        # INITIAL OCEAN SEED POINT MESH ----------------------------------------------------
        self.create_initial_ocean_seed_points()
        logger.info(&#34;Finished building initial_ocean_seed_points!&#34;)

        # MOR SEED POINTS AND CONTINENTAL MASKS --------------------------------------------

        # The start time for seeding is controlled by whether the overwrite_existing_gridding_inputs
        # parameter is set to `True` (in which case the start time is `max_time`). If it is `False`
        # and;
        # - a run of seeding and continental masking was interrupted, and ridge points were
        # checkpointed at n Ma, seeding resumes at n-1 Ma until `min_time` or another interruption
        # occurs;
        # - seeding was completed but the subsequent gridding input creation was interrupted,
        # seeding is assumed completed and skipped. The workflow automatically proceeds to re-gridding.

        self.build_all_continental_masks()

        self.build_all_MOR_seedpoints()

        # load the initial ocean seed points
        lons = self.initial_ocean_point_df[&#34;lon&#34;].tolist()
        lats = self.initial_ocean_point_df[&#34;lat&#34;].tolist()
        active_points = [
            pygplates.PointOnSphere(lat, lon) for lon, lat in zip(lons, lats)
        ]
        appearance_time = self.initial_ocean_point_df[&#34;begin_time&#34;].tolist()
        birth_lat = lats
        prev_lat = lats
        prev_lon = lons
        zvalues = np.empty((0, len(self.zval_names)))
        zvalues = np.concatenate(
            (
                zvalues,
                self.initial_ocean_point_df[&#34;SPREADING_RATE&#34;].to_numpy()[..., None],
            ),
            axis=0,
        )

        for time in self._times[1:]:
            # load MOR points for each time step
            df = pd.read_pickle(self.mid_ocean_ridges_file_path.format(time))
            lons = df[&#34;lon&#34;].tolist()
            lats = df[&#34;lat&#34;].tolist()
            active_points += [
                pygplates.PointOnSphere(lat, lon) for lon, lat in zip(lons, lats)
            ]
            appearance_time += [time] * len(lons)
            birth_lat += lats
            prev_lat += lats
            prev_lon += lons

            zvalues = np.concatenate(
                (zvalues, df[self.zval_names[0]].to_numpy()[..., None]), axis=0
            )

        return active_points, appearance_time, birth_lat, prev_lat, prev_lon, zvalues

    def _update_current_active_points(
        self, lons, lats, begin_times, end_times, spread_rates, replace=True
    ):
        &#34;&#34;&#34;If the `replace` is true, use the new data to replace self.current_active_points_df.
        Otherwise, append the new data to the end of self.current_active_points_df&#34;&#34;&#34;
        data = {
            &#34;lon&#34;: lons,
            &#34;lat&#34;: lats,
            &#34;begin_time&#34;: begin_times,
            &#34;end_time&#34;: end_times,
            &#34;SPREADING_RATE&#34;: spread_rates,
        }
        if replace:
            self.current_active_points_df = pd.DataFrame(data=data)
        else:
            self.current_active_points_df = pd.concat(
                [
                    self.current_active_points_df,
                    pd.DataFrame(data=data),
                ],
                ignore_index=True,
            )

    def _update_current_active_points_coordinates(
        self, reconstructed_points: List[pygplates.PointOnSphere]
    ):
        &#34;&#34;&#34;Update the current active points with the reconstructed coordinates.
        The length of `reconstructed_points` must be the same with the length of self.current_active_points_df
        &#34;&#34;&#34;
        assert len(reconstructed_points) == len(self.current_active_points_df)
        lons = []
        lats = []
        begin_times = []
        end_times = []
        spread_rates = []
        for i in range(len(reconstructed_points)):
            if reconstructed_points[i]:
                lat_lon = reconstructed_points[i].to_lat_lon()
                lons.append(lat_lon[1])
                lats.append(lat_lon[0])
                begin_times.append(self.current_active_points_df.loc[i, &#34;begin_time&#34;])
                end_times.append(self.current_active_points_df.loc[i, &#34;end_time&#34;])
                spread_rates.append(
                    self.current_active_points_df.loc[i, &#34;SPREADING_RATE&#34;]
                )
        self._update_current_active_points(
            lons, lats, begin_times, end_times, spread_rates
        )

    def _remove_continental_points(self, time):
        &#34;&#34;&#34;remove all the points which are inside continents at `time` from self.current_active_points_df&#34;&#34;&#34;
        gridZ, gridX, gridY = grids.read_netcdf_grid(
            self.continent_mask_filepath.format(time), return_grids=True
        )
        ni, nj = gridZ.shape
        xmin = np.nanmin(gridX)
        xmax = np.nanmax(gridX)
        ymin = np.nanmin(gridY)
        ymax = np.nanmax(gridY)

        # TODO
        def remove_points_on_continents(row):
            i = int(round((ni - 1) * ((row.lat - ymin) / (ymax - ymin))))
            j = int(round((nj - 1) * ((row.lon - xmin) / (xmax - xmin))))
            i = 0 if i &lt; 0 else i
            j = 0 if j &lt; 0 else j
            i = ni - 1 if i &gt; ni - 1 else i
            j = nj - 1 if j &gt; nj - 1 else j

            if gridZ[i, j] &gt; 0:
                return False
            else:
                return True

        m = self.current_active_points_df.apply(remove_points_on_continents, axis=1)
        self.current_active_points_df = self.current_active_points_df[m]

    def _load_middle_ocean_ridge_points(self, time):
        &#34;&#34;&#34;add middle ocean ridge points at `time` to current_active_points_df&#34;&#34;&#34;
        df = pd.read_pickle(self.mid_ocean_ridges_file_path.format(time))
        self._update_current_active_points(
            df[&#34;lon&#34;],
            df[&#34;lat&#34;],
            [time] * len(df),
            [0] * len(df),
            df[&#34;SPREADING_RATE&#34;],
            replace=False,
        )

        # obsolete code. keep here for a while. will delete later. -- 2024-05-30
        if 0:
            fc = pygplates.FeatureCollection(
                self.mid_ocean_ridges_file_path.format(time)
            )
            assert len(self.zval_names) &gt; 0
            lons = []
            lats = []
            begin_times = []
            end_times = []
            for feature in fc:
                lat_lon = feature.get_geometry().to_lat_lon()
                valid_time = feature.get_valid_time()
                lons.append(lat_lon[1])
                lats.append(lat_lon[0])
                begin_times.append(valid_time[0])
                end_times.append(valid_time[1])

            curr_zvalues = self._extract_zvalues_from_npz_to_ndarray(fc, time)
            self._update_current_active_points(
                lons, lats, begin_times, end_times, curr_zvalues[:, 0], replace=False
            )

    def _save_gridding_input_data(self, time):
        &#34;&#34;&#34;save the data into file for creating netcdf file later&#34;&#34;&#34;
        data_len = len(self.current_active_points_df[&#34;lon&#34;])
        np.savez_compressed(
            self.gridding_input_filepath.format(time),
            CURRENT_LONGITUDES=self.current_active_points_df[&#34;lon&#34;],
            CURRENT_LATITUDES=self.current_active_points_df[&#34;lat&#34;],
            SEAFLOOR_AGE=self.current_active_points_df[&#34;begin_time&#34;] - time,
            BIRTH_LAT_SNAPSHOT=[0] * data_len,
            POINT_ID_SNAPSHOT=[0] * data_len,
            SPREADING_RATE=self.current_active_points_df[&#34;SPREADING_RATE&#34;],
        )

    def reconstruct_by_topological_model(self):
        &#34;&#34;&#34;Use pygplates TopologicalModel to reconstruct seed points&#34;&#34;&#34;
        self.create_initial_ocean_seed_points()
        logger.info(&#34;Finished building initial_ocean_seed_points!&#34;)

        self.build_all_continental_masks()
        self.build_all_MOR_seedpoints()

        # not necessary, but put here for readability purpose only
        self.current_active_points_df = self.initial_ocean_point_df

        time = int(self._max_time)
        while True:
            self.current_active_points_df.to_pickle(
                self.sample_points_file_path.format(time)
            )
            self._save_gridding_input_data(time)
            # save debug file
            if get_debug_level() &gt; 100:
                _save_seed_points_as_multipoint_coverage(
                    self.current_active_points_df[&#34;lon&#34;],
                    self.current_active_points_df[&#34;lat&#34;],
                    self.current_active_points_df[&#34;begin_time&#34;] - time,
                    time,
                    self.sample_points_dir,
                )
            next_time = time - int(self._ridge_time_step)
            if next_time &gt;= int(self._min_time):
                points = [
                    pygplates.PointOnSphere(row.lat, row.lon)
                    for index, row in self.current_active_points_df.iterrows()
                ]
                # reconstruct_geometry() needs time to be integral value
                # https://www.gplates.org/docs/pygplates/generated/pygplates.topologicalmodel#pygplates.TopologicalModel.reconstruct_geometry
                reconstructed_time_span = self.topological_model.reconstruct_geometry(
                    points,
                    initial_time=time,
                    youngest_time=next_time,
                    time_increment=int(self._ridge_time_step),
                    deactivate_points=pygplates.ReconstructedGeometryTimeSpan.DefaultDeactivatePoints(
                        threshold_velocity_delta=self.subduction_collision_parameters[0]
                        / 10,  # cms/yr
                        threshold_distance_to_boundary=self.subduction_collision_parameters[
                            1
                        ],  # kms/myr
                        deactivate_points_that_fall_outside_a_network=True,
                    ),
                )

                reconstructed_points = reconstructed_time_span.get_geometry_points(
                    next_time, return_inactive_points=True
                )
                logger.info(
                    f&#34;Finished topological reconstruction of {len(self.current_active_points_df)} points from {time} to {next_time} Ma.&#34;
                )
                # update the current activate points to prepare for the reconstruction to &#34;next time&#34;
                self._update_current_active_points_coordinates(reconstructed_points)
                self._remove_continental_points(next_time)
                self._load_middle_ocean_ridge_points(next_time)
                time = next_time
            else:
                break

    def reconstruct_by_topologies(self):
        &#34;&#34;&#34;Obtain all active ocean seed points at `time` - these are
        points that have not been consumed at subduction zones or have not
        collided with continental polygons.

        All active points&#39; latitudes, longitues, seafloor ages, spreading rates and all
        other general z-values are saved to a gridding input file (.npz).
        &#34;&#34;&#34;
        logger.info(&#34;Preparing all initial files...&#34;)

        # Obtain all info from the ocean seed points and all MOR points through time, store in
        # arrays
        (
            active_points,
            appearance_time,
            birth_lat,
            prev_lat,
            prev_lon,
            zvalues,
        ) = self.prepare_for_reconstruction_by_topologies()

        ####  Begin reconstruction by topology process:
        # Indices for all points (`active_points`) that have existed from `max_time` to `min_time`.
        point_id = range(len(active_points))

        # Specify the default collision detection region as subduction zones
        default_collision = reconstruction._DefaultCollision(
            feature_specific_collision_parameters=[
                (
                    pygplates.FeatureType.gpml_subduction_zone,
                    self.subduction_collision_parameters,
                )
            ]
        )
        # In addition to the default subduction detection, also detect continental collisions
        collision_spec = reconstruction._ContinentCollision(
            # This filename string should not have a time formatted into it - this is
            # taken care of later.
            self.continent_mask_filepath,
            default_collision,
            verbose=False,
        )

        # Call the reconstruct by topologies object
        topology_reconstruction = reconstruction._ReconstructByTopologies(
            self.rotation_model,
            self.topology_features,
            self._max_time,
            self._min_time,
            self._ridge_time_step,
            active_points,
            point_begin_times=appearance_time,
            detect_collisions=collision_spec,
        )
        # Initialise the reconstruction.
        topology_reconstruction.begin_reconstruction()

        # Loop over the reconstruction times until the end of the reconstruction time span, or until
        # all points have entered their valid time range *and* either exited their time range or
        # have been deactivated (subducted forward in time or consumed by MOR backward in time).
        reconstruction_data = []
        while True:
            logger.info(
                f&#34;Reconstruct by topologies: working on time {topology_reconstruction.get_current_time():0.2f} Ma&#34;
            )

            # NOTE:
            # topology_reconstruction.get_active_current_points() and topology_reconstruction.get_all_current_points()
            # are different. The former is a subset of the latter, and it represents all points at the timestep that
            # have not collided with a continental or subduction boundary. The remainders in the latter are inactive
            # (NoneType) points, which represent the collided points.

            # We need to access active point data from topology_reconstruction.get_all_current_points() because it has
            # the same length as the list of all initial ocean points and MOR seed points that have ever emerged from
            # spreading ridge topologies through `max_time` to `min_time`. Therefore, it protects the time and space
            # order in which all MOR points through time were seeded by pyGPlates. At any given timestep, not all these
            # points will be active, but their indices are retained. Thus, z value allocation, point latitudes and
            # longitudes of active points will be correctly indexed if taking it from
            # topology_reconstruction.get_all_current_points().
            curr_points = topology_reconstruction.get_active_current_points()
            curr_points_including_inactive = (
                topology_reconstruction.get_all_current_points()
            )
            logger.debug(f&#34;the number of current active points is :{len(curr_points)}&#34;)
            logger.debug(
                f&#34;the number of all current  points is :{len(curr_points_including_inactive)}&#34;
            )

            # Collect latitudes and longitudes of currently ACTIVE points in the ocean basin
            curr_lat_lon_points = [point.to_lat_lon() for point in curr_points]

            if curr_lat_lon_points:
                # Get the number of active points at this timestep.
                num_current_points = len(curr_points)

                # ndarray to fill with active point lats, lons and zvalues
                # FOR NOW, the number of gridding input columns is 6:
                # 0 = longitude
                # 1 = latitude
                # 2 = seafloor age
                # 3 = birth latitude snapshot
                # 4 = point id

                # 5 for the default gridding columns above, plus additional zvalues added next
                total_number_of_columns = 5 + len(self.zval_names)
                gridding_input_data = np.empty(
                    [num_current_points, total_number_of_columns]
                )

                # Lons and lats are first and second columns of the ndarray respectively
                gridding_input_data[:, 1], gridding_input_data[:, 0] = zip(
                    *curr_lat_lon_points
                )

                # NOTE: We need a single index to access data from curr_points_including_inactive AND allocate
                # this data to an ndarray with a number of rows equal to num_current_points. This index will
                # append +1 after each loop through curr_points_including_inactive.
                i = 0

                # Get indices and points of all points at `time`, both active and inactive (which are NoneType points that
                # have undergone continental collision or subduction at `time`).
                for point_index, current_point in enumerate(
                    curr_points_including_inactive
                ):
                    # Look at all active points (these have not collided with a continent or trench)
                    if current_point is not None:
                        # Seafloor age
                        gridding_input_data[i, 2] = (
                            appearance_time[point_index]
                            - topology_reconstruction.get_current_time()
                        )
                        # Birth latitude (snapshot)
                        gridding_input_data[i, 3] = birth_lat[point_index]
                        # Point ID (snapshot)
                        gridding_input_data[i, 4] = point_id[
                            point_index
                        ]  # The ID of a corresponding point from the original list of all MOR-resolved points

                        # GENERAL Z-VALUE ALLOCATION
                        # Z values are 1st index onwards; 0th belongs to the point feature ID (thus +1)
                        for j in range(len(self.zval_names)):
                            # Adjusted index - and we have to add j to 5 to account for lat, lon, age, birth lat and point ID,
                            adjusted_index = 5 + j

                            # Spreading rate would be first
                            # Access current zval from the master list of all zvalues for all points that ever existed in time_array
                            gridding_input_data[i, adjusted_index] = zvalues[
                                point_index, j
                            ]

                        # Go to the next active point
                        i += 1

                gridding_input_dictionary = {}

                for i in list(range(total_number_of_columns)):
                    gridding_input_dictionary[self.total_column_headers[i]] = [
                        list(j) for j in zip(*gridding_input_data)
                    ][i]
                    data_to_store = [
                        gridding_input_dictionary[i] for i in gridding_input_dictionary
                    ]

                # save debug file
                if get_debug_level() &gt; 100:
                    seafloor_ages = gridding_input_dictionary[&#34;SEAFLOOR_AGE&#34;]
                    logger.debug(
                        f&#34;The max and min values of seafloor age are: {np.max(seafloor_ages)} - {np.min(seafloor_ages)} ({topology_reconstruction.get_current_time()}Ma)&#34;
                    )
                    _save_seed_points_as_multipoint_coverage(
                        gridding_input_dictionary[&#34;CURRENT_LONGITUDES&#34;],
                        gridding_input_dictionary[&#34;CURRENT_LATITUDES&#34;],
                        gridding_input_dictionary[&#34;SEAFLOOR_AGE&#34;],
                        topology_reconstruction.get_current_time(),
                        self.sample_points_dir,
                    )

                np.savez_compressed(
                    self.gridding_input_filepath.format(
                        topology_reconstruction.get_current_time()
                    ),
                    *data_to_store,
                )

            if not topology_reconstruction.reconstruct_to_next_time():
                break

            logger.info(
                f&#34;Reconstruction done for {topology_reconstruction.get_current_time()}!&#34;
            )
        # return reconstruction_data

    def lat_lon_z_to_netCDF(
        self,
        zval_name,
        time_arr=None,
        unmasked=False,
        nprocs=1,
    ):
        &#34;&#34;&#34;Produce a netCDF4 grid of a z-value identified by its `zval_name` for a
        given time range in `time_arr`.

        Seafloor age can be gridded by passing `zval_name` as `SEAFLOOR_AGE`, and spreading
        rate can be gridded with `SPREADING_RATE`.

        Saves all grids to compressed netCDF format in the attributed directory. Grids
        can be read into ndarray format using `gplately.grids.read_netcdf_grid()`.

        Parameters
        ----------
        zval_name : str
            A string identifiers for a column in the ReconstructByTopologies gridding
            input files.
        time_arr : list of float, default None
            A time range to turn lons, lats and z-values into netCDF4 grids. If not provided,
            `time_arr` defaults to the full `time_array` provided to `SeafloorGrids`.
        unmasked : bool, default False
            Save unmasked grids, in addition to masked versions.
        nprocs : int, defaullt 1
            Number of processes to use for certain operations (requires joblib).
            Passed to `joblib.Parallel`, so -1 means all available processes.
        &#34;&#34;&#34;

        parallel = None
        nprocs = int(nprocs)
        if nprocs != 1:
            try:
                from joblib import Parallel

                parallel = Parallel(nprocs)
            except ImportError:
                warnings.warn(
                    &#34;Could not import joblib; falling back to serial execution&#34;
                )

        # User can put any time array within SeafloorGrid bounds, but if none
        # is provided, it defaults to the attributed time array
        if time_arr is None:
            time_arr = self._times

        if parallel is None:
            for time in time_arr:
                _lat_lon_z_to_netCDF_time(
                    time=time,
                    zval_name=zval_name,
                    file_collection=self.file_collection,
                    save_directory=self.save_directory,
                    total_column_headers=self.total_column_headers,
                    extent=self.extent,
                    resX=self.spacingX,
                    resY=self.spacingY,
                    unmasked=unmasked,
                    continent_mask_filename=self.continent_mask_filepath,
                    gridding_input_filename=self.gridding_input_filepath,
                )
        else:
            from joblib import delayed

            parallel(
                delayed(_lat_lon_z_to_netCDF_time)(
                    time=time,
                    zval_name=zval_name,
                    file_collection=self.file_collection,
                    save_directory=self.save_directory,
                    total_column_headers=self.total_column_headers,
                    extent=self.extent,
                    resX=self.spacingX,
                    resY=self.spacingY,
                    unmasked=unmasked,
                    continent_mask_filename=self.continent_mask_filepath,
                    gridding_input_filename=self.gridding_input_filepath,
                )
                for time in time_arr
            )

    def save_netcdf_files(
        self,
        name,
        times=None,
        unmasked=False,
        nprocs=None,
    ):
        if times is None:
            times = self._times
        if nprocs is None:
            try:
                nprocs = multiprocessing.cpu_count() - 1
            except NotImplementedError:
                nprocs = 1

        if nprocs &gt; 1:
            with multiprocessing.Pool(nprocs) as pool:
                pool.map(
                    partial(
                        _save_netcdf_file,
                        name=name,
                        file_collection=self.file_collection,
                        save_directory=self.save_directory,
                        extent=self.extent,
                        resX=self.spacingX,
                        resY=self.spacingY,
                        unmasked=unmasked,
                        continent_mask_filename=self.continent_mask_filepath,
                        sample_points_file_path=self.sample_points_file_path,
                    ),
                    times,
                )
        else:
            for time in times:
                _save_netcdf_file(
                    time,
                    name=name,
                    file_collection=self.file_collection,
                    save_directory=self.save_directory,
                    extent=self.extent,
                    resX=self.spacingX,
                    resY=self.spacingY,
                    unmasked=unmasked,
                    continent_mask_filename=self.continent_mask_filepath,
                    sample_points_file_path=self.sample_points_file_path,
                )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="gplately.oceans.SeafloorGrid.PlotTopologiesTime"><code class="name">prop <span class="ident">PlotTopologiesTime</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def PlotTopologiesTime(self):
    return self._PlotTopologies_object.time</code></pre>
</details>
</dd>
<dt id="gplately.oceans.SeafloorGrid.max_time"><code class="name">prop <span class="ident">max_time</span></code></dt>
<dd>
<div class="desc"><p>The reconstruction time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_time(self):
    &#34;&#34;&#34;The reconstruction time.&#34;&#34;&#34;
    return self._max_time</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gplately.oceans.SeafloorGrid.build_all_MOR_seedpoints"><code class="name flex">
<span>def <span class="ident">build_all_MOR_seedpoints</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve mid-ocean ridges for all times between <code>min_time</code> and <code>max_time</code>, divide them
into points that make up their shared sub-segments. Rotate these points to the left
and right of the ridge using their stage rotation so that they spread from the ridge.</p>
<p>Z-value allocation to each point is done here. In future, a function (like
the spreading rate function) to calculate general z-data will be an input parameter.</p>
<h2 id="notes">Notes</h2>
<p>If MOR seed point building is interrupted, progress is safeguarded as long as
<code>resume_from_checkpoints</code> is set to <code>True</code>.</p>
<p>This assumes that points spread from ridges symmetrically, with the exception of
large ridge jumps at successive timesteps. Therefore, z-values allocated to ridge-emerging
points will appear symmetrical until changes in spreading ridge geometries create
asymmetries.</p>
<p>In future, this will have a checkpoint save feature so that execution
(which occurs during preparation for ReconstructByTopologies and can take several hours)
can be safeguarded against run interruptions.</p>
<h2 id="references">References</h2>
<p>get_mid_ocean_ridge_seedpoints() has been adapted from
<a href="https://github.com/siwill22/agegrid-0.1/blob/master/automatic_age_grid_seeding.py#L117.">https://github.com/siwill22/agegrid-0.1/blob/master/automatic_age_grid_seeding.py#L117.</a></p></div>
</dd>
<dt id="gplately.oceans.SeafloorGrid.build_all_continental_masks"><code class="name flex">
<span>def <span class="ident">build_all_continental_masks</span></span>(<span>self, use_continent_contouring=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a continental mask to define the ocean basin for all times between <code>min_time</code> and <code>max_time</code>.</p>
<h2 id="notes">Notes</h2>
<p>Continental masking progress is safeguarded if ever masking is interrupted,
provided that <code>resume_from_checkpoints</code> is set to <code>True</code>.</p>
<p>The continental masks will be saved to f"continent_mask_{time}Ma.nc" as compressed netCDF4 files.</p></div>
</dd>
<dt id="gplately.oceans.SeafloorGrid.create_initial_ocean_seed_points"><code class="name flex">
<span>def <span class="ident">create_initial_ocean_seed_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the initial ocean basin seed point domain (at <code>max_time</code> only)
using Stripy's icosahedral triangulation with the specified <code>self.refinement_levels</code>.</p>
<p>The ocean mesh starts off as a global-spanning Stripy icosahedral mesh.
<code>create_initial_ocean_seed_points</code> passes the automatically-resolved-to-current-time
continental polygons from the <code>PlotTopologies_object</code>'s <code>continents</code> attribute
(which can be from a COB terrane file or a continental polygon file) into
Plate Tectonic Tools' point-in-polygon routine. It identifies ocean basin points that lie:
* outside the polygons (for the ocean basin point domain)
* inside the polygons (for the continental mask)</p>
<p>Points from the mesh outside the continental polygons make up the ocean basin seed
point mesh. The masked mesh is outputted as a compressed GPML (GPMLZ) file with
the filename: "ocean_basin_seed_points_{}Ma.gpmlz" if a <code>save_directory</code> is passed.
Otherwise, the mesh is returned as a pyGPlates FeatureCollection object.</p>
<h2 id="notes">Notes</h2>
<p>This point mesh represents ocean basin seafloor that was produced
before <code><a title="gplately.oceans.SeafloorGrid.max_time" href="#gplately.oceans.SeafloorGrid.max_time">SeafloorGrid.max_time</a></code>, and thus has unknown properties like valid
time and spreading rate. As time passes, the plate reconstruction model sees
points emerging from MORs. These new points spread to occupy the ocean basins,
moving the initial filler points closer to subduction zones and continental
polygons with which they can collide. If a collision is detected by
<code>PlateReconstruction</code>s <code>ReconstructByTopologies</code> object, these points are deleted.</p>
<p>Ideally, if a reconstruction tree spans a large time range, <strong>all</strong> initial mesh
points would collide with a continent or be subducted, leaving behind a mesh of
well-defined MOR-emerged ocean basin points that data can be attributed to.
However, some of these initial points situated close to contiental boundaries are
retained through time - these form point artefacts with anomalously high ages. Even
deep-time plate models (e.g. 1 Ga) will have these artefacts - removing them would
require more detail to be added to the reconstruction model.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ocean_basin_point_mesh</code></strong> :&ensp;<code>pygplates.FeatureCollection</code></dt>
<dd>A feature collection of pygplates.PointOnSphere objects on the ocean basin.</dd>
</dl></div>
</dd>
<dt id="gplately.oceans.SeafloorGrid.lat_lon_z_to_netCDF"><code class="name flex">
<span>def <span class="ident">lat_lon_z_to_netCDF</span></span>(<span>self, zval_name, time_arr=None, unmasked=False, nprocs=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a netCDF4 grid of a z-value identified by its <code>zval_name</code> for a
given time range in <code>time_arr</code>.</p>
<p>Seafloor age can be gridded by passing <code>zval_name</code> as <code>SEAFLOOR_AGE</code>, and spreading
rate can be gridded with <code>SPREADING_RATE</code>.</p>
<p>Saves all grids to compressed netCDF format in the attributed directory. Grids
can be read into ndarray format using <code><a title="gplately.grids.read_netcdf_grid" href="grids.html#gplately.grids.read_netcdf_grid">read_netcdf_grid()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>zval_name</code></strong> :&ensp;<code>str</code></dt>
<dd>A string identifiers for a column in the ReconstructByTopologies gridding
input files.</dd>
<dt><strong><code>time_arr</code></strong> :&ensp;<code>list</code> of <code>float</code>, default <code>None</code></dt>
<dd>A time range to turn lons, lats and z-values into netCDF4 grids. If not provided,
<code>time_arr</code> defaults to the full <code>time_array</code> provided to <code>SeafloorGrids</code>.</dd>
<dt><strong><code>unmasked</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Save unmasked grids, in addition to masked versions.</dd>
<dt><strong><code>nprocs</code></strong> :&ensp;<code>int, defaullt 1</code></dt>
<dd>Number of processes to use for certain operations (requires joblib).
Passed to <code>joblib.Parallel</code>, so -1 means all available processes.</dd>
</dl></div>
</dd>
<dt id="gplately.oceans.SeafloorGrid.prepare_for_reconstruction_by_topologies"><code class="name flex">
<span>def <span class="ident">prepare_for_reconstruction_by_topologies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare three main auxiliary files for seafloor data gridding:
* Initial ocean seed points (at <code>max_time</code>)
* Continental masks (from <code>max_time</code> to <code>min_time</code>)
* MOR points (from <code>max_time</code> to <code>min_time</code>)</p>
<p>Returns lists of all attributes for the initial ocean point mesh and
all ridge points for all times in the reconstruction time array.</p></div>
</dd>
<dt id="gplately.oceans.SeafloorGrid.reconstruct_by_topological_model"><code class="name flex">
<span>def <span class="ident">reconstruct_by_topological_model</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Use pygplates TopologicalModel to reconstruct seed points</p></div>
</dd>
<dt id="gplately.oceans.SeafloorGrid.reconstruct_by_topologies"><code class="name flex">
<span>def <span class="ident">reconstruct_by_topologies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain all active ocean seed points at <code>time</code> - these are
points that have not been consumed at subduction zones or have not
collided with continental polygons.</p>
<p>All active points' latitudes, longitues, seafloor ages, spreading rates and all
other general z-values are saved to a gridding input file (.npz).</p></div>
</dd>
<dt id="gplately.oceans.SeafloorGrid.save_netcdf_files"><code class="name flex">
<span>def <span class="ident">save_netcdf_files</span></span>(<span>self, name, times=None, unmasked=False, nprocs=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gplately.oceans.SeafloorGrid.update_time"><code class="name flex">
<span>def <span class="ident">update_time</span></span>(<span>self, max_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="GPlately logo" height="172" width="205">
</a>
</header>
<div class="toc">
<ul>
<li><a href="#seafloorgrid-methodology">SeafloorGrid Methodology</a></li>
<li><a href="#classes">Classes</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gplately.oceans.create_icosahedral_mesh" href="#gplately.oceans.create_icosahedral_mesh">create_icosahedral_mesh</a></code></li>
<li><code><a title="gplately.oceans.ensure_polygon_geometry" href="#gplately.oceans.ensure_polygon_geometry">ensure_polygon_geometry</a></code></li>
<li><code><a title="gplately.oceans.point_in_polygon_routine" href="#gplately.oceans.point_in_polygon_routine">point_in_polygon_routine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.oceans.SeafloorGrid" href="#gplately.oceans.SeafloorGrid">SeafloorGrid</a></code></h4>
<ul class="">
<li><code><a title="gplately.oceans.SeafloorGrid.PlotTopologiesTime" href="#gplately.oceans.SeafloorGrid.PlotTopologiesTime">PlotTopologiesTime</a></code></li>
<li><code><a title="gplately.oceans.SeafloorGrid.build_all_MOR_seedpoints" href="#gplately.oceans.SeafloorGrid.build_all_MOR_seedpoints">build_all_MOR_seedpoints</a></code></li>
<li><code><a title="gplately.oceans.SeafloorGrid.build_all_continental_masks" href="#gplately.oceans.SeafloorGrid.build_all_continental_masks">build_all_continental_masks</a></code></li>
<li><code><a title="gplately.oceans.SeafloorGrid.create_initial_ocean_seed_points" href="#gplately.oceans.SeafloorGrid.create_initial_ocean_seed_points">create_initial_ocean_seed_points</a></code></li>
<li><code><a title="gplately.oceans.SeafloorGrid.lat_lon_z_to_netCDF" href="#gplately.oceans.SeafloorGrid.lat_lon_z_to_netCDF">lat_lon_z_to_netCDF</a></code></li>
<li><code><a title="gplately.oceans.SeafloorGrid.max_time" href="#gplately.oceans.SeafloorGrid.max_time">max_time</a></code></li>
<li><code><a title="gplately.oceans.SeafloorGrid.prepare_for_reconstruction_by_topologies" href="#gplately.oceans.SeafloorGrid.prepare_for_reconstruction_by_topologies">prepare_for_reconstruction_by_topologies</a></code></li>
<li><code><a title="gplately.oceans.SeafloorGrid.reconstruct_by_topological_model" href="#gplately.oceans.SeafloorGrid.reconstruct_by_topological_model">reconstruct_by_topological_model</a></code></li>
<li><code><a title="gplately.oceans.SeafloorGrid.reconstruct_by_topologies" href="#gplately.oceans.SeafloorGrid.reconstruct_by_topologies">reconstruct_by_topologies</a></code></li>
<li><code><a title="gplately.oceans.SeafloorGrid.save_netcdf_files" href="#gplately.oceans.SeafloorGrid.save_netcdf_files">save_netcdf_files</a></code></li>
<li><code><a title="gplately.oceans.SeafloorGrid.update_time" href="#gplately.oceans.SeafloorGrid.update_time">update_time</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
