<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>gplately.pygplates API documentation</title>
<meta name="description" content="A light wrapping of some [`pyGPlates`](https://www.gplates.org/docs/pygplates/index.html)
classes to keep track of filenames. Each object listed here …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.pygplates</code></h1>
</header>
<section id="section-intro">
<p>A light wrapping of some <a href="https://www.gplates.org/docs/pygplates/index.html"><code>pyGPlates</code></a>
classes to keep track of filenames. Each object listed here will have a <code>self.filenames</code> attribute.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A light wrapping of some [`pyGPlates`](https://www.gplates.org/docs/pygplates/index.html) 
classes to keep track of filenames. Each object listed here will have a `self.filenames` attribute.
&#34;&#34;&#34;

import warnings as _warnings
from copy import copy
from typing import List, Union

import pygplates as _pygplates
from pygplates import *

_warnings.simplefilter(&#34;always&#34;, ImportWarning)


class RotationModel(_pygplates.RotationModel):
    &#34;&#34;&#34;A class that wraps the [`pyGPlates.RotationModel` class](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel).&#34;&#34;&#34;

    def __init__(
        self,
        rotation_features,
        reconstruction_tree_cache_size=150,
        extend_total_reconstruction_poles_to_distant_past=False,
        default_anchor_plate_id=0,
    ):
        # N.B. if rotation_features is a RotationModel, the constructor
        # will not accept &#39;extend_total_reconstruction_poles_to_distant_past&#39;
        # as an argument
        if isinstance(rotation_features, _pygplates.RotationModel):
            super(RotationModel, self).__init__(
                rotation_features,
                reconstruction_tree_cache_size=reconstruction_tree_cache_size,
                default_anchor_plate_id=default_anchor_plate_id,
            )
        else:
            super(RotationModel, self).__init__(
                rotation_features,
                reconstruction_tree_cache_size=reconstruction_tree_cache_size,
                extend_total_reconstruction_poles_to_distant_past=extend_total_reconstruction_poles_to_distant_past,
                default_anchor_plate_id=default_anchor_plate_id,
            )

        if isinstance(rotation_features, str):
            self._filenames = [rotation_features]
        elif hasattr(rotation_features, &#34;__iter__&#34;) and all(
            isinstance(f, str) for f in rotation_features
        ):
            self._filenames = list(rotation_features)
        else:
            self._filenames = []

    @property
    def filenames(self):
        return self._filenames

    @filenames.setter
    def filenames(self, filenames):
        self._filenames = filenames

    @filenames.deleter
    def filenames(self):
        del self._filenames


class Feature(_pygplates.Feature):
    &#34;&#34;&#34;A class that wraps the `pyGPlates.Feature` class. This contains tools to query and set
    geological or plate-tectonic feature properties defined by the
    [GPlates Geological Information Model (GPGIM)](https://www.gplates.org/docs/gpgim/).
    A feature consists of a collection of `properties`, a `feature type` and a `feature id`.

    See the link below for inherited methods

    https://www.gplates.org/docs/pygplates/generated/pygplates.feature

    &#34;&#34;&#34;

    #
    # this class seems unfinished. need to implement properly in the future.
    #

    def __init__(
        self,
        feature_type: _pygplates.FeatureType = _pygplates.FeatureType.gpml_unclassified_feature,
        feature_id: str = None,
        verify_information_model=_pygplates.VerifyInformationModel.yes,
        *,
        filenames: Union[str, List[str]] = [],
        feature: &#34;Feature&#34; = None,
    ):
        &#34;&#34;&#34;
        Notes
        -----
        The signature of this constructor has been changed since gplately 1.3.0 to be compatible with pygplates.
        THe &#39;filenames&#39; and &#39;feature&#39; parameters must be given as keyword argument.

        Parameters
        ----------

        feature_type : instance of `pygplates.FeatureType`
            The type of feature. See
            [here](https://www.gplates.org/docs/pygplates/generated/pygplates.featuretype#pygplates.FeatureType)
            for a list of pygplates feature types.

        feature_id : instance of `pygplates.FeatureId`
            The [feature identifier](https://www.gplates.org/docs/pygplates/generated/pygplates.featureid#pygplates.FeatureID).

        verify_information_model : instance of `VerifyInformationModel.yes` or `VerifyInformationModel.no`
            Specify whether to check `feature_type` with the information model (default) or not.

        filenames: `str` or `list` of `str`
            The filenames being associated with this feature.

        feature: instance of `gplately.pygplates.Feature`
            The other &#34;Feature&#34; object

        Raises
        ------
        ImportWarning
            If neither a `str` nor `list` of `str` is passed, no
            `Feature` filenames will be collected, and the user will be alerted of this.

        InformationModelError
            if `verify_information_model` is `VerifyInformationModel.yes` and `feature_type` is not a recognised feature type.

        &#34;&#34;&#34;

        # bugfix: gplately.pygplates.Feature is not compatible with pygplates.Feature
        # see https://github.com/GPlates/gplately/issues/150
        # this gplately.pygplates.Feature class seems not completed yet. for example, the clone() method returns nothing. It looks unfinished.
        # Why is a feature associated with multiple file names?
        super().__init__(feature_type, feature_id, verify_information_model)
        self.filenames = []

        # try the best to detect backward compatibility issue
        if not isinstance(feature_type, _pygplates.FeatureType):
            raise Exception(
                &#34;The __init__() signature has been changed. The first positional argument(besides self) is &#39;feature_type&#39; now. &#34;
                + &#34;Check the online documentation https://gplates.github.io/gplately/pygplates.html&#34;
            )

        # update filename list
        if isinstance(filenames, list) and all(
            isinstance(filename, str) for filename in filenames
        ):
            self.filenames = filenames
        elif isinstance(filenames, str):
            self.filenames = [filenames]
        else:
            msg = (
                f&#34;\nFeature: No filename associated with {type(filenames)} in __init__&#34;
                + &#34;\n ensure pygplates is imported from gplately. Run,&#34;
                + &#34;\n from gplately import pygplates&#34;
            )
            _warnings.warn(msg, ImportWarning)
            self.filenames = []

        if feature:
            self.filenames = feature.filenames
            # TODO: also need to copy everything else in the other feature into this feature

    def add(self, feature):
        &#34;&#34;&#34;Adds a property (or properties) to this feature. See original docs
        [here](https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature.add).

        Parameters
        ----------
        property_name : instance of `pygplates.PropertyName`
            The name of the property (or properties) to add.

        property_value : instance of `pygplates.PropertyValue` or sequence (eg, `list` or `tuple`) of `pygplates.PropertyValue`
            The value (or values) of the property (or properties) to add.

        verify_information_model : instance of `VerifyInformationModel.yes` or `VerifyInformationModel.no`
            Specify whether to check `feature_type` with the information model (default) or not.


        Returns
        -------
        property_added : `Property` or `list` of `Property` depending on whether `property_value` is a `PropertyValue` or sequence of `PropertyValue`
            The property (or properties) added to the feature.
        &#34;&#34;&#34;
        super().add(feature)
        if isinstance(feature, Feature):
            self.filenames.extend(feature.filenames)
        elif _is_string(feature):
            self.filenames.extend(feature)
        elif hasattr(feature, &#34;filenames&#34;):
            self.filenames.extend(feature.filenames)
        else:
            msg = &#34;\nFeature: No filename associated with {} in add&#34;.format(
                type(feature)
            )
            msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
            msg += &#34;\n from gplately import pygplates&#34;
            _warnings.warn(msg, ImportWarning)

    def clone(self):
        &#34;&#34;&#34;Create a duplicate of this `Feature` instance.

        This creates a new `Feature` instance with cloned versions of this feature’s `properties`.
        The cloned feature is created with its own unique `pygplates.FeatureId`.

        Returns
        -------
        Feature : instance of `gplately.pygplates.Feature`
            The cloned `Feature` instance.

        &#34;&#34;&#34;
        feat = super().clone()
        feat.filenames = self.filenames


class FeatureCollection(_pygplates.FeatureCollection):
    &#34;&#34;&#34;A class that wraps the
    [`pyGPlates.FeatureCollection`](https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection)
    class. This aggregates a set of features into a collection.
    This is traditionally so that a group of  features can be loaded, saved or
    unloaded in a single operation.

    This wrapping of `pygplates.FeatureCollection` contains all
    [`pygplates.FeatureCollection` functionality](https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection),
    and in addition tracks the names of files from which the feature
    collection(s) are read using the
    `gplately.pygplates.FeatureCollection.filenames` attribute.

    Examples
    --------

    For example, to read coastline features from a file:

        coastline_feature_collection = pygplates.FeatureCollection(&#39;coastlines.gpml&#39;)

    And to write coastline features to a file:

        coastline_feature_collection = pygplates.FeatureCollection(coastline_features)
        coastline_feature_collection.write(&#39;coastlines.gpml&#39;)

    To create a new feature collection from a sequence of `features`:

        feature_collection = pygplates.FeatureCollection([feature1, feature2])

        # ...is the equivalent of...

        feature_collection = pygplates.FeatureCollection()
        feature_collection.add(feature1)
        feature_collection.add(feature2)

    The following feature collection file formats are currently supported:

    ---

    |         **File Format**        | **Filename  Extension** | **Supports  Read** | **Supports Write** |
    |:------------------------------:|:-----------------------:|:------------------:|:------------------:|
    |     GPlates Markup Language    |         ‘.gpml’         |         Yes        |         Yes        |
    |         Compressed GPML        |  ‘.gpmlz’ or ‘.gpml.gz’ |         Yes        |         Yes        |
    |          PLATES4 line          |     ‘.dat’ or ‘.pla’    |         Yes        |         Yes        |
    |        PLATES4 rotation        |          ‘.rot’         |         Yes        |         Yes        |
    |        GPlates rotation        |         ‘.grot’         |         Yes        |         Yes        |
    |         ESRI Shapefile         |          ‘.shp’         |         Yes        |         Yes        |
    |             GeoJSON            |  ‘.geojson’ or ‘.json’  |         Yes        |         Yes        |
    |           GeoPackage           |         ‘.gpkg’         |         Yes        |         Yes        |
    |             OGR GMT            |          ‘.gmt’         |         Yes        |         Yes        |
    |             GMT xy             |          ‘.xy’          |         No         |         Yes        |
    | GMAP Virtual Geomagnetic Poles |          ‘.vgp’         |         Yes        |         No         |

    ---

    In the future, support will be added to enable users to implement and register readers/writers for other file formats (or their own non-standard file formats).


    Operations for accessing features
    ---------------------------------

    The following operations for accessing the features are supported:


    * `len(fc)` : Number of features in feature collection `fc`.

    * `for f in fc` : Iterates over the features `f` in feature collection `fc`.

    * `fc[i]` : The feature of fc at index `i`.


    For example:

        num_features = len(feature_collection)
        features_in_collection = [feature for feature in feature_collection]
        # assert(num_features == len(features_in_collection))

    &#34;&#34;&#34;

    def __init__(self, features=None):
        &#34;&#34;&#34;

        Parameters
        ----------
        features : instance of `Feature` or `str` or a sequence (eg, `list` or `tuple`) of `Feature`
            An optional filename, or sequence of features, or a single feature


        Raises
        ------
        OpenFileForReadingError
            If file is not readable (if filename specified).

        FileFormatNotSupportedError
            If file format (identified by the filename extension) does not support reading (when filename specified).

        &#34;&#34;&#34;
        super(FeatureCollection, self).__init__(features)
        self.filenames = []

        # update filename list
        if _is_string(features) and type(features) is list:
            self.filenames = features
        elif _is_string(features) and type(features) is str:
            self.filenames = [features]
        elif features is None:
            self.filenames = []
        elif isinstance(features, FeatureCollection):
            self.filenames = features.filenames
        elif hasattr(features, &#34;filenames&#34;):
            self.filenames = features.filenames
        else:
            msg = &#34;\nFeatureCollection: No filename associated with {} in __init__&#34;.format(
                type(features)
            )
            msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
            msg += &#34;\n from gplately import pygplates&#34;
            _warnings.warn(msg, ImportWarning)
            self.filenames = []

    def add(self, features):
        &#34;&#34;&#34;Adds one or more features to this collection.

        Parameters
        ----------
        feature : instance of `Feature` or sequence (eg, `list` or `tuple`) of `Feature`
            One or more features to add.

        A feature collection is an unordered collection of features so there is no concept
        of where a feature is inserted in the sequence of features.

            feature_collection.add(feature)
            feature_collection.add([feature1, feature2])
        &#34;&#34;&#34;
        super().add(features)

        # update filename list
        if isinstance(features, FeatureCollection):
            self.filenames.extend(features.filenames)
        elif _is_string(features):
            self.filenames.extend(features)
        elif hasattr(features, &#34;filenames&#34;):
            self.filenames.extend(features.filenames)
        else:
            msg = &#34;\nFeatureCollection: No filename associated with {} in add&#34;.format(
                type(features)
            )
            msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
            msg += &#34;\n from gplately import pygplates&#34;
            _warnings.warn(msg, ImportWarning)

    def clone(self):
        &#34;&#34;&#34;Create a duplicate of this feature collection instance.

        This creates a new `FeatureCollection` instance with cloned versions of
        this collection’s features. And the cloned features (in the cloned
        collection) are each created with a unique `FeatureId`.

        Returns
        -------
        feature_collection : instance of `gplately.pygplates.FeatureCollection`
            The cloned `FeatureCollection`.

        &#34;&#34;&#34;
        fc = super().clone()
        fc.filenames = self.filenames
        return fc


def _is_string(value):
    # convert sets to list
    if type(value) is set:
        value = list(value)

    # check for strings inside a list
    if type(value) is list:
        bl = []
        for val in value:
            bl.append(type(val) is str)
        return all(bl)

    # if no list, check if string
    else:
        return type(value) is str</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.pygplates.Feature"><code class="flex name class">
<span>class <span class="ident">Feature</span></span>
<span>(</span><span>feature_type: pygplates.pygplates.FeatureType = &lt;pygplates.pygplates.FeatureType object&gt;, feature_id: str = None, verify_information_model=pygplates.pygplates.VerifyInformationModel.yes, *, filenames: Union[str, List[str]] = [], feature: Feature = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that wraps the <code>pyGPlates.Feature</code> class. This contains tools to query and set
geological or plate-tectonic feature properties defined by the
<a href="https://www.gplates.org/docs/gpgim/">GPlates Geological Information Model (GPGIM)</a>.
A feature consists of a collection of <code>properties</code>, a <code>feature type</code> and a <code>feature id</code>.</p>
<p>See the link below for inherited methods</p>
<p><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.feature">https://www.gplates.org/docs/pygplates/generated/pygplates.feature</a></p>
<h2 id="notes">Notes</h2>
<p>The signature of this constructor has been changed since gplately 1.3.0 to be compatible with pygplates.
THe 'filenames' and 'feature' parameters must be given as keyword argument.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_type</code></strong> :&ensp;<code>instance</code> of <code>pygplates.FeatureType</code></dt>
<dd>The type of feature. See
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.featuretype#pygplates.FeatureType">here</a>
for a list of pygplates feature types.</dd>
<dt><strong><code>feature_id</code></strong> :&ensp;<code>instance</code> of <code>pygplates.FeatureId</code></dt>
<dd>The <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.featureid#pygplates.FeatureID">feature identifier</a>.</dd>
<dt><strong><code>verify_information_model</code></strong> :&ensp;<code>instance</code> of <code>VerifyInformationModel.yes</code> or <code>VerifyInformationModel.no</code></dt>
<dd>Specify whether to check <code>feature_type</code> with the information model (default) or not.</dd>
<dt><strong><code>filenames</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>The filenames being associated with this feature.</dd>
<dt><strong><code>feature</code></strong> :&ensp;<code>instance</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></dt>
<dd>The other "Feature" object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ImportWarning</code></dt>
<dd>If neither a <code>str</code> nor <code>list</code> of <code>str</code> is passed, no
<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> filenames will be collected, and the user will be alerted of this.</dd>
<dt><code>InformationModelError</code></dt>
<dd>if <code>verify_information_model</code> is <code>VerifyInformationModel.yes</code> and <code>feature_type</code> is not a recognised feature type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Feature(_pygplates.Feature):
    &#34;&#34;&#34;A class that wraps the `pyGPlates.Feature` class. This contains tools to query and set
    geological or plate-tectonic feature properties defined by the
    [GPlates Geological Information Model (GPGIM)](https://www.gplates.org/docs/gpgim/).
    A feature consists of a collection of `properties`, a `feature type` and a `feature id`.

    See the link below for inherited methods

    https://www.gplates.org/docs/pygplates/generated/pygplates.feature

    &#34;&#34;&#34;

    #
    # this class seems unfinished. need to implement properly in the future.
    #

    def __init__(
        self,
        feature_type: _pygplates.FeatureType = _pygplates.FeatureType.gpml_unclassified_feature,
        feature_id: str = None,
        verify_information_model=_pygplates.VerifyInformationModel.yes,
        *,
        filenames: Union[str, List[str]] = [],
        feature: &#34;Feature&#34; = None,
    ):
        &#34;&#34;&#34;
        Notes
        -----
        The signature of this constructor has been changed since gplately 1.3.0 to be compatible with pygplates.
        THe &#39;filenames&#39; and &#39;feature&#39; parameters must be given as keyword argument.

        Parameters
        ----------

        feature_type : instance of `pygplates.FeatureType`
            The type of feature. See
            [here](https://www.gplates.org/docs/pygplates/generated/pygplates.featuretype#pygplates.FeatureType)
            for a list of pygplates feature types.

        feature_id : instance of `pygplates.FeatureId`
            The [feature identifier](https://www.gplates.org/docs/pygplates/generated/pygplates.featureid#pygplates.FeatureID).

        verify_information_model : instance of `VerifyInformationModel.yes` or `VerifyInformationModel.no`
            Specify whether to check `feature_type` with the information model (default) or not.

        filenames: `str` or `list` of `str`
            The filenames being associated with this feature.

        feature: instance of `gplately.pygplates.Feature`
            The other &#34;Feature&#34; object

        Raises
        ------
        ImportWarning
            If neither a `str` nor `list` of `str` is passed, no
            `Feature` filenames will be collected, and the user will be alerted of this.

        InformationModelError
            if `verify_information_model` is `VerifyInformationModel.yes` and `feature_type` is not a recognised feature type.

        &#34;&#34;&#34;

        # bugfix: gplately.pygplates.Feature is not compatible with pygplates.Feature
        # see https://github.com/GPlates/gplately/issues/150
        # this gplately.pygplates.Feature class seems not completed yet. for example, the clone() method returns nothing. It looks unfinished.
        # Why is a feature associated with multiple file names?
        super().__init__(feature_type, feature_id, verify_information_model)
        self.filenames = []

        # try the best to detect backward compatibility issue
        if not isinstance(feature_type, _pygplates.FeatureType):
            raise Exception(
                &#34;The __init__() signature has been changed. The first positional argument(besides self) is &#39;feature_type&#39; now. &#34;
                + &#34;Check the online documentation https://gplates.github.io/gplately/pygplates.html&#34;
            )

        # update filename list
        if isinstance(filenames, list) and all(
            isinstance(filename, str) for filename in filenames
        ):
            self.filenames = filenames
        elif isinstance(filenames, str):
            self.filenames = [filenames]
        else:
            msg = (
                f&#34;\nFeature: No filename associated with {type(filenames)} in __init__&#34;
                + &#34;\n ensure pygplates is imported from gplately. Run,&#34;
                + &#34;\n from gplately import pygplates&#34;
            )
            _warnings.warn(msg, ImportWarning)
            self.filenames = []

        if feature:
            self.filenames = feature.filenames
            # TODO: also need to copy everything else in the other feature into this feature

    def add(self, feature):
        &#34;&#34;&#34;Adds a property (or properties) to this feature. See original docs
        [here](https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature.add).

        Parameters
        ----------
        property_name : instance of `pygplates.PropertyName`
            The name of the property (or properties) to add.

        property_value : instance of `pygplates.PropertyValue` or sequence (eg, `list` or `tuple`) of `pygplates.PropertyValue`
            The value (or values) of the property (or properties) to add.

        verify_information_model : instance of `VerifyInformationModel.yes` or `VerifyInformationModel.no`
            Specify whether to check `feature_type` with the information model (default) or not.


        Returns
        -------
        property_added : `Property` or `list` of `Property` depending on whether `property_value` is a `PropertyValue` or sequence of `PropertyValue`
            The property (or properties) added to the feature.
        &#34;&#34;&#34;
        super().add(feature)
        if isinstance(feature, Feature):
            self.filenames.extend(feature.filenames)
        elif _is_string(feature):
            self.filenames.extend(feature)
        elif hasattr(feature, &#34;filenames&#34;):
            self.filenames.extend(feature.filenames)
        else:
            msg = &#34;\nFeature: No filename associated with {} in add&#34;.format(
                type(feature)
            )
            msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
            msg += &#34;\n from gplately import pygplates&#34;
            _warnings.warn(msg, ImportWarning)

    def clone(self):
        &#34;&#34;&#34;Create a duplicate of this `Feature` instance.

        This creates a new `Feature` instance with cloned versions of this feature’s `properties`.
        The cloned feature is created with its own unique `pygplates.FeatureId`.

        Returns
        -------
        Feature : instance of `gplately.pygplates.Feature`
            The cloned `Feature` instance.

        &#34;&#34;&#34;
        feat = super().clone()
        feat.filenames = self.filenames</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.pygplates.Feature</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gplately.pygplates.Feature.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, feature)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a property (or properties) to this feature. See original docs
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature.add">here</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>property_name</code></strong> :&ensp;<code>instance</code> of <code>pygplates.PropertyName</code></dt>
<dd>The name of the property (or properties) to add.</dd>
<dt><strong><code>property_value</code></strong> :&ensp;<code>instance</code> of <code>pygplates.PropertyValue</code> or <code>sequence (eg, </code>list<code> or </code>tuple<code>)</code> of <code>pygplates.PropertyValue</code></dt>
<dd>The value (or values) of the property (or properties) to add.</dd>
<dt><strong><code>verify_information_model</code></strong> :&ensp;<code>instance</code> of <code>VerifyInformationModel.yes</code> or <code>VerifyInformationModel.no</code></dt>
<dd>Specify whether to check <code>feature_type</code> with the information model (default) or not.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>property_added</code></strong> :&ensp;<code>Property</code> or <code>list</code> of <code>Property<code>depending on whether</code>property_value<code>is a</code>PropertyValue</code> or <code>sequence</code> of <code>PropertyValue</code></dt>
<dd>The property (or properties) added to the feature.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, feature):
    &#34;&#34;&#34;Adds a property (or properties) to this feature. See original docs
    [here](https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature.add).

    Parameters
    ----------
    property_name : instance of `pygplates.PropertyName`
        The name of the property (or properties) to add.

    property_value : instance of `pygplates.PropertyValue` or sequence (eg, `list` or `tuple`) of `pygplates.PropertyValue`
        The value (or values) of the property (or properties) to add.

    verify_information_model : instance of `VerifyInformationModel.yes` or `VerifyInformationModel.no`
        Specify whether to check `feature_type` with the information model (default) or not.


    Returns
    -------
    property_added : `Property` or `list` of `Property` depending on whether `property_value` is a `PropertyValue` or sequence of `PropertyValue`
        The property (or properties) added to the feature.
    &#34;&#34;&#34;
    super().add(feature)
    if isinstance(feature, Feature):
        self.filenames.extend(feature.filenames)
    elif _is_string(feature):
        self.filenames.extend(feature)
    elif hasattr(feature, &#34;filenames&#34;):
        self.filenames.extend(feature.filenames)
    else:
        msg = &#34;\nFeature: No filename associated with {} in add&#34;.format(
            type(feature)
        )
        msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
        msg += &#34;\n from gplately import pygplates&#34;
        _warnings.warn(msg, ImportWarning)</code></pre>
</details>
</dd>
<dt id="gplately.pygplates.Feature.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a duplicate of this <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> instance.</p>
<p>This creates a new <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> instance with cloned versions of this feature’s <code>properties</code>.
The cloned feature is created with its own unique <code>pygplates.FeatureId</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Feature</code></strong> :&ensp;<code>instance</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></dt>
<dd>The cloned <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self):
    &#34;&#34;&#34;Create a duplicate of this `Feature` instance.

    This creates a new `Feature` instance with cloned versions of this feature’s `properties`.
    The cloned feature is created with its own unique `pygplates.FeatureId`.

    Returns
    -------
    Feature : instance of `gplately.pygplates.Feature`
        The cloned `Feature` instance.

    &#34;&#34;&#34;
    feat = super().clone()
    feat.filenames = self.filenames</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gplately.pygplates.FeatureCollection"><code class="flex name class">
<span>class <span class="ident">FeatureCollection</span></span>
<span>(</span><span>features=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that wraps the
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection"><code>pyGPlates.FeatureCollection</code></a>
class. This aggregates a set of features into a collection.
This is traditionally so that a group of
features can be loaded, saved or
unloaded in a single operation.</p>
<p>This wrapping of <code>pygplates.FeatureCollection</code> contains all
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection"><code>pygplates.FeatureCollection</code> functionality</a>,
and in addition tracks the names of files from which the feature
collection(s) are read using the
<code>gplately.pygplates.FeatureCollection.filenames</code> attribute.</p>
<h2 id="examples">Examples</h2>
<p>For example, to read coastline features from a file:</p>
<pre><code>coastline_feature_collection = pygplates.FeatureCollection('coastlines.gpml')
</code></pre>
<p>And to write coastline features to a file:</p>
<pre><code>coastline_feature_collection = pygplates.FeatureCollection(coastline_features)
coastline_feature_collection.write('coastlines.gpml')
</code></pre>
<p>To create a new feature collection from a sequence of <code>features</code>:</p>
<pre><code>feature_collection = pygplates.FeatureCollection([feature1, feature2])

# ...is the equivalent of...

feature_collection = pygplates.FeatureCollection()
feature_collection.add(feature1)
feature_collection.add(feature2)
</code></pre>
<p>The following feature collection file formats are currently supported:</p>
<hr>
<table>
<thead>
<tr>
<th style="text-align: center;"><strong>File Format</strong></th>
<th style="text-align: center;"><strong>Filename
Extension</strong></th>
<th style="text-align: center;"><strong>Supports
Read</strong></th>
<th style="text-align: center;"><strong>Supports Write</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">GPlates Markup Language</td>
<td style="text-align: center;">‘.gpml’</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr>
<td style="text-align: center;">Compressed GPML</td>
<td style="text-align: center;">‘.gpmlz’ or ‘.gpml.gz’</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr>
<td style="text-align: center;">PLATES4 line</td>
<td style="text-align: center;">‘.dat’ or ‘.pla’</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr>
<td style="text-align: center;">PLATES4 rotation</td>
<td style="text-align: center;">‘.rot’</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr>
<td style="text-align: center;">GPlates rotation</td>
<td style="text-align: center;">‘.grot’</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr>
<td style="text-align: center;">ESRI Shapefile</td>
<td style="text-align: center;">‘.shp’</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr>
<td style="text-align: center;">GeoJSON</td>
<td style="text-align: center;">‘.geojson’ or ‘.json’</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr>
<td style="text-align: center;">GeoPackage</td>
<td style="text-align: center;">‘.gpkg’</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr>
<td style="text-align: center;">OGR GMT</td>
<td style="text-align: center;">‘.gmt’</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr>
<td style="text-align: center;">GMT xy</td>
<td style="text-align: center;">‘.xy’</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr>
<td style="text-align: center;">GMAP Virtual Geomagnetic Poles</td>
<td style="text-align: center;">‘.vgp’</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
</tbody>
</table>
<hr>
<p>In the future, support will be added to enable users to implement and register readers/writers for other file formats (or their own non-standard file formats).</p>
<h2 id="operations-for-accessing-features">Operations For Accessing Features</h2>
<p>The following operations for accessing the features are supported:</p>
<ul>
<li>
<p><code>len(fc)</code> : Number of features in feature collection <code>fc</code>.</p>
</li>
<li>
<p><code>for f in fc</code> : Iterates over the features <code>f</code> in feature collection <code>fc</code>.</p>
</li>
<li>
<p><code>fc[i]</code> : The feature of fc at index <code>i</code>.</p>
</li>
</ul>
<p>For example:</p>
<pre><code>num_features = len(feature_collection)
features_in_collection = [feature for feature in feature_collection]
# assert(num_features == len(features_in_collection))
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>instance</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> or <code>str</code> or <code>a sequence (eg, </code>list<code> or </code>tuple<code>)</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></dt>
<dd>An optional filename, or sequence of features, or a single feature</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>OpenFileForReadingError</code></dt>
<dd>If file is not readable (if filename specified).</dd>
<dt><code>FileFormatNotSupportedError</code></dt>
<dd>If file format (identified by the filename extension) does not support reading (when filename specified).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureCollection(_pygplates.FeatureCollection):
    &#34;&#34;&#34;A class that wraps the
    [`pyGPlates.FeatureCollection`](https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection)
    class. This aggregates a set of features into a collection.
    This is traditionally so that a group of  features can be loaded, saved or
    unloaded in a single operation.

    This wrapping of `pygplates.FeatureCollection` contains all
    [`pygplates.FeatureCollection` functionality](https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection),
    and in addition tracks the names of files from which the feature
    collection(s) are read using the
    `gplately.pygplates.FeatureCollection.filenames` attribute.

    Examples
    --------

    For example, to read coastline features from a file:

        coastline_feature_collection = pygplates.FeatureCollection(&#39;coastlines.gpml&#39;)

    And to write coastline features to a file:

        coastline_feature_collection = pygplates.FeatureCollection(coastline_features)
        coastline_feature_collection.write(&#39;coastlines.gpml&#39;)

    To create a new feature collection from a sequence of `features`:

        feature_collection = pygplates.FeatureCollection([feature1, feature2])

        # ...is the equivalent of...

        feature_collection = pygplates.FeatureCollection()
        feature_collection.add(feature1)
        feature_collection.add(feature2)

    The following feature collection file formats are currently supported:

    ---

    |         **File Format**        | **Filename  Extension** | **Supports  Read** | **Supports Write** |
    |:------------------------------:|:-----------------------:|:------------------:|:------------------:|
    |     GPlates Markup Language    |         ‘.gpml’         |         Yes        |         Yes        |
    |         Compressed GPML        |  ‘.gpmlz’ or ‘.gpml.gz’ |         Yes        |         Yes        |
    |          PLATES4 line          |     ‘.dat’ or ‘.pla’    |         Yes        |         Yes        |
    |        PLATES4 rotation        |          ‘.rot’         |         Yes        |         Yes        |
    |        GPlates rotation        |         ‘.grot’         |         Yes        |         Yes        |
    |         ESRI Shapefile         |          ‘.shp’         |         Yes        |         Yes        |
    |             GeoJSON            |  ‘.geojson’ or ‘.json’  |         Yes        |         Yes        |
    |           GeoPackage           |         ‘.gpkg’         |         Yes        |         Yes        |
    |             OGR GMT            |          ‘.gmt’         |         Yes        |         Yes        |
    |             GMT xy             |          ‘.xy’          |         No         |         Yes        |
    | GMAP Virtual Geomagnetic Poles |          ‘.vgp’         |         Yes        |         No         |

    ---

    In the future, support will be added to enable users to implement and register readers/writers for other file formats (or their own non-standard file formats).


    Operations for accessing features
    ---------------------------------

    The following operations for accessing the features are supported:


    * `len(fc)` : Number of features in feature collection `fc`.

    * `for f in fc` : Iterates over the features `f` in feature collection `fc`.

    * `fc[i]` : The feature of fc at index `i`.


    For example:

        num_features = len(feature_collection)
        features_in_collection = [feature for feature in feature_collection]
        # assert(num_features == len(features_in_collection))

    &#34;&#34;&#34;

    def __init__(self, features=None):
        &#34;&#34;&#34;

        Parameters
        ----------
        features : instance of `Feature` or `str` or a sequence (eg, `list` or `tuple`) of `Feature`
            An optional filename, or sequence of features, or a single feature


        Raises
        ------
        OpenFileForReadingError
            If file is not readable (if filename specified).

        FileFormatNotSupportedError
            If file format (identified by the filename extension) does not support reading (when filename specified).

        &#34;&#34;&#34;
        super(FeatureCollection, self).__init__(features)
        self.filenames = []

        # update filename list
        if _is_string(features) and type(features) is list:
            self.filenames = features
        elif _is_string(features) and type(features) is str:
            self.filenames = [features]
        elif features is None:
            self.filenames = []
        elif isinstance(features, FeatureCollection):
            self.filenames = features.filenames
        elif hasattr(features, &#34;filenames&#34;):
            self.filenames = features.filenames
        else:
            msg = &#34;\nFeatureCollection: No filename associated with {} in __init__&#34;.format(
                type(features)
            )
            msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
            msg += &#34;\n from gplately import pygplates&#34;
            _warnings.warn(msg, ImportWarning)
            self.filenames = []

    def add(self, features):
        &#34;&#34;&#34;Adds one or more features to this collection.

        Parameters
        ----------
        feature : instance of `Feature` or sequence (eg, `list` or `tuple`) of `Feature`
            One or more features to add.

        A feature collection is an unordered collection of features so there is no concept
        of where a feature is inserted in the sequence of features.

            feature_collection.add(feature)
            feature_collection.add([feature1, feature2])
        &#34;&#34;&#34;
        super().add(features)

        # update filename list
        if isinstance(features, FeatureCollection):
            self.filenames.extend(features.filenames)
        elif _is_string(features):
            self.filenames.extend(features)
        elif hasattr(features, &#34;filenames&#34;):
            self.filenames.extend(features.filenames)
        else:
            msg = &#34;\nFeatureCollection: No filename associated with {} in add&#34;.format(
                type(features)
            )
            msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
            msg += &#34;\n from gplately import pygplates&#34;
            _warnings.warn(msg, ImportWarning)

    def clone(self):
        &#34;&#34;&#34;Create a duplicate of this feature collection instance.

        This creates a new `FeatureCollection` instance with cloned versions of
        this collection’s features. And the cloned features (in the cloned
        collection) are each created with a unique `FeatureId`.

        Returns
        -------
        feature_collection : instance of `gplately.pygplates.FeatureCollection`
            The cloned `FeatureCollection`.

        &#34;&#34;&#34;
        fc = super().clone()
        fc.filenames = self.filenames
        return fc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.pygplates.FeatureCollection</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gplately.pygplates.FeatureCollection.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, features)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds one or more features to this collection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature</code></strong> :&ensp;<code>instance</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> or <code>sequence (eg, </code>list<code> or </code>tuple<code>)</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></dt>
<dd>One or more features to add.</dd>
</dl>
<p>A feature collection is an unordered collection of features so there is no concept
of where a feature is inserted in the sequence of features.</p>
<pre><code>feature_collection.add(feature)
feature_collection.add([feature1, feature2])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, features):
    &#34;&#34;&#34;Adds one or more features to this collection.

    Parameters
    ----------
    feature : instance of `Feature` or sequence (eg, `list` or `tuple`) of `Feature`
        One or more features to add.

    A feature collection is an unordered collection of features so there is no concept
    of where a feature is inserted in the sequence of features.

        feature_collection.add(feature)
        feature_collection.add([feature1, feature2])
    &#34;&#34;&#34;
    super().add(features)

    # update filename list
    if isinstance(features, FeatureCollection):
        self.filenames.extend(features.filenames)
    elif _is_string(features):
        self.filenames.extend(features)
    elif hasattr(features, &#34;filenames&#34;):
        self.filenames.extend(features.filenames)
    else:
        msg = &#34;\nFeatureCollection: No filename associated with {} in add&#34;.format(
            type(features)
        )
        msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
        msg += &#34;\n from gplately import pygplates&#34;
        _warnings.warn(msg, ImportWarning)</code></pre>
</details>
</dd>
<dt id="gplately.pygplates.FeatureCollection.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a duplicate of this feature collection instance.</p>
<p>This creates a new <code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code> instance with cloned versions of
this collection’s features. And the cloned features (in the cloned
collection) are each created with a unique <code>FeatureId</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>feature_collection</code></strong> :&ensp;<code>instance</code> of <code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code></dt>
<dd>The cloned <code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self):
    &#34;&#34;&#34;Create a duplicate of this feature collection instance.

    This creates a new `FeatureCollection` instance with cloned versions of
    this collection’s features. And the cloned features (in the cloned
    collection) are each created with a unique `FeatureId`.

    Returns
    -------
    feature_collection : instance of `gplately.pygplates.FeatureCollection`
        The cloned `FeatureCollection`.

    &#34;&#34;&#34;
    fc = super().clone()
    fc.filenames = self.filenames
    return fc</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gplately.pygplates.RotationModel"><code class="flex name class">
<span>class <span class="ident">RotationModel</span></span>
<span>(</span><span>rotation_features, reconstruction_tree_cache_size=150, extend_total_reconstruction_poles_to_distant_past=False, default_anchor_plate_id=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that wraps the <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel"><code>pyGPlates.RotationModel</code> class</a>.</p>
<p><strong>init</strong>(&hellip;)
A <em>RotationModel</em> object can be constructed in more than one way&hellip;</p>
<p><strong>init</strong>(rotation_features, [reconstruction_tree_cache_size=150], [extend_total_reconstruction_poles_to_distant_past=False], [default_anchor_plate_id=0])
Create from rotation feature collection(s) and/or rotation filename(s).</p>
<p>:param rotation_features: A rotation feature collection, or rotation filename, or rotation feature, or sequence of rotation features, or a sequence (eg, <code>list</code> or <code>tuple</code>) of any combination of those four types
:type rotation_features: :class:<code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code>, or string, or :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code>, or sequence of :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code>, or sequence of any combination of those four types
:param reconstruction_tree_cache_size: Number of reconstruction trees to cache internally. Defaults to 150.
:type reconstruction_tree_cache_size: int
:param extend_total_reconstruction_poles_to_distant_past: extend each moving plate sequence back infinitely far into the distant past such that reconstructed geometries will not snap back to their present day positions when the reconstruction time is older than the oldest times specified in the rotation features (defaults to <code>False</code>)
:type extend_total_reconstruction_poles_to_distant_past: bool
:param default_anchor_plate_id: The default anchored plate id to use when :meth:<code>get_rotation</code> and :meth:<code>get_reconstruction_tree</code> are called without specifying their <em>anchor_plate_id</em> parameter. Defaults to 0.
:type default_anchor_plate_id: int
:raises: OpenFileForReadingError if any file is not readable (when filenames specified)
:raises: FileFormatNotSupportedError if any file format (identified by the filename extensions) does not support reading (when filenames specified)</p>
<p>Note that <em>rotation_features</em> can be a rotation :class:<code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code> or a rotation filename or a rotation :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> or a sequence of rotation :class:<code>features&lt;Feature&gt;</code>, or a sequence (eg, <code>list</code> or <code>tuple</code>) of any combination of those four types.</p>
<p>If any rotation filenames are specified then this method uses :class:<code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code> internally to read the rotation files.</p>
<p>Load a rotation file and some rotation adjustments (as a collection of rotation features) into a rotation model:
::</p>
<pre><code>rotation_adjustments = pygplates.FeatureCollection()
...
rotation_model = pygplates.RotationModel(['rotations.rot', rotation_adjustments])
</code></pre>
<p>!!! versionchanged "Changed in version:&ensp;0.25"
Added <em>extend_total_reconstruction_poles_to_distant_past</em> argument and removed <em>clone_rotation_features</em> argument.</p>
<p>!!! versionchanged "Changed in version:&ensp;0.26"
Added <em>default_anchor_plate_id</em> argument.</p>
<p><strong>init</strong>(rotation_model, [reconstruction_tree_cache_size=2], [default_anchor_plate_id])
Use an existing rotation model but adapt it with a potentially different cache size and/or default anchor plate ID.</p>
<p>:param rotation_model: an existing rotation model
:type rotation_model: :class:<code><a title="gplately.pygplates.RotationModel" href="#gplately.pygplates.RotationModel">RotationModel</a></code>
:param reconstruction_tree_cache_size: Number of reconstruction trees to cache internally. Defaults to 2 - this is much lower than the usual default cache size since the existing rotation model likely already has a sizeable cache anyway - and if you are leaving this at its default value then you are presumably only interested in changing the default anchor plate ID (not increasing the cache size).
:type reconstruction_tree_cache_size: int
:param default_anchor_plate_id: The default anchored plate id to use when :meth:<code>get_rotation</code> and :meth:<code>get_reconstruction_tree</code> are called without specifying their <em>anchor_plate_id</em> parameter. Defaults to the default anchor plate of <em>rotation_model</em>.
:type default_anchor_plate_id: int</p>
<p>This is useful if you want to use an existing rotation model but with a larger cache size or a different default anchor plate ID:
::</p>
<pre><code>rotation_model = pygplates.RotationModel(rotation_files)
...
rotation_model_anchor_1 = pygplates.RotationModel(rotation_model, default_anchor_plate_id=1)
</code></pre>
<p>!!! note "Note:&ensp;The above example just changes the <em>default</em> anchor plate ID. You can still explicitly specify any anchor plate ID to :meth:<code>get_rotation</code>. So the following two calls return the same results:"
::</p>
<pre><code>    rotation_model.get_rotation(100.0, 802, anchor_plate_id=1)
    rotation_model_anchor_1.get_rotation(100.0, 802)
</code></pre>
<p>!!! versionadded "Added in version:&ensp;0.29"</p>
<p><strong>init</strong>(rotation_model)
Simply return an existing rotation model as a convenience.</p>
<p>:param rotation_model: an existing rotation model
:type rotation_model: :class:<code><a title="gplately.pygplates.RotationModel" href="#gplately.pygplates.RotationModel">RotationModel</a></code></p>
<p>This is useful when defining your own function that accepts rotation features or a rotation model. It avoids the hassle of having to explicitly test for each source type:
::</p>
<pre><code>def my_function(rotation_features_or_model):
    # The appropriate constructor (__init__) overload is chosen depending on argument type.
    rotation_model = pygplates.RotationModel(rotation_features_or_model)
    ...
</code></pre>
<p>!!! note "Note:&ensp;This :meth:<code>constructor&lt;__init__&gt;</code> just returns a reference to the existing <em>rotation_model</em> because a <em>RotationModel</em> object is immutable (contains no operations or methods that modify its state) and hence a deep copy of <em>rotation_model</em> is not needed."</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RotationModel(_pygplates.RotationModel):
    &#34;&#34;&#34;A class that wraps the [`pyGPlates.RotationModel` class](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel).&#34;&#34;&#34;

    def __init__(
        self,
        rotation_features,
        reconstruction_tree_cache_size=150,
        extend_total_reconstruction_poles_to_distant_past=False,
        default_anchor_plate_id=0,
    ):
        # N.B. if rotation_features is a RotationModel, the constructor
        # will not accept &#39;extend_total_reconstruction_poles_to_distant_past&#39;
        # as an argument
        if isinstance(rotation_features, _pygplates.RotationModel):
            super(RotationModel, self).__init__(
                rotation_features,
                reconstruction_tree_cache_size=reconstruction_tree_cache_size,
                default_anchor_plate_id=default_anchor_plate_id,
            )
        else:
            super(RotationModel, self).__init__(
                rotation_features,
                reconstruction_tree_cache_size=reconstruction_tree_cache_size,
                extend_total_reconstruction_poles_to_distant_past=extend_total_reconstruction_poles_to_distant_past,
                default_anchor_plate_id=default_anchor_plate_id,
            )

        if isinstance(rotation_features, str):
            self._filenames = [rotation_features]
        elif hasattr(rotation_features, &#34;__iter__&#34;) and all(
            isinstance(f, str) for f in rotation_features
        ):
            self._filenames = list(rotation_features)
        else:
            self._filenames = []

    @property
    def filenames(self):
        return self._filenames

    @filenames.setter
    def filenames(self, filenames):
        self._filenames = filenames

    @filenames.deleter
    def filenames(self):
        del self._filenames</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.pygplates.RotationModel</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gplately.pygplates.RotationModel.filenames"><code class="name">var <span class="ident">filenames</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def filenames(self):
    return self._filenames</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="GPlately logo" height="172" width="205">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></h4>
<ul class="">
<li><code><a title="gplately.pygplates.Feature.add" href="#gplately.pygplates.Feature.add">add</a></code></li>
<li><code><a title="gplately.pygplates.Feature.clone" href="#gplately.pygplates.Feature.clone">clone</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code></h4>
<ul class="">
<li><code><a title="gplately.pygplates.FeatureCollection.add" href="#gplately.pygplates.FeatureCollection.add">add</a></code></li>
<li><code><a title="gplately.pygplates.FeatureCollection.clone" href="#gplately.pygplates.FeatureCollection.clone">clone</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.pygplates.RotationModel" href="#gplately.pygplates.RotationModel">RotationModel</a></code></h4>
<ul class="">
<li><code><a title="gplately.pygplates.RotationModel.filenames" href="#gplately.pygplates.RotationModel.filenames">filenames</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>