<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gplately.plot API documentation</title>
<meta name="description" content="Tools for reconstructing and plotting geological features and feature data through time …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.plot</code></h1>
</header>
<section id="section-intro">
<p>Tools for reconstructing and plotting geological features and feature data through time.</p>
<p>Methods in <code>plot.py</code> reconstruct geological features using
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.reconstruct.html">pyGPlates' <code>reconstruct</code> function</a>,
turns them into plottable Shapely geometries, and plots them onto
Cartopy GeoAxes using Shapely and GeoPandas.</p>
<h2 id="classes">Classes</h2>
<p>PlotTopologies</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Tools for reconstructing and plotting geological features and feature data through time.

Methods in `plot.py` reconstruct geological features using 
[pyGPlates&#39; `reconstruct` function](https://www.gplates.org/docs/pygplates/generated/pygplates.reconstruct.html),
turns them into plottable Shapely geometries, and plots them onto 
Cartopy GeoAxes using Shapely and GeoPandas.

Classes
-------
PlotTopologies
&#34;&#34;&#34;
import re

import pygplates
import cartopy.crs as ccrs
import matplotlib.pyplot as plt
import numpy as np
import ptt
from shapely.geometry import Point, Polygon
from shapely.geometry.base import BaseGeometry, BaseMultipartGeometry
from shapely.ops import linemerge

from .pygplates import FeatureCollection as _FeatureCollection
from .pygplates import _is_string
from .reconstruction import PlateReconstruction as _PlateReconstruction
from .geometry import pygplates_to_shapely
import geopandas as gpd
from .io import (
    get_valid_geometries,  # included for backwards compatibility
    get_geometries as _get_geometries,
)
from .tools import EARTH_RADIUS
from .gpml import _load_FeatureCollection
    
def add_coastlines(ax, reconstruction_time, **kwargs):
    &#34;&#34;&#34;Reconstruct coastline features to a `reconstruction_time` and plot them as 
    Shapely geometries onto a standard map Projection. 

    Notes
    -----
    `add_coastlines` can be used as part of the `PlotTopologies` object. In this case, the `coastlines` 
    and `rotation_model` needed for plotting will be accessed from the `PlotTopologies` object. 
    Otherwise, `add_coastlines` can be used as a standalone method. In this case, the coastlines for 
    plotting must be defined in a variable `coastlines` above the method, along with a `rotation_model`.

    `coastlines` should be a pyGPlates FeatureCollection, or a filename string, or a pyGPlates Feature, 
    or a a sequence of features, or a list or tuple of any combination of those four types. 


    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) at which to reconstruct the coastline features. 

    **export_wrap_to_dateline : bool, optional, default=True
        Wrap/clip reconstructed geometries to the dateline using pyGPlates&#39; 
        [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper).

    **kwargs : 
        Keyword arguments for parameters such as `‘facecolor’`, `‘alpha’`, etc. for 
        plotting coastline geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with coastline features plotted onto the chosen projection. 
    &#34;&#34;&#34;
    # write shapefile
    reconstructed_coastlines = []
    pygplates.reconstruct(coastlines, rotation_model, reconstructed_coastlines, float(reconstruction_time),
                          export_wrap_to_dateline=True)
    coastlines_geometries = shapelify_feature_polygons(reconstructed_coastlines)
    ax.add_geometries(coastlines_geometries, crs=ccrs.PlateCarree(), **kwargs)
    
def add_continents(ax, reconstruction_time, **kwargs):
    &#34;&#34;&#34;Reconstruct continental features to a `reconstruction_time` and plot them as 
    Shapely geometries onto a standard map Projection. 

    Notes
    -----
    `add_continents` can be used as part of the `PlotTopologies` object. In this case, the `continents` 
    and `rotation_model` needed for plotting will be accessed from the `PlotTopologies` object. 
    Otherwise, `add_continents` can be used as a standalone method. In this case, the continents for 
    plotting must be defined in a variable `continents` above the method, along with a `rotation_model`.

    `continents` should be a pyGPlates FeatureCollection, or a filename string, or a pyGPlates Feature, 
    or a a sequence of features, or a list or tuple of any combination of those four types. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) at which to reconstruct the continent features. 

    **export_wrap_to_dateline : bool, optional, default=True
        Wrap/clip reconstructed geometries to the dateline using pyGPlates&#39; 
        [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper).

    **kwargs : 
        Keyword arguments for parameters such as `‘facecolor’`, `‘alpha’`, etc. for 
        plotting continent geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with continental features plotted onto the chosen projection. 
    &#34;&#34;&#34;
    reconstructed_continents = []
    pygplates.reconstruct(continents, rotation_model, reconstructed_continents, float(reconstruction_time),
                          export_wrap_to_dateline=True)
    continent_geometries = shapelify_feature_polygons(reconstructed_continents)
    ax.add_geometries(continent_geometries, crs=ccrs.PlateCarree(), **kwargs)

    
def add_ridges(ax, reconstruction_time, **kwargs):
    &#34;&#34;&#34;Reconstruct ridge features to a specific `reconstruction_time` and plot them as 
    Shapely geometries onto a standard map Projection. 
    
    Notes
    -----
    `add_ridges` can be used as part of the `PlotTopologies` object. In this case, the `ridges` 
    and `rotation_model` needed for plotting will be accessed from the `PlotTopologies` object. 
    Otherwise, `add_ridges` can be used as a standalone method. In this case, the ridges for 
    plotting must be contained in a variable `topology_features` above the method, along with a 
    `rotation_model`.

    `topology_features` should be a pyGPlates FeatureCollection, or a filename string, 
    or a pyGPlates Feature, or a a sequence of features, or a list or tuple of any combination 
    of those four types. 

    Exterior coordinates of ridge polylines are ordered anti-clockwise and only valid geometries 
    are passed to ensure compatibility with Cartopy.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) at which to reconstruct the ridge features. 

    **kwargs : 
        Keyword arguments for parameters such as `‘facecolor’`, 
        `‘alpha’`, etc. for plotting ridge geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).


    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with ridge features plotted onto the chosen projection.
    &#34;&#34;&#34;
    import shapely
    reconstructed_ridges = get_ridge_transforms(topology_features, rotation_model, float(reconstruction_time))
    all_geometries = []
    for feature in reconstructed_ridges:
        geometry = feature.get_all_geometries()[0].to_lat_lon_array()[::-1,::-1]
        
        # construct shapely geometry
        geom = shapely.geometry.LineString(geometry)

        # we need to make sure the exterior coordinates are ordered anti-clockwise
        # and the geometry is valid otherwise it will screw with cartopy
        if geom.is_valid:
            all_geometries.append(geom)
    
    ax.add_geometries(all_geometries, crs=ccrs.PlateCarree(), **kwargs)
    
def add_ridges(ax, reconstruction_time, **kwargs):
    &#34;&#34;&#34;Read a shapefile containing ridge features already reconstructed to a 
    `reconstruction_time`. Plots them as Shapely geometries onto a standard map Projection. 

    Notes
    -----
    The ridge features to be plotted must be reconstructed to a specific geological time already. 
    These are assumed to be held in the filename string
    `&#34;reconstructed_topologies/ridge_transform_boundaries_{reconstruction_time}Ma.shp&#34;` for each 
    reconstruction time. This filename is read and its ridge geometries are extracted, turned 
    into Shapely geometries, and plotted onto the given map `ax`.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) at which to reconstruct the ridge features. 

    **kwargs : 
        Keyword arguments for parameters such as `‘facecolor’`, 
        `‘alpha’`, etc. for plotting ridge geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with ridge features plotted onto the chosen projection. 
    &#34;&#34;&#34;
    shp_name = &#34;reconstructed_topologies/ridge_transform_boundaries_{:.2f}Ma.shp&#34;.format(reconstruction_time)
    shp_continents = shpreader.Reader(shp_name).geometries()
    ft_continents  = cfeature.ShapelyFeature(shp_continents, ccrs.PlateCarree())
    ax.add_feature(ft_continents, **kwargs)

def add_trenches(ax, reconstruction_time, color=&#39;k&#39;, linewidth=2, **kwargs):
    &#34;&#34;&#34;Generate subduction teeth along subduction boundaries and plot both subduction 
    zones and teeth onto a standard map Projection.

    Notes
    -----
    To tessellate trenches and their teeth (which visualise their subduction polarities), 
    `add_trenches` reads 3 shapefiles: 

    * reconstructed subduction boundaries in 
    `reconstructed_topologies/subduction_boundaries_{reconstruction_time}Ma.shp`
    * left subduction trenches in
    `&#34;reconstructed_topologies/subduction_boundaries_sL_{reconstruction_time}Ma.shp&#34;`
    * right subduction trenches in
    `&#34;reconstructed_topologies/subduction_boundaries_sR_{reconstruction_time}Ma.shp&#34;`

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) used to identify the correct trench filenames.
        This is substituted into:

        * `reconstructed_topologies/subduction_boundaries_{reconstruction_time}Ma.shp`
        * `reconstructed_topologies/subduction_boundaries_sL_{reconstruction_time}Ma.shp`
        * `reconstructed_topologies/subduction_boundaries_sR_{reconstruction_time}Ma.shp`

    color : str, default=&#39;k&#39;
        Sets the subduction boundaries to a specific edge color.

    linewidth : float, default=2
        Defines the thickness of the subduction boundaries.

    **kwargs :
        Keyword arguments for map features like ‘alpha’, etc. for plotting 
        trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with trench features plotted onto the chosen Projection. 
    &#34;&#34;&#34;
    shp_name = &#34;reconstructed_topologies/subduction_boundaries_{:.2f}Ma.shp&#34;.format(reconstruction_time)
    shp_subd = shpreader.Reader(shp_name).geometries()
    ft_subd  = cfeature.ShapelyFeature(shp_subd, ccrs.PlateCarree())
    ax.add_feature(ft_subd, facecolor=&#39;none&#39;, edgecolor=color, linewidth=linewidth, zorder=5)
    # add Subduction Teeth
    subd_xL, subd_yL = tesselate_triangles(
        &#34;reconstructed_topologies/subduction_boundaries_sL_{:.2f}Ma.shp&#34;.format(reconstruction_time),
        tesselation_radians=0.1, triangle_base_length=2.0, triangle_aspect=-1.0)
    subd_xR, subd_yR = tesselate_triangles(
        &#34;reconstructed_topologies/subduction_boundaries_sR_{:.2f}Ma.shp&#34;.format(reconstruction_time),
        tesselation_radians=0.1, triangle_base_length=2.0, triangle_aspect=1.0)
    
    for tX, tY in zip(subd_xL, subd_yL):
        triangle_xy_points = np.c_[tX, tY]
        patch = plt.Polygon(triangle_xy_points, color=color, transform=ccrs.PlateCarree(), zorder=6)
        ax.add_patch(patch)
    for tX, tY in zip(subd_xR, subd_yR):
        triangle_xy_points = np.c_[tX, tY]
        patch = plt.Polygon(triangle_xy_points, color=color, transform=ccrs.PlateCarree(), zorder=6)
        ax.add_patch(patch)
    
    
def add_quiver(ax, reconstruction_time, **kwargs):
    &#34;&#34;&#34;Plot a topological plate velocity vector field onto a standard map Projection for a 
    specific `reconstruction_time`. 

    Notes
    -----
    `add_quiver` uses 
    [Plate Tectonic Tools](https://github.com/EarthByte/PlateTectonicTools), a `rotation_model` 
    and a set of `topology_features` to generate a domain of point features on a GeoAxes `ax`. 
    Plate velocities are calculated for each point in the domain at a specific `reconstruction_time`. 
    These velocities are visualised on a cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot 
    as a vector field. Velocity magnitudes are not normalised. 

    `add_quiver` can be used as part of the `PlotTopologies` object. In this case, the 
    `rotation_model` and set of `topology_features` needed to generate the velocity vector field
    are automatically accessed from the object&#39;s attributes. Otherwise, a `rotation_model` and set 
    of `topology_features` must be defined above this method. 

    Parameters
    -----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) at which to reconstruct global topological plates and
        calculate their velocities.

    **kwargs : 
        Keyword arguments for quiver features like ‘alpha’, etc. for velocity 
        vectors.
        See `Matplotlib` quiver keyword arguments 
        [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.quiver.html).

    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with velocity vector fields plotted onto the chosen Projection. 
    &#34;&#34;&#34;
    Xnodes, Ynodes, U, V = ptt.velocity_tools.get_velocity_x_y_u_v(reconstruction_time, rotation_model,
                                                                   topology_features)
    mag = np.hypot(U, V)
#     mag = np.clip(mag, 1.0, 1e99)
#     mag[mag==0] = 1 #to avoid 0 divisor
#     U = U/mag
#     V = V/mag
    
    if mag.any():
        ax.quiver(Xnodes, Ynodes, U, V, transform=ccrs.PlateCarree(), **kwargs)



# subduction teeth
def tesselate_triangles(shapefilename, tesselation_radians, triangle_base_length, triangle_aspect=1.0):
    &#34;&#34;&#34;Place subduction teeth along subduction boundary line segments read from a 
    MultiLineString `shapefilename`. 

    Parameters
    ----------
    shapefilename : str
        Path to shapefile containing the reconstructed subduction boundary features.

    tesselation_radians : float
        Parametrises subduction teeth density. Triangles are generated only along line 
        segments with distances that exceed the given threshold `tessellation_radians`.

    triangle_base_length : float  
        Length of teeth triangle base.
        
    triangle_aspect : float, default=1.0  
        Aspect ratio of teeth triangles. Ratio is 1.0 by default.

    Returns
    -------
    X_points : (n,3) array
        X (longitudinal) coordinates of points that define subduction teeth triangles.
    Y_points : (n,3) array 
        Y (latitudinal) coordinates of points that define subduction teeth triangles.
    &#34;&#34;&#34;

    import shapefile

    with shapefile.Reader(shapefilename) as shp:
        tesselation_degrees = np.degrees(tesselation_radians)
        triangle_pointsX = []
        triangle_pointsY = []

        for i in range(len(shp)):
            pts = np.array(shp.shape(i).points)

            cum_distance = 0.0
            for p in range(len(pts) - 1):

                A = pts[p]
                B = pts[p + 1]

                AB_dist = B - A
                AB_norm = AB_dist / np.hypot(*AB_dist)
                cum_distance += np.hypot(*AB_dist)

                # create a new triangle if cumulative distance is exceeded.
                if cum_distance &gt;= tesselation_degrees:

                    C = A + triangle_base_length * AB_norm

                    # find normal vector
                    AD_dist = np.array([AB_norm[1], -AB_norm[0]])
                    AD_norm = AD_dist / np.linalg.norm(AD_dist)

                    C0 = A + 0.5 * triangle_base_length * AB_norm

                    # project point along normal vector
                    D = C0 + triangle_base_length * triangle_aspect * AD_norm

                    triangle_pointsX.append([A[0], C[0], D[0]])
                    triangle_pointsY.append([A[1], C[1], D[1]])

                    cum_distance = 0.0

    return np.array(triangle_pointsX), np.array(triangle_pointsY)


def plot_subduction_teeth(
    geometries,
    width,
    polarity=None,
    height=None,
    spacing=None,
    projection=&#34;auto&#34;,
    transform=None,
    ax=None,
    **kwargs
):
    &#34;&#34;&#34;Add subduction teeth to a plot.

    The subduction polarity used for subduction teeth can be specified
    manually or detected automatically if `geometries` is a
    `geopandas.GeoDataFrame` object with a `polarity` column.

    Parameters
    ----------
    geometries : geopandas.GeoDataFrame, sequence of shapely geometries, or str
        If a `geopandas.GeoDataFrame` is given, its geometry attribute
        will be used. If `geometries` is a string, it must be the path to
        a file, which will be loaded with `geopandas.read_file`. Otherwise,
        `geometries` must be a sequence of shapely geometry objects (instances
        of the `shapely.geometry.base.BaseGeometry` class).
    width : float
        The (approximate) width of the subduction teeth. If a projection is
        used, this value will be in projected units.
    polarity : {&#34;left&#34;, &#34;l&#34;, &#34;right&#34;, &#34;r&#34;, None}, default None
        The subduction polarity of the geometries. If no polarity is provided,
        and `geometries` is a `geopandas.GeoDataFrame`, this function will
        attempt to find a `polarity` column in the data frame and use the
        values given there. If `polarity` is not manually specified and no
        appropriate column can be found, an error will be raised.
    height : float, default None
        If provided, the height of the subduction teeth. As with `width`,
        this value should be given in projected units. If no value is given,
        the height of the teeth will be equal to 0.6 * `width`.
    spacing : float, default None
        If provided, the spacing between the subduction teeth. As with
        `width` and `height`, this value should be given in projected units.
        If no value is given, `spacing` will default to `width`, producing
        tightly packed subduction teeth.
    projection : cartopy.crs.Transform, &#34;auto&#34;, or None, default &#34;auto&#34;
        The projection of the plot. If the plot has no projection, this value
        can be explicitly given as `None`. The default value is &#34;auto&#34;, which
        will acquire the projection automatically from the plot axes.
    transform : cartopy.crs.Transform, or None, default None
        If the plot is projected, a `transform` value is usually needed.
        Frequently, the appropriate value is an instance of
        `cartopy.crs.PlateCarree`.
    ax : matplotlib.axes.Axes, or None, default None
        The axes on which the subduction teeth will be drawn. By default,
        the current axes will be acquired using `matplotlib.pyplot.gca`.
    **kwargs
        Any further keyword arguments will be passed to
        `matplotlib.patches.Polygon`.

    Raises
    ------
    ValueError
        If `width` &lt;= 0, or if `polarity` is an invalid value or could not
        be determined.
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()

    if projection == &#34;auto&#34;:
        try:
            projection = ax.projection
        except AttributeError:
            projection = None
    elif isinstance(projection, str):
        raise ValueError(&#34;Invalid projection: {}&#34;.format(projection))

    if polarity is None:
        polarity_column = _find_polarity_column(geometries.columns.values)
        if polarity_column is None:
            raise ValueError(
                &#34;Could not automatically determine polarity; &#34;
                + &#34;it must be defined manually instead.&#34;
            )
        triangles = []
        for p in geometries[polarity_column].unique():
            if p.lower() not in {&#34;left&#34;, &#34;l&#34;, &#34;right&#34;, &#34;r&#34;}:
                continue
            gdf_polarity = geometries[geometries[polarity_column] == p]
            triangles.extend(
                _tesselate_triangles(
                    gdf_polarity,
                    width,
                    p,
                    height,
                    spacing,
                    projection,
                    transform,
                )
            )
    else:
        triangles = _tesselate_triangles(
            geometries,
            width,
            polarity,
            height,
            spacing,
            projection,
            transform,
        )

    if projection is not None:
        domain = projection.domain
        triangles = [domain.intersection(i) for i in triangles]

    if hasattr(ax, &#34;add_geometries&#34;) and projection is not None:
        ax.add_geometries(triangles, crs=projection, **kwargs)
    else:
        for triangle in triangles:
            ax.fill(*triangle.exterior.xy, **kwargs)


def _tesselate_triangles(
    geometries,
    width,
    polarity=&#34;left&#34;,
    height=None,
    spacing=None,
    projection=None,
    transform=None,
):
    &#34;&#34;&#34;Generate subduction teeth triangles for plotting.

    Forms continuous trench geometries and identifies their subduction polarities.
    Subduction teeth triangles can be customised with a given spacing and width.  
    Their apexes point in the identified polarity directions.

    Parameters
    ----------
    geometries : geopandas.GeoDataFrame, sequence of shapely geometries, or str
        If a `geopandas.GeoDataFrame` is given, its geometry attribute
        will be used. If `geometries` is a string, it must be the path to
        a file, which will be loaded with `geopandas.read_file`. Otherwise,
        `geometries` must be a sequence of shapely geometry objects (instances
        of the `shapely.geometry.base.BaseGeometry` class).
    width : float
        The (approximate) width of the subduction teeth. If a projection is
        used, this value will be in projected units.
    polarity : {&#34;left&#34;, &#34;l&#34;, &#34;right&#34;, &#34;r&#34;, None}, default &#34;left&#34;
        The subduction polarity of the geometries. If no polarity is provided,
        and `geometries` is a `geopandas.GeoDataFrame`, this function will
        attempt to find a `polarity` column in the data frame and use the
        values given there. If `polarity` is not manually specified and no
        appropriate column can be found, an error will be raised.
    height : float, default None
        If provided, the height of the subduction teeth. As with `width`,
        this value should be given in projected units. If no value is given,
        the height of the teeth will be equal to 0.6 * `width`.
    spacing : float, default None
        If provided, the spacing between the subduction teeth. As with
        `width` and `height`, this value should be given in projected units.
        If no value is given, `spacing` will default to `width`, producing
        tightly packed subduction teeth.
    projection : cartopy.crs.Transform, &#34;auto&#34;, or None, default None
        The projection of the plot. If the plot has no projection, this value
        can be explicitly given as `None`. The default value is &#34;auto&#34;, which
        will acquire the projection automatically from the plot axes.
    transform : cartopy.crs.Transform, or None, default None
        If the plot is projected, a `transform` value is usually needed.
        Frequently, the appropriate value is an instance of
        `cartopy.crs.PlateCarree`.

    Returns
    -------
    results : list of shapely Polygon objects
        Subduction teeth generated for the given geometries. 
    &#34;&#34;&#34;
    if width &lt;= 0.0:
        raise ValueError(&#34;Invalid `width` argument: {}&#34;.format(width))
    polarity = _parse_polarity(polarity)
    geometries = _parse_geometries(geometries)
    if height is None:
        height = width * 2.0/3.0
    if spacing is None:
        spacing = width

    if projection is not None:
        geometries_new = []
        for i in geometries:
            geometries_new.extend(
                _project_geometry(i, projection, transform)
            )
        geometries = geometries_new
        del geometries_new
    geometries = linemerge(geometries)
    if isinstance(geometries, BaseMultipartGeometry):
        geometries = list(geometries.geoms)
    elif isinstance(geometries, BaseGeometry):
        geometries = [geometries]
    results = _calculate_triangle_vertices(
        geometries,
        width,
        spacing,
        height,
        polarity,
    )
    return results


def _project_geometry(geometry, projection, transform=None):
    &#34;&#34;&#34;Project shapely geometries onto a certain Cartopy CRS map projection. 

    Uses a coordinate system (&#34;transform&#34;), if given. 

    Parameters
    ----------
    geometry : shapely.geometry.base.BaseGeometry
        An instance of a shapely geometry.
    projection : cartopy.crs.Transform, 
        The projection of the plot. 
    transform : cartopy.crs.Transform or None, default None
        If the plot is projected, a `transform` value is usually needed.
        Frequently, the appropriate value is an instance of
        `cartopy.crs.PlateCarree`.

    Returns
    -------
    projected : list
        The provided shapely geometries projected onto a Cartopy CRS map projection.
    &#34;&#34;&#34;
    if transform is None:
        transform = ccrs.PlateCarree()
    result = [projection.project_geometry(geometry, transform)]
    projected = []
    for i in result:
        if isinstance(i, BaseMultipartGeometry):
            projected.extend(list(i.geoms))
        else:
            projected.append(i)
    return projected


def _calculate_triangle_vertices(
    geometries,
    width,
    spacing,
    height,
    polarity,
):
    &#34;&#34;&#34;Generate vertices of subduction teeth triangles.

    Triangle bases are set on shapely BaseGeometry trench instances with their apexes 
    pointing in directions of subduction polarity. Triangle dimensions are set by a 
    specified width, spacing and height (either provided by the user or set as default
    values from _tesselate_triangles). The teeth are returned as shapely polygons.

    Parameters
    ----------
    geometries : list of shapely geometries (instances of the
        shapely.geometry.base.BaseGeometry or shapely.geometry.base.BaseMultipartGeometry
        class)
        Trench geometries projected onto a certain map projection (using a 
        coordinate system if specified), each with identified subduction polarities. 
        Teeth triangles will be generated only on the BaseGeometry instances. 
    width : float
        The (approximate) width of the subduction teeth. If a projection is
        used, this value will be in projected units.
    spacing : float,
        The spacing between the subduction teeth. As with
        `width` and `height`, this value should be given in projected units.
    height : float, default None
        The height of the subduction teeth. This value should also be given in projected
        units.
    polarity : {&#34;left&#34;, &#34;right&#34;}
        The subduction polarity of the shapely geometries. 
    
    Returns
    -------
    triangles : list of shapely polygons
        The subduction teeth generated along the supplied trench geometries. 
    &#34;&#34;&#34;
    if isinstance(geometries, BaseGeometry):
        geometries = [geometries]
    triangles = []
    for geometry in geometries:
        if not isinstance(geometry, BaseGeometry):
            continue
        length = geometry.length
        tesselated_x = []
        tesselated_y = []
        for distance in np.arange(spacing, length, spacing):
            point = Point(geometry.interpolate(distance))
            tesselated_x.append(point.x)
            tesselated_y.append(point.y)
        tesselated_x = np.array(tesselated_x)
        tesselated_y = np.array(tesselated_y)

        for i in range(len(tesselated_x) - 1):
            normal_x = tesselated_y[i] - tesselated_y[i + 1]
            normal_y = tesselated_x[i + 1] - tesselated_x[i]
            normal = np.array((normal_x, normal_y))
            normal_mag = np.sqrt((normal ** 2).sum())
            if normal_mag == 0:
                continue
            normal *= height / normal_mag
            midpoint = np.array((tesselated_x[i], tesselated_y[i]))
            if polarity == &#34;right&#34;:
                normal *= -1.0
            apex = midpoint + normal

            next_midpoint = np.array((tesselated_x[i + 1], tesselated_y[i + 1]))
            line_vector = np.array(next_midpoint - midpoint)
            line_vector_mag = np.sqrt((line_vector ** 2).sum())
            line_vector /= line_vector_mag
            triangle_point_a = midpoint + width * 0.5 * line_vector
            triangle_point_b = midpoint - width * 0.5 * line_vector
            triangle_points = np.array(
                (
                    triangle_point_a,
                    triangle_point_b,
                    apex,
                )
            )
            triangles.append(Polygon(triangle_points))
    return triangles


def _parse_polarity(polarity):
    &#34;&#34;&#34;Ensure subduction polarities have valid strings as labels - either &#34;left&#34;, &#34;l&#34;, &#34;right&#34; or &#34;r&#34;.

    The geometries&#39; subduction polarities are either provided by the user in plot_subduction_teeth
    or found automatically in a geopandas.GeoDataFrame column by _find_polarity_column, if such a
    column exists.
 
    Parameters
    ----------
    polarity : {&#34;left&#34;, &#34;l&#34;, &#34;right&#34;, &#34;r&#34;}
        The subduction polarity of the geometries (either set by the user or found automatically
        from the geometries&#39; data frame). 

    Returns
    -------
    polarity : {&#34;left&#34;, &#34;right&#34;}
        Returned if the provided polarity string is one of {&#34;left&#34;, &#34;l&#34;, &#34;right&#34;, &#34;r&#34;}. &#34;l&#34; and &#34;r&#34;
        are classified and returned as &#34;left&#34; and &#34;right&#34; respectively.  

    Raises
    ------
    TypeError
        If the provided polarity is not a string type.
    ValueError
        If the provided polarity is not valid (&#34;left&#34;, &#34;l&#34;, &#34;right&#34; or &#34;r&#34;).
    &#34;&#34;&#34;
    if not isinstance(polarity, str):
        raise TypeError(
            &#34;Invalid `polarity` argument type: {}&#34;.format(type(polarity))
        )
    if polarity.lower() in {&#34;left&#34;, &#34;l&#34;}:
        polarity = &#34;left&#34;
    elif polarity.lower() in {&#34;right&#34;, &#34;r&#34;}:
        polarity = &#34;right&#34;
    else:
        valid_args = {&#34;left&#34;, &#34;l&#34;, &#34;right&#34;, &#34;r&#34;}
        err_msg = &#34;Invalid `polarity` argument: {}&#34;.format(
            polarity
        ) + &#34;\n(must be one of: {})&#34;.format(valid_args)
        raise ValueError(err_msg)
    return polarity


def _find_polarity_column(columns):
    &#34;&#34;&#34;Search for a &#39;polarity&#39; column in a geopandas.GeoDataFrame to extract subduction
    polarity values.

    Subduction polarities can be used for tessellating subduction teeth.

    Parameters
    ----------
    columns : geopandas.GeoDataFrame.columns.values instance
        A list of geopandas.GeoDataFrame column header strings.

    Returns
    -------
    column : list
        If found, returns a list of all subduction polarities ascribed to the supplied
        geometry data frame.
    None
        if a &#39;polarity&#39; column was not found in the data frame. In this case, subduction
        polarities will have to be manually provided to plot_subduction_teeth.

    &#34;&#34;&#34;
    pattern = &#34;polarity&#34;
    for column in columns:
        if re.fullmatch(pattern, column) is not None:
            return column
    return None


def _parse_geometries(geometries):
    &#34;&#34;&#34;Resolve a geopandas.GeoSeries object into shapely BaseGeometry and/or
    BaseMutipartGeometry instances.

    Parameters
    ----------
    geometries : geopandas.GeoDataFrame, sequence of shapely geometries, or str
        If a `geopandas.GeoDataFrame` is given, its geometry attribute
        will be used. If `geometries` is a string, it must be the path to
        a file, which will be loaded with `geopandas.read_file`. Otherwise,
        `geometries` must be a sequence of shapely geometry objects (instances
        of the `shapely.geometry.base.BaseGeometry` class).

    Returns
    -------
    out : list
        Resolved shapely BaseMutipartGeometry and/or BaseGeometry instances.
    &#34;&#34;&#34;
    geometries = _get_geometries(geometries)
    if isinstance(geometries, gpd.GeoSeries):
        geometries = list(geometries)

    # Explode multi-part geometries
    # Weirdly the following seems to be faster than
    # the equivalent explode() method from GeoPandas:
    out = []
    for i in geometries:
        if isinstance(i, BaseMultipartGeometry):
            out.extend(list(i.geoms))
        else:
            out.append(i)
    return out


def shapelify_features(features, central_meridian=0.0, tessellate_degrees=None):
    &#34;&#34;&#34;Generate Shapely `MultiPolygon` or `MultiLineString` geometries
    from reconstructed feature polygons.
    
    Notes
    -----
    Some Shapely polygons generated by `shapelify_features` cut longitudes of 180 
    or -180 degrees. These features may appear unclosed at the dateline, so Shapely 
    &#34;closes&#34; these polygons by connecting any of their open ends with lines. These 
    lines may manifest on GeoAxes plots as horizontal lines that span the entire 
    global extent. To prevent this, `shapelify_features` uses pyGPlates&#39; 
    [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
    to split a feature polygon into multiple closed polygons if it happens to cut the 
    antimeridian.
    Another measure taken to ensure features are valid is to order exterior coordinates 
    of Shapely polygons anti-clockwise. 

    Parameters
    ----------
    features : iterable of &lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt; or &lt;GeometryOnSphere&gt;
        Iterable containing reconstructed polygon features.
    central_meridian : float
        Central meridian around which to perform wrapping; default: 0.0.
    tessellate_degrees : float or None
        If provided, geometries will be tessellated to this resolution prior
        to wrapping.

    Returns
    -------
    all_geometries : list of `shapely.geometry.BaseGeometry`
        Shapely geometries converted from the given reconstructed features. Any
        geometries at the dateline are split. 

    See Also
    --------
    geometry.pygplates_to_shapely : convert PyGPlates geometry objects to
    Shapely geometries.
    &#34;&#34;&#34;
    if isinstance(
        features,
        (
            pygplates.Feature,
            pygplates.ReconstructedFeatureGeometry,
            pygplates.GeometryOnSphere,
        ),
    ):
        features = [features]

    geometries = []
    for feature in features:
        if isinstance(feature, pygplates.Feature):
            geometries.extend(feature.get_all_geometries())
        elif isinstance(feature, pygplates.ReconstructedFeatureGeometry):
            geometries.append(feature.get_reconstructed_geometry())
        elif isinstance(feature, (pygplates.GeometryOnSphere, pygplates.LatLonPoint)):
            geometries.append(feature)
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonMultiPoint):
            geometries.append(
                pygplates.MultiPointOnSphere(
                    [i.to_lat_lon() for i in feature.get_points()]
                )
            )
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonPolyline):
            geometries.append(pygplates.PolylineOnSphere(feature.get_points()))
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonPolygon):
            geometries.append(
                pygplates.PolygonOnSphere(
                    [i.to_lat_lon() for i in feature.get_exterior_points()]
                )
            )

    return [
        pygplates_to_shapely(
            i,
            force_ccw=True,
            validate=True,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
            explode=False,
        )
        for i in geometries
    ]


shapelify_feature_lines = shapelify_features
shapelify_feature_polygons = shapelify_features


class PlotTopologies(object):
    &#34;&#34;&#34;A class with tools to read, reconstruct and plot topology features at specific
    reconstruction times.

    `PlotTopologies` is a shorthand for PyGPlates and Shapely functionalities that:

    * Read features held in GPlates GPML (GPlates Markup Language) files and 
    ESRI shapefiles;
    * Reconstruct the locations of these features as they migrate through
    geological time; 
    * Turn these reconstructed features into Shapely geometries for plotting 
    on `cartopy.mpl.geoaxes.GeoAxes` or `cartopy.mpl.geoaxes.GeoAxesSubplot` map 
    Projections. 

    To call the `PlotTopologies` object, supply: 

    * an instance of the GPlately `PlateReconstruction_object`
    * a reconstruction `time`

    and optionally, 

    * a `coastline_filename`
    * a `continent_filename`
    * a `COB_filename`
    * an `anchor_plate_id`

    For example:

        # Calling the PlotTopologies object
        gplot = gplately.plot.PlotTopologies(plate_reconstruction_object,
                                            time,
                                            coastline_filename,
                                            continent_filename,
                                            COB_filename,
                                            anchor_plate_id,
                )

    The `coastline_filename`, `continent_filename` and `COB_filename` can be single
    strings to GPML and/or shapefiles, as well as instances of `pygplates.FeatureCollection`. 
    If using GPlately&#39;s `DataServer` object to source these files, they will be passed as 
    `pygplates.FeatureCollection` items.

    Some features for plotting (like plate boundaries) are taken from the `PlateReconstruction` 
    object&#39;s`topology_features` attribute. They have already been reconstructed to the given
    `time` using [Plate Tectonic Tools](https://github.com/EarthByte/PlateTectonicTools).


    A variety of geological features can be plotted on GeoAxes/GeoAxesSubplot maps 
    as Shapely `MultiLineString` or `MultiPolygon` geometries, including:
    
    * subduction boundaries &amp; subduction polarity teeth
    * mid-ocean ridge boundaries
    * transform boundaries
    * miscellaneous boundaries
    * coastline polylines
    * continental polygons and 
    * continent-ocean boundary polylines
    * topological plate velocity vector fields
    * netCDF4 MaskedArray or ndarray raster data:
        - seafloor age grids 
        - paleo-age grids
        - global relief (topography and bathymetry)
    * assorted reconstructable feature data, for example:
        - seafloor fabric
        - large igneous provinces 
        - volcanic provinces

    Attributes
    ----------
    PlateReconstruction_object : instance of &lt;gplately.reconstruction.PlateReconstruction&gt;
        The GPlately `PlateReconstruction` object will be used to access a plate 
        `rotation_model` and a set of `topology_features` which contains plate boundary 
        features like trenches, ridges and transforms.

    anchor_plate_id : int, default 0
        The anchor plate ID used for reconstruction.

    base_projection : instance of &lt;cartopy.crs.{transform}&gt;, default &lt;cartopy.crs.PlateCarree&gt; object
        where {transform} is the map Projection to use on the Cartopy GeoAxes. 
        By default, the base projection is set to cartopy.crs.PlateCarree. See the 
        [Cartopy projection list](https://scitools.org.uk/cartopy/docs/v0.15/crs/projections.html)
        for all supported Projection types.

    coastlines : str, or instance of &lt;pygplates.FeatureCollection&gt;
        The full string path to a coastline feature file. Coastline features can also 
        be passed as instances of the `pygplates.FeatureCollection` object (this is 
        the case if these features are sourced from the `DataServer` object).

    continents : str, or instance of &lt;pygplates.FeatureCollection&gt;
        The full string path to a continent feature file. Continent features can also 
        be passed as instances of the `pygplates.FeatureCollection` object (this is 
        the case if these features are sourced from the `DataServer` object).

    COBs : str, or instance of &lt;pygplates.FeatureCollection&gt;
        The full string path to a COB feature file. COB features can also be passed 
        as instances of the `pygplates.FeatureCollection` object (this is the case 
        if these features are sourced from the `DataServer` object).

    coastlines : iterable/list of &lt;pygplates.ReconstructedFeatureGeometry&gt;
        A list containing coastline features reconstructed to the specified `time` attribute. 

    continents : iterable/list of &lt;pygplates.ReconstructedFeatureGeometry&gt;
        A list containing continent features reconstructed to the specified `time` attribute. 

    COBs : iterable/list of &lt;pygplates.ReconstructedFeatureGeometry&gt;
        A list containing COB features reconstructed to the specified `time` attribute.

    time : float
        The time (Ma) to reconstruct and plot geological features to.

    topologies : iterable/list of &lt;pygplates.Feature&gt;
        A list containing assorted topologies like:

        - pygplates.FeatureType.gpml_topological_network
        - pygplates.FeatureType.gpml_oceanic_crust
        - pygplates.FeatureType.gpml_topological_slab_boundary
        - pygplates.FeatureType.gpml_topological_closed_plate_boundary

    ridge_transforms : iterable/list of &lt;pygplates.Feature&gt;
        A list containing ridge and transform boundary sections of type 
        pygplates.FeatureType.gpml_mid_ocean_ridge

    ridges : iterable/list of &lt;pygplates.Feature&gt;
        A list containing ridge boundary sections of type pygplates.FeatureType.gpml_mid_ocean_ridge
    
    transforms : iterable/list of &lt;pygplates.Feature&gt;
        A list containing transform boundary sections of type pygplates.FeatureType.gpml_mid_ocean_ridge

    trenches : iterable/list of &lt;pygplates.Feature&gt;
        A list containing trench boundary sections of type pygplates.FeatureType.gpml_subduction_zone

    trench_left : iterable/list of &lt;pygplates.Feature&gt;
        A list containing left subduction boundary sections of type pygplates.FeatureType.gpml_subduction_zone

    trench_right : iterable/list of &lt;pygplates.Feature&gt;
        A list containing right subduction boundary sections of type pygplates.FeatureType.gpml_subduction_zone

    other : iterable/list of &lt;pygplates.Feature&gt;
        A list containing other geological features like unclassified features, extended continental crusts,
        continental rifts, faults, orogenic belts, fracture zones, inferred paleo boundaries, terrane 
        boundaries and passive continental boundaries.

    &#34;&#34;&#34;
    def __init__(
        self,
        PlateReconstruction_object,
        time,
        coastlines=None,
        continents=None,
        COBs=None,
        anchor_plate_id=0,
    ):
        self.PlateReconstruction_object = PlateReconstruction_object
        self.plate_model = self.PlateReconstruction_object

        if self.plate_model.topology_features is None:
            raise ValueError(&#34;Plate model must have topology features.&#34;)

        self.base_projection = ccrs.PlateCarree()

        # store these for when time is updated
        # make sure these are initialised as FeatureCollection objects

        self._coastlines = _load_FeatureCollection(coastlines)
        self._continents = _load_FeatureCollection(continents)
        self._COBs = _load_FeatureCollection(COBs)

        self.coastlines = None
        self.continents = None
        self.COBs = None

        self._anchor_plate_id = self._check_anchor_plate_id(anchor_plate_id)

        # store topologies for easy access
        # setting time runs the update_time routine
        self.time = time

    def __getstate__(self):

        filenames = self.PlateReconstruction_object.__getstate__()

        # add important variables from Points object
        if self._coastlines:
            filenames[&#34;coastlines&#34;] = self._coastlines.filenames
        if self._continents:
            filenames[&#34;continents&#34;] = self._continents.filenames
        if self._COBs:
            filenames[&#34;COBs&#34;] = self._COBs.filenames
        filenames[&#39;time&#39;] = self.time
        filenames[&#39;plate_id&#39;] = self._anchor_plate_id

        del self.coastlines, self.continents, self.COBs
        del self._coastlines, self._continents, self._COBs

        self.coastlines = None
        self.continents = None
        self.COBs = None
        self._coastlines = None
        self._continents = None
        self._COBs = None

        return filenames

    def __setstate__(self, state):

        self.PlateReconstruction_object = _PlateReconstruction(state[&#39;rotation_model&#39;], state[&#39;topology_features&#39;], state[&#39;static_polygons&#39;])

        self._coastlines = None
        self._continents = None
        self._COBs = None
        self.coastlines = None
        self.continents = None
        self.COBs = None

        # reinstate unpicklable items
        if &#39;coastlines&#39; in state:
            self._coastlines = _FeatureCollection()
            for feature in state[&#39;coastlines&#39;]:
                self._coastlines.add( _FeatureCollection(feature) )

        if &#39;continents&#39; in state:
            self._continents = _FeatureCollection()
            for feature in state[&#39;continents&#39;]:
                self._continents.add( _FeatureCollection(feature) )

        if &#39;COBs&#39; in state:
            self._COBs = _FeatureCollection()
            for feature in state[&#39;COBs&#39;]:
                self._COBs.add( _FeatureCollection(feature) )


        self._anchor_plate_id = state[&#34;plate_id&#34;]
        self.time = state[&#39;time&#39;]


    @property
    def time(self):
        &#34;&#34;&#34; The reconstruction time.&#34;&#34;&#34;
        return self._time

    @time.setter
    def time(self, var):
        &#34;&#34;&#34;Allows the time attribute to be changed. Updates all instances of the time attribute in the object (e.g.
        reconstructions and resolving topologies will use this new time).

        Raises
        ------
        ValueError
            If the chosen reconstruction time is &lt;0 Ma.
        &#34;&#34;&#34;
        if var &gt;= 0:
            self.update_time(var)
        else:
            raise ValueError(&#34;Enter a valid time &gt;= 0&#34;)

    @property
    def anchor_plate_id(self):
        &#34;&#34;&#34;Anchor plate ID for reconstruction. Must be an integer &gt;= 0.&#34;&#34;&#34;
        return self._anchor_plate_id

    @anchor_plate_id.setter
    def anchor_plate_id(self, anchor_plate):
        self._anchor_plate_id = self._check_anchor_plate_id(anchor_plate)
        self.update_time(self.time)

    @staticmethod
    def _check_anchor_plate_id(id):
        id = int(id)
        if id &lt; 0:
            raise ValueError(
                &#34;Invalid anchor plate ID: {}&#34;.format(id)
            )
        return id

    def update_time(self, time):
        &#34;&#34;&#34;Re-reconstruct features and topologies to the time specified by the `PlotTopologies` `time` attribute 
        whenever it or the anchor plate is updated.

        Notes
        -----
        The following `PlotTopologies` attributes are updated whenever a reconstruction `time` attribute is set:

        - resolved topology features (topological plates and networks)
        - ridge and transform boundary sections (resolved features)
        - ridge boundary sections (resolved features)
        - transform boundary sections (resolved features)
        - subduction boundary sections (resolved features)
        - left subduction boundary sections (resolved features)
        - right subduction boundary sections (resolved features)
        - other boundary sections (resolved features) that are not subduction zones or mid-ocean ridges 
        (ridge/transform)

        Moreover, coastlines, continents and COBs are reconstructed to the new specified `time`.
        &#34;&#34;&#34;
        self._time = float(time)
        resolved_topologies = ptt.resolve_topologies.resolve_topologies_into_features(
            self.PlateReconstruction_object.rotation_model,
            self.PlateReconstruction_object.topology_features,
            self.time)

        self.topologies, self.ridge_transforms, self.ridges, self.transforms, self.trenches, self.trench_left, self.trench_right, self.other = resolved_topologies

        # miscellaneous boundaries
        self.continental_rifts = []
        self.faults = []
        self.fracture_zones = []
        self.inferred_paleo_boundaries = []
        self.terrane_boundaries = []
        self.transitional_crusts = []
        self.orogenic_belts = []
        self.sutures = []
        self.continental_crusts = []
        self.extended_continental_crusts = []
        self.passive_continental_boundaries = []
        self.slab_edges = []
        self.misc_transforms = []
        self.unclassified_features = []

        for topol in self.other:
            if topol.get_feature_type() == pygplates.FeatureType.gpml_continental_rift:
                self.continental_rifts.append(topol)

            elif topol.get_feature_type() == pygplates.FeatureType.gpml_fault:
                self.faults.append(topol)
                    
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_fracture_zone:
                self.fracture_zones.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_inferred_paleo_boundary:
                self.inferred_paleo_boundaries.append(topol)

            elif topol.get_feature_type() == pygplates.FeatureType.gpml_terrane_boundary:
                self.terrane_boundaries.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_transitional_crust:
                self.transitional_crusts.append(topol)
            
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_orogenic_belt:
                self.orogenic_belts.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_suture:
                self.sutures.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_continental_crust:
                self.continental_crusts.append(topol)
            
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_extended_continental_crust:
                self.extended_continental_crusts.append(topol)
            
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_passive_continental_boundary:
                self.passive_continental_boundaries.append(topol)
            
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_slab_edge:
                self.slab_edges.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_transform:
                self.misc_transforms.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_unclassified_feature:
                self.unclassified_features.append(topol)

        # reconstruct other important polygons and lines
        if self._coastlines:
            self.coastlines = self.PlateReconstruction_object.reconstruct(
                self._coastlines, self.time, from_time=0, anchor_plate_id=self.anchor_plate_id)

        if self._continents:
            self.continents = self.PlateReconstruction_object.reconstruct(
                self._continents, self.time, from_time=0, anchor_plate_id=self.anchor_plate_id)

        if self._COBs:
            self.COBs = self.PlateReconstruction_object.reconstruct(
                self._COBs, self.time, from_time=0, anchor_plate_id=self.anchor_plate_id)


    # subduction teeth
    def _tesselate_triangles(self, features, tesselation_radians, triangle_base_length, triangle_aspect=1.0):
        &#34;&#34;&#34;Places subduction teeth along subduction boundary line segments within a MultiLineString shapefile. 

        Parameters
        ----------
        shapefilename  : str  
            Path to shapefile containing the subduction boundary features

        tesselation_radians : float
            Parametrises subduction teeth density. Triangles are generated only along line segments with distances
            that exceed the given threshold tessellation_radians.

        triangle_base_length : float  
            Length of teeth triangle base
        
        triangle_aspect : float, default=1.0  
            Aspect ratio of teeth triangles. Ratio is 1.0 by default.

        Returns
        -------
        X_points : (n,3) array 
            X points that define the teeth triangles
        Y_points : (n,3) array 
            Y points that define the teeth triangles
        &#34;&#34;&#34;

        tesselation_degrees = np.degrees(tesselation_radians)
        triangle_pointsX = []
        triangle_pointsY = []

        date_line_wrapper = pygplates.DateLineWrapper()


        for feature in features:

            cum_distance = 0.0

            for geometry in feature.get_geometries():
                wrapped_lines = date_line_wrapper.wrap(geometry)
                for line in wrapped_lines:
                    pts = np.array([(p.get_longitude(), p.get_latitude()) for p in line.get_points()])

                    for p in range(0, len(pts) - 1):
                        A = pts[p]
                        B = pts[p+1]

                        AB_dist = B - A
                        AB_norm = AB_dist / np.hypot(*AB_dist)
                        cum_distance += np.hypot(*AB_dist)

                        # create a new triangle if cumulative distance is exceeded.
                        if cum_distance &gt;= tesselation_degrees:

                            C = A + triangle_base_length*AB_norm

                            # find normal vector
                            AD_dist = np.array([AB_norm[1], -AB_norm[0]])
                            AD_norm = AD_dist / np.linalg.norm(AD_dist)

                            C0 = A + 0.5*triangle_base_length*AB_norm

                            # project point along normal vector
                            D = C0 + triangle_base_length*triangle_aspect*AD_norm

                            triangle_pointsX.append( [A[0], C[0], D[0]] )
                            triangle_pointsY.append( [A[1], C[1], D[1]] )

                            cum_distance = 0.0

        return np.array(triangle_pointsX), np.array(triangle_pointsY)

    def plot_feature(self, ax, feature, **kwargs):
        shp = shapelify_features(feature)
        gdf = gpd.GeoDataFrame({&#39;geometry&#39;: shp}, geometry=&#39;geometry&#39;)
        return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)

    def plot_coastlines(self, ax, **kwargs):
        &#34;&#34;&#34;Plot reconstructed coastline polygons onto a standard map Projection. 

        Notes
        -----
        The `coastlines` for plotting are accessed from the `PlotTopologies` object&#39;s
        `coastlines` attribute. These `coastlines` are reconstructed to the `time` 
        passed to the `PlotTopologies` object and converted into Shapely polylines. The
        reconstructed `coastlines` are added onto the GeoAxes or GeoAxesSubplot map `ax` using
        GeoPandas.
        Map resentation details (e.g. facecolor, edgecolor, alpha…) are permitted as keyword
        arguments.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        **kwargs : 
            Keyword arguments for parameters such as `facecolor`, `alpha`, 
            etc. for plotting coastline geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with coastline features plotted onto the chosen map projection. 
        &#34;&#34;&#34;

        if self.coastlines is None:
            raise ValueError(&#34;Supply coastline_filename to PlotTopologies object&#34;)

        coastline_polygons = shapelify_feature_polygons(self.coastlines)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: coastline_polygons}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)

    def plot_continents(self, ax, **kwargs):
        &#34;&#34;&#34;Plot reconstructed continental polygons onto a standard map Projection. 

        Notes
        -----
        The `continents` for plotting are accessed from the `PlotTopologies` object&#39;s
        `continents` attribute. These `continents` are reconstructed to the `time` 
        passed to the `PlotTopologies` object and converted into Shapely polygons. 
        The reconstructed `coastlines` are plotted onto the GeoAxes or GeoAxesSubplot map `ax` using
        GeoPandas.
        Map presentation details (e.g. facecolor, edgecolor, alpha…) are permitted as
        keyword arguments.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        **kwargs : 
            Keyword arguments for parameters such as `facecolor`, `alpha`, 
            etc. for plotting continental geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with continent features plotted onto the chosen map projection. 
        &#34;&#34;&#34;
        if self.continents is None:
            raise ValueError(&#34;Supply continent_filename to PlotTopologies object&#34;)

        continent_polygons = shapelify_feature_polygons(self.continents)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: continent_polygons}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)

    def plot_continent_ocean_boundaries(self, ax, **kwargs):
        &#34;&#34;&#34;Plot reconstructed continent-ocean boundary (COB) polygons onto a standard 
        map Projection. 

        Notes
        -----
        The `COBs` for plotting are accessed from the `PlotTopologies` object&#39;s
        `COBs` attribute. These `COBs` are reconstructed to the `time` 
        passed to the `PlotTopologies` object and converted into Shapely polylines. 
        The reconstructed `COBs` are plotted onto the GeoAxes or GeoAxesSubplot map 
        `ax` using GeoPandas. Map presentation details (e.g. `facecolor`, `edgecolor`, `alpha`…) 
        are permitted as keyword arguments.

        These COBs are transformed into shapely
        geometries and added onto the chosen map for a specific geological time (supplied to the 
        PlotTopologies object). Map presentation details (e.g. facecolor, edgecolor, alpha…) 
        are permitted.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        **kwargs : 
            Keyword arguments for parameters such as `facecolor`, `alpha`, 
            etc. for plotting COB geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with COB features plotted onto the chosen map projection. 
        &#34;&#34;&#34;
        if self.COBs is None:
            raise ValueError(&#34;Supply COB_filename to PlotTopologies object&#34;)

        COB_lines = shapelify_feature_lines(self.COBs)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: COB_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)

    def plot_ridges(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed ridge polylines onto a standard map Projection. 
        
        Notes
        -----
        The `ridges` for plotting are accessed from the `PlotTopologies` object&#39;s
        `ridges` attribute. These `ridges` are reconstructed to the `time` 
        passed to the `PlotTopologies` object and converted into Shapely polylines. 
        The reconstructed `ridges` are plotted onto the GeoAxes or GeoAxesSubplot map 
        `ax` using GeoPandas. Map presentation details (e.g. `facecolor`, `edgecolor`, `alpha`…) 
        are permitted as keyword arguments.

        Ridge geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper) 
        by splitting a polyline into multiple polylines at the dateline. This is to avoid 
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
        compatibility with Cartopy. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the ridge lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. for 
            plotting ridge geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with ridge features plotted onto the chosen map projection. 
        &#34;&#34;&#34;
        ridge_lines = shapelify_feature_lines(self.ridges)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: ridge_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)

    def plot_ridges_and_transforms(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed ridge &amp; transform boundary polylines onto a standard map
        Projection. 

        Notes
        -----
        The ridge &amp; transform sections for plotting are accessed from the 
        `PlotTopologies` object&#39;s `ridge_transforms` attribute. These `ridge_transforms` 
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
        into Shapely polylines. The reconstructed `ridge_transforms` are plotted onto the 
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Note: Ridge &amp; transform geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper) 
        by splitting a polyline into multiple polylines at the dateline. This is to avoid 
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
        compatibility with Cartopy. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the ridge &amp; transform lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as ‘alpha’, etc. for 
            plotting ridge &amp; transform geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with ridge &amp; transform features plotted onto the chosen map projection. 
        &#34;&#34;&#34;
        ridge_transform_lines = shapelify_feature_lines(self.ridge_transforms)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: ridge_transform_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)

    def plot_transforms(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed transform boundary polylines onto a standard map. 

        Notes
        -----
        The transform sections for plotting are accessed from the 
        `PlotTopologies` object&#39;s `transforms` attribute. These `transforms` 
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
        into Shapely polylines. The reconstructed `transforms` are plotted onto the 
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Transform geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
        by splitting a polyline into multiple polylines at the dateline. This is to avoid 
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
        compatibility with Cartopy. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the transform lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting transform geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with transform features plotted onto the chosen map projection.
        &#34;&#34;&#34;
        transform_lines = shapelify_feature_lines(self.transforms)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: transform_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)

    def plot_trenches(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed subduction trench polylines onto a standard map
        Projection. 

        Notes
        -----
        The trench sections for plotting are accessed from the 
        `PlotTopologies` object&#39;s `trenches` attribute. These `trenches` 
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
        into Shapely polylines. The reconstructed `trenches` are plotted onto the 
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Trench geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
        by splitting a polyline into multiple polylines at the dateline. This is to avoid 
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
        compatibility with Cartopy. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with transform features plotted onto the chosen map projection.
        &#34;&#34;&#34;
        trench_lines = shapelify_feature_lines(self.trenches)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: trench_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)

    def plot_misc_boundaries(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed miscellaneous plate boundary polylines onto a standard 
        map Projection.

        Notes
        -----
        The miscellaneous boundary sections for plotting are accessed from the 
        `PlotTopologies` object&#39;s `other` attribute. These `other` boundaries
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
        into Shapely polylines. The reconstructed `other` boundaries are plotted onto the 
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Miscellaneous boundary geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
        by splitting a polyline into multiple polylines at the dateline. This is to avoid 
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
        compatibility with Cartopy. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the boundary lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as ‘alpha’, etc. for 
            plotting miscellaneous boundary geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with miscellaneous boundary features plotted onto the chosen map projection.
        &#34;&#34;&#34;
        lines = shapelify_features(self.other)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)

    def plot_subduction_teeth_deprecated(self, ax, spacing=0.1, size=2.0, aspect=1, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot subduction teeth onto a standard map Projection. 

        Notes
        -----
        Subduction teeth are tessellated from `PlotTopologies` object attributes `trench_left` and 
        `trench_right`, and transformed into Shapely polygons for plotting. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        spacing : float, default=0.1 
            The tessellation threshold (in radians). Parametrises subduction tooth density. 
            Triangles are generated only along line segments with distances that exceed 
            the given threshold ‘spacing’.

        size : float, default=2.0
            Length of teeth triangle base.

        aspect : float, default=1
            Aspect ratio of teeth triangles. Ratio is 1.0 by default. 

        color : str, default=’black’
            The colour of the teeth. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as ‘alpha’, etc. for 
            plotting subduction tooth polygons.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with subduction teeth plotted onto the chosen map projection.
        &#34;&#34;&#34;
        import shapely

        # add Subduction Teeth
        subd_xL, subd_yL = self._tesselate_triangles(
            self.trench_left,
            tesselation_radians=spacing,
            triangle_base_length=size,
            triangle_aspect=-aspect)
        subd_xR, subd_yR = self._tesselate_triangles(
            self.trench_right,
            tesselation_radians=spacing,
            triangle_base_length=size,
            triangle_aspect=aspect)
        
        teeth = []
        for tX, tY in zip(subd_xL, subd_yL):
            triangle_xy_points = np.c_[tX, tY]
            shp = shapely.geometry.Polygon(triangle_xy_points)
            teeth.append(shp)

        for tX, tY in zip(subd_xR, subd_yR):
            triangle_xy_points = np.c_[tX, tY]
            shp = shapely.geometry.Polygon(triangle_xy_points)
            teeth.append(shp)

        return ax.add_geometries(teeth, crs=self.base_projection, color=color, **kwargs)


    def plot_subduction_teeth(self, ax, spacing=0.07, size=None, aspect=None, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot subduction teeth onto a standard map Projection.  

        Notes
        -----
        Subduction teeth are tessellated from `PlotTopologies` object attributes `trench_left` and 
        `trench_right`, and transformed into Shapely polygons for plotting. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        spacing : float, default=0.1 
            The tessellation threshold (in radians). Parametrises subduction tooth density. 
            Triangles are generated only along line segments with distances that exceed 
            the given threshold ‘spacing’.

        size : float, default=None
            Length of teeth triangle base (in radians). If kept at `None`, then
            `size = 0.5*spacing`.

        aspect : float, default=None
            Aspect ratio of teeth triangles. If kept at `None`, then `aspect = 2/3*size`.

        color : str, default=’black’
            The colour of the teeth. By default, it is set to black.

        **kwargs : 
            Keyword arguments parameters such as ‘alpha’, etc. 
            for plotting subduction tooth polygons.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with subduction teeth plotted onto the chosen map projection.
        &#34;&#34;&#34;

        spacing = spacing * EARTH_RADIUS * 1e3

        if aspect is None:
            aspect = 2.0/3.0
        if size is None:
            size = spacing*0.5

        height = size*aspect

        trench_left_features  = shapelify_feature_lines(self.trench_left)
        trench_right_features = shapelify_feature_lines(self.trench_right)

        return(
            plot_subduction_teeth(trench_left_features,  size, &#39;l&#39;, height, spacing, ax=ax, color=color, **kwargs),
            plot_subduction_teeth(trench_right_features,  size, &#39;r&#39;, height, spacing, ax=ax, color=color, **kwargs)
        )

    def plot_plate_id(self, ax, plate_id, **kwargs):
        &#34;&#34;&#34;Plot a plate polygon with an associated `plate_id` onto a standard map Projection. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        plate_id : int
            A plate ID that identifies the continental polygon to plot. See the 
            [Global EarthByte plate IDs list](https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/SampleData/FeatureCollections/Rotations/Global_EarthByte_PlateIDs_20071218.pdf)
            for a full list of plate IDs to plot.

        **kwargs : 
            Keyword arguments for map presentation parameters such as 
            `alpha`, etc. for plotting the grid.
            See `Matplotlib`&#39;s `imshow` keyword arguments 
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        &#34;&#34;&#34;
        for feature in self.topologies:
            if feature.get_reconstruction_plate_id() == plate_id:
                ft_plate = shapelify_feature_polygons([feature])
                return ax.add_geometries(ft_plate, crs=self.base_projection, **kwargs)


    def plot_grid(self, ax, grid, extent=[-180,180,-90,90], **kwargs):
        &#34;&#34;&#34;Plot a `MaskedArray` raster or grid onto a standard map Projection. 

        Notes
        -----
        Uses Matplotlib&#39;s `imshow` 
        [function](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        grid : MaskedArray
            A `MaskedArray` with elements that define a grid. The number of rows in the raster
            corresponds to the number of latitudinal coordinates, while the number of raster 
            columns corresponds to the number of longitudinal coordinates.

        extent : 1d array, default=[-180,180,-90,90]
            A four-element array to specify the [min lon, max lon, min lat, max lat] with 
            which to constrain the grid image. If no extents are supplied, full global 
            extent is assumed. 

        **kwargs : 
            Keyword arguments for map presentation parameters such as 
            `alpha`, etc. for plotting the grid.
            See `Matplotlib`&#39;s `imshow` keyword arguments 
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with the grid plotted onto the chosen map projection.
        &#34;&#34;&#34;
        # Override matplotlib default origin (&#39;upper&#39;)
        origin = kwargs.pop(&#34;origin&#34;, &#34;lower&#34;)
        return ax.imshow(
            grid,
            extent=extent,
            transform=self.base_projection,
            origin=origin,
            **kwargs,
        )


    def plot_grid_from_netCDF(self, ax, filename, **kwargs):
        &#34;&#34;&#34;Read a raster from a netCDF file, convert it to a `MaskedArray` and plot it 
        onto a standard map Projection. 

        Notes
        -----
        `plot_grid_from_netCDF` uses Matplotlib&#39;s `imshow` 
        [function](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        filename : str
            Full path to a netCDF filename.

        **kwargs : 
            Keyword arguments for map presentation parameters for 
            plotting the grid. See `Matplotlib`&#39;s `imshow` keyword arguments 
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with the netCDF grid plotted onto the chosen map projection.
        &#34;&#34;&#34;
        from .grids import read_netcdf_grid

        raster, lon_coords, lat_coords = read_netcdf_grid(filename, return_grids=True)
        extent = [lon_coords.min(), lon_coords.max(), lat_coords.min(), lat_coords.max()]
        return self.plot_grid(ax, raster, extent=extent, **kwargs)


    def plot_plate_motion_vectors(self, ax, spacingX=10, spacingY=10, normalise=False, **kwargs):
        &#34;&#34;&#34;Calculate plate motion velocity vector fields at a particular geological time 
        and plot them onto a standard map Projection. 
        
        Notes
        -----
        `plot_plate_motion_vectors` generates a MeshNode domain of point features using 
        given spacings in the X and Y directions (`spacingX` and `spacingY`). Each point in
        the domain is assigned a plate ID, and these IDs are used to obtain equivalent stage 
        rotations of identified tectonic plates over a 5 Ma time interval. Each point and 
        its stage rotation are used to calculate plate velocities at a particular geological 
        time. Velocities for each domain point are represented in the north-east-down 
        coordinate system and plotted on a GeoAxes.
        
        Vector fields can be optionally normalised by setting `normalise` to `True`. This
        makes vector arrow lengths uniform. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        spacingX : int, default=10
            The spacing in the X direction used to make the velocity domain point feature mesh. 

        spacingY : int, default=10
            The spacing in the Y direction used to make the velocity domain point feature mesh. 

        normalise : bool, default=False
            Choose whether to normalise the velocity magnitudes so that vector lengths are 
            all equal. 

        **kwargs : 
            Keyword arguments for quiver presentation parameters for plotting 
            the velocity vector field. See `Matplotlib` quiver keyword arguments 
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.quiver.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with the velocity vector field plotted onto the chosen map projection.
        &#34;&#34;&#34;
        
        lons = np.arange(-180, 180+spacingX, spacingX)
        lats = np.arange(-90, 90+spacingY, spacingY)
        lonq, latq = np.meshgrid(lons, lats)

        # create a feature from all the points
        velocity_domain_features = ptt.velocity_tools.make_GPML_velocity_feature(lonq.ravel(), latq.ravel())

        rotation_model = self.PlateReconstruction_object.rotation_model
        topology_features = self.PlateReconstruction_object.topology_features

        delta_time = 5.0
        all_velocities = ptt.velocity_tools.get_plate_velocities(
            velocity_domain_features,
            topology_features,
            rotation_model,
            self.time,
            delta_time,
            &#39;vector_comp&#39;)

        X, Y, U, V = ptt.velocity_tools.get_x_y_u_v(lons, lats, all_velocities)

        if normalise:
            mag = np.hypot(U, V)
            mag[mag == 0] = 1
            U /= mag
            V /= mag

        return ax.quiver(X, Y, U, V, transform=self.base_projection, **kwargs)


    def plot_continental_rifts(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot continental rifts on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with continental rifts plotted onto the chosen map projection.
        &#34;&#34;&#34;
        continental_rift_lines = shapelify_feature_lines(self.continental_rifts)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: continental_rift_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_faults(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot faults on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with faults plotted onto the chosen map projection.
        &#34;&#34;&#34;
        fault_lines = shapelify_feature_lines(self.faults)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: fault_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_fracture_zones(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot fracture zones on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with fracture zones plotted onto the chosen map projection.
        &#34;&#34;&#34;
        fracture_zone_lines = shapelify_feature_lines(self.fracture_zones)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: fracture_zone_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_inferred_paleo_boundaries(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot inferred paleo boundaries on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with inferred paleo boundaries plotted onto the chosen map projection.
        &#34;&#34;&#34;
        inferred_paleo_boundary_lines = shapelify_feature_lines(self.inferred_paleo_boundaries)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: inferred_paleo_boundary_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_terrane_boundaries(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot terrane boundaries on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with terrane boundaries plotted onto the chosen map projection.
        &#34;&#34;&#34;
        terrane_boundary_lines = shapelify_feature_lines(self.terrane_boundaries)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: terrane_boundary_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_transitional_crusts(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot transitional crust on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with transitional crust plotted onto the chosen map projection.
        &#34;&#34;&#34;
        transitional_crust_lines = shapelify_feature_lines(self.transitional_crusts)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: transitional_crust_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_orogenic_belts(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot orogenic belts on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with orogenic belts plotted onto the chosen map projection.
        &#34;&#34;&#34;
        orogenic_belt_lines = shapelify_feature_lines(self.orogenic_belts)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: transitional_crust_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_sutures(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot sutures on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with sutures plotted onto the chosen map projection.
        &#34;&#34;&#34;
        suture_lines = shapelify_feature_lines(self.sutures)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: suture_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_continental_crusts(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot continental crust lines on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with continental crust lines plotted onto the chosen map projection.
        &#34;&#34;&#34;
        continental_crust_lines = shapelify_feature_lines(self.continental_crusts)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: continental_crust_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_extended_continental_crusts(self, ax, color=&#39;black&#39;, **kwargs): 
        &#34;&#34;&#34;Plot extended continental crust lines on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with extended continental crust lines plotted onto the chosen map projection.
        &#34;&#34;&#34;
        extended_continental_crust_lines = shapelify_feature_lines(self.extended_continental_crusts)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: extended_continental_crust_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_passive_continental_boundaries(self, ax, color=&#39;black&#39;, **kwargs): 
        &#34;&#34;&#34;Plot passive continental boundaries on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with passive continental boundaries plotted onto the chosen map projection.
        &#34;&#34;&#34;
        passive_continental_boundary_lines = shapelify_feature_lines(self.passive_continental_boundaries)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: passive_continental_boundary_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_slab_edges(self, ax, color=&#39;black&#39;, **kwargs): 
        &#34;&#34;&#34;Plot slab edges on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with slab edges plotted onto the chosen map projection.
        &#34;&#34;&#34;
        slab_edge_lines = shapelify_feature_lines(self.slab_edges)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: slab_edge_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_misc_transforms(self, ax, color=&#39;black&#39;, **kwargs): 
        &#34;&#34;&#34;Plot miscellaneous transform boundaries on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with miscellaneous transform boundaries plotted onto the chosen map projection.
        &#34;&#34;&#34;
        misc_transform_lines = shapelify_feature_lines(self.misc_transforms)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: misc_transform_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_unclassified_features(self, ax, color=&#39;black&#39;, **kwargs): 
        &#34;&#34;&#34;Plot GPML unclassified features on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with unclassified features plotted onto the chosen map projection.
        &#34;&#34;&#34;
        unclassified_feature_lines = shapelify_feature_lines(self.unclassified_features)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: unclassified_feature_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gplately.plot.add_coastlines"><code class="name flex">
<span>def <span class="ident">add_coastlines</span></span>(<span>ax, reconstruction_time, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct coastline features to a <code>reconstruction_time</code> and plot them as
Shapely geometries onto a standard map Projection. </p>
<h2 id="notes">Notes</h2>
<p><code><a title="gplately.plot.add_coastlines" href="#gplately.plot.add_coastlines">add_coastlines()</a></code> can be used as part of the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object. In this case, the <code>coastlines</code>
and <code>rotation_model</code> needed for plotting will be accessed from the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object.
Otherwise, <code><a title="gplately.plot.add_coastlines" href="#gplately.plot.add_coastlines">add_coastlines()</a></code> can be used as a standalone method. In this case, the coastlines for
plotting must be defined in a variable <code>coastlines</code> above the method, along with a <code>rotation_model</code>.</p>
<p><code>coastlines</code> should be a pyGPlates FeatureCollection, or a filename string, or a pyGPlates Feature,
or a a sequence of features, or a list or tuple of any combination of those four types. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>reconstruction_time</code></strong> :&ensp;<code>float</code></dt>
<dd>A particular geological time (Ma) at which to reconstruct the coastline features.</dd>
<dt><strong><code>**export_wrap_to_dateline</code></strong> :&ensp;<code>bool</code>, optional, default=<code>True</code></dt>
<dd>Wrap/clip reconstructed geometries to the dateline using pyGPlates'
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>‘facecolor’</code>, <code>‘alpha’</code>, etc. for
plotting coastline geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A standard GeoAxis map with coastline features plotted onto the chosen projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_coastlines(ax, reconstruction_time, **kwargs):
    &#34;&#34;&#34;Reconstruct coastline features to a `reconstruction_time` and plot them as 
    Shapely geometries onto a standard map Projection. 

    Notes
    -----
    `add_coastlines` can be used as part of the `PlotTopologies` object. In this case, the `coastlines` 
    and `rotation_model` needed for plotting will be accessed from the `PlotTopologies` object. 
    Otherwise, `add_coastlines` can be used as a standalone method. In this case, the coastlines for 
    plotting must be defined in a variable `coastlines` above the method, along with a `rotation_model`.

    `coastlines` should be a pyGPlates FeatureCollection, or a filename string, or a pyGPlates Feature, 
    or a a sequence of features, or a list or tuple of any combination of those four types. 


    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) at which to reconstruct the coastline features. 

    **export_wrap_to_dateline : bool, optional, default=True
        Wrap/clip reconstructed geometries to the dateline using pyGPlates&#39; 
        [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper).

    **kwargs : 
        Keyword arguments for parameters such as `‘facecolor’`, `‘alpha’`, etc. for 
        plotting coastline geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with coastline features plotted onto the chosen projection. 
    &#34;&#34;&#34;
    # write shapefile
    reconstructed_coastlines = []
    pygplates.reconstruct(coastlines, rotation_model, reconstructed_coastlines, float(reconstruction_time),
                          export_wrap_to_dateline=True)
    coastlines_geometries = shapelify_feature_polygons(reconstructed_coastlines)
    ax.add_geometries(coastlines_geometries, crs=ccrs.PlateCarree(), **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.add_continents"><code class="name flex">
<span>def <span class="ident">add_continents</span></span>(<span>ax, reconstruction_time, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct continental features to a <code>reconstruction_time</code> and plot them as
Shapely geometries onto a standard map Projection. </p>
<h2 id="notes">Notes</h2>
<p><code><a title="gplately.plot.add_continents" href="#gplately.plot.add_continents">add_continents()</a></code> can be used as part of the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object. In this case, the <code>continents</code>
and <code>rotation_model</code> needed for plotting will be accessed from the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object.
Otherwise, <code><a title="gplately.plot.add_continents" href="#gplately.plot.add_continents">add_continents()</a></code> can be used as a standalone method. In this case, the continents for
plotting must be defined in a variable <code>continents</code> above the method, along with a <code>rotation_model</code>.</p>
<p><code>continents</code> should be a pyGPlates FeatureCollection, or a filename string, or a pyGPlates Feature,
or a a sequence of features, or a list or tuple of any combination of those four types. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>reconstruction_time</code></strong> :&ensp;<code>float</code></dt>
<dd>A particular geological time (Ma) at which to reconstruct the continent features.</dd>
<dt><strong><code>**export_wrap_to_dateline</code></strong> :&ensp;<code>bool</code>, optional, default=<code>True</code></dt>
<dd>Wrap/clip reconstructed geometries to the dateline using pyGPlates'
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>‘facecolor’</code>, <code>‘alpha’</code>, etc. for
plotting continent geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A standard GeoAxis map with continental features plotted onto the chosen projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_continents(ax, reconstruction_time, **kwargs):
    &#34;&#34;&#34;Reconstruct continental features to a `reconstruction_time` and plot them as 
    Shapely geometries onto a standard map Projection. 

    Notes
    -----
    `add_continents` can be used as part of the `PlotTopologies` object. In this case, the `continents` 
    and `rotation_model` needed for plotting will be accessed from the `PlotTopologies` object. 
    Otherwise, `add_continents` can be used as a standalone method. In this case, the continents for 
    plotting must be defined in a variable `continents` above the method, along with a `rotation_model`.

    `continents` should be a pyGPlates FeatureCollection, or a filename string, or a pyGPlates Feature, 
    or a a sequence of features, or a list or tuple of any combination of those four types. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) at which to reconstruct the continent features. 

    **export_wrap_to_dateline : bool, optional, default=True
        Wrap/clip reconstructed geometries to the dateline using pyGPlates&#39; 
        [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper).

    **kwargs : 
        Keyword arguments for parameters such as `‘facecolor’`, `‘alpha’`, etc. for 
        plotting continent geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with continental features plotted onto the chosen projection. 
    &#34;&#34;&#34;
    reconstructed_continents = []
    pygplates.reconstruct(continents, rotation_model, reconstructed_continents, float(reconstruction_time),
                          export_wrap_to_dateline=True)
    continent_geometries = shapelify_feature_polygons(reconstructed_continents)
    ax.add_geometries(continent_geometries, crs=ccrs.PlateCarree(), **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.add_quiver"><code class="name flex">
<span>def <span class="ident">add_quiver</span></span>(<span>ax, reconstruction_time, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a topological plate velocity vector field onto a standard map Projection for a
specific <code>reconstruction_time</code>. </p>
<h2 id="notes">Notes</h2>
<p><code><a title="gplately.plot.add_quiver" href="#gplately.plot.add_quiver">add_quiver()</a></code> uses
<a href="https://github.com/EarthByte/PlateTectonicTools">Plate Tectonic Tools</a>, a <code>rotation_model</code>
and a set of <code>topology_features</code> to generate a domain of point features on a GeoAxes <code>ax</code>.
Plate velocities are calculated for each point in the domain at a specific <code>reconstruction_time</code>.
These velocities are visualised on a cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot
as a vector field. Velocity magnitudes are not normalised. </p>
<p><code><a title="gplately.plot.add_quiver" href="#gplately.plot.add_quiver">add_quiver()</a></code> can be used as part of the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object. In this case, the
<code>rotation_model</code> and set of <code>topology_features</code> needed to generate the velocity vector field
are automatically accessed from the object's attributes. Otherwise, a <code>rotation_model</code> and set
of <code>topology_features</code> must be defined above this method. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>reconstruction_time</code></strong> :&ensp;<code>float</code></dt>
<dd>A particular geological time (Ma) at which to reconstruct global topological plates and
calculate their velocities.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for quiver features like ‘alpha’, etc. for velocity
vectors.
See <code>Matplotlib</code> quiver keyword arguments
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.quiver.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A standard GeoAxis map with velocity vector fields plotted onto the chosen Projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_quiver(ax, reconstruction_time, **kwargs):
    &#34;&#34;&#34;Plot a topological plate velocity vector field onto a standard map Projection for a 
    specific `reconstruction_time`. 

    Notes
    -----
    `add_quiver` uses 
    [Plate Tectonic Tools](https://github.com/EarthByte/PlateTectonicTools), a `rotation_model` 
    and a set of `topology_features` to generate a domain of point features on a GeoAxes `ax`. 
    Plate velocities are calculated for each point in the domain at a specific `reconstruction_time`. 
    These velocities are visualised on a cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot 
    as a vector field. Velocity magnitudes are not normalised. 

    `add_quiver` can be used as part of the `PlotTopologies` object. In this case, the 
    `rotation_model` and set of `topology_features` needed to generate the velocity vector field
    are automatically accessed from the object&#39;s attributes. Otherwise, a `rotation_model` and set 
    of `topology_features` must be defined above this method. 

    Parameters
    -----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) at which to reconstruct global topological plates and
        calculate their velocities.

    **kwargs : 
        Keyword arguments for quiver features like ‘alpha’, etc. for velocity 
        vectors.
        See `Matplotlib` quiver keyword arguments 
        [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.quiver.html).

    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with velocity vector fields plotted onto the chosen Projection. 
    &#34;&#34;&#34;
    Xnodes, Ynodes, U, V = ptt.velocity_tools.get_velocity_x_y_u_v(reconstruction_time, rotation_model,
                                                                   topology_features)
    mag = np.hypot(U, V)
#     mag = np.clip(mag, 1.0, 1e99)
#     mag[mag==0] = 1 #to avoid 0 divisor
#     U = U/mag
#     V = V/mag
    
    if mag.any():
        ax.quiver(Xnodes, Ynodes, U, V, transform=ccrs.PlateCarree(), **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.add_ridges"><code class="name flex">
<span>def <span class="ident">add_ridges</span></span>(<span>ax, reconstruction_time, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a shapefile containing ridge features already reconstructed to a
<code>reconstruction_time</code>. Plots them as Shapely geometries onto a standard map Projection. </p>
<h2 id="notes">Notes</h2>
<p>The ridge features to be plotted must be reconstructed to a specific geological time already.
These are assumed to be held in the filename string
<code>"reconstructed_topologies/ridge_transform_boundaries_{reconstruction_time}Ma.shp"</code> for each
reconstruction time. This filename is read and its ridge geometries are extracted, turned
into Shapely geometries, and plotted onto the given map <code>ax</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>reconstruction_time</code></strong> :&ensp;<code>float</code></dt>
<dd>A particular geological time (Ma) at which to reconstruct the ridge features.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>‘facecolor’</code>,
<code>‘alpha’</code>, etc. for plotting ridge geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A standard GeoAxis map with ridge features plotted onto the chosen projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ridges(ax, reconstruction_time, **kwargs):
    &#34;&#34;&#34;Read a shapefile containing ridge features already reconstructed to a 
    `reconstruction_time`. Plots them as Shapely geometries onto a standard map Projection. 

    Notes
    -----
    The ridge features to be plotted must be reconstructed to a specific geological time already. 
    These are assumed to be held in the filename string
    `&#34;reconstructed_topologies/ridge_transform_boundaries_{reconstruction_time}Ma.shp&#34;` for each 
    reconstruction time. This filename is read and its ridge geometries are extracted, turned 
    into Shapely geometries, and plotted onto the given map `ax`.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) at which to reconstruct the ridge features. 

    **kwargs : 
        Keyword arguments for parameters such as `‘facecolor’`, 
        `‘alpha’`, etc. for plotting ridge geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with ridge features plotted onto the chosen projection. 
    &#34;&#34;&#34;
    shp_name = &#34;reconstructed_topologies/ridge_transform_boundaries_{:.2f}Ma.shp&#34;.format(reconstruction_time)
    shp_continents = shpreader.Reader(shp_name).geometries()
    ft_continents  = cfeature.ShapelyFeature(shp_continents, ccrs.PlateCarree())
    ax.add_feature(ft_continents, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.add_trenches"><code class="name flex">
<span>def <span class="ident">add_trenches</span></span>(<span>ax, reconstruction_time, color='k', linewidth=2, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate subduction teeth along subduction boundaries and plot both subduction
zones and teeth onto a standard map Projection.</p>
<h2 id="notes">Notes</h2>
<p>To tessellate trenches and their teeth (which visualise their subduction polarities),
<code><a title="gplately.plot.add_trenches" href="#gplately.plot.add_trenches">add_trenches()</a></code> reads 3 shapefiles: </p>
<ul>
<li>reconstructed subduction boundaries in
<code>reconstructed_topologies/subduction_boundaries_{reconstruction_time}Ma.shp</code></li>
<li>left subduction trenches in
<code>"reconstructed_topologies/subduction_boundaries_sL_{reconstruction_time}Ma.shp"</code></li>
<li>right subduction trenches in
<code>"reconstructed_topologies/subduction_boundaries_sR_{reconstruction_time}Ma.shp"</code></li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>reconstruction_time</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>A particular geological time (Ma) used to identify the correct trench filenames.
This is substituted into:</p>
<ul>
<li><code>reconstructed_topologies/subduction_boundaries_{reconstruction_time}Ma.shp</code></li>
<li><code>reconstructed_topologies/subduction_boundaries_sL_{reconstruction_time}Ma.shp</code></li>
<li><code>reconstructed_topologies/subduction_boundaries_sR_{reconstruction_time}Ma.shp</code></li>
</ul>
</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>'k'</code></dt>
<dd>Sets the subduction boundaries to a specific edge color.</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, default=<code>2</code></dt>
<dd>Defines the thickness of the subduction boundaries.</dd>
</dl>
<p>**kwargs :
Keyword arguments for map features like ‘alpha’, etc. for plotting
trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A standard GeoAxis map with trench features plotted onto the chosen Projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_trenches(ax, reconstruction_time, color=&#39;k&#39;, linewidth=2, **kwargs):
    &#34;&#34;&#34;Generate subduction teeth along subduction boundaries and plot both subduction 
    zones and teeth onto a standard map Projection.

    Notes
    -----
    To tessellate trenches and their teeth (which visualise their subduction polarities), 
    `add_trenches` reads 3 shapefiles: 

    * reconstructed subduction boundaries in 
    `reconstructed_topologies/subduction_boundaries_{reconstruction_time}Ma.shp`
    * left subduction trenches in
    `&#34;reconstructed_topologies/subduction_boundaries_sL_{reconstruction_time}Ma.shp&#34;`
    * right subduction trenches in
    `&#34;reconstructed_topologies/subduction_boundaries_sR_{reconstruction_time}Ma.shp&#34;`

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    reconstruction_time : float
        A particular geological time (Ma) used to identify the correct trench filenames.
        This is substituted into:

        * `reconstructed_topologies/subduction_boundaries_{reconstruction_time}Ma.shp`
        * `reconstructed_topologies/subduction_boundaries_sL_{reconstruction_time}Ma.shp`
        * `reconstructed_topologies/subduction_boundaries_sR_{reconstruction_time}Ma.shp`

    color : str, default=&#39;k&#39;
        Sets the subduction boundaries to a specific edge color.

    linewidth : float, default=2
        Defines the thickness of the subduction boundaries.

    **kwargs :
        Keyword arguments for map features like ‘alpha’, etc. for plotting 
        trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A standard GeoAxis map with trench features plotted onto the chosen Projection. 
    &#34;&#34;&#34;
    shp_name = &#34;reconstructed_topologies/subduction_boundaries_{:.2f}Ma.shp&#34;.format(reconstruction_time)
    shp_subd = shpreader.Reader(shp_name).geometries()
    ft_subd  = cfeature.ShapelyFeature(shp_subd, ccrs.PlateCarree())
    ax.add_feature(ft_subd, facecolor=&#39;none&#39;, edgecolor=color, linewidth=linewidth, zorder=5)
    # add Subduction Teeth
    subd_xL, subd_yL = tesselate_triangles(
        &#34;reconstructed_topologies/subduction_boundaries_sL_{:.2f}Ma.shp&#34;.format(reconstruction_time),
        tesselation_radians=0.1, triangle_base_length=2.0, triangle_aspect=-1.0)
    subd_xR, subd_yR = tesselate_triangles(
        &#34;reconstructed_topologies/subduction_boundaries_sR_{:.2f}Ma.shp&#34;.format(reconstruction_time),
        tesselation_radians=0.1, triangle_base_length=2.0, triangle_aspect=1.0)
    
    for tX, tY in zip(subd_xL, subd_yL):
        triangle_xy_points = np.c_[tX, tY]
        patch = plt.Polygon(triangle_xy_points, color=color, transform=ccrs.PlateCarree(), zorder=6)
        ax.add_patch(patch)
    for tX, tY in zip(subd_xR, subd_yR):
        triangle_xy_points = np.c_[tX, tY]
        patch = plt.Polygon(triangle_xy_points, color=color, transform=ccrs.PlateCarree(), zorder=6)
        ax.add_patch(patch)</code></pre>
</details>
</dd>
<dt id="gplately.plot.plot_subduction_teeth"><code class="name flex">
<span>def <span class="ident">plot_subduction_teeth</span></span>(<span>geometries, width, polarity=None, height=None, spacing=None, projection='auto', transform=None, ax=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add subduction teeth to a plot.</p>
<p>The subduction polarity used for subduction teeth can be specified
manually or detected automatically if <code>geometries</code> is a
<code>geopandas.GeoDataFrame</code> object with a <code>polarity</code> column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geometries</code></strong> :&ensp;<code>geopandas.GeoDataFrame, sequence</code> of <code>shapely geometries,</code> or <code>str</code></dt>
<dd>If a <code>geopandas.GeoDataFrame</code> is given, its geometry attribute
will be used. If <code>geometries</code> is a string, it must be the path to
a file, which will be loaded with <code>geopandas.read_file</code>. Otherwise,
<code>geometries</code> must be a sequence of shapely geometry objects (instances
of the <code>shapely.geometry.base.BaseGeometry</code> class).</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>The (approximate) width of the subduction teeth. If a projection is
used, this value will be in projected units.</dd>
<dt><strong><code>polarity</code></strong> :&ensp;<code>{"left", "l", "right", "r", None}</code>, default <code>None</code></dt>
<dd>The subduction polarity of the geometries. If no polarity is provided,
and <code>geometries</code> is a <code>geopandas.GeoDataFrame</code>, this function will
attempt to find a <code>polarity</code> column in the data frame and use the
values given there. If <code>polarity</code> is not manually specified and no
appropriate column can be found, an error will be raised.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code>, default <code>None</code></dt>
<dd>If provided, the height of the subduction teeth. As with <code>width</code>,
this value should be given in projected units. If no value is given,
the height of the teeth will be equal to 0.6 * <code>width</code>.</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code>, default <code>None</code></dt>
<dd>If provided, the spacing between the subduction teeth. As with
<code>width</code> and <code>height</code>, this value should be given in projected units.
If no value is given, <code>spacing</code> will default to <code>width</code>, producing
tightly packed subduction teeth.</dd>
<dt><strong><code>projection</code></strong> :&ensp;<code>cartopy.crs.Transform, "auto",</code> or <code>None</code>, default <code>"auto"</code></dt>
<dd>The projection of the plot. If the plot has no projection, this value
can be explicitly given as <code>None</code>. The default value is "auto", which
will acquire the projection automatically from the plot axes.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>cartopy.crs.Transform,</code> or <code>None</code>, default <code>None</code></dt>
<dd>If the plot is projected, a <code>transform</code> value is usually needed.
Frequently, the appropriate value is an instance of
<code>cartopy.crs.PlateCarree</code>.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes,</code> or <code>None</code>, default <code>None</code></dt>
<dd>The axes on which the subduction teeth will be drawn. By default,
the current axes will be acquired using <code>matplotlib.pyplot.gca</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any further keyword arguments will be passed to
<code>matplotlib.patches.Polygon</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>width</code> &lt;= 0, or if <code>polarity</code> is an invalid value or could not
be determined.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_subduction_teeth(
    geometries,
    width,
    polarity=None,
    height=None,
    spacing=None,
    projection=&#34;auto&#34;,
    transform=None,
    ax=None,
    **kwargs
):
    &#34;&#34;&#34;Add subduction teeth to a plot.

    The subduction polarity used for subduction teeth can be specified
    manually or detected automatically if `geometries` is a
    `geopandas.GeoDataFrame` object with a `polarity` column.

    Parameters
    ----------
    geometries : geopandas.GeoDataFrame, sequence of shapely geometries, or str
        If a `geopandas.GeoDataFrame` is given, its geometry attribute
        will be used. If `geometries` is a string, it must be the path to
        a file, which will be loaded with `geopandas.read_file`. Otherwise,
        `geometries` must be a sequence of shapely geometry objects (instances
        of the `shapely.geometry.base.BaseGeometry` class).
    width : float
        The (approximate) width of the subduction teeth. If a projection is
        used, this value will be in projected units.
    polarity : {&#34;left&#34;, &#34;l&#34;, &#34;right&#34;, &#34;r&#34;, None}, default None
        The subduction polarity of the geometries. If no polarity is provided,
        and `geometries` is a `geopandas.GeoDataFrame`, this function will
        attempt to find a `polarity` column in the data frame and use the
        values given there. If `polarity` is not manually specified and no
        appropriate column can be found, an error will be raised.
    height : float, default None
        If provided, the height of the subduction teeth. As with `width`,
        this value should be given in projected units. If no value is given,
        the height of the teeth will be equal to 0.6 * `width`.
    spacing : float, default None
        If provided, the spacing between the subduction teeth. As with
        `width` and `height`, this value should be given in projected units.
        If no value is given, `spacing` will default to `width`, producing
        tightly packed subduction teeth.
    projection : cartopy.crs.Transform, &#34;auto&#34;, or None, default &#34;auto&#34;
        The projection of the plot. If the plot has no projection, this value
        can be explicitly given as `None`. The default value is &#34;auto&#34;, which
        will acquire the projection automatically from the plot axes.
    transform : cartopy.crs.Transform, or None, default None
        If the plot is projected, a `transform` value is usually needed.
        Frequently, the appropriate value is an instance of
        `cartopy.crs.PlateCarree`.
    ax : matplotlib.axes.Axes, or None, default None
        The axes on which the subduction teeth will be drawn. By default,
        the current axes will be acquired using `matplotlib.pyplot.gca`.
    **kwargs
        Any further keyword arguments will be passed to
        `matplotlib.patches.Polygon`.

    Raises
    ------
    ValueError
        If `width` &lt;= 0, or if `polarity` is an invalid value or could not
        be determined.
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()

    if projection == &#34;auto&#34;:
        try:
            projection = ax.projection
        except AttributeError:
            projection = None
    elif isinstance(projection, str):
        raise ValueError(&#34;Invalid projection: {}&#34;.format(projection))

    if polarity is None:
        polarity_column = _find_polarity_column(geometries.columns.values)
        if polarity_column is None:
            raise ValueError(
                &#34;Could not automatically determine polarity; &#34;
                + &#34;it must be defined manually instead.&#34;
            )
        triangles = []
        for p in geometries[polarity_column].unique():
            if p.lower() not in {&#34;left&#34;, &#34;l&#34;, &#34;right&#34;, &#34;r&#34;}:
                continue
            gdf_polarity = geometries[geometries[polarity_column] == p]
            triangles.extend(
                _tesselate_triangles(
                    gdf_polarity,
                    width,
                    p,
                    height,
                    spacing,
                    projection,
                    transform,
                )
            )
    else:
        triangles = _tesselate_triangles(
            geometries,
            width,
            polarity,
            height,
            spacing,
            projection,
            transform,
        )

    if projection is not None:
        domain = projection.domain
        triangles = [domain.intersection(i) for i in triangles]

    if hasattr(ax, &#34;add_geometries&#34;) and projection is not None:
        ax.add_geometries(triangles, crs=projection, **kwargs)
    else:
        for triangle in triangles:
            ax.fill(*triangle.exterior.xy, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.shapelify_feature_lines"><code class="name flex">
<span>def <span class="ident">shapelify_feature_lines</span></span>(<span>features, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Shapely <code>MultiPolygon</code> or <code>MultiLineString</code> geometries
from reconstructed feature polygons.</p>
<h2 id="notes">Notes</h2>
<p>Some Shapely polygons generated by <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> cut longitudes of 180
or -180 degrees. These features may appear unclosed at the dateline, so Shapely
"closes" these polygons by connecting any of their open ends with lines. These
lines may manifest on GeoAxes plots as horizontal lines that span the entire
global extent. To prevent this, <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> uses pyGPlates'
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
to split a feature polygon into multiple closed polygons if it happens to cut the
antimeridian.
Another measure taken to ensure features are valid is to order exterior coordinates
of Shapely polygons anti-clockwise. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>iterable</code> of <code>&lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt;</code> or <code>&lt;GeometryOnSphere&gt;</code></dt>
<dd>Iterable containing reconstructed polygon features.</dd>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>all_geometries</code></strong> :&ensp;<code>list</code> of <code>shapely.geometry.BaseGeometry</code></dt>
<dd>Shapely geometries converted from the given reconstructed features. Any
geometries at the dateline are split.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>geometry.pygplates_to_shapely</code></dt>
<dd>convert PyGPlates geometry objects to
<code>Shapely geometries.</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shapelify_features(features, central_meridian=0.0, tessellate_degrees=None):
    &#34;&#34;&#34;Generate Shapely `MultiPolygon` or `MultiLineString` geometries
    from reconstructed feature polygons.
    
    Notes
    -----
    Some Shapely polygons generated by `shapelify_features` cut longitudes of 180 
    or -180 degrees. These features may appear unclosed at the dateline, so Shapely 
    &#34;closes&#34; these polygons by connecting any of their open ends with lines. These 
    lines may manifest on GeoAxes plots as horizontal lines that span the entire 
    global extent. To prevent this, `shapelify_features` uses pyGPlates&#39; 
    [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
    to split a feature polygon into multiple closed polygons if it happens to cut the 
    antimeridian.
    Another measure taken to ensure features are valid is to order exterior coordinates 
    of Shapely polygons anti-clockwise. 

    Parameters
    ----------
    features : iterable of &lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt; or &lt;GeometryOnSphere&gt;
        Iterable containing reconstructed polygon features.
    central_meridian : float
        Central meridian around which to perform wrapping; default: 0.0.
    tessellate_degrees : float or None
        If provided, geometries will be tessellated to this resolution prior
        to wrapping.

    Returns
    -------
    all_geometries : list of `shapely.geometry.BaseGeometry`
        Shapely geometries converted from the given reconstructed features. Any
        geometries at the dateline are split. 

    See Also
    --------
    geometry.pygplates_to_shapely : convert PyGPlates geometry objects to
    Shapely geometries.
    &#34;&#34;&#34;
    if isinstance(
        features,
        (
            pygplates.Feature,
            pygplates.ReconstructedFeatureGeometry,
            pygplates.GeometryOnSphere,
        ),
    ):
        features = [features]

    geometries = []
    for feature in features:
        if isinstance(feature, pygplates.Feature):
            geometries.extend(feature.get_all_geometries())
        elif isinstance(feature, pygplates.ReconstructedFeatureGeometry):
            geometries.append(feature.get_reconstructed_geometry())
        elif isinstance(feature, (pygplates.GeometryOnSphere, pygplates.LatLonPoint)):
            geometries.append(feature)
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonMultiPoint):
            geometries.append(
                pygplates.MultiPointOnSphere(
                    [i.to_lat_lon() for i in feature.get_points()]
                )
            )
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonPolyline):
            geometries.append(pygplates.PolylineOnSphere(feature.get_points()))
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonPolygon):
            geometries.append(
                pygplates.PolygonOnSphere(
                    [i.to_lat_lon() for i in feature.get_exterior_points()]
                )
            )

    return [
        pygplates_to_shapely(
            i,
            force_ccw=True,
            validate=True,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
            explode=False,
        )
        for i in geometries
    ]</code></pre>
</details>
</dd>
<dt id="gplately.plot.shapelify_feature_polygons"><code class="name flex">
<span>def <span class="ident">shapelify_feature_polygons</span></span>(<span>features, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Shapely <code>MultiPolygon</code> or <code>MultiLineString</code> geometries
from reconstructed feature polygons.</p>
<h2 id="notes">Notes</h2>
<p>Some Shapely polygons generated by <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> cut longitudes of 180
or -180 degrees. These features may appear unclosed at the dateline, so Shapely
"closes" these polygons by connecting any of their open ends with lines. These
lines may manifest on GeoAxes plots as horizontal lines that span the entire
global extent. To prevent this, <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> uses pyGPlates'
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
to split a feature polygon into multiple closed polygons if it happens to cut the
antimeridian.
Another measure taken to ensure features are valid is to order exterior coordinates
of Shapely polygons anti-clockwise. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>iterable</code> of <code>&lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt;</code> or <code>&lt;GeometryOnSphere&gt;</code></dt>
<dd>Iterable containing reconstructed polygon features.</dd>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>all_geometries</code></strong> :&ensp;<code>list</code> of <code>shapely.geometry.BaseGeometry</code></dt>
<dd>Shapely geometries converted from the given reconstructed features. Any
geometries at the dateline are split.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>geometry.pygplates_to_shapely</code></dt>
<dd>convert PyGPlates geometry objects to
<code>Shapely geometries.</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shapelify_features(features, central_meridian=0.0, tessellate_degrees=None):
    &#34;&#34;&#34;Generate Shapely `MultiPolygon` or `MultiLineString` geometries
    from reconstructed feature polygons.
    
    Notes
    -----
    Some Shapely polygons generated by `shapelify_features` cut longitudes of 180 
    or -180 degrees. These features may appear unclosed at the dateline, so Shapely 
    &#34;closes&#34; these polygons by connecting any of their open ends with lines. These 
    lines may manifest on GeoAxes plots as horizontal lines that span the entire 
    global extent. To prevent this, `shapelify_features` uses pyGPlates&#39; 
    [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
    to split a feature polygon into multiple closed polygons if it happens to cut the 
    antimeridian.
    Another measure taken to ensure features are valid is to order exterior coordinates 
    of Shapely polygons anti-clockwise. 

    Parameters
    ----------
    features : iterable of &lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt; or &lt;GeometryOnSphere&gt;
        Iterable containing reconstructed polygon features.
    central_meridian : float
        Central meridian around which to perform wrapping; default: 0.0.
    tessellate_degrees : float or None
        If provided, geometries will be tessellated to this resolution prior
        to wrapping.

    Returns
    -------
    all_geometries : list of `shapely.geometry.BaseGeometry`
        Shapely geometries converted from the given reconstructed features. Any
        geometries at the dateline are split. 

    See Also
    --------
    geometry.pygplates_to_shapely : convert PyGPlates geometry objects to
    Shapely geometries.
    &#34;&#34;&#34;
    if isinstance(
        features,
        (
            pygplates.Feature,
            pygplates.ReconstructedFeatureGeometry,
            pygplates.GeometryOnSphere,
        ),
    ):
        features = [features]

    geometries = []
    for feature in features:
        if isinstance(feature, pygplates.Feature):
            geometries.extend(feature.get_all_geometries())
        elif isinstance(feature, pygplates.ReconstructedFeatureGeometry):
            geometries.append(feature.get_reconstructed_geometry())
        elif isinstance(feature, (pygplates.GeometryOnSphere, pygplates.LatLonPoint)):
            geometries.append(feature)
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonMultiPoint):
            geometries.append(
                pygplates.MultiPointOnSphere(
                    [i.to_lat_lon() for i in feature.get_points()]
                )
            )
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonPolyline):
            geometries.append(pygplates.PolylineOnSphere(feature.get_points()))
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonPolygon):
            geometries.append(
                pygplates.PolygonOnSphere(
                    [i.to_lat_lon() for i in feature.get_exterior_points()]
                )
            )

    return [
        pygplates_to_shapely(
            i,
            force_ccw=True,
            validate=True,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
            explode=False,
        )
        for i in geometries
    ]</code></pre>
</details>
</dd>
<dt id="gplately.plot.shapelify_features"><code class="name flex">
<span>def <span class="ident">shapelify_features</span></span>(<span>features, central_meridian=0.0, tessellate_degrees=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Shapely <code>MultiPolygon</code> or <code>MultiLineString</code> geometries
from reconstructed feature polygons.</p>
<h2 id="notes">Notes</h2>
<p>Some Shapely polygons generated by <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> cut longitudes of 180
or -180 degrees. These features may appear unclosed at the dateline, so Shapely
"closes" these polygons by connecting any of their open ends with lines. These
lines may manifest on GeoAxes plots as horizontal lines that span the entire
global extent. To prevent this, <code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features()</a></code> uses pyGPlates'
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
to split a feature polygon into multiple closed polygons if it happens to cut the
antimeridian.
Another measure taken to ensure features are valid is to order exterior coordinates
of Shapely polygons anti-clockwise. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>iterable</code> of <code>&lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt;</code> or <code>&lt;GeometryOnSphere&gt;</code></dt>
<dd>Iterable containing reconstructed polygon features.</dd>
<dt><strong><code>central_meridian</code></strong> :&ensp;<code>float</code></dt>
<dd>Central meridian around which to perform wrapping; default: 0.0.</dd>
<dt><strong><code>tessellate_degrees</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>If provided, geometries will be tessellated to this resolution prior
to wrapping.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>all_geometries</code></strong> :&ensp;<code>list</code> of <code>shapely.geometry.BaseGeometry</code></dt>
<dd>Shapely geometries converted from the given reconstructed features. Any
geometries at the dateline are split.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>geometry.pygplates_to_shapely</code></dt>
<dd>convert PyGPlates geometry objects to
<code>Shapely geometries.</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shapelify_features(features, central_meridian=0.0, tessellate_degrees=None):
    &#34;&#34;&#34;Generate Shapely `MultiPolygon` or `MultiLineString` geometries
    from reconstructed feature polygons.
    
    Notes
    -----
    Some Shapely polygons generated by `shapelify_features` cut longitudes of 180 
    or -180 degrees. These features may appear unclosed at the dateline, so Shapely 
    &#34;closes&#34; these polygons by connecting any of their open ends with lines. These 
    lines may manifest on GeoAxes plots as horizontal lines that span the entire 
    global extent. To prevent this, `shapelify_features` uses pyGPlates&#39; 
    [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
    to split a feature polygon into multiple closed polygons if it happens to cut the 
    antimeridian.
    Another measure taken to ensure features are valid is to order exterior coordinates 
    of Shapely polygons anti-clockwise. 

    Parameters
    ----------
    features : iterable of &lt;pygplates.Feature&gt;, &lt;ReconstructedFeatureGeometry&gt; or &lt;GeometryOnSphere&gt;
        Iterable containing reconstructed polygon features.
    central_meridian : float
        Central meridian around which to perform wrapping; default: 0.0.
    tessellate_degrees : float or None
        If provided, geometries will be tessellated to this resolution prior
        to wrapping.

    Returns
    -------
    all_geometries : list of `shapely.geometry.BaseGeometry`
        Shapely geometries converted from the given reconstructed features. Any
        geometries at the dateline are split. 

    See Also
    --------
    geometry.pygplates_to_shapely : convert PyGPlates geometry objects to
    Shapely geometries.
    &#34;&#34;&#34;
    if isinstance(
        features,
        (
            pygplates.Feature,
            pygplates.ReconstructedFeatureGeometry,
            pygplates.GeometryOnSphere,
        ),
    ):
        features = [features]

    geometries = []
    for feature in features:
        if isinstance(feature, pygplates.Feature):
            geometries.extend(feature.get_all_geometries())
        elif isinstance(feature, pygplates.ReconstructedFeatureGeometry):
            geometries.append(feature.get_reconstructed_geometry())
        elif isinstance(feature, (pygplates.GeometryOnSphere, pygplates.LatLonPoint)):
            geometries.append(feature)
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonMultiPoint):
            geometries.append(
                pygplates.MultiPointOnSphere(
                    [i.to_lat_lon() for i in feature.get_points()]
                )
            )
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonPolyline):
            geometries.append(pygplates.PolylineOnSphere(feature.get_points()))
        elif isinstance(feature, pygplates.DateLineWrapper.LatLonPolygon):
            geometries.append(
                pygplates.PolygonOnSphere(
                    [i.to_lat_lon() for i in feature.get_exterior_points()]
                )
            )

    return [
        pygplates_to_shapely(
            i,
            force_ccw=True,
            validate=True,
            central_meridian=central_meridian,
            tessellate_degrees=tessellate_degrees,
            explode=False,
        )
        for i in geometries
    ]</code></pre>
</details>
</dd>
<dt id="gplately.plot.tesselate_triangles"><code class="name flex">
<span>def <span class="ident">tesselate_triangles</span></span>(<span>shapefilename, tesselation_radians, triangle_base_length, triangle_aspect=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Place subduction teeth along subduction boundary line segments read from a
MultiLineString <code>shapefilename</code>. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shapefilename</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to shapefile containing the reconstructed subduction boundary features.</dd>
<dt><strong><code>tesselation_radians</code></strong> :&ensp;<code>float</code></dt>
<dd>Parametrises subduction teeth density. Triangles are generated only along line
segments with distances that exceed the given threshold <code>tessellation_radians</code>.</dd>
<dt><strong><code>triangle_base_length</code></strong> :&ensp;<code>float
</code></dt>
<dd>Length of teeth triangle base.</dd>
<dt><strong><code>triangle_aspect</code></strong> :&ensp;<code>float</code>, default=<code>1.0
</code></dt>
<dd>Aspect ratio of teeth triangles. Ratio is 1.0 by default.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>X_points</code></strong> :&ensp;<code>(n,3) array</code></dt>
<dd>X (longitudinal) coordinates of points that define subduction teeth triangles.</dd>
<dt><strong><code>Y_points</code></strong> :&ensp;<code>(n,3) array </code></dt>
<dd>Y (latitudinal) coordinates of points that define subduction teeth triangles.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tesselate_triangles(shapefilename, tesselation_radians, triangle_base_length, triangle_aspect=1.0):
    &#34;&#34;&#34;Place subduction teeth along subduction boundary line segments read from a 
    MultiLineString `shapefilename`. 

    Parameters
    ----------
    shapefilename : str
        Path to shapefile containing the reconstructed subduction boundary features.

    tesselation_radians : float
        Parametrises subduction teeth density. Triangles are generated only along line 
        segments with distances that exceed the given threshold `tessellation_radians`.

    triangle_base_length : float  
        Length of teeth triangle base.
        
    triangle_aspect : float, default=1.0  
        Aspect ratio of teeth triangles. Ratio is 1.0 by default.

    Returns
    -------
    X_points : (n,3) array
        X (longitudinal) coordinates of points that define subduction teeth triangles.
    Y_points : (n,3) array 
        Y (latitudinal) coordinates of points that define subduction teeth triangles.
    &#34;&#34;&#34;

    import shapefile

    with shapefile.Reader(shapefilename) as shp:
        tesselation_degrees = np.degrees(tesselation_radians)
        triangle_pointsX = []
        triangle_pointsY = []

        for i in range(len(shp)):
            pts = np.array(shp.shape(i).points)

            cum_distance = 0.0
            for p in range(len(pts) - 1):

                A = pts[p]
                B = pts[p + 1]

                AB_dist = B - A
                AB_norm = AB_dist / np.hypot(*AB_dist)
                cum_distance += np.hypot(*AB_dist)

                # create a new triangle if cumulative distance is exceeded.
                if cum_distance &gt;= tesselation_degrees:

                    C = A + triangle_base_length * AB_norm

                    # find normal vector
                    AD_dist = np.array([AB_norm[1], -AB_norm[0]])
                    AD_norm = AD_dist / np.linalg.norm(AD_dist)

                    C0 = A + 0.5 * triangle_base_length * AB_norm

                    # project point along normal vector
                    D = C0 + triangle_base_length * triangle_aspect * AD_norm

                    triangle_pointsX.append([A[0], C[0], D[0]])
                    triangle_pointsY.append([A[1], C[1], D[1]])

                    cum_distance = 0.0

    return np.array(triangle_pointsX), np.array(triangle_pointsY)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.plot.PlotTopologies"><code class="flex name class">
<span>class <span class="ident">PlotTopologies</span></span>
<span>(</span><span>PlateReconstruction_object, time, coastlines=None, continents=None, COBs=None, anchor_plate_id=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A class with tools to read, reconstruct and plot topology features at specific
reconstruction times.</p>
<p><code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> is a shorthand for PyGPlates and Shapely functionalities that:</p>
<ul>
<li>Read features held in GPlates GPML (GPlates Markup Language) files and
ESRI shapefiles;</li>
<li>Reconstruct the locations of these features as they migrate through
geological time; </li>
<li>Turn these reconstructed features into Shapely geometries for plotting
on <code>cartopy.mpl.geoaxes.GeoAxes</code> or <code>cartopy.mpl.geoaxes.GeoAxesSubplot</code> map
Projections. </li>
</ul>
<p>To call the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object, supply: </p>
<ul>
<li>an instance of the GPlately <code>PlateReconstruction_object</code></li>
<li>a reconstruction <code>time</code></li>
</ul>
<p>and optionally, </p>
<ul>
<li>a <code>coastline_filename</code></li>
<li>a <code>continent_filename</code></li>
<li>a <code>COB_filename</code></li>
<li>an <code>anchor_plate_id</code></li>
</ul>
<p>For example:</p>
<pre><code># Calling the PlotTopologies object
gplot = gplately.plot.PlotTopologies(plate_reconstruction_object,
                                    time,
                                    coastline_filename,
                                    continent_filename,
                                    COB_filename,
                                    anchor_plate_id,
        )
</code></pre>
<p>The <code>coastline_filename</code>, <code>continent_filename</code> and <code>COB_filename</code> can be single
strings to GPML and/or shapefiles, as well as instances of <code>pygplates.FeatureCollection</code>.
If using GPlately's <code>DataServer</code> object to source these files, they will be passed as
<code>pygplates.FeatureCollection</code> items.</p>
<p>Some features for plotting (like plate boundaries) are taken from the <code>PlateReconstruction</code>
object's<code>topology_features</code> attribute. They have already been reconstructed to the given
<code>time</code> using <a href="https://github.com/EarthByte/PlateTectonicTools">Plate Tectonic Tools</a>.</p>
<p>A variety of geological features can be plotted on GeoAxes/GeoAxesSubplot maps
as Shapely <code>MultiLineString</code> or <code>MultiPolygon</code> geometries, including:</p>
<ul>
<li>subduction boundaries &amp; subduction polarity teeth</li>
<li>mid-ocean ridge boundaries</li>
<li>transform boundaries</li>
<li>miscellaneous boundaries</li>
<li>coastline polylines</li>
<li>continental polygons and </li>
<li>continent-ocean boundary polylines</li>
<li>topological plate velocity vector fields</li>
<li>netCDF4 MaskedArray or ndarray raster data:<ul>
<li>seafloor age grids </li>
<li>paleo-age grids</li>
<li>global relief (topography and bathymetry)</li>
</ul>
</li>
<li>assorted reconstructable feature data, for example:<ul>
<li>seafloor fabric</li>
<li>large igneous provinces </li>
<li>volcanic provinces</li>
</ul>
</li>
</ul>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>PlateReconstruction_object</code></strong> :&ensp;<code>instance</code> of <code>&lt;gplately.reconstruction.PlateReconstruction&gt;</code></dt>
<dd>The GPlately <code>PlateReconstruction</code> object will be used to access a plate
<code>rotation_model</code> and a set of <code>topology_features</code> which contains plate boundary
features like trenches, ridges and transforms.</dd>
<dt><strong><code>anchor_plate_id</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>The anchor plate ID used for reconstruction.</dd>
<dt><strong><code>base_projection</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.crs.{transform}&gt;</code>, default <code>&lt;cartopy.crs.PlateCarree&gt; object</code></dt>
<dd>where {transform} is the map Projection to use on the Cartopy GeoAxes.
By default, the base projection is set to cartopy.crs.PlateCarree. See the
<a href="https://scitools.org.uk/cartopy/docs/v0.15/crs/projections.html">Cartopy projection list</a>
for all supported Projection types.</dd>
<dt><strong><code>coastlines</code></strong> :&ensp;<code>str,</code> or <code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>The full string path to a coastline feature file. Coastline features can also
be passed as instances of the <code>pygplates.FeatureCollection</code> object (this is
the case if these features are sourced from the <code>DataServer</code> object).</dd>
<dt><strong><code>continents</code></strong> :&ensp;<code>str,</code> or <code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>The full string path to a continent feature file. Continent features can also
be passed as instances of the <code>pygplates.FeatureCollection</code> object (this is
the case if these features are sourced from the <code>DataServer</code> object).</dd>
<dt><strong><code>COBs</code></strong> :&ensp;<code>str,</code> or <code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>The full string path to a COB feature file. COB features can also be passed
as instances of the <code>pygplates.FeatureCollection</code> object (this is the case
if these features are sourced from the <code>DataServer</code> object).</dd>
<dt><strong><code>coastlines</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.ReconstructedFeatureGeometry&gt;</code></dt>
<dd>A list containing coastline features reconstructed to the specified <code>time</code> attribute.</dd>
<dt><strong><code>continents</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.ReconstructedFeatureGeometry&gt;</code></dt>
<dd>A list containing continent features reconstructed to the specified <code>time</code> attribute.</dd>
<dt><strong><code>COBs</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.ReconstructedFeatureGeometry&gt;</code></dt>
<dd>A list containing COB features reconstructed to the specified <code>time</code> attribute.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>The time (Ma) to reconstruct and plot geological features to.</dd>
<dt><strong><code>topologies</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>
<p>A list containing assorted topologies like:</p>
<ul>
<li>pygplates.FeatureType.gpml_topological_network</li>
<li>pygplates.FeatureType.gpml_oceanic_crust</li>
<li>pygplates.FeatureType.gpml_topological_slab_boundary</li>
<li>pygplates.FeatureType.gpml_topological_closed_plate_boundary</li>
</ul>
</dd>
<dt><strong><code>ridge_transforms</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing ridge and transform boundary sections of type
pygplates.FeatureType.gpml_mid_ocean_ridge</dd>
<dt><strong><code>ridges</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing ridge boundary sections of type pygplates.FeatureType.gpml_mid_ocean_ridge</dd>
<dt><strong><code>transforms</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing transform boundary sections of type pygplates.FeatureType.gpml_mid_ocean_ridge</dd>
<dt><strong><code>trenches</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing trench boundary sections of type pygplates.FeatureType.gpml_subduction_zone</dd>
<dt><strong><code>trench_left</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing left subduction boundary sections of type pygplates.FeatureType.gpml_subduction_zone</dd>
<dt><strong><code>trench_right</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing right subduction boundary sections of type pygplates.FeatureType.gpml_subduction_zone</dd>
<dt><strong><code>other</code></strong> :&ensp;<code>iterable/list</code> of <code>&lt;pygplates.Feature&gt;</code></dt>
<dd>A list containing other geological features like unclassified features, extended continental crusts,
continental rifts, faults, orogenic belts, fracture zones, inferred paleo boundaries, terrane
boundaries and passive continental boundaries.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlotTopologies(object):
    &#34;&#34;&#34;A class with tools to read, reconstruct and plot topology features at specific
    reconstruction times.

    `PlotTopologies` is a shorthand for PyGPlates and Shapely functionalities that:

    * Read features held in GPlates GPML (GPlates Markup Language) files and 
    ESRI shapefiles;
    * Reconstruct the locations of these features as they migrate through
    geological time; 
    * Turn these reconstructed features into Shapely geometries for plotting 
    on `cartopy.mpl.geoaxes.GeoAxes` or `cartopy.mpl.geoaxes.GeoAxesSubplot` map 
    Projections. 

    To call the `PlotTopologies` object, supply: 

    * an instance of the GPlately `PlateReconstruction_object`
    * a reconstruction `time`

    and optionally, 

    * a `coastline_filename`
    * a `continent_filename`
    * a `COB_filename`
    * an `anchor_plate_id`

    For example:

        # Calling the PlotTopologies object
        gplot = gplately.plot.PlotTopologies(plate_reconstruction_object,
                                            time,
                                            coastline_filename,
                                            continent_filename,
                                            COB_filename,
                                            anchor_plate_id,
                )

    The `coastline_filename`, `continent_filename` and `COB_filename` can be single
    strings to GPML and/or shapefiles, as well as instances of `pygplates.FeatureCollection`. 
    If using GPlately&#39;s `DataServer` object to source these files, they will be passed as 
    `pygplates.FeatureCollection` items.

    Some features for plotting (like plate boundaries) are taken from the `PlateReconstruction` 
    object&#39;s`topology_features` attribute. They have already been reconstructed to the given
    `time` using [Plate Tectonic Tools](https://github.com/EarthByte/PlateTectonicTools).


    A variety of geological features can be plotted on GeoAxes/GeoAxesSubplot maps 
    as Shapely `MultiLineString` or `MultiPolygon` geometries, including:
    
    * subduction boundaries &amp; subduction polarity teeth
    * mid-ocean ridge boundaries
    * transform boundaries
    * miscellaneous boundaries
    * coastline polylines
    * continental polygons and 
    * continent-ocean boundary polylines
    * topological plate velocity vector fields
    * netCDF4 MaskedArray or ndarray raster data:
        - seafloor age grids 
        - paleo-age grids
        - global relief (topography and bathymetry)
    * assorted reconstructable feature data, for example:
        - seafloor fabric
        - large igneous provinces 
        - volcanic provinces

    Attributes
    ----------
    PlateReconstruction_object : instance of &lt;gplately.reconstruction.PlateReconstruction&gt;
        The GPlately `PlateReconstruction` object will be used to access a plate 
        `rotation_model` and a set of `topology_features` which contains plate boundary 
        features like trenches, ridges and transforms.

    anchor_plate_id : int, default 0
        The anchor plate ID used for reconstruction.

    base_projection : instance of &lt;cartopy.crs.{transform}&gt;, default &lt;cartopy.crs.PlateCarree&gt; object
        where {transform} is the map Projection to use on the Cartopy GeoAxes. 
        By default, the base projection is set to cartopy.crs.PlateCarree. See the 
        [Cartopy projection list](https://scitools.org.uk/cartopy/docs/v0.15/crs/projections.html)
        for all supported Projection types.

    coastlines : str, or instance of &lt;pygplates.FeatureCollection&gt;
        The full string path to a coastline feature file. Coastline features can also 
        be passed as instances of the `pygplates.FeatureCollection` object (this is 
        the case if these features are sourced from the `DataServer` object).

    continents : str, or instance of &lt;pygplates.FeatureCollection&gt;
        The full string path to a continent feature file. Continent features can also 
        be passed as instances of the `pygplates.FeatureCollection` object (this is 
        the case if these features are sourced from the `DataServer` object).

    COBs : str, or instance of &lt;pygplates.FeatureCollection&gt;
        The full string path to a COB feature file. COB features can also be passed 
        as instances of the `pygplates.FeatureCollection` object (this is the case 
        if these features are sourced from the `DataServer` object).

    coastlines : iterable/list of &lt;pygplates.ReconstructedFeatureGeometry&gt;
        A list containing coastline features reconstructed to the specified `time` attribute. 

    continents : iterable/list of &lt;pygplates.ReconstructedFeatureGeometry&gt;
        A list containing continent features reconstructed to the specified `time` attribute. 

    COBs : iterable/list of &lt;pygplates.ReconstructedFeatureGeometry&gt;
        A list containing COB features reconstructed to the specified `time` attribute.

    time : float
        The time (Ma) to reconstruct and plot geological features to.

    topologies : iterable/list of &lt;pygplates.Feature&gt;
        A list containing assorted topologies like:

        - pygplates.FeatureType.gpml_topological_network
        - pygplates.FeatureType.gpml_oceanic_crust
        - pygplates.FeatureType.gpml_topological_slab_boundary
        - pygplates.FeatureType.gpml_topological_closed_plate_boundary

    ridge_transforms : iterable/list of &lt;pygplates.Feature&gt;
        A list containing ridge and transform boundary sections of type 
        pygplates.FeatureType.gpml_mid_ocean_ridge

    ridges : iterable/list of &lt;pygplates.Feature&gt;
        A list containing ridge boundary sections of type pygplates.FeatureType.gpml_mid_ocean_ridge
    
    transforms : iterable/list of &lt;pygplates.Feature&gt;
        A list containing transform boundary sections of type pygplates.FeatureType.gpml_mid_ocean_ridge

    trenches : iterable/list of &lt;pygplates.Feature&gt;
        A list containing trench boundary sections of type pygplates.FeatureType.gpml_subduction_zone

    trench_left : iterable/list of &lt;pygplates.Feature&gt;
        A list containing left subduction boundary sections of type pygplates.FeatureType.gpml_subduction_zone

    trench_right : iterable/list of &lt;pygplates.Feature&gt;
        A list containing right subduction boundary sections of type pygplates.FeatureType.gpml_subduction_zone

    other : iterable/list of &lt;pygplates.Feature&gt;
        A list containing other geological features like unclassified features, extended continental crusts,
        continental rifts, faults, orogenic belts, fracture zones, inferred paleo boundaries, terrane 
        boundaries and passive continental boundaries.

    &#34;&#34;&#34;
    def __init__(
        self,
        PlateReconstruction_object,
        time,
        coastlines=None,
        continents=None,
        COBs=None,
        anchor_plate_id=0,
    ):
        self.PlateReconstruction_object = PlateReconstruction_object
        self.plate_model = self.PlateReconstruction_object

        if self.plate_model.topology_features is None:
            raise ValueError(&#34;Plate model must have topology features.&#34;)

        self.base_projection = ccrs.PlateCarree()

        # store these for when time is updated
        # make sure these are initialised as FeatureCollection objects

        self._coastlines = _load_FeatureCollection(coastlines)
        self._continents = _load_FeatureCollection(continents)
        self._COBs = _load_FeatureCollection(COBs)

        self.coastlines = None
        self.continents = None
        self.COBs = None

        self._anchor_plate_id = self._check_anchor_plate_id(anchor_plate_id)

        # store topologies for easy access
        # setting time runs the update_time routine
        self.time = time

    def __getstate__(self):

        filenames = self.PlateReconstruction_object.__getstate__()

        # add important variables from Points object
        if self._coastlines:
            filenames[&#34;coastlines&#34;] = self._coastlines.filenames
        if self._continents:
            filenames[&#34;continents&#34;] = self._continents.filenames
        if self._COBs:
            filenames[&#34;COBs&#34;] = self._COBs.filenames
        filenames[&#39;time&#39;] = self.time
        filenames[&#39;plate_id&#39;] = self._anchor_plate_id

        del self.coastlines, self.continents, self.COBs
        del self._coastlines, self._continents, self._COBs

        self.coastlines = None
        self.continents = None
        self.COBs = None
        self._coastlines = None
        self._continents = None
        self._COBs = None

        return filenames

    def __setstate__(self, state):

        self.PlateReconstruction_object = _PlateReconstruction(state[&#39;rotation_model&#39;], state[&#39;topology_features&#39;], state[&#39;static_polygons&#39;])

        self._coastlines = None
        self._continents = None
        self._COBs = None
        self.coastlines = None
        self.continents = None
        self.COBs = None

        # reinstate unpicklable items
        if &#39;coastlines&#39; in state:
            self._coastlines = _FeatureCollection()
            for feature in state[&#39;coastlines&#39;]:
                self._coastlines.add( _FeatureCollection(feature) )

        if &#39;continents&#39; in state:
            self._continents = _FeatureCollection()
            for feature in state[&#39;continents&#39;]:
                self._continents.add( _FeatureCollection(feature) )

        if &#39;COBs&#39; in state:
            self._COBs = _FeatureCollection()
            for feature in state[&#39;COBs&#39;]:
                self._COBs.add( _FeatureCollection(feature) )


        self._anchor_plate_id = state[&#34;plate_id&#34;]
        self.time = state[&#39;time&#39;]


    @property
    def time(self):
        &#34;&#34;&#34; The reconstruction time.&#34;&#34;&#34;
        return self._time

    @time.setter
    def time(self, var):
        &#34;&#34;&#34;Allows the time attribute to be changed. Updates all instances of the time attribute in the object (e.g.
        reconstructions and resolving topologies will use this new time).

        Raises
        ------
        ValueError
            If the chosen reconstruction time is &lt;0 Ma.
        &#34;&#34;&#34;
        if var &gt;= 0:
            self.update_time(var)
        else:
            raise ValueError(&#34;Enter a valid time &gt;= 0&#34;)

    @property
    def anchor_plate_id(self):
        &#34;&#34;&#34;Anchor plate ID for reconstruction. Must be an integer &gt;= 0.&#34;&#34;&#34;
        return self._anchor_plate_id

    @anchor_plate_id.setter
    def anchor_plate_id(self, anchor_plate):
        self._anchor_plate_id = self._check_anchor_plate_id(anchor_plate)
        self.update_time(self.time)

    @staticmethod
    def _check_anchor_plate_id(id):
        id = int(id)
        if id &lt; 0:
            raise ValueError(
                &#34;Invalid anchor plate ID: {}&#34;.format(id)
            )
        return id

    def update_time(self, time):
        &#34;&#34;&#34;Re-reconstruct features and topologies to the time specified by the `PlotTopologies` `time` attribute 
        whenever it or the anchor plate is updated.

        Notes
        -----
        The following `PlotTopologies` attributes are updated whenever a reconstruction `time` attribute is set:

        - resolved topology features (topological plates and networks)
        - ridge and transform boundary sections (resolved features)
        - ridge boundary sections (resolved features)
        - transform boundary sections (resolved features)
        - subduction boundary sections (resolved features)
        - left subduction boundary sections (resolved features)
        - right subduction boundary sections (resolved features)
        - other boundary sections (resolved features) that are not subduction zones or mid-ocean ridges 
        (ridge/transform)

        Moreover, coastlines, continents and COBs are reconstructed to the new specified `time`.
        &#34;&#34;&#34;
        self._time = float(time)
        resolved_topologies = ptt.resolve_topologies.resolve_topologies_into_features(
            self.PlateReconstruction_object.rotation_model,
            self.PlateReconstruction_object.topology_features,
            self.time)

        self.topologies, self.ridge_transforms, self.ridges, self.transforms, self.trenches, self.trench_left, self.trench_right, self.other = resolved_topologies

        # miscellaneous boundaries
        self.continental_rifts = []
        self.faults = []
        self.fracture_zones = []
        self.inferred_paleo_boundaries = []
        self.terrane_boundaries = []
        self.transitional_crusts = []
        self.orogenic_belts = []
        self.sutures = []
        self.continental_crusts = []
        self.extended_continental_crusts = []
        self.passive_continental_boundaries = []
        self.slab_edges = []
        self.misc_transforms = []
        self.unclassified_features = []

        for topol in self.other:
            if topol.get_feature_type() == pygplates.FeatureType.gpml_continental_rift:
                self.continental_rifts.append(topol)

            elif topol.get_feature_type() == pygplates.FeatureType.gpml_fault:
                self.faults.append(topol)
                    
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_fracture_zone:
                self.fracture_zones.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_inferred_paleo_boundary:
                self.inferred_paleo_boundaries.append(topol)

            elif topol.get_feature_type() == pygplates.FeatureType.gpml_terrane_boundary:
                self.terrane_boundaries.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_transitional_crust:
                self.transitional_crusts.append(topol)
            
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_orogenic_belt:
                self.orogenic_belts.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_suture:
                self.sutures.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_continental_crust:
                self.continental_crusts.append(topol)
            
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_extended_continental_crust:
                self.extended_continental_crusts.append(topol)
            
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_passive_continental_boundary:
                self.passive_continental_boundaries.append(topol)
            
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_slab_edge:
                self.slab_edges.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_transform:
                self.misc_transforms.append(topol)
                
            elif topol.get_feature_type() == pygplates.FeatureType.gpml_unclassified_feature:
                self.unclassified_features.append(topol)

        # reconstruct other important polygons and lines
        if self._coastlines:
            self.coastlines = self.PlateReconstruction_object.reconstruct(
                self._coastlines, self.time, from_time=0, anchor_plate_id=self.anchor_plate_id)

        if self._continents:
            self.continents = self.PlateReconstruction_object.reconstruct(
                self._continents, self.time, from_time=0, anchor_plate_id=self.anchor_plate_id)

        if self._COBs:
            self.COBs = self.PlateReconstruction_object.reconstruct(
                self._COBs, self.time, from_time=0, anchor_plate_id=self.anchor_plate_id)


    # subduction teeth
    def _tesselate_triangles(self, features, tesselation_radians, triangle_base_length, triangle_aspect=1.0):
        &#34;&#34;&#34;Places subduction teeth along subduction boundary line segments within a MultiLineString shapefile. 

        Parameters
        ----------
        shapefilename  : str  
            Path to shapefile containing the subduction boundary features

        tesselation_radians : float
            Parametrises subduction teeth density. Triangles are generated only along line segments with distances
            that exceed the given threshold tessellation_radians.

        triangle_base_length : float  
            Length of teeth triangle base
        
        triangle_aspect : float, default=1.0  
            Aspect ratio of teeth triangles. Ratio is 1.0 by default.

        Returns
        -------
        X_points : (n,3) array 
            X points that define the teeth triangles
        Y_points : (n,3) array 
            Y points that define the teeth triangles
        &#34;&#34;&#34;

        tesselation_degrees = np.degrees(tesselation_radians)
        triangle_pointsX = []
        triangle_pointsY = []

        date_line_wrapper = pygplates.DateLineWrapper()


        for feature in features:

            cum_distance = 0.0

            for geometry in feature.get_geometries():
                wrapped_lines = date_line_wrapper.wrap(geometry)
                for line in wrapped_lines:
                    pts = np.array([(p.get_longitude(), p.get_latitude()) for p in line.get_points()])

                    for p in range(0, len(pts) - 1):
                        A = pts[p]
                        B = pts[p+1]

                        AB_dist = B - A
                        AB_norm = AB_dist / np.hypot(*AB_dist)
                        cum_distance += np.hypot(*AB_dist)

                        # create a new triangle if cumulative distance is exceeded.
                        if cum_distance &gt;= tesselation_degrees:

                            C = A + triangle_base_length*AB_norm

                            # find normal vector
                            AD_dist = np.array([AB_norm[1], -AB_norm[0]])
                            AD_norm = AD_dist / np.linalg.norm(AD_dist)

                            C0 = A + 0.5*triangle_base_length*AB_norm

                            # project point along normal vector
                            D = C0 + triangle_base_length*triangle_aspect*AD_norm

                            triangle_pointsX.append( [A[0], C[0], D[0]] )
                            triangle_pointsY.append( [A[1], C[1], D[1]] )

                            cum_distance = 0.0

        return np.array(triangle_pointsX), np.array(triangle_pointsY)

    def plot_feature(self, ax, feature, **kwargs):
        shp = shapelify_features(feature)
        gdf = gpd.GeoDataFrame({&#39;geometry&#39;: shp}, geometry=&#39;geometry&#39;)
        return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)

    def plot_coastlines(self, ax, **kwargs):
        &#34;&#34;&#34;Plot reconstructed coastline polygons onto a standard map Projection. 

        Notes
        -----
        The `coastlines` for plotting are accessed from the `PlotTopologies` object&#39;s
        `coastlines` attribute. These `coastlines` are reconstructed to the `time` 
        passed to the `PlotTopologies` object and converted into Shapely polylines. The
        reconstructed `coastlines` are added onto the GeoAxes or GeoAxesSubplot map `ax` using
        GeoPandas.
        Map resentation details (e.g. facecolor, edgecolor, alpha…) are permitted as keyword
        arguments.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        **kwargs : 
            Keyword arguments for parameters such as `facecolor`, `alpha`, 
            etc. for plotting coastline geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with coastline features plotted onto the chosen map projection. 
        &#34;&#34;&#34;

        if self.coastlines is None:
            raise ValueError(&#34;Supply coastline_filename to PlotTopologies object&#34;)

        coastline_polygons = shapelify_feature_polygons(self.coastlines)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: coastline_polygons}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)

    def plot_continents(self, ax, **kwargs):
        &#34;&#34;&#34;Plot reconstructed continental polygons onto a standard map Projection. 

        Notes
        -----
        The `continents` for plotting are accessed from the `PlotTopologies` object&#39;s
        `continents` attribute. These `continents` are reconstructed to the `time` 
        passed to the `PlotTopologies` object and converted into Shapely polygons. 
        The reconstructed `coastlines` are plotted onto the GeoAxes or GeoAxesSubplot map `ax` using
        GeoPandas.
        Map presentation details (e.g. facecolor, edgecolor, alpha…) are permitted as
        keyword arguments.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        **kwargs : 
            Keyword arguments for parameters such as `facecolor`, `alpha`, 
            etc. for plotting continental geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with continent features plotted onto the chosen map projection. 
        &#34;&#34;&#34;
        if self.continents is None:
            raise ValueError(&#34;Supply continent_filename to PlotTopologies object&#34;)

        continent_polygons = shapelify_feature_polygons(self.continents)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: continent_polygons}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)

    def plot_continent_ocean_boundaries(self, ax, **kwargs):
        &#34;&#34;&#34;Plot reconstructed continent-ocean boundary (COB) polygons onto a standard 
        map Projection. 

        Notes
        -----
        The `COBs` for plotting are accessed from the `PlotTopologies` object&#39;s
        `COBs` attribute. These `COBs` are reconstructed to the `time` 
        passed to the `PlotTopologies` object and converted into Shapely polylines. 
        The reconstructed `COBs` are plotted onto the GeoAxes or GeoAxesSubplot map 
        `ax` using GeoPandas. Map presentation details (e.g. `facecolor`, `edgecolor`, `alpha`…) 
        are permitted as keyword arguments.

        These COBs are transformed into shapely
        geometries and added onto the chosen map for a specific geological time (supplied to the 
        PlotTopologies object). Map presentation details (e.g. facecolor, edgecolor, alpha…) 
        are permitted.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        **kwargs : 
            Keyword arguments for parameters such as `facecolor`, `alpha`, 
            etc. for plotting COB geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with COB features plotted onto the chosen map projection. 
        &#34;&#34;&#34;
        if self.COBs is None:
            raise ValueError(&#34;Supply COB_filename to PlotTopologies object&#34;)

        COB_lines = shapelify_feature_lines(self.COBs)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: COB_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)

    def plot_ridges(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed ridge polylines onto a standard map Projection. 
        
        Notes
        -----
        The `ridges` for plotting are accessed from the `PlotTopologies` object&#39;s
        `ridges` attribute. These `ridges` are reconstructed to the `time` 
        passed to the `PlotTopologies` object and converted into Shapely polylines. 
        The reconstructed `ridges` are plotted onto the GeoAxes or GeoAxesSubplot map 
        `ax` using GeoPandas. Map presentation details (e.g. `facecolor`, `edgecolor`, `alpha`…) 
        are permitted as keyword arguments.

        Ridge geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper) 
        by splitting a polyline into multiple polylines at the dateline. This is to avoid 
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
        compatibility with Cartopy. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the ridge lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. for 
            plotting ridge geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with ridge features plotted onto the chosen map projection. 
        &#34;&#34;&#34;
        ridge_lines = shapelify_feature_lines(self.ridges)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: ridge_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)

    def plot_ridges_and_transforms(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed ridge &amp; transform boundary polylines onto a standard map
        Projection. 

        Notes
        -----
        The ridge &amp; transform sections for plotting are accessed from the 
        `PlotTopologies` object&#39;s `ridge_transforms` attribute. These `ridge_transforms` 
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
        into Shapely polylines. The reconstructed `ridge_transforms` are plotted onto the 
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Note: Ridge &amp; transform geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper) 
        by splitting a polyline into multiple polylines at the dateline. This is to avoid 
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
        compatibility with Cartopy. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the ridge &amp; transform lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as ‘alpha’, etc. for 
            plotting ridge &amp; transform geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with ridge &amp; transform features plotted onto the chosen map projection. 
        &#34;&#34;&#34;
        ridge_transform_lines = shapelify_feature_lines(self.ridge_transforms)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: ridge_transform_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)

    def plot_transforms(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed transform boundary polylines onto a standard map. 

        Notes
        -----
        The transform sections for plotting are accessed from the 
        `PlotTopologies` object&#39;s `transforms` attribute. These `transforms` 
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
        into Shapely polylines. The reconstructed `transforms` are plotted onto the 
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Transform geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
        by splitting a polyline into multiple polylines at the dateline. This is to avoid 
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
        compatibility with Cartopy. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the transform lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting transform geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with transform features plotted onto the chosen map projection.
        &#34;&#34;&#34;
        transform_lines = shapelify_feature_lines(self.transforms)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: transform_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)

    def plot_trenches(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed subduction trench polylines onto a standard map
        Projection. 

        Notes
        -----
        The trench sections for plotting are accessed from the 
        `PlotTopologies` object&#39;s `trenches` attribute. These `trenches` 
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
        into Shapely polylines. The reconstructed `trenches` are plotted onto the 
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Trench geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
        by splitting a polyline into multiple polylines at the dateline. This is to avoid 
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
        compatibility with Cartopy. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with transform features plotted onto the chosen map projection.
        &#34;&#34;&#34;
        trench_lines = shapelify_feature_lines(self.trenches)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: trench_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)

    def plot_misc_boundaries(self, ax, color=&#34;black&#34;, **kwargs):
        &#34;&#34;&#34;Plot reconstructed miscellaneous plate boundary polylines onto a standard 
        map Projection.

        Notes
        -----
        The miscellaneous boundary sections for plotting are accessed from the 
        `PlotTopologies` object&#39;s `other` attribute. These `other` boundaries
        are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
        into Shapely polylines. The reconstructed `other` boundaries are plotted onto the 
        GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
        (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

        Miscellaneous boundary geometries are wrapped to the dateline using
        pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
        by splitting a polyline into multiple polylines at the dateline. This is to avoid 
        horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
        Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
        compatibility with Cartopy. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the boundary lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as ‘alpha’, etc. for 
            plotting miscellaneous boundary geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with miscellaneous boundary features plotted onto the chosen map projection.
        &#34;&#34;&#34;
        lines = shapelify_features(self.other)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)

    def plot_subduction_teeth_deprecated(self, ax, spacing=0.1, size=2.0, aspect=1, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot subduction teeth onto a standard map Projection. 

        Notes
        -----
        Subduction teeth are tessellated from `PlotTopologies` object attributes `trench_left` and 
        `trench_right`, and transformed into Shapely polygons for plotting. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        spacing : float, default=0.1 
            The tessellation threshold (in radians). Parametrises subduction tooth density. 
            Triangles are generated only along line segments with distances that exceed 
            the given threshold ‘spacing’.

        size : float, default=2.0
            Length of teeth triangle base.

        aspect : float, default=1
            Aspect ratio of teeth triangles. Ratio is 1.0 by default. 

        color : str, default=’black’
            The colour of the teeth. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as ‘alpha’, etc. for 
            plotting subduction tooth polygons.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with subduction teeth plotted onto the chosen map projection.
        &#34;&#34;&#34;
        import shapely

        # add Subduction Teeth
        subd_xL, subd_yL = self._tesselate_triangles(
            self.trench_left,
            tesselation_radians=spacing,
            triangle_base_length=size,
            triangle_aspect=-aspect)
        subd_xR, subd_yR = self._tesselate_triangles(
            self.trench_right,
            tesselation_radians=spacing,
            triangle_base_length=size,
            triangle_aspect=aspect)
        
        teeth = []
        for tX, tY in zip(subd_xL, subd_yL):
            triangle_xy_points = np.c_[tX, tY]
            shp = shapely.geometry.Polygon(triangle_xy_points)
            teeth.append(shp)

        for tX, tY in zip(subd_xR, subd_yR):
            triangle_xy_points = np.c_[tX, tY]
            shp = shapely.geometry.Polygon(triangle_xy_points)
            teeth.append(shp)

        return ax.add_geometries(teeth, crs=self.base_projection, color=color, **kwargs)


    def plot_subduction_teeth(self, ax, spacing=0.07, size=None, aspect=None, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot subduction teeth onto a standard map Projection.  

        Notes
        -----
        Subduction teeth are tessellated from `PlotTopologies` object attributes `trench_left` and 
        `trench_right`, and transformed into Shapely polygons for plotting. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        spacing : float, default=0.1 
            The tessellation threshold (in radians). Parametrises subduction tooth density. 
            Triangles are generated only along line segments with distances that exceed 
            the given threshold ‘spacing’.

        size : float, default=None
            Length of teeth triangle base (in radians). If kept at `None`, then
            `size = 0.5*spacing`.

        aspect : float, default=None
            Aspect ratio of teeth triangles. If kept at `None`, then `aspect = 2/3*size`.

        color : str, default=’black’
            The colour of the teeth. By default, it is set to black.

        **kwargs : 
            Keyword arguments parameters such as ‘alpha’, etc. 
            for plotting subduction tooth polygons.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with subduction teeth plotted onto the chosen map projection.
        &#34;&#34;&#34;

        spacing = spacing * EARTH_RADIUS * 1e3

        if aspect is None:
            aspect = 2.0/3.0
        if size is None:
            size = spacing*0.5

        height = size*aspect

        trench_left_features  = shapelify_feature_lines(self.trench_left)
        trench_right_features = shapelify_feature_lines(self.trench_right)

        return(
            plot_subduction_teeth(trench_left_features,  size, &#39;l&#39;, height, spacing, ax=ax, color=color, **kwargs),
            plot_subduction_teeth(trench_right_features,  size, &#39;r&#39;, height, spacing, ax=ax, color=color, **kwargs)
        )

    def plot_plate_id(self, ax, plate_id, **kwargs):
        &#34;&#34;&#34;Plot a plate polygon with an associated `plate_id` onto a standard map Projection. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        plate_id : int
            A plate ID that identifies the continental polygon to plot. See the 
            [Global EarthByte plate IDs list](https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/SampleData/FeatureCollections/Rotations/Global_EarthByte_PlateIDs_20071218.pdf)
            for a full list of plate IDs to plot.

        **kwargs : 
            Keyword arguments for map presentation parameters such as 
            `alpha`, etc. for plotting the grid.
            See `Matplotlib`&#39;s `imshow` keyword arguments 
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        &#34;&#34;&#34;
        for feature in self.topologies:
            if feature.get_reconstruction_plate_id() == plate_id:
                ft_plate = shapelify_feature_polygons([feature])
                return ax.add_geometries(ft_plate, crs=self.base_projection, **kwargs)


    def plot_grid(self, ax, grid, extent=[-180,180,-90,90], **kwargs):
        &#34;&#34;&#34;Plot a `MaskedArray` raster or grid onto a standard map Projection. 

        Notes
        -----
        Uses Matplotlib&#39;s `imshow` 
        [function](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        grid : MaskedArray
            A `MaskedArray` with elements that define a grid. The number of rows in the raster
            corresponds to the number of latitudinal coordinates, while the number of raster 
            columns corresponds to the number of longitudinal coordinates.

        extent : 1d array, default=[-180,180,-90,90]
            A four-element array to specify the [min lon, max lon, min lat, max lat] with 
            which to constrain the grid image. If no extents are supplied, full global 
            extent is assumed. 

        **kwargs : 
            Keyword arguments for map presentation parameters such as 
            `alpha`, etc. for plotting the grid.
            See `Matplotlib`&#39;s `imshow` keyword arguments 
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with the grid plotted onto the chosen map projection.
        &#34;&#34;&#34;
        # Override matplotlib default origin (&#39;upper&#39;)
        origin = kwargs.pop(&#34;origin&#34;, &#34;lower&#34;)
        return ax.imshow(
            grid,
            extent=extent,
            transform=self.base_projection,
            origin=origin,
            **kwargs,
        )


    def plot_grid_from_netCDF(self, ax, filename, **kwargs):
        &#34;&#34;&#34;Read a raster from a netCDF file, convert it to a `MaskedArray` and plot it 
        onto a standard map Projection. 

        Notes
        -----
        `plot_grid_from_netCDF` uses Matplotlib&#39;s `imshow` 
        [function](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        filename : str
            Full path to a netCDF filename.

        **kwargs : 
            Keyword arguments for map presentation parameters for 
            plotting the grid. See `Matplotlib`&#39;s `imshow` keyword arguments 
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with the netCDF grid plotted onto the chosen map projection.
        &#34;&#34;&#34;
        from .grids import read_netcdf_grid

        raster, lon_coords, lat_coords = read_netcdf_grid(filename, return_grids=True)
        extent = [lon_coords.min(), lon_coords.max(), lat_coords.min(), lat_coords.max()]
        return self.plot_grid(ax, raster, extent=extent, **kwargs)


    def plot_plate_motion_vectors(self, ax, spacingX=10, spacingY=10, normalise=False, **kwargs):
        &#34;&#34;&#34;Calculate plate motion velocity vector fields at a particular geological time 
        and plot them onto a standard map Projection. 
        
        Notes
        -----
        `plot_plate_motion_vectors` generates a MeshNode domain of point features using 
        given spacings in the X and Y directions (`spacingX` and `spacingY`). Each point in
        the domain is assigned a plate ID, and these IDs are used to obtain equivalent stage 
        rotations of identified tectonic plates over a 5 Ma time interval. Each point and 
        its stage rotation are used to calculate plate velocities at a particular geological 
        time. Velocities for each domain point are represented in the north-east-down 
        coordinate system and plotted on a GeoAxes.
        
        Vector fields can be optionally normalised by setting `normalise` to `True`. This
        makes vector arrow lengths uniform. 

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        spacingX : int, default=10
            The spacing in the X direction used to make the velocity domain point feature mesh. 

        spacingY : int, default=10
            The spacing in the Y direction used to make the velocity domain point feature mesh. 

        normalise : bool, default=False
            Choose whether to normalise the velocity magnitudes so that vector lengths are 
            all equal. 

        **kwargs : 
            Keyword arguments for quiver presentation parameters for plotting 
            the velocity vector field. See `Matplotlib` quiver keyword arguments 
            [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.quiver.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with the velocity vector field plotted onto the chosen map projection.
        &#34;&#34;&#34;
        
        lons = np.arange(-180, 180+spacingX, spacingX)
        lats = np.arange(-90, 90+spacingY, spacingY)
        lonq, latq = np.meshgrid(lons, lats)

        # create a feature from all the points
        velocity_domain_features = ptt.velocity_tools.make_GPML_velocity_feature(lonq.ravel(), latq.ravel())

        rotation_model = self.PlateReconstruction_object.rotation_model
        topology_features = self.PlateReconstruction_object.topology_features

        delta_time = 5.0
        all_velocities = ptt.velocity_tools.get_plate_velocities(
            velocity_domain_features,
            topology_features,
            rotation_model,
            self.time,
            delta_time,
            &#39;vector_comp&#39;)

        X, Y, U, V = ptt.velocity_tools.get_x_y_u_v(lons, lats, all_velocities)

        if normalise:
            mag = np.hypot(U, V)
            mag[mag == 0] = 1
            U /= mag
            V /= mag

        return ax.quiver(X, Y, U, V, transform=self.base_projection, **kwargs)


    def plot_continental_rifts(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot continental rifts on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with continental rifts plotted onto the chosen map projection.
        &#34;&#34;&#34;
        continental_rift_lines = shapelify_feature_lines(self.continental_rifts)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: continental_rift_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_faults(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot faults on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with faults plotted onto the chosen map projection.
        &#34;&#34;&#34;
        fault_lines = shapelify_feature_lines(self.faults)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: fault_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_fracture_zones(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot fracture zones on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with fracture zones plotted onto the chosen map projection.
        &#34;&#34;&#34;
        fracture_zone_lines = shapelify_feature_lines(self.fracture_zones)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: fracture_zone_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_inferred_paleo_boundaries(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot inferred paleo boundaries on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with inferred paleo boundaries plotted onto the chosen map projection.
        &#34;&#34;&#34;
        inferred_paleo_boundary_lines = shapelify_feature_lines(self.inferred_paleo_boundaries)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: inferred_paleo_boundary_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_terrane_boundaries(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot terrane boundaries on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with terrane boundaries plotted onto the chosen map projection.
        &#34;&#34;&#34;
        terrane_boundary_lines = shapelify_feature_lines(self.terrane_boundaries)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: terrane_boundary_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_transitional_crusts(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot transitional crust on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with transitional crust plotted onto the chosen map projection.
        &#34;&#34;&#34;
        transitional_crust_lines = shapelify_feature_lines(self.transitional_crusts)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: transitional_crust_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_orogenic_belts(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot orogenic belts on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with orogenic belts plotted onto the chosen map projection.
        &#34;&#34;&#34;
        orogenic_belt_lines = shapelify_feature_lines(self.orogenic_belts)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: transitional_crust_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_sutures(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot sutures on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with sutures plotted onto the chosen map projection.
        &#34;&#34;&#34;
        suture_lines = shapelify_feature_lines(self.sutures)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: suture_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_continental_crusts(self, ax, color=&#39;black&#39;, **kwargs):
        &#34;&#34;&#34;Plot continental crust lines on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with continental crust lines plotted onto the chosen map projection.
        &#34;&#34;&#34;
        continental_crust_lines = shapelify_feature_lines(self.continental_crusts)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: continental_crust_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_extended_continental_crusts(self, ax, color=&#39;black&#39;, **kwargs): 
        &#34;&#34;&#34;Plot extended continental crust lines on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with extended continental crust lines plotted onto the chosen map projection.
        &#34;&#34;&#34;
        extended_continental_crust_lines = shapelify_feature_lines(self.extended_continental_crusts)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: extended_continental_crust_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_passive_continental_boundaries(self, ax, color=&#39;black&#39;, **kwargs): 
        &#34;&#34;&#34;Plot passive continental boundaries on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with passive continental boundaries plotted onto the chosen map projection.
        &#34;&#34;&#34;
        passive_continental_boundary_lines = shapelify_feature_lines(self.passive_continental_boundaries)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: passive_continental_boundary_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_slab_edges(self, ax, color=&#39;black&#39;, **kwargs): 
        &#34;&#34;&#34;Plot slab edges on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with slab edges plotted onto the chosen map projection.
        &#34;&#34;&#34;
        slab_edge_lines = shapelify_feature_lines(self.slab_edges)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: slab_edge_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_misc_transforms(self, ax, color=&#39;black&#39;, **kwargs): 
        &#34;&#34;&#34;Plot miscellaneous transform boundaries on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with miscellaneous transform boundaries plotted onto the chosen map projection.
        &#34;&#34;&#34;
        misc_transform_lines = shapelify_feature_lines(self.misc_transforms)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: misc_transform_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)


    def plot_unclassified_features(self, ax, color=&#39;black&#39;, **kwargs): 
        &#34;&#34;&#34;Plot GPML unclassified features on a standard map projection.

        Parameters
        ----------
        ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
            A subclass of `matplotlib.axes.Axes` which represents a map Projection.
            The map should be set at a particular Cartopy projection.

        color : str, default=’black’
            The colour of the trench lines. By default, it is set to black.

        **kwargs : 
            Keyword arguments for parameters such as `alpha`, etc. 
            for plotting trench geometries.
            See `Matplotlib` keyword arguments 
            [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

        Returns
        -------
        ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
            A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
            with unclassified features plotted onto the chosen map projection.
        &#34;&#34;&#34;
        unclassified_feature_lines = shapelify_feature_lines(self.unclassified_features)
        gdf = gpd.GeoDataFrame({&#34;geometry&#34;: unclassified_feature_lines}, geometry=&#34;geometry&#34;)
        return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="gplately.plot.PlotTopologies.anchor_plate_id"><code class="name">var <span class="ident">anchor_plate_id</span></code></dt>
<dd>
<div class="desc"><p>Anchor plate ID for reconstruction. Must be an integer &gt;= 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def anchor_plate_id(self):
    &#34;&#34;&#34;Anchor plate ID for reconstruction. Must be an integer &gt;= 0.&#34;&#34;&#34;
    return self._anchor_plate_id</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.time"><code class="name">var <span class="ident">time</span></code></dt>
<dd>
<div class="desc"><p>The reconstruction time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time(self):
    &#34;&#34;&#34; The reconstruction time.&#34;&#34;&#34;
    return self._time</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gplately.plot.PlotTopologies.plot_coastlines"><code class="name flex">
<span>def <span class="ident">plot_coastlines</span></span>(<span>self, ax, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed coastline polygons onto a standard map Projection. </p>
<h2 id="notes">Notes</h2>
<p>The <code>coastlines</code> for plotting are accessed from the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's
<code>coastlines</code> attribute. These <code>coastlines</code> are reconstructed to the <code>time</code>
passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted into Shapely polylines. The
reconstructed <code>coastlines</code> are added onto the GeoAxes or GeoAxesSubplot map <code>ax</code> using
GeoPandas.
Map resentation details (e.g. facecolor, edgecolor, alpha…) are permitted as keyword
arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>facecolor</code>, <code>alpha</code>,
etc. for plotting coastline geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with coastline features plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_coastlines(self, ax, **kwargs):
    &#34;&#34;&#34;Plot reconstructed coastline polygons onto a standard map Projection. 

    Notes
    -----
    The `coastlines` for plotting are accessed from the `PlotTopologies` object&#39;s
    `coastlines` attribute. These `coastlines` are reconstructed to the `time` 
    passed to the `PlotTopologies` object and converted into Shapely polylines. The
    reconstructed `coastlines` are added onto the GeoAxes or GeoAxesSubplot map `ax` using
    GeoPandas.
    Map resentation details (e.g. facecolor, edgecolor, alpha…) are permitted as keyword
    arguments.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    **kwargs : 
        Keyword arguments for parameters such as `facecolor`, `alpha`, 
        etc. for plotting coastline geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with coastline features plotted onto the chosen map projection. 
    &#34;&#34;&#34;

    if self.coastlines is None:
        raise ValueError(&#34;Supply coastline_filename to PlotTopologies object&#34;)

    coastline_polygons = shapelify_feature_polygons(self.coastlines)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: coastline_polygons}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_continent_ocean_boundaries"><code class="name flex">
<span>def <span class="ident">plot_continent_ocean_boundaries</span></span>(<span>self, ax, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed continent-ocean boundary (COB) polygons onto a standard
map Projection. </p>
<h2 id="notes">Notes</h2>
<p>The <code>COBs</code> for plotting are accessed from the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's
<code>COBs</code> attribute. These <code>COBs</code> are reconstructed to the <code>time</code>
passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted into Shapely polylines.
The reconstructed <code>COBs</code> are plotted onto the GeoAxes or GeoAxesSubplot map
<code>ax</code> using GeoPandas. Map presentation details (e.g. <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>…)
are permitted as keyword arguments.</p>
<p>These COBs are transformed into shapely
geometries and added onto the chosen map for a specific geological time (supplied to the
PlotTopologies object). Map presentation details (e.g. facecolor, edgecolor, alpha…)
are permitted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>facecolor</code>, <code>alpha</code>,
etc. for plotting COB geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with COB features plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_continent_ocean_boundaries(self, ax, **kwargs):
    &#34;&#34;&#34;Plot reconstructed continent-ocean boundary (COB) polygons onto a standard 
    map Projection. 

    Notes
    -----
    The `COBs` for plotting are accessed from the `PlotTopologies` object&#39;s
    `COBs` attribute. These `COBs` are reconstructed to the `time` 
    passed to the `PlotTopologies` object and converted into Shapely polylines. 
    The reconstructed `COBs` are plotted onto the GeoAxes or GeoAxesSubplot map 
    `ax` using GeoPandas. Map presentation details (e.g. `facecolor`, `edgecolor`, `alpha`…) 
    are permitted as keyword arguments.

    These COBs are transformed into shapely
    geometries and added onto the chosen map for a specific geological time (supplied to the 
    PlotTopologies object). Map presentation details (e.g. facecolor, edgecolor, alpha…) 
    are permitted.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    **kwargs : 
        Keyword arguments for parameters such as `facecolor`, `alpha`, 
        etc. for plotting COB geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with COB features plotted onto the chosen map projection. 
    &#34;&#34;&#34;
    if self.COBs is None:
        raise ValueError(&#34;Supply COB_filename to PlotTopologies object&#34;)

    COB_lines = shapelify_feature_lines(self.COBs)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: COB_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_continental_crusts"><code class="name flex">
<span>def <span class="ident">plot_continental_crusts</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot continental crust lines on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with continental crust lines plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_continental_crusts(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot continental crust lines on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with continental crust lines plotted onto the chosen map projection.
    &#34;&#34;&#34;
    continental_crust_lines = shapelify_feature_lines(self.continental_crusts)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: continental_crust_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_continental_rifts"><code class="name flex">
<span>def <span class="ident">plot_continental_rifts</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot continental rifts on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with continental rifts plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_continental_rifts(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot continental rifts on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with continental rifts plotted onto the chosen map projection.
    &#34;&#34;&#34;
    continental_rift_lines = shapelify_feature_lines(self.continental_rifts)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: continental_rift_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_continents"><code class="name flex">
<span>def <span class="ident">plot_continents</span></span>(<span>self, ax, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed continental polygons onto a standard map Projection. </p>
<h2 id="notes">Notes</h2>
<p>The <code>continents</code> for plotting are accessed from the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's
<code>continents</code> attribute. These <code>continents</code> are reconstructed to the <code>time</code>
passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted into Shapely polygons.
The reconstructed <code>coastlines</code> are plotted onto the GeoAxes or GeoAxesSubplot map <code>ax</code> using
GeoPandas.
Map presentation details (e.g. facecolor, edgecolor, alpha…) are permitted as
keyword arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>facecolor</code>, <code>alpha</code>,
etc. for plotting continental geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with continent features plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_continents(self, ax, **kwargs):
    &#34;&#34;&#34;Plot reconstructed continental polygons onto a standard map Projection. 

    Notes
    -----
    The `continents` for plotting are accessed from the `PlotTopologies` object&#39;s
    `continents` attribute. These `continents` are reconstructed to the `time` 
    passed to the `PlotTopologies` object and converted into Shapely polygons. 
    The reconstructed `coastlines` are plotted onto the GeoAxes or GeoAxesSubplot map `ax` using
    GeoPandas.
    Map presentation details (e.g. facecolor, edgecolor, alpha…) are permitted as
    keyword arguments.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    **kwargs : 
        Keyword arguments for parameters such as `facecolor`, `alpha`, 
        etc. for plotting continental geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with continent features plotted onto the chosen map projection. 
    &#34;&#34;&#34;
    if self.continents is None:
        raise ValueError(&#34;Supply continent_filename to PlotTopologies object&#34;)

    continent_polygons = shapelify_feature_polygons(self.continents)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: continent_polygons}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_extended_continental_crusts"><code class="name flex">
<span>def <span class="ident">plot_extended_continental_crusts</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot extended continental crust lines on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with extended continental crust lines plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_extended_continental_crusts(self, ax, color=&#39;black&#39;, **kwargs): 
    &#34;&#34;&#34;Plot extended continental crust lines on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with extended continental crust lines plotted onto the chosen map projection.
    &#34;&#34;&#34;
    extended_continental_crust_lines = shapelify_feature_lines(self.extended_continental_crusts)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: extended_continental_crust_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_faults"><code class="name flex">
<span>def <span class="ident">plot_faults</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot faults on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with faults plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_faults(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot faults on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with faults plotted onto the chosen map projection.
    &#34;&#34;&#34;
    fault_lines = shapelify_feature_lines(self.faults)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: fault_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_feature"><code class="name flex">
<span>def <span class="ident">plot_feature</span></span>(<span>self, ax, feature, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_feature(self, ax, feature, **kwargs):
    shp = shapelify_features(feature)
    gdf = gpd.GeoDataFrame({&#39;geometry&#39;: shp}, geometry=&#39;geometry&#39;)
    return gdf.plot(ax=ax, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_fracture_zones"><code class="name flex">
<span>def <span class="ident">plot_fracture_zones</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot fracture zones on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with fracture zones plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_fracture_zones(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot fracture zones on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with fracture zones plotted onto the chosen map projection.
    &#34;&#34;&#34;
    fracture_zone_lines = shapelify_feature_lines(self.fracture_zones)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: fracture_zone_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_grid"><code class="name flex">
<span>def <span class="ident">plot_grid</span></span>(<span>self, ax, grid, extent=[-180, 180, -90, 90], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a <code>MaskedArray</code> raster or grid onto a standard map Projection. </p>
<h2 id="notes">Notes</h2>
<p>Uses Matplotlib's <code>imshow</code>
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html">function</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>MaskedArray</code></dt>
<dd>A <code>MaskedArray</code> with elements that define a grid. The number of rows in the raster
corresponds to the number of latitudinal coordinates, while the number of raster
columns corresponds to the number of longitudinal coordinates.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>1d array</code>, default=<code>[-180,180,-90,90]</code></dt>
<dd>A four-element array to specify the [min lon, max lon, min lat, max lat] with
which to constrain the grid image. If no extents are supplied, full global
extent is assumed.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for map presentation parameters such as
<code>alpha</code>, etc. for plotting the grid.
See <code>Matplotlib</code>'s <code>imshow</code> keyword arguments
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with the grid plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_grid(self, ax, grid, extent=[-180,180,-90,90], **kwargs):
    &#34;&#34;&#34;Plot a `MaskedArray` raster or grid onto a standard map Projection. 

    Notes
    -----
    Uses Matplotlib&#39;s `imshow` 
    [function](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    grid : MaskedArray
        A `MaskedArray` with elements that define a grid. The number of rows in the raster
        corresponds to the number of latitudinal coordinates, while the number of raster 
        columns corresponds to the number of longitudinal coordinates.

    extent : 1d array, default=[-180,180,-90,90]
        A four-element array to specify the [min lon, max lon, min lat, max lat] with 
        which to constrain the grid image. If no extents are supplied, full global 
        extent is assumed. 

    **kwargs : 
        Keyword arguments for map presentation parameters such as 
        `alpha`, etc. for plotting the grid.
        See `Matplotlib`&#39;s `imshow` keyword arguments 
        [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with the grid plotted onto the chosen map projection.
    &#34;&#34;&#34;
    # Override matplotlib default origin (&#39;upper&#39;)
    origin = kwargs.pop(&#34;origin&#34;, &#34;lower&#34;)
    return ax.imshow(
        grid,
        extent=extent,
        transform=self.base_projection,
        origin=origin,
        **kwargs,
    )</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_grid_from_netCDF"><code class="name flex">
<span>def <span class="ident">plot_grid_from_netCDF</span></span>(<span>self, ax, filename, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a raster from a netCDF file, convert it to a <code>MaskedArray</code> and plot it
onto a standard map Projection. </p>
<h2 id="notes">Notes</h2>
<p><code>plot_grid_from_netCDF</code> uses Matplotlib's <code>imshow</code>
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html">function</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Full path to a netCDF filename.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for map presentation parameters for
plotting the grid. See <code>Matplotlib</code>'s <code>imshow</code> keyword arguments
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with the netCDF grid plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_grid_from_netCDF(self, ax, filename, **kwargs):
    &#34;&#34;&#34;Read a raster from a netCDF file, convert it to a `MaskedArray` and plot it 
    onto a standard map Projection. 

    Notes
    -----
    `plot_grid_from_netCDF` uses Matplotlib&#39;s `imshow` 
    [function](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    filename : str
        Full path to a netCDF filename.

    **kwargs : 
        Keyword arguments for map presentation parameters for 
        plotting the grid. See `Matplotlib`&#39;s `imshow` keyword arguments 
        [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with the netCDF grid plotted onto the chosen map projection.
    &#34;&#34;&#34;
    from .grids import read_netcdf_grid

    raster, lon_coords, lat_coords = read_netcdf_grid(filename, return_grids=True)
    extent = [lon_coords.min(), lon_coords.max(), lat_coords.min(), lat_coords.max()]
    return self.plot_grid(ax, raster, extent=extent, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_inferred_paleo_boundaries"><code class="name flex">
<span>def <span class="ident">plot_inferred_paleo_boundaries</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot inferred paleo boundaries on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with inferred paleo boundaries plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_inferred_paleo_boundaries(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot inferred paleo boundaries on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with inferred paleo boundaries plotted onto the chosen map projection.
    &#34;&#34;&#34;
    inferred_paleo_boundary_lines = shapelify_feature_lines(self.inferred_paleo_boundaries)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: inferred_paleo_boundary_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_misc_boundaries"><code class="name flex">
<span>def <span class="ident">plot_misc_boundaries</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed miscellaneous plate boundary polylines onto a standard
map Projection.</p>
<h2 id="notes">Notes</h2>
<p>The miscellaneous boundary sections for plotting are accessed from the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's <code>other</code> attribute. These <code>other</code> boundaries
are reconstructed to the <code>time</code> passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted
into Shapely polylines. The reconstructed <code>other</code> boundaries are plotted onto the
GeoAxes or GeoAxesSubplot map <code>ax</code> using GeoPandas. Map presentation details
(e.g. <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>…) are permitted as keyword arguments.</p>
<p>Miscellaneous boundary geometries are wrapped to the dateline using
pyGPlates' <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
by splitting a polyline into multiple polylines at the dateline. This is to avoid
horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
compatibility with Cartopy. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the boundary lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as ‘alpha’, etc. for
plotting miscellaneous boundary geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with miscellaneous boundary features plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_misc_boundaries(self, ax, color=&#34;black&#34;, **kwargs):
    &#34;&#34;&#34;Plot reconstructed miscellaneous plate boundary polylines onto a standard 
    map Projection.

    Notes
    -----
    The miscellaneous boundary sections for plotting are accessed from the 
    `PlotTopologies` object&#39;s `other` attribute. These `other` boundaries
    are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
    into Shapely polylines. The reconstructed `other` boundaries are plotted onto the 
    GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
    (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

    Miscellaneous boundary geometries are wrapped to the dateline using
    pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
    by splitting a polyline into multiple polylines at the dateline. This is to avoid 
    horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
    Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
    compatibility with Cartopy. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the boundary lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as ‘alpha’, etc. for 
        plotting miscellaneous boundary geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with miscellaneous boundary features plotted onto the chosen map projection.
    &#34;&#34;&#34;
    lines = shapelify_features(self.other)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_misc_transforms"><code class="name flex">
<span>def <span class="ident">plot_misc_transforms</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot miscellaneous transform boundaries on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with miscellaneous transform boundaries plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_misc_transforms(self, ax, color=&#39;black&#39;, **kwargs): 
    &#34;&#34;&#34;Plot miscellaneous transform boundaries on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with miscellaneous transform boundaries plotted onto the chosen map projection.
    &#34;&#34;&#34;
    misc_transform_lines = shapelify_feature_lines(self.misc_transforms)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: misc_transform_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_orogenic_belts"><code class="name flex">
<span>def <span class="ident">plot_orogenic_belts</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot orogenic belts on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with orogenic belts plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_orogenic_belts(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot orogenic belts on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with orogenic belts plotted onto the chosen map projection.
    &#34;&#34;&#34;
    orogenic_belt_lines = shapelify_feature_lines(self.orogenic_belts)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: transitional_crust_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_passive_continental_boundaries"><code class="name flex">
<span>def <span class="ident">plot_passive_continental_boundaries</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot passive continental boundaries on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with passive continental boundaries plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_passive_continental_boundaries(self, ax, color=&#39;black&#39;, **kwargs): 
    &#34;&#34;&#34;Plot passive continental boundaries on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with passive continental boundaries plotted onto the chosen map projection.
    &#34;&#34;&#34;
    passive_continental_boundary_lines = shapelify_feature_lines(self.passive_continental_boundaries)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: passive_continental_boundary_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_plate_id"><code class="name flex">
<span>def <span class="ident">plot_plate_id</span></span>(<span>self, ax, plate_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a plate polygon with an associated <code>plate_id</code> onto a standard map Projection. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>plate_id</code></strong> :&ensp;<code>int</code></dt>
<dd>A plate ID that identifies the continental polygon to plot. See the
<a href="https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/SampleData/FeatureCollections/Rotations/Global_EarthByte_PlateIDs_20071218.pdf">Global EarthByte plate IDs list</a>
for a full list of plate IDs to plot.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for map presentation parameters such as
<code>alpha</code>, etc. for plotting the grid.
See <code>Matplotlib</code>'s <code>imshow</code> keyword arguments
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html">here</a>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_plate_id(self, ax, plate_id, **kwargs):
    &#34;&#34;&#34;Plot a plate polygon with an associated `plate_id` onto a standard map Projection. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    plate_id : int
        A plate ID that identifies the continental polygon to plot. See the 
        [Global EarthByte plate IDs list](https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/SampleData/FeatureCollections/Rotations/Global_EarthByte_PlateIDs_20071218.pdf)
        for a full list of plate IDs to plot.

    **kwargs : 
        Keyword arguments for map presentation parameters such as 
        `alpha`, etc. for plotting the grid.
        See `Matplotlib`&#39;s `imshow` keyword arguments 
        [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.imshow.html).

    &#34;&#34;&#34;
    for feature in self.topologies:
        if feature.get_reconstruction_plate_id() == plate_id:
            ft_plate = shapelify_feature_polygons([feature])
            return ax.add_geometries(ft_plate, crs=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_plate_motion_vectors"><code class="name flex">
<span>def <span class="ident">plot_plate_motion_vectors</span></span>(<span>self, ax, spacingX=10, spacingY=10, normalise=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate plate motion velocity vector fields at a particular geological time
and plot them onto a standard map Projection. </p>
<h2 id="notes">Notes</h2>
<p><code>plot_plate_motion_vectors</code> generates a MeshNode domain of point features using
given spacings in the X and Y directions (<code>spacingX</code> and <code>spacingY</code>). Each point in
the domain is assigned a plate ID, and these IDs are used to obtain equivalent stage
rotations of identified tectonic plates over a 5 Ma time interval. Each point and
its stage rotation are used to calculate plate velocities at a particular geological
time. Velocities for each domain point are represented in the north-east-down
coordinate system and plotted on a GeoAxes.</p>
<p>Vector fields can be optionally normalised by setting <code>normalise</code> to <code>True</code>. This
makes vector arrow lengths uniform. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>spacingX</code></strong> :&ensp;<code>int</code>, default=<code>10</code></dt>
<dd>The spacing in the X direction used to make the velocity domain point feature mesh.</dd>
<dt><strong><code>spacingY</code></strong> :&ensp;<code>int</code>, default=<code>10</code></dt>
<dd>The spacing in the Y direction used to make the velocity domain point feature mesh.</dd>
<dt><strong><code>normalise</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Choose whether to normalise the velocity magnitudes so that vector lengths are
all equal.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for quiver presentation parameters for plotting
the velocity vector field. See <code>Matplotlib</code> quiver keyword arguments
<a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.quiver.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with the velocity vector field plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_plate_motion_vectors(self, ax, spacingX=10, spacingY=10, normalise=False, **kwargs):
    &#34;&#34;&#34;Calculate plate motion velocity vector fields at a particular geological time 
    and plot them onto a standard map Projection. 
    
    Notes
    -----
    `plot_plate_motion_vectors` generates a MeshNode domain of point features using 
    given spacings in the X and Y directions (`spacingX` and `spacingY`). Each point in
    the domain is assigned a plate ID, and these IDs are used to obtain equivalent stage 
    rotations of identified tectonic plates over a 5 Ma time interval. Each point and 
    its stage rotation are used to calculate plate velocities at a particular geological 
    time. Velocities for each domain point are represented in the north-east-down 
    coordinate system and plotted on a GeoAxes.
    
    Vector fields can be optionally normalised by setting `normalise` to `True`. This
    makes vector arrow lengths uniform. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    spacingX : int, default=10
        The spacing in the X direction used to make the velocity domain point feature mesh. 

    spacingY : int, default=10
        The spacing in the Y direction used to make the velocity domain point feature mesh. 

    normalise : bool, default=False
        Choose whether to normalise the velocity magnitudes so that vector lengths are 
        all equal. 

    **kwargs : 
        Keyword arguments for quiver presentation parameters for plotting 
        the velocity vector field. See `Matplotlib` quiver keyword arguments 
        [here](https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.quiver.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with the velocity vector field plotted onto the chosen map projection.
    &#34;&#34;&#34;
    
    lons = np.arange(-180, 180+spacingX, spacingX)
    lats = np.arange(-90, 90+spacingY, spacingY)
    lonq, latq = np.meshgrid(lons, lats)

    # create a feature from all the points
    velocity_domain_features = ptt.velocity_tools.make_GPML_velocity_feature(lonq.ravel(), latq.ravel())

    rotation_model = self.PlateReconstruction_object.rotation_model
    topology_features = self.PlateReconstruction_object.topology_features

    delta_time = 5.0
    all_velocities = ptt.velocity_tools.get_plate_velocities(
        velocity_domain_features,
        topology_features,
        rotation_model,
        self.time,
        delta_time,
        &#39;vector_comp&#39;)

    X, Y, U, V = ptt.velocity_tools.get_x_y_u_v(lons, lats, all_velocities)

    if normalise:
        mag = np.hypot(U, V)
        mag[mag == 0] = 1
        U /= mag
        V /= mag

    return ax.quiver(X, Y, U, V, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_ridges"><code class="name flex">
<span>def <span class="ident">plot_ridges</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed ridge polylines onto a standard map Projection. </p>
<h2 id="notes">Notes</h2>
<p>The <code>ridges</code> for plotting are accessed from the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's
<code>ridges</code> attribute. These <code>ridges</code> are reconstructed to the <code>time</code>
passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted into Shapely polylines.
The reconstructed <code>ridges</code> are plotted onto the GeoAxes or GeoAxesSubplot map
<code>ax</code> using GeoPandas. Map presentation details (e.g. <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>…)
are permitted as keyword arguments.</p>
<p>Ridge geometries are wrapped to the dateline using
pyGPlates' <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
by splitting a polyline into multiple polylines at the dateline. This is to avoid
horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
compatibility with Cartopy. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the ridge lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc. for
plotting ridge geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with ridge features plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ridges(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot reconstructed ridge polylines onto a standard map Projection. 
    
    Notes
    -----
    The `ridges` for plotting are accessed from the `PlotTopologies` object&#39;s
    `ridges` attribute. These `ridges` are reconstructed to the `time` 
    passed to the `PlotTopologies` object and converted into Shapely polylines. 
    The reconstructed `ridges` are plotted onto the GeoAxes or GeoAxesSubplot map 
    `ax` using GeoPandas. Map presentation details (e.g. `facecolor`, `edgecolor`, `alpha`…) 
    are permitted as keyword arguments.

    Ridge geometries are wrapped to the dateline using
    pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper) 
    by splitting a polyline into multiple polylines at the dateline. This is to avoid 
    horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
    Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
    compatibility with Cartopy. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the ridge lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. for 
        plotting ridge geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with ridge features plotted onto the chosen map projection. 
    &#34;&#34;&#34;
    ridge_lines = shapelify_feature_lines(self.ridges)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: ridge_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_ridges_and_transforms"><code class="name flex">
<span>def <span class="ident">plot_ridges_and_transforms</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed ridge &amp; transform boundary polylines onto a standard map
Projection. </p>
<h2 id="notes">Notes</h2>
<p>The ridge &amp; transform sections for plotting are accessed from the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's <code>ridge_transforms</code> attribute. These <code>ridge_transforms</code>
are reconstructed to the <code>time</code> passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted
into Shapely polylines. The reconstructed <code>ridge_transforms</code> are plotted onto the
GeoAxes or GeoAxesSubplot map <code>ax</code> using GeoPandas. Map presentation details
(e.g. <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>…) are permitted as keyword arguments.</p>
<p>Note: Ridge &amp; transform geometries are wrapped to the dateline using
pyGPlates' <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
by splitting a polyline into multiple polylines at the dateline. This is to avoid
horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
compatibility with Cartopy. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the ridge &amp; transform lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as ‘alpha’, etc. for
plotting ridge &amp; transform geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with ridge &amp; transform features plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ridges_and_transforms(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot reconstructed ridge &amp; transform boundary polylines onto a standard map
    Projection. 

    Notes
    -----
    The ridge &amp; transform sections for plotting are accessed from the 
    `PlotTopologies` object&#39;s `ridge_transforms` attribute. These `ridge_transforms` 
    are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
    into Shapely polylines. The reconstructed `ridge_transforms` are plotted onto the 
    GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
    (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

    Note: Ridge &amp; transform geometries are wrapped to the dateline using
    pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper) 
    by splitting a polyline into multiple polylines at the dateline. This is to avoid 
    horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
    Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
    compatibility with Cartopy. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the ridge &amp; transform lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as ‘alpha’, etc. for 
        plotting ridge &amp; transform geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with ridge &amp; transform features plotted onto the chosen map projection. 
    &#34;&#34;&#34;
    ridge_transform_lines = shapelify_feature_lines(self.ridge_transforms)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: ridge_transform_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_slab_edges"><code class="name flex">
<span>def <span class="ident">plot_slab_edges</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot slab edges on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with slab edges plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_slab_edges(self, ax, color=&#39;black&#39;, **kwargs): 
    &#34;&#34;&#34;Plot slab edges on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with slab edges plotted onto the chosen map projection.
    &#34;&#34;&#34;
    slab_edge_lines = shapelify_feature_lines(self.slab_edges)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: slab_edge_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_subduction_teeth"><code class="name flex">
<span>def <span class="ident">plot_subduction_teeth</span></span>(<span>self, ax, spacing=0.07, size=None, aspect=None, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot subduction teeth onto a standard map Projection.
</p>
<h2 id="notes">Notes</h2>
<p>Subduction teeth are tessellated from <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object attributes <code>trench_left</code> and
<code>trench_right</code>, and transformed into Shapely polygons for plotting. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code>, default=<code>0.1 </code></dt>
<dd>The tessellation threshold (in radians). Parametrises subduction tooth density.
Triangles are generated only along line segments with distances that exceed
the given threshold ‘spacing’.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code>, default=<code>None</code></dt>
<dd>Length of teeth triangle base (in radians). If kept at <code>None</code>, then
<code>size = 0.5*spacing</code>.</dd>
<dt><strong><code>aspect</code></strong> :&ensp;<code>float</code>, default=<code>None</code></dt>
<dd>Aspect ratio of teeth triangles. If kept at <code>None</code>, then <code>aspect = 2/3*size</code>.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the teeth. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments parameters such as ‘alpha’, etc.
for plotting subduction tooth polygons.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with subduction teeth plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_subduction_teeth(self, ax, spacing=0.07, size=None, aspect=None, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot subduction teeth onto a standard map Projection.  

    Notes
    -----
    Subduction teeth are tessellated from `PlotTopologies` object attributes `trench_left` and 
    `trench_right`, and transformed into Shapely polygons for plotting. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    spacing : float, default=0.1 
        The tessellation threshold (in radians). Parametrises subduction tooth density. 
        Triangles are generated only along line segments with distances that exceed 
        the given threshold ‘spacing’.

    size : float, default=None
        Length of teeth triangle base (in radians). If kept at `None`, then
        `size = 0.5*spacing`.

    aspect : float, default=None
        Aspect ratio of teeth triangles. If kept at `None`, then `aspect = 2/3*size`.

    color : str, default=’black’
        The colour of the teeth. By default, it is set to black.

    **kwargs : 
        Keyword arguments parameters such as ‘alpha’, etc. 
        for plotting subduction tooth polygons.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with subduction teeth plotted onto the chosen map projection.
    &#34;&#34;&#34;

    spacing = spacing * EARTH_RADIUS * 1e3

    if aspect is None:
        aspect = 2.0/3.0
    if size is None:
        size = spacing*0.5

    height = size*aspect

    trench_left_features  = shapelify_feature_lines(self.trench_left)
    trench_right_features = shapelify_feature_lines(self.trench_right)

    return(
        plot_subduction_teeth(trench_left_features,  size, &#39;l&#39;, height, spacing, ax=ax, color=color, **kwargs),
        plot_subduction_teeth(trench_right_features,  size, &#39;r&#39;, height, spacing, ax=ax, color=color, **kwargs)
    )</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_subduction_teeth_deprecated"><code class="name flex">
<span>def <span class="ident">plot_subduction_teeth_deprecated</span></span>(<span>self, ax, spacing=0.1, size=2.0, aspect=1, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot subduction teeth onto a standard map Projection. </p>
<h2 id="notes">Notes</h2>
<p>Subduction teeth are tessellated from <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object attributes <code>trench_left</code> and
<code>trench_right</code>, and transformed into Shapely polygons for plotting. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code>, default=<code>0.1 </code></dt>
<dd>The tessellation threshold (in radians). Parametrises subduction tooth density.
Triangles are generated only along line segments with distances that exceed
the given threshold ‘spacing’.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code>, default=<code>2.0</code></dt>
<dd>Length of teeth triangle base.</dd>
<dt><strong><code>aspect</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>Aspect ratio of teeth triangles. Ratio is 1.0 by default.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the teeth. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as ‘alpha’, etc. for
plotting subduction tooth polygons.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with subduction teeth plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_subduction_teeth_deprecated(self, ax, spacing=0.1, size=2.0, aspect=1, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot subduction teeth onto a standard map Projection. 

    Notes
    -----
    Subduction teeth are tessellated from `PlotTopologies` object attributes `trench_left` and 
    `trench_right`, and transformed into Shapely polygons for plotting. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    spacing : float, default=0.1 
        The tessellation threshold (in radians). Parametrises subduction tooth density. 
        Triangles are generated only along line segments with distances that exceed 
        the given threshold ‘spacing’.

    size : float, default=2.0
        Length of teeth triangle base.

    aspect : float, default=1
        Aspect ratio of teeth triangles. Ratio is 1.0 by default. 

    color : str, default=’black’
        The colour of the teeth. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as ‘alpha’, etc. for 
        plotting subduction tooth polygons.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with subduction teeth plotted onto the chosen map projection.
    &#34;&#34;&#34;
    import shapely

    # add Subduction Teeth
    subd_xL, subd_yL = self._tesselate_triangles(
        self.trench_left,
        tesselation_radians=spacing,
        triangle_base_length=size,
        triangle_aspect=-aspect)
    subd_xR, subd_yR = self._tesselate_triangles(
        self.trench_right,
        tesselation_radians=spacing,
        triangle_base_length=size,
        triangle_aspect=aspect)
    
    teeth = []
    for tX, tY in zip(subd_xL, subd_yL):
        triangle_xy_points = np.c_[tX, tY]
        shp = shapely.geometry.Polygon(triangle_xy_points)
        teeth.append(shp)

    for tX, tY in zip(subd_xR, subd_yR):
        triangle_xy_points = np.c_[tX, tY]
        shp = shapely.geometry.Polygon(triangle_xy_points)
        teeth.append(shp)

    return ax.add_geometries(teeth, crs=self.base_projection, color=color, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_sutures"><code class="name flex">
<span>def <span class="ident">plot_sutures</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot sutures on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with sutures plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_sutures(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot sutures on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with sutures plotted onto the chosen map projection.
    &#34;&#34;&#34;
    suture_lines = shapelify_feature_lines(self.sutures)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: suture_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_terrane_boundaries"><code class="name flex">
<span>def <span class="ident">plot_terrane_boundaries</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot terrane boundaries on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with terrane boundaries plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_terrane_boundaries(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot terrane boundaries on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with terrane boundaries plotted onto the chosen map projection.
    &#34;&#34;&#34;
    terrane_boundary_lines = shapelify_feature_lines(self.terrane_boundaries)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: terrane_boundary_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_transforms"><code class="name flex">
<span>def <span class="ident">plot_transforms</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed transform boundary polylines onto a standard map. </p>
<h2 id="notes">Notes</h2>
<p>The transform sections for plotting are accessed from the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's <code>transforms</code> attribute. These <code>transforms</code>
are reconstructed to the <code>time</code> passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted
into Shapely polylines. The reconstructed <code>transforms</code> are plotted onto the
GeoAxes or GeoAxesSubplot map <code>ax</code> using GeoPandas. Map presentation details
(e.g. <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>…) are permitted as keyword arguments.</p>
<p>Transform geometries are wrapped to the dateline using
pyGPlates' <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
by splitting a polyline into multiple polylines at the dateline. This is to avoid
horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
compatibility with Cartopy. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the transform lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting transform geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with transform features plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_transforms(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot reconstructed transform boundary polylines onto a standard map. 

    Notes
    -----
    The transform sections for plotting are accessed from the 
    `PlotTopologies` object&#39;s `transforms` attribute. These `transforms` 
    are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
    into Shapely polylines. The reconstructed `transforms` are plotted onto the 
    GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
    (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

    Transform geometries are wrapped to the dateline using
    pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
    by splitting a polyline into multiple polylines at the dateline. This is to avoid 
    horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
    Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
    compatibility with Cartopy. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the transform lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting transform geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with transform features plotted onto the chosen map projection.
    &#34;&#34;&#34;
    transform_lines = shapelify_feature_lines(self.transforms)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: transform_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_transitional_crusts"><code class="name flex">
<span>def <span class="ident">plot_transitional_crusts</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot transitional crust on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with transitional crust plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_transitional_crusts(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot transitional crust on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with transitional crust plotted onto the chosen map projection.
    &#34;&#34;&#34;
    transitional_crust_lines = shapelify_feature_lines(self.transitional_crusts)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: transitional_crust_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_trenches"><code class="name flex">
<span>def <span class="ident">plot_trenches</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot reconstructed subduction trench polylines onto a standard map
Projection. </p>
<h2 id="notes">Notes</h2>
<p>The trench sections for plotting are accessed from the
<code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object's <code>trenches</code> attribute. These <code>trenches</code>
are reconstructed to the <code>time</code> passed to the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> object and converted
into Shapely polylines. The reconstructed <code>trenches</code> are plotted onto the
GeoAxes or GeoAxesSubplot map <code>ax</code> using GeoPandas. Map presentation details
(e.g. <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>…) are permitted as keyword arguments.</p>
<p>Trench geometries are wrapped to the dateline using
pyGPlates' <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper">DateLineWrapper</a>
by splitting a polyline into multiple polylines at the dateline. This is to avoid
horizontal lines being formed between polylines at longitudes of -180 and 180 degrees.
Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure
compatibility with Cartopy. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with transform features plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_trenches(self, ax, color=&#39;black&#39;, **kwargs):
    &#34;&#34;&#34;Plot reconstructed subduction trench polylines onto a standard map
    Projection. 

    Notes
    -----
    The trench sections for plotting are accessed from the 
    `PlotTopologies` object&#39;s `trenches` attribute. These `trenches` 
    are reconstructed to the `time` passed to the `PlotTopologies` object and converted 
    into Shapely polylines. The reconstructed `trenches` are plotted onto the 
    GeoAxes or GeoAxesSubplot map `ax` using GeoPandas. Map presentation details 
    (e.g. `facecolor`, `edgecolor`, `alpha`…) are permitted as keyword arguments.

    Trench geometries are wrapped to the dateline using
    pyGPlates&#39; [DateLineWrapper](https://www.gplates.org/docs/pygplates/generated/pygplates.datelinewrapper)
    by splitting a polyline into multiple polylines at the dateline. This is to avoid 
    horizontal lines being formed between polylines at longitudes of -180 and 180 degrees. 
    Point features near the poles (-89 &amp; 89 degree latitude) are also clipped to ensure 
    compatibility with Cartopy. 

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with transform features plotted onto the chosen map projection.
    &#34;&#34;&#34;
    trench_lines = shapelify_feature_lines(self.trenches)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: trench_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.plot_unclassified_features"><code class="name flex">
<span>def <span class="ident">plot_unclassified_features</span></span>(<span>self, ax, color='black', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot GPML unclassified features on a standard map projection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;cartopy.mpl.geoaxes.GeoAxes&gt;</code> or <code>&lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;</code></dt>
<dd>A subclass of <code>matplotlib.axes.Axes</code> which represents a map Projection.
The map should be set at a particular Cartopy projection.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, default=<code>’black’</code></dt>
<dd>The colour of the trench lines. By default, it is set to black.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for parameters such as <code>alpha</code>, etc.
for plotting trench geometries.
See <code>Matplotlib</code> keyword arguments
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>instance</code> of <code>&lt;geopandas.GeoDataFrame.plot&gt;</code></dt>
<dd>A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map
with unclassified features plotted onto the chosen map projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_unclassified_features(self, ax, color=&#39;black&#39;, **kwargs): 
    &#34;&#34;&#34;Plot GPML unclassified features on a standard map projection.

    Parameters
    ----------
    ax : instance of &lt;cartopy.mpl.geoaxes.GeoAxes&gt; or &lt;cartopy.mpl.geoaxes.GeoAxesSubplot&gt;
        A subclass of `matplotlib.axes.Axes` which represents a map Projection.
        The map should be set at a particular Cartopy projection.

    color : str, default=’black’
        The colour of the trench lines. By default, it is set to black.

    **kwargs : 
        Keyword arguments for parameters such as `alpha`, etc. 
        for plotting trench geometries.
        See `Matplotlib` keyword arguments 
        [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).

    Returns
    -------
    ax : instance of &lt;geopandas.GeoDataFrame.plot&gt;
        A standard cartopy.mpl.geoaxes.GeoAxes or cartopy.mpl.geoaxes.GeoAxesSubplot map 
        with unclassified features plotted onto the chosen map projection.
    &#34;&#34;&#34;
    unclassified_feature_lines = shapelify_feature_lines(self.unclassified_features)
    gdf = gpd.GeoDataFrame({&#34;geometry&#34;: unclassified_feature_lines}, geometry=&#34;geometry&#34;)
    return gdf.plot(ax=ax, facecolor=&#39;none&#39;, edgecolor=color, transform=self.base_projection, **kwargs)</code></pre>
</details>
</dd>
<dt id="gplately.plot.PlotTopologies.update_time"><code class="name flex">
<span>def <span class="ident">update_time</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-reconstruct features and topologies to the time specified by the <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> <code>time</code> attribute
whenever it or the anchor plate is updated.</p>
<h2 id="notes">Notes</h2>
<p>The following <code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code> attributes are updated whenever a reconstruction <code>time</code> attribute is set:</p>
<ul>
<li>resolved topology features (topological plates and networks)</li>
<li>ridge and transform boundary sections (resolved features)</li>
<li>ridge boundary sections (resolved features)</li>
<li>transform boundary sections (resolved features)</li>
<li>subduction boundary sections (resolved features)</li>
<li>left subduction boundary sections (resolved features)</li>
<li>right subduction boundary sections (resolved features)</li>
<li>other boundary sections (resolved features) that are not subduction zones or mid-ocean ridges
(ridge/transform)</li>
</ul>
<p>Moreover, coastlines, continents and COBs are reconstructed to the new specified <code>time</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_time(self, time):
    &#34;&#34;&#34;Re-reconstruct features and topologies to the time specified by the `PlotTopologies` `time` attribute 
    whenever it or the anchor plate is updated.

    Notes
    -----
    The following `PlotTopologies` attributes are updated whenever a reconstruction `time` attribute is set:

    - resolved topology features (topological plates and networks)
    - ridge and transform boundary sections (resolved features)
    - ridge boundary sections (resolved features)
    - transform boundary sections (resolved features)
    - subduction boundary sections (resolved features)
    - left subduction boundary sections (resolved features)
    - right subduction boundary sections (resolved features)
    - other boundary sections (resolved features) that are not subduction zones or mid-ocean ridges 
    (ridge/transform)

    Moreover, coastlines, continents and COBs are reconstructed to the new specified `time`.
    &#34;&#34;&#34;
    self._time = float(time)
    resolved_topologies = ptt.resolve_topologies.resolve_topologies_into_features(
        self.PlateReconstruction_object.rotation_model,
        self.PlateReconstruction_object.topology_features,
        self.time)

    self.topologies, self.ridge_transforms, self.ridges, self.transforms, self.trenches, self.trench_left, self.trench_right, self.other = resolved_topologies

    # miscellaneous boundaries
    self.continental_rifts = []
    self.faults = []
    self.fracture_zones = []
    self.inferred_paleo_boundaries = []
    self.terrane_boundaries = []
    self.transitional_crusts = []
    self.orogenic_belts = []
    self.sutures = []
    self.continental_crusts = []
    self.extended_continental_crusts = []
    self.passive_continental_boundaries = []
    self.slab_edges = []
    self.misc_transforms = []
    self.unclassified_features = []

    for topol in self.other:
        if topol.get_feature_type() == pygplates.FeatureType.gpml_continental_rift:
            self.continental_rifts.append(topol)

        elif topol.get_feature_type() == pygplates.FeatureType.gpml_fault:
            self.faults.append(topol)
                
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_fracture_zone:
            self.fracture_zones.append(topol)
            
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_inferred_paleo_boundary:
            self.inferred_paleo_boundaries.append(topol)

        elif topol.get_feature_type() == pygplates.FeatureType.gpml_terrane_boundary:
            self.terrane_boundaries.append(topol)
            
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_transitional_crust:
            self.transitional_crusts.append(topol)
        
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_orogenic_belt:
            self.orogenic_belts.append(topol)
            
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_suture:
            self.sutures.append(topol)
            
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_continental_crust:
            self.continental_crusts.append(topol)
        
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_extended_continental_crust:
            self.extended_continental_crusts.append(topol)
        
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_passive_continental_boundary:
            self.passive_continental_boundaries.append(topol)
        
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_slab_edge:
            self.slab_edges.append(topol)
            
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_transform:
            self.misc_transforms.append(topol)
            
        elif topol.get_feature_type() == pygplates.FeatureType.gpml_unclassified_feature:
            self.unclassified_features.append(topol)

    # reconstruct other important polygons and lines
    if self._coastlines:
        self.coastlines = self.PlateReconstruction_object.reconstruct(
            self._coastlines, self.time, from_time=0, anchor_plate_id=self.anchor_plate_id)

    if self._continents:
        self.continents = self.PlateReconstruction_object.reconstruct(
            self._continents, self.time, from_time=0, anchor_plate_id=self.anchor_plate_id)

    if self._COBs:
        self.COBs = self.PlateReconstruction_object.reconstruct(
            self._COBs, self.time, from_time=0, anchor_plate_id=self.anchor_plate_id)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#classes">Classes</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gplately.plot.add_coastlines" href="#gplately.plot.add_coastlines">add_coastlines</a></code></li>
<li><code><a title="gplately.plot.add_continents" href="#gplately.plot.add_continents">add_continents</a></code></li>
<li><code><a title="gplately.plot.add_quiver" href="#gplately.plot.add_quiver">add_quiver</a></code></li>
<li><code><a title="gplately.plot.add_ridges" href="#gplately.plot.add_ridges">add_ridges</a></code></li>
<li><code><a title="gplately.plot.add_trenches" href="#gplately.plot.add_trenches">add_trenches</a></code></li>
<li><code><a title="gplately.plot.plot_subduction_teeth" href="#gplately.plot.plot_subduction_teeth">plot_subduction_teeth</a></code></li>
<li><code><a title="gplately.plot.shapelify_feature_lines" href="#gplately.plot.shapelify_feature_lines">shapelify_feature_lines</a></code></li>
<li><code><a title="gplately.plot.shapelify_feature_polygons" href="#gplately.plot.shapelify_feature_polygons">shapelify_feature_polygons</a></code></li>
<li><code><a title="gplately.plot.shapelify_features" href="#gplately.plot.shapelify_features">shapelify_features</a></code></li>
<li><code><a title="gplately.plot.tesselate_triangles" href="#gplately.plot.tesselate_triangles">tesselate_triangles</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.plot.PlotTopologies" href="#gplately.plot.PlotTopologies">PlotTopologies</a></code></h4>
<ul class="">
<li><code><a title="gplately.plot.PlotTopologies.anchor_plate_id" href="#gplately.plot.PlotTopologies.anchor_plate_id">anchor_plate_id</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_coastlines" href="#gplately.plot.PlotTopologies.plot_coastlines">plot_coastlines</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_continent_ocean_boundaries" href="#gplately.plot.PlotTopologies.plot_continent_ocean_boundaries">plot_continent_ocean_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_continental_crusts" href="#gplately.plot.PlotTopologies.plot_continental_crusts">plot_continental_crusts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_continental_rifts" href="#gplately.plot.PlotTopologies.plot_continental_rifts">plot_continental_rifts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_continents" href="#gplately.plot.PlotTopologies.plot_continents">plot_continents</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_extended_continental_crusts" href="#gplately.plot.PlotTopologies.plot_extended_continental_crusts">plot_extended_continental_crusts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_faults" href="#gplately.plot.PlotTopologies.plot_faults">plot_faults</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_feature" href="#gplately.plot.PlotTopologies.plot_feature">plot_feature</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_fracture_zones" href="#gplately.plot.PlotTopologies.plot_fracture_zones">plot_fracture_zones</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_grid" href="#gplately.plot.PlotTopologies.plot_grid">plot_grid</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_grid_from_netCDF" href="#gplately.plot.PlotTopologies.plot_grid_from_netCDF">plot_grid_from_netCDF</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_inferred_paleo_boundaries" href="#gplately.plot.PlotTopologies.plot_inferred_paleo_boundaries">plot_inferred_paleo_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_misc_boundaries" href="#gplately.plot.PlotTopologies.plot_misc_boundaries">plot_misc_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_misc_transforms" href="#gplately.plot.PlotTopologies.plot_misc_transforms">plot_misc_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_orogenic_belts" href="#gplately.plot.PlotTopologies.plot_orogenic_belts">plot_orogenic_belts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_passive_continental_boundaries" href="#gplately.plot.PlotTopologies.plot_passive_continental_boundaries">plot_passive_continental_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_plate_id" href="#gplately.plot.PlotTopologies.plot_plate_id">plot_plate_id</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_plate_motion_vectors" href="#gplately.plot.PlotTopologies.plot_plate_motion_vectors">plot_plate_motion_vectors</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_ridges" href="#gplately.plot.PlotTopologies.plot_ridges">plot_ridges</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_ridges_and_transforms" href="#gplately.plot.PlotTopologies.plot_ridges_and_transforms">plot_ridges_and_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_slab_edges" href="#gplately.plot.PlotTopologies.plot_slab_edges">plot_slab_edges</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_subduction_teeth" href="#gplately.plot.PlotTopologies.plot_subduction_teeth">plot_subduction_teeth</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_subduction_teeth_deprecated" href="#gplately.plot.PlotTopologies.plot_subduction_teeth_deprecated">plot_subduction_teeth_deprecated</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_sutures" href="#gplately.plot.PlotTopologies.plot_sutures">plot_sutures</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_terrane_boundaries" href="#gplately.plot.PlotTopologies.plot_terrane_boundaries">plot_terrane_boundaries</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_transforms" href="#gplately.plot.PlotTopologies.plot_transforms">plot_transforms</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_transitional_crusts" href="#gplately.plot.PlotTopologies.plot_transitional_crusts">plot_transitional_crusts</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_trenches" href="#gplately.plot.PlotTopologies.plot_trenches">plot_trenches</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.plot_unclassified_features" href="#gplately.plot.PlotTopologies.plot_unclassified_features">plot_unclassified_features</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.time" href="#gplately.plot.PlotTopologies.time">time</a></code></li>
<li><code><a title="gplately.plot.PlotTopologies.update_time" href="#gplately.plot.PlotTopologies.update_time">update_time</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>