<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gplately.grids API documentation</title>
<meta name="description" content="A module that uses Scipy interpolation tools for working with raster/grid data …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.grids</code></h1>
</header>
<section id="section-intro">
<p>A module that uses Scipy interpolation tools for working with raster/grid data.</p>
<p>Gridded data can be sampled at a set of point coordinates using either linear or nearest-neighbour interpolation.
These grids can also be resampled using X and Y-direction spacing, and can be resized using given X and Y resolutions.
Grids can be searched for invalid, NaN-type data cells. These can be replaced with the values of their nearest valid neighbours. </p>
<h2 id="classes">Classes</h2>
<p>RegularGridInterpolator
Raster
TimeRaster</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A module that uses Scipy interpolation tools for working with raster/grid data.

Gridded data can be sampled at a set of point coordinates using either linear or nearest-neighbour interpolation. 
These grids can also be resampled using X and Y-direction spacing, and can be resized using given X and Y resolutions.
Grids can be searched for invalid, NaN-type data cells. These can be replaced with the values of their nearest valid neighbours. 

Classes
-------
RegularGridInterpolator
Raster
TimeRaster
&#34;&#34;&#34;
import concurrent.futures
from multiprocessing import cpu_count
import warnings

import pygplates
import numpy as np
from rasterio.enums import MergeAlg
from rasterio.features import rasterize as _rasterize
from rasterio.transform import from_bounds as _from_bounds
from scipy.interpolate import RegularGridInterpolator as _RGI
from scipy.ndimage import distance_transform_edt, map_coordinates

from .geometry import pygplates_to_shapely
from .reconstruction import Points as _Points

__all__ = [
    &#34;fill_raster&#34;,
    &#34;read_netcdf_grid&#34;,
    &#34;write_netcdf_grid&#34;,
    &#34;RegularGridInterpolator&#34;,
    &#34;sample_grid&#34;,
    &#34;reconstruct_grid&#34;,
    &#34;rasterise&#34;,
    &#34;rasterize&#34;,
    &#34;Raster&#34;,
    &#34;TimeRaster&#34;,
]


def fill_raster(data,invalid=None):
    &#34;&#34;&#34;Searches grid for invalid ‘data’ cells containing NaN-type entries (as indicated by ‘invalid’), locates the index 
    of the nearest valid data cell and replaces NaNs with the value of the nearest valid data cell.

    Searches a supplied data frame “data” for invalid data cells containing NaN-type entries. If these invalidities have been  
    replaced with a “fill_value” attribute before being passed into fill_raster, there may no longer be invalid cells in the 
    data. If so, the data’s NaN entries are recovered. Where there is an invalid cell in “data”, the index of the closest 
    valid data cell entry is located. This is superimposed onto “data”’s invalid cells and replaces NaNs with the nearest
    valid value.

    Parameters
    ----------
    data : ndarray
        A numpy array enclosing grid data that may have invalid cells (entries of type NaN), or formerly-invalid cells masked 
        with a fill value. 

    invalid : ndarray, optional, default=None
        A boolean-binary array with the same shape as “data”. Entries should be 1 if its corresponding entry in “data” is of 
        type NaN, and 0 if its corresponding entry in “data” is valid. Used to locate the indices of the nearest valid data 
        cells. An optional parameter; by default, this method assumes that “invalid” isn’t provided and will create it if 
        not supplied.

    Returns
    -------
    data : ndarray
        An updated grid of data where each invalid cell has been replaced with the value of its nearest valid neighbour. 
    &#34;&#34;&#34;
    masked_array = hasattr(data, &#34;fill_value&#34;)
    if masked_array:
        mask_fill_value = data.data == data.fill_value
        data = data.data.copy()
        data[mask_fill_value] = np.nan
    else:
        data = data.copy()

    if invalid is None:
        invalid = np.isnan(data)
        if masked_array:
            invalid += mask_fill_value
    ind = distance_transform_edt(invalid, return_distances=False, return_indices=True)
    return data[tuple(ind)]

def read_netcdf_grid(filename, return_grids=False, resample=None):
    &#34;&#34;&#34;Reads in a netCDF file and re-aligns its grid, lat and lon variables from -180 to 180 degrees.

    Can optionally resample grid if given required spacing in X and Y direction. Depending on user preference, it can 
    return the grid read from the file, or the grid along with its associated lat, lon arrays.
    
    Parameters
    ----------
    filename : str
        Path to netCDF file
        
    return_grids : bool, default=False
        If set to True, optionally returns lon, lat arrays associated with grid.
        
    resample : tuple, default=None
        Optionally resample grid, pass spacing in X and Y direction as a tuple
        e.g. resample=(spacingX, spacingY)

    Returns
    -------
    cdf_grid_z : array-like
        A numpy array of the grid defined by the supplied netCDF4 file. Can be resampled if given a specific spacing in 
        the X and Y directions. Entries are rescaled using longitudes between -180 and 180 degrees.

    cdf_lon, cdf_lat : array-like
        Numpy arrays encasing longitude and latitude variables belonging to the supplied netCDF4 file. Longitudes are 
        rescaled between -180 and 180 degrees.  
    &#34;&#34;&#34;
    import netCDF4
    
    # open netCDF file and re-align from -180, 180 degrees
    with netCDF4.Dataset(filename, &#39;r&#39;) as cdf:
        cdf_grid = cdf[&#34;z&#34;]
        try:
            cdf_lon = cdf[&#39;lon&#39;][:]
            cdf_lat = cdf[&#39;lat&#39;][:]
        except:
            cdf_lon = cdf[&#39;x&#39;][:]
            cdf_lat = cdf[&#39;y&#39;][:]
            
        cdf_lon_mask = cdf_lon[:] &gt; 180
        dlon = np.diff(cdf_lon[:]).mean()
        
        if cdf_lon_mask.any():
            cdf_grid_z = np.hstack([cdf_grid[:,cdf_lon_mask], cdf_grid[:,~cdf_lon_mask]])
            cdf_lon = np.hstack([cdf_lon[cdf_lon_mask]-360-dlon, cdf_lon[~cdf_lon_mask]])
        else:
            cdf_grid_z = cdf_grid[:]

    # resample
    if resample is not None:
        spacingX, spacingY = resample
        lon_grid = np.arange(cdf_lon.min(), cdf_lon.max()+spacingX, spacingX)
        lat_grid = np.arange(cdf_lat.min(), cdf_lat.max()+spacingY, spacingY)
        lonq, latq = np.meshgrid(lon_grid, lat_grid)
        interp = RegularGridInterpolator((cdf_lat, cdf_lon), cdf_grid_z, method=&#39;nearest&#39;, bounds_error=False)
        cdf_grid_z = interp((latq, lonq))
        cdf_lon = lon_grid
        cdf_lat = lat_grid
            
    if return_grids:
        return cdf_grid_z, cdf_lon, cdf_lat
    else:
        return cdf_grid_z
    
def write_netcdf_grid(filename, grid, extent=[-180,180,-90,90]):
    &#34;&#34;&#34; Writes grid, latitude and longitude variables to a given netCDF4 file using specified longitudinal and latitudinal
    extents. 

    Latitude and longitude arrays correspond to the size (num of rows and columns respectively) of the given numpy grid and 
    set between specified latitudinal and longitudinal angular extents. The given grid and generated lat,lon arrays are 
    ascribed to a given netCDF4 filename and written as additional variables of the file. 

    Parameters
    ----------
    filename : str
        Path to the netCDF file

    grid : array-like
        An array with elements that define a grid. The number of rows corresponds to the number of latitudinal points, 
        while the number of columns corresponds to the number of longitudinal points.

    extent : 1D numpy array, default=[-180,180,-90,90]
        Four elements must specify the [min lon, max lon, min lat, max lat] with which to constrain the lat and lon 
        variables to write to the netCDF file. If no extents are supplied, full global extent is assumed. 

    Returns
    -------
    cdf_lon, cdf_lat : 1D numpy arrays
        Longitude and latitude variables that have been written to the supplied netCDF4 file. Lengths of these arrays 
        equal the number of cols and rows respectively of the supplied “grid”. Defined between angular extents specified 
        in “extent”.

    cdf_data : array-like
        The supplied grid is ascribed to the given netCDF4 file.
    &#34;&#34;&#34;
    import netCDF4
    
    nrows, ncols = np.shape(grid)
    
    lon_grid = np.linspace(extent[0], extent[1], ncols)
    lat_grid = np.linspace(extent[2], extent[3], nrows)
    
    with netCDF4.Dataset(filename, &#39;w&#39;) as cdf:
        cdf.createDimension(&#39;x&#39;, lon_grid.size)
        cdf.createDimension(&#39;y&#39;, lat_grid.size)
        cdf_lon = cdf.createVariable(&#39;x&#39;, lon_grid.dtype, (&#39;x&#39;,), zlib=True)
        cdf_lat = cdf.createVariable(&#39;y&#39;, lat_grid.dtype, (&#39;y&#39;,), zlib=True)
        cdf_lon[:] = lon_grid
        cdf_lat[:] = lat_grid
        cdf_lon.units = &#34;degrees&#34;
        cdf_lat.units = &#34;degrees&#34;

        cdf_data = cdf.createVariable(&#39;z&#39;, grid.dtype, (&#39;y&#39;,&#39;x&#39;), zlib=True)
        cdf_data[:,:] = grid


class RegularGridInterpolator(_RGI):
    &#34;&#34;&#34;A class to sample gridded data at a set of point coordinates using either linear or nearest-neighbour 
    interpolation methods.

    It is a child class of the scipy.interpolate module’s RegularGridInterpolator class. 

    Attributes
    ----------
    points
    values
    method
    bounds_error
    Fill_value

    Methods
    -------
    __init__(self, points, values, method=&#34;linear&#34;, bounds_error=False, fill_value=np.nan)
        Constructs all necessary attributes for the RegularGridInterpolator object.
    __call__(self, xi, method=None, return_indices=False, return_distances=False)
        Allows the RegularGridInterpolator object to be called as a method.
    &#34;&#34;&#34;
    def __init__(self, points, values, method=&#34;linear&#34;, bounds_error=False, fill_value=np.nan):
        &#34;&#34;&#34;Constructs all necessary attributes for the RegularGridInterpolator object.

        Parameters
        ----------
        points : tuple of 1d arrays
            Each array contains point coordinates (e.g. 2 arrays; 1 for each point’s lat, 1 for each point’s lon).
            Defines the points to sample data with. 
        values : ndarray
            Defines a grid. The number of rows corresponds to the number of latitudinal points, while the number
            of columns corresponds to the number of longitudinal points.
        method : str, default=’linear’
            The method of interpolation to perform. Supported are &#34;linear&#34; and &#34;nearest&#34;. Assumes “linear” by default.
        bounds_error : bool, default=false
            Choose whether to return a ValueError and terminate the interpolation if any provided sample points are out
            of grid bounds. By default, it is set to false. In this case, all out-of-bound point values are replaced 
            with the fill_value (defined below) if supplied.
        fill_value : float, default=np.nan
            Used to replace point values that are out of grid bounds, provided that ‘bounds_error’ is false.
        &#34;&#34;&#34; 
        super(RegularGridInterpolator, self).__init__(points, values, method, bounds_error, fill_value)

    def __call__(self, xi, method=None, return_indices=False, return_distances=False):
        &#34;&#34;&#34;Samples gridded data at a set of point coordinates. Uses either linear or nearest-neighbour interpolation methods.

        Uses the gridded data specified in the sample_grid method parameter. Note: if any provided sample points are out of 
        grid bounds and a corresponding error message was suppressed (by specifying bounds_error=False), all out-of-bound 
        point values are replaced with the self.fill_value attribute ascribed to the RegularGridInterpolator object (if it
        exists). Terminates otherwise.
    
        Parameters
        ----------
        xi : ndarray of shape (..., ndim)
            The coordinates of points to sample the gridded data at.

        method : str, default=None
            The method of interpolation to perform. Supported are &#34;linear&#34; and &#34;Nearest&#34;. Assumes “linear” interpolation
            if None provided.  

        return_indices : bool, default=False
            Choose whether to return indices of neighbouring sampling points. 

        return_distances : bool, default=False
            Choose whether to return normal distances between interpolated points and neighbouring sampling points.

        Returns
        -------
        output_tuple : tuple of ndarrays
            The first ndarray in the output tuple holds the interpolated grid data. If sample point distances and indices are
            required, these are returned as subsequent tuple elements. 

        Raises
        ------
        ValueError
            * Raised if the string method supplied is not “linear” or “nearest”.
            * Raised if the provided sample points for interpolation (xi) do not have the same dimensions as the supplied grid. 
            * Raised if the provided sample points for interpolation include any point out of grid bounds. Alerts user which
            dimension (index) the point is located. Only raised if the RegularGridInterpolator attribute bounds_error is set
            to True. If suppressed, out-of-bound points are replaced with a set fill_value. 
        &#34;&#34;&#34;
        from scipy.interpolate.interpnd import _ndim_coords_from_arrays
        method = self.method if method is None else method
        if method not in [&#34;linear&#34;, &#34;nearest&#34;]:
            raise ValueError(&#34;Method &#39;%s&#39; is not defined&#34; % method)

        ndim = len(self.grid)
        xi = _ndim_coords_from_arrays(xi, ndim=ndim)
        if xi.shape[-1] != len(self.grid):
            raise ValueError(&#34;The requested sample points xi have dimension &#34;
                             &#34;%d, but this RegularGridInterpolator has &#34;
                             &#34;dimension %d&#34; % (xi.shape[1], ndim))

        xi_shape = xi.shape
        xi = xi.reshape(-1, xi_shape[-1])

        if self.bounds_error:
            for i, p in enumerate(xi.T):
                if not np.logical_and(np.all(self.grid[i][0] &lt;= p),
                                      np.all(p &lt;= self.grid[i][-1])):
                    raise ValueError(&#34;One of the requested xi is out of bounds &#34;
                                     &#34;in dimension %d&#34; % i)

        indices, norm_distances, out_of_bounds = self._find_indices(xi.T)
        if method == &#34;linear&#34;:
            result = self._evaluate_linear(indices,
                                           norm_distances,
                                           out_of_bounds)
        elif method == &#34;nearest&#34;:
            result = self._evaluate_nearest(indices,
                                            norm_distances,
                                            out_of_bounds)
        if not self.bounds_error and self.fill_value is not None:
            result[out_of_bounds] = self.fill_value
            
        interp_output = result.reshape(xi_shape[:-1] + self.values.shape[ndim:])
        output_tuple = [interp_output]

        if return_indices:
            output_tuple.append(indices)
        if return_distances:
            output_tuple.append(norm_distances)
        
        if return_distances or return_indices:
            return tuple(output_tuple)
        else:
            return output_tuple[0]


def sample_grid(lon, lat, grid, extent=[-180,180,-90,90], return_indices=False, return_distances=False, method=&#39;linear&#39;):
    &#34;&#34;&#34;Samples gridded data at a set of point coordinates. Uses either linear or nearest-neighbour interpolation methods.
    
    Note: if any provided sample points are out of grid bounds and a corresponding error message was suppressed (by 
    specifying bounds_error=False), all out-of-bound point values are replaced with the RegularGridInterpolator object’s
    self.fill_value attribute (if it exists). Terminates otherwise. 

    Parameters
    ----------
    lon, lat : 1d arrays
        Two arrays each specifying the longitude and latitude of sampling points for interpolation.

    grid : ndarray
        An array with elements that define a grid. The number of rows corresponds to the number of latitudinal points, while
        the number of columns corresponds to the number of longitudinal points.

    extent : 1D numpy array, default=[-180,180,-90,90]
        Four-element array to specify the [min lon, max lon, min lat, max lat] with which to constrain lat and lon sampling
        points with respect to the given grid. If no extents are supplied, full global extent is assumed. 

    return_indices : bool, default=False
        Choose whether to return indices of neighbouring sampling points. 

    return_distances : bool, default=False
        Choose whether to return normal distances between interpolated points and neighbouring sampling points.

    method : str, default=’linear’
        The method of interpolation to perform. Supported are &#34;linear&#34; and &#34;nearest&#34;. Assumes “linear” by default.

    Returns
    -----
    output_tuple : tuple of ndarrays
        The first ndarray in the output tuple holds the interpolated grid data. If sample point distances and indices are
        required, these are returned as subsequent tuple elements. 

    Raises
    ------
    ValueError
        * Raised if the string method supplied is not “linear” or “nearest”.
        * Raised if the provided sample points for interpolation (xi) do not have the same dimensions as the supplied grid. 
        * Raised if the provided sample points for interpolation include any point out of grid bounds. Alerts user which 
        dimension (index) the point is located. Only raised if the RegularGridInterpolator attribute bounds_error is set 
        to True. If suppressed, out-of-bound points are replaced with a set fill_value. 
    &#34;&#34;&#34;
    interpolator = RegularGridInterpolator((np.linspace(extent[2], extent[3], grid.shape[0]),
                                            np.linspace(extent[0], extent[1], grid.shape[1])),
                                            grid, method=method)

    return interpolator(np.c_[lat, lon], return_indices=return_indices, return_distances=return_distances)


def reconstruct_grid(
    grid,
    partitioning_features=None,
    rotation_model=None,
    to_time=0.0,
    from_time=0.0,
    extent=&#34;global&#34;,
    origin=&#34;upper&#34;,
    plate_ids=None,
    threads=1,
):
    &#34;&#34;&#34;Reconstruct a gridded dataset to a given reconstruction time.

    Parameters
    ----------
    grid : array_like, or str
        The grid to be reconstructed. If `grid` is a filename, it will be
        loaded using `gplately.grids.read_netcdf_grid`.
    partitioning_features : valid argument to pygplates.FeaturesFunctionArgument
        Features used to partition `grid` by plate ID, usually a static
        polygons file. `partitioning_features` may be a single
        feature (`pygplates.Feature`), a feature collection
        (`pygplates.FeatureCollection`), a filename (`str`), or a (potentially
        nested) sequence of any combination of the above types.
    rotation_model : valid argument to pygplates.RotationModel
        The rotation model used to reconstruct `grid`.
        `rotation_model` may be a rotation model object
        (`pygplates.RotationModel`), a rotation feature collection
        (`pygplates.FeatureCollection`), a rotation filename
        (`str`), a rotation feature (`pygplates.Feature`), a sequence of
        rotation features, or a (potentially nested) sequence of any
        combination of the above types.
    to_time : float
        Time to which `grid` will be reconstructed.
    from_time : float, default 0.0
        Time from which to reconstruct `grid`.
    extent : tuple or &#34;global&#34;, default &#34;global&#34;
        Extent of `grid`. Valid arguments are a tuple of
        the form (xmin, xmax, ymin, ymax), or the string &#34;global&#34;,
        equivalent to (-180.0, 180.0, -90.0, 90.0).
    origin : {&#34;upper&#34;, &#34;lower&#34;}
        Origin of `grid` - either lower-left or upper-left.
    plate_ids : array_like, optional
        If a rasterised grid of plate IDs has already been obtained
        (e.g. using `gplately.grids.rasterise`), it can be provided here
        in order to avoid repeatedly rasterising `partitioning_features`.
        `plate_ids` must be of the same shape as `grid`.
    threads : int, default 1
        Number of threads to use for certain computationally heavy subroutines.

    Returns
    -------
    numpy.ndarray
        The reconstructed grid. Areas for which no plate ID could be obtained
        from `partitioning_features` will be filled with either `-1` or
        `np.nan`, depending on the dtype of `grid`.
    &#34;&#34;&#34;
    try:
        grid = np.array(read_netcdf_grid(grid))
    except Exception:
        pass
    if to_time == from_time:
        return grid
    elif rotation_model is None:
        raise TypeError(
            &#34;`rotation_model` must be provided if `to_time` != `from_time`&#34;
        )

    if plate_ids is not None:
        plate_ids = np.array(plate_ids)
    if plate_ids is not None and plate_ids.shape != grid.shape:
        raise ValueError(
            &#34;Shape mismatch: &#34;
            + &#34;`grid.shape` == {}, &#34;.format(grid.shape)
            + &#34;`plate_ids.shape` == {}&#34;.format(plate_ids.shape)
        )
    if origin.lower() not in {&#34;lower&#34;, &#34;upper&#34;}:
        raise ValueError(&#34;Invalid `origin` value: {}&#34;.format(origin))
    origin = origin.lower()
    dtype = grid.dtype
    if dtype.kind in (&#34;b&#34;, &#34;u&#34;):
        grid = grid.astype(int)
        dtype = grid.dtype

    if isinstance(threads, str):
        if threads.lower() in {&#34;all&#34;, &#34;max&#34;}:
            threads = cpu_count()
        else:
            raise ValueError(&#34;Invalid `threads` value: {}&#34;.format(threads))
    threads = min([int(threads), cpu_count()])
    threads = max([threads, 1])

    grid = grid.squeeze()
    if grid.ndim != 2:
        raise ValueError(&#34;`grid` has invalid shape {}&#34;.format(grid.shape))
    if extent == &#34;global&#34;:
        extent = (-180, 180, -90, 90)
    xmin, xmax, ymin, ymax = extent
    if xmin &gt; xmax:
        xmin, xmax = xmax, xmin
    if ymin &gt; ymax:
        ymin, ymax = ymax, ymin
    ny, nx = grid.shape
    resx = (xmax - xmin) / nx
    resy = (ymax - ymin) / ny

    if not isinstance(partitioning_features, pygplates.FeatureCollection):
        partitioning_features = pygplates.FeatureCollection(
            pygplates.FeaturesFunctionArgument(
                partitioning_features
            ).get_features()
        )
    if not isinstance(rotation_model, pygplates.RotationModel):
        rotation_model = pygplates.RotationModel(rotation_model)

    lats = np.arange(ymin + resy * 0.5, ymax, resy)
    lons = np.arange(xmin + resx * 0.5, xmax, resx)
    lons, lats = np.meshgrid(lons, lats)
    if plate_ids is None:
        plate_ids = rasterise(
            features=partitioning_features,
            rotation_model=rotation_model,
            key=&#34;plate_id&#34;,
            time=None if to_time == 0.0 and rotation_model is None else to_time,
            extent=extent,
            shape=grid.shape,
        )
        if origin == &#34;upper&#34;:
            plate_ids = np.flipud(plate_ids)
    plate_ids = plate_ids.flatten()

    unique_plate_ids = np.unique(plate_ids)
    rotations_dict = {}
    for plate in unique_plate_ids:
        if plate == -1:
            continue
        rot = rotation_model.get_rotation(
            float(from_time),
            int(plate),
            float(to_time),
        )
        if not isinstance(rot, pygplates.FiniteRotation):
            continue
        lat, lon, angle = rot.get_lat_lon_euler_pole_and_angle_degrees()
        angle = np.deg2rad(angle)
        vec = _lat_lon_to_vector(lat, lon, degrees=True)
        rotations_dict[plate] = (vec, angle)

    point_vecs = _lat_lon_to_vector(
        lats,
        lons,
        degrees=True,
        threads=threads,
    )

    rotated_vecs = np.full_like(point_vecs, np.nan)
    if threads &gt; 1:
        executor = concurrent.futures.ThreadPoolExecutor(threads)
        plate_ids_divided = np.array_split(unique_plate_ids, threads)

        def _fill(ids, out):
            for id in ids:
                if id == -1:
                    continue
                index = plate_ids == id
                vec_subset = point_vecs[index, :]
                rotation, angle = rotations_dict[id]
                rotated = _rotate(vec_subset, rotation, angle)
                out[index] = rotated

        futures = {}
        for i in range(threads):
            args = (
                _fill,
                plate_ids_divided[i],
                rotated_vecs,
            )
            futures[executor.submit(*args)] = i
        concurrent.futures.wait(futures)
        executor.shutdown(False)
    else:
        for plate_id in unique_plate_ids:
            if plate_id == -1:
                continue
            index = plate_ids == plate_id
            vec_subset = point_vecs[index, :]
            rotation, angle = rotations_dict[plate_id]
            rotated = _rotate(vec_subset, rotation, angle)
            rotated_vecs[index] = rotated

    x = rotated_vecs[:, 0]
    y = rotated_vecs[:, 1]
    z = rotated_vecs[:, 2]
    rotated_lats, rotated_lons = _vector_to_lat_lon(
        x,
        y,
        z,
        degrees=True,
        return_array=True,
        threads=threads,
    )
    if origin == &#34;upper&#34;:
        rotated_y = (ymax - rotated_lats) / resy
    else:
        rotated_y = (rotated_lats - ymin) / resy
    rotated_x = np.abs((rotated_lons - xmin) / resx)

    mask = plate_ids != -1
    interp_coords = np.vstack(
        (
            rotated_y.reshape((1, -1)),
            rotated_x.reshape((1, -1)),
        )
    )
    # data = np.full(rotated_lats.size, np.nan)
    if dtype.kind == &#34;i&#34;:
        fill_value = -1
    elif dtype.kind in (&#34;f&#34;, &#34;c&#34;):
        fill_value = np.nan
    else:
        fill_value = np.nan
    data = np.full(rotated_lats.size, fill_value, dtype=dtype)
    tmp = map_coordinates(
        grid,
        interp_coords[:, mask],
        mode=&#34;grid-wrap&#34;,
        order=0,
    ).squeeze()
    data[mask] = tmp
    data = data.reshape(grid.shape)
    if origin == &#34;upper&#34;:
        data = np.flipud(data)
    return data


def rasterise(
    features,
    rotation_model=None,
    key=&#34;plate_id&#34;,
    time=None,
    resx=1.0,
    resy=1.0,
    shape=None,
    extent=&#34;global&#34;,
):
    &#34;&#34;&#34;Rasterise GPlates objects at a given reconstruction time.

    This function is particularly useful for rasterising static polygons
    to extract a grid of plate IDs.

    Parameters
    ----------
    features : valid argument for pygplates.FeaturesFunctionArgument
        `features` may be a single `pygplates.Feature`, a
        `pygplates.FeatureCollection`, a `str` filename,
        or a (potentially nested) sequence of any combination of the
        above types.
    rotation_model : valid argument for pygplates.RotationModel, optional
        `rotation_model` may be a `pygplates.RotationModel`, a rotation
        feature collection (pygplates.FeatureCollection), a rotation filename
        (`str`), a rotation feature (`pygplates.Feature`), a sequence of
        rotation features, or a (potentially nested) sequence of any
        combination of the above types.
        Alternatively, if time not given, a rotation model is
        not usually required.
    key : str, default &#34;plate_id&#34;
        The value used to create the rasterised grid. May be any of
        the following values:
        - &#34;plate_id&#34;
        - &#34;conjugate_plate_id&#34;
        - &#34;from_age&#34;
        - &#34;to_age&#34;
        - &#34;left_plate&#34;
        - &#34;right_plate&#34;
    time : float, optional
        Reconstruction time at which to perform rasterisation. If given,
        `rotation_model` must also be specified.
    resx, resy : float, default 1.0
        Resolution (in degrees) of the rasterised grid.
    shape : tuple, optional
        If given, the output grid will have the specified shape,
        overriding `resx` and `resy`.
    extent : tuple or &#34;global&#34;, default &#34;global&#34;
        Extent of the rasterised grid. Valid arguments are a tuple of
        the form (xmin, xmax, ymin, ymax), or the string &#34;global&#34;,
        equivalent to (-180.0, 180.0, -90.0, 90.0).

    Returns
    -------
    grid : numpy.ndarray
        The output array will have the shape specified in `shape`, if given.
        The origin of the array will be in the lower-left corner of
        the area specified in `extent`, unless `resx` or `resy` is negative.

    Raises
    ------
    ValueError
        If an invalid `key` value is passed.
    TypeError
        If `rotation_model` is not supplied and `time` is not `None`.

    Notes
    -----
    This function is used by gplately.grids.reconstruct_grids to rasterise
    static polygons in order to extract their plate IDs.
    &#34;&#34;&#34;
    valid_keys = {
        &#34;plate_id&#34;,
        &#34;conjugate_plate_id&#34;,
        &#34;from_age&#34;,
        &#34;to_age&#34;,
        &#34;left_plate&#34;,
        &#34;right_plate&#34;,
    }
    try:
        key = key.lower()
    except AttributeError as err:
        raise TypeError(&#34;Invalid key type: {}&#34;.format(type(key))) from err
    if key not in valid_keys:
        raise ValueError(
            &#34;Invalid key: {}&#34;.format(key)
            + &#34;\nkey must be one of {}&#34;.format(valid_keys)
        )

    try:
        extent = extent.lower()
    except AttributeError:
        pass
    if extent == &#34;global&#34;:
        extent = (-180.0, 180.0, -90.0, 90.0)
    minx, maxx, miny, maxy = extent

    if shape is not None:
        lons = np.linspace(minx, maxx, shape[1], endpoint=True)
        lats = np.linspace(miny, maxy, shape[0], endpoint=True)
    else:
        lons = np.arange(minx, maxx + resx, resx)
        lats = np.arange(miny, maxy + resy, resy)
    nx = lons.size
    ny = lats.size

    if rotation_model is None:
        if time is not None:
            raise TypeError(
                &#34;Rotation model must be provided if `time` is not `None`&#34;
            )
        rotation_model = pygplates.RotationModel(pygplates.Feature())
        time = 0.0
    features = pygplates.FeaturesFunctionArgument(features).get_features()
    time = float(time)

    reconstructed = []
    pygplates.reconstruct(
        features,
        rotation_model,
        reconstructed,
        time,
    )
    geometries = pygplates_to_shapely(reconstructed)

    if key == &#34;plate_id&#34;:
        values = [i.get_feature().get_reconstruction_plate_id() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    elif key == &#34;conjugate_plate_id&#34;:
        values = [i.get_feature().get_conjugate_plate_id() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    elif key == &#34;from_age&#34;:
        values = [i.get_feature().get_valid_time()[0] for i in reconstructed]
        fill_value = np.nan
        dtype = np.float32
    elif key == &#34;to_age&#34;:
        values = [i.get_feature().get_valid_time()[1] for i in reconstructed]
        fill_value = np.nan
        dtype = np.float32
    elif key == &#34;left_plate&#34;:
        values = [i.get_feature().get_left_plate() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    elif key == &#34;right_plate&#34;:
        values = [i.get_feature().get_right_plate() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    else:
        raise ValueError(
            &#34;Invalid key: {}&#34;.format(key)
            + &#34;\nkey must be one of {}&#34;.format(valid_keys)
        )

    out = _rasterize(
        shapes=zip(geometries, values),
        out_shape=(ny, nx),
        fill=fill_value,
        dtype=dtype,
        merge_alg=MergeAlg.replace,
        transform=_from_bounds(minx, miny, maxx, maxy, nx, ny),
    )
    return out


rasterize = rasterise


def _lat_lon_to_vector(lat, lon, degrees=False, threads=1):
    &#34;&#34;&#34;Convert (lat, lon) coordinates (degrees or radians) to vectors on
    the unit sphere. Returns a vector of shape (3,) if `lat` and `lon` are
    single values, else an array of shape (N, 3) containing N (x, y, z)
    row vectors, where N is the size of `lat` and `lon`.
    &#34;&#34;&#34;
    lon = np.atleast_1d(lon).flatten()
    lat = np.atleast_1d(lat).flatten()
    if degrees:
        lat = np.deg2rad(lat)
        lon = np.deg2rad(lon)

    if threads == 1:
        x = np.cos(lat) * np.cos(lon)
        y = np.cos(lat) * np.sin(lon)
        z = np.sin(lat)
    else:
        n = lat.size
        step = np.ceil(n / threads).astype(np.int_)
        executor = concurrent.futures.ThreadPoolExecutor(threads)

        def _fill(out_x, out_y, out_z, first, last):
            np.multiply(
                np.cos(lat[first:last]),
                np.cos(lon[first:last]),
                out=out_x[first:last],
            )
            np.multiply(
                np.cos(lat[first:last]),
                np.sin(lon[first:last]),
                out=out_y[first:last],
            )
            np.sin(lat[first:last], out=out_z[first:last])

        futures = {}
        x = np.zeros_like(lat)
        y = np.zeros_like(x)
        z = np.zeros_like(x)
        for i in range(threads):
            args = (
                _fill,
                x,
                y,
                z,
                i * step,
                (i + 1) * step,
            )
            futures[executor.submit(*args)] = i
        concurrent.futures.wait(futures)
        executor.shutdown(False)

    size = x.size
    if size == 1:
        x = np.atleast_1d(np.squeeze(x))[0]
        y = np.atleast_1d(np.squeeze(y))[0]
        z = np.atleast_1d(np.squeeze(z))[0]
        return np.array((x, y, z))

    x = x.reshape((-1, 1))
    y = y.reshape((-1, 1))
    z = z.reshape((-1, 1))
    return np.hstack((x, y, z))


def _vector_to_lat_lon(
    x,
    y,
    z,
    degrees=False,
    return_array=False,
    threads=1,
):
    &#34;&#34;&#34;Convert one or more (x, y, z) vectors (on the unit sphere) to
    (lat, lon) coordinate pairs, in degrees or radians. Optionally, use
    more than one thread.
    &#34;&#34;&#34;
    x = np.atleast_1d(x).flatten()
    y = np.atleast_1d(y).flatten()
    z = np.atleast_1d(z).flatten()

    with warnings.catch_warnings():
        warnings.simplefilter(&#34;ignore&#34;, RuntimeWarning)
        if threads == 1:
            lat = np.arcsin(z)
            lon = np.arctan2(y, x)
            if degrees:
                lat = np.rad2deg(lat)
                lon = np.rad2deg(lon)
        else:
            n = x.size
            step = np.ceil(n / threads).astype(np.int_)
            executor = concurrent.futures.ThreadPoolExecutor(threads)

            def _fill(out_lat, out_lon, first, last, degrees=False):
                if degrees:
                    np.rad2deg(
                        np.arcsin(z[first:last]),
                        out=out_lat[first:last],
                    )
                    np.rad2deg(
                        np.arctan2(
                            y[first:last],
                            x[first:last],
                        ),
                        out=out_lon[first:last],
                    )
                else:
                    np.arcsin(z[first:last], out=out_lat[first:last])
                    np.arctan2(
                        y[first:last],
                        x[first:last],
                        out=out_lon[first:last],
                    )

            futures = {}
            lat = np.zeros_like(x)
            lon = np.zeros_like(lat)
            for i in range(threads):
                args = (
                    _fill,
                    lat,
                    lon,
                    i * step,
                    (i + 1) * step,
                    degrees,
                )
                futures[executor.submit(*args)] = i
            concurrent.futures.wait(futures)
            executor.shutdown(False)

    if lat.size == 1 and not return_array:
        lat = np.atleast_1d(np.squeeze(lat))[0]
        lon = np.atleast_1d(np.squeeze(lon))[0]
        return (lat, lon)

    lat = lat.reshape((-1, 1))
    lon = lon.reshape((-1, 1))
    return lat, lon


def _rotate(vectors, rotation, angle):
    cross = _cross_products
    dot = np.dot

    invalid_dims_err = ValueError(
        &#34;Invalid shapes: {}, {}&#34;.format(vectors.shape, rotation.shape)
    )
    vectors = np.atleast_2d(vectors)
    rotation = np.squeeze(rotation)
    if vectors.shape[1] != 3:
        vectors = vectors.T
    if vectors.shape[1] != 3 or rotation.shape != (3,):
        raise invalid_dims_err

    angle = float(angle)

    t1 = np.cos(angle) * vectors
    t2 = np.sin(angle) * cross(rotation, vectors)
    t3 = (
        (1.0 - np.cos(angle))
        * dot(vectors, rotation.reshape((-1, 1))).reshape((-1, 1))
        * vectors
    )
    return t1 + t2 + t3


def _cross_products(a, b):
    &#34;&#34;&#34;Cross products of a vector and a list of vectors.&#34;&#34;&#34;
    if a.ndim == 2 and b.ndim == 1:
        return -1.0 * _cross_products(b, a)
    vec = a
    arr = b
    invalid_dims_err = ValueError(
        &#34;Invalid dimensions: {}, {}&#34;.format(vec.ndim, arr.ndim)
    )
    if vec.ndim != 1 or arr.ndim != 2:
        raise invalid_dims_err

    if arr.shape[1] != 3:
        arr = arr.T
    if arr.shape[1] != 3:
        raise invalid_dims_err

    out = np.zeros_like(arr)
    out[:, 0] = vec[1] * arr[:, 2] - vec[2] * arr[:, 1]
    out[:, 1] = vec[2] * arr[:, 0] - vec[0] * arr[:, 2]
    out[:, 2] = vec[0] * arr[:, 1] - vec[1] * arr[:, 0]
    return out


class Raster(object):
    &#34;&#34;&#34;A class providing Scipy’s RegularGridInterpolator functionalities for interpolation. 

    Gridded data are sampled at a set of point coordinates using either linear or nearest-neighbour interpolation. 
    These grids can also be resampled using X and Y-direction spacing, and can be resized using X and Y resolutions.
    Grids can be searched for invalid, NaN-type data cells. These can be replaced with the values of their nearest
    valid neighbours. 

    Attributes
    ----------
    PlateReconstruction_object : object pointer
    filename
    array
    extent
    Resample
    data 
    lons
    lats
    method

    Methods
    -------
    __init__(self, filename=None, array=None, extent=None, resample=None)
        Constructs all necessary attributes for the Raster object.
        
    _update(self)
        Allows RegularGridInterpolator attributes ((self.lats, self.lons), self.data, method=&#39;linear&#39;) and methods 
        (__call__(), or RegularGridInterpolator) to be accessible from the Raster object.
        
    interpolate(self, lons, lats, method=&#39;linear&#39;, return_indices=False, return_distances=False)
        Sample gridded data on a set of points using interpolation from RegularGridInterpolator.
        
    resample(self, spacingX, spacingY, overwrite=False)
        Resamples the grid using X &amp; Y-spaced lat-lon arrays, meshed with linear interpolation.
        
    resize(self, resX, resY, overwrite=False)
        Resizes the grid with a specific resolution and samples points using linear interpolation.
        
    fill_NaNs(self, overwrite=False)
        Searches for invalid ‘data’ cells containing NaN-type entries and replaces NaNs with the value of the nearest
        valid data cell.
    &#34;&#34;&#34;
    def __init__(self, PlateReconstruction_object=None, filename=None, array=None, extent=None, resample=None):
        &#34;&#34;&#34;Constructs all necessary attributes for the raster object.

        Note: either a str path to a netCDF file OR an ndarray representing a grid must be specified. 

        Parameters
        ----------
        PlateReconstruction_object : object pointer
            Allows for the accessibility of PlateReconstruction object attributes. Namely, PlateReconstruction object 
            attributes rotation_model, topology_featues and static_polygons can be used in the points object if called using
            “self.PlateReconstruction_object.X”, where X is the attribute.

        filename : str, default=None
            Path to netCDF file
        OR
        array : ndarray, default=None
            An array with elements that define a grid. The number of rows corresponds to the number of latitudinal points, while
            the number of columns corresponds to the number of longitudinal points.

        extent : 1D numpy array, default=None
            Four-element array to specify [min lon, max lon, min lat, max lat] extents of any sampling points. If no extents are 
            supplied, full global extent [-180,180,-90,90] is assumed. 

        resample : tuple, default=None
            Optionally resample grid, pass spacing in X and Y direction as a tuple
            e.g. resample=(spacingX, spacingY)

        Returns
        -------
        __init__ generates the following attributes for the raster object:
        data : ndarray
            The grid - either a read netCDF4 file, or the ndarray supplied to __init__.

        extent : 1d array
            The [min lon, max lon, min lat, max lat] extents supplied to __init__. If not supplied, it is taken to be
            [-180,180,-90,90].

        lons, lats : 1d arrays
            Either the longitude and latitude variables belonging to the netCDF4 file provided, or arrays linearly spaced 
            between the given lon &amp; lat extents to match the dimensions of the grid array.


        The following objects + methods can be accessed in the raster object:
        _update() : method of RegularGridInterpolator
            Stored as _interpolator, this samples the “data” attribute at a set of point coordinates (generated from the 
            attributes “lats” &amp; “lons”). Uses linear interpolation.
        &#34;&#34;&#34;

        self.PlateReconstruction_object = PlateReconstruction_object

        # we initialise an empty points object as we do not want to build this before any resampling takes place.
        self.points = None

        if filename is None and array is None:
            raise ValueError(&#34;Supply either a filename or numpy array&#34;)

        elif filename and array:
            raise ValueError(&#34;Supply either a filename or numpy array&#34;)

        elif filename is not None:
            self.data, lons, lats = read_netcdf_grid(filename, return_grids=True, resample=resample)
            self.extent = [lons.min(), lons.max(), lats.min(), lats.max()]
            self.lons = lons
            self.lats = lats

        elif array is not None:
            if extent is None:
                extent = [-180,180,-90,90]
            self.data = array
            self.extent = extent
            self.lons = np.linspace(extent[0], extent[1], self.data.shape[1])
            self.lats = np.linspace(extent[2], extent[3], self.data.shape[0])

        self._update()

        if array is not None and resample is not None:
            self.resample(*resample, override=True)


    def _update(self):
        &#34;&#34;&#34;Stores the RegularGridInterpolator object’s method for sampling gridded data at a set of point coordinates. 

        Allows methods of the Raster object to access grid sampling functionalities. The gridded data used is the “data” 
        attribute - either read from a netCDF4 file, or supplied as an ndarray. Points to sample are either variables of the 
        netCDF4 file, or are generated from the “extent” attribute and scaled to fit the grid “data”.
        &#34;&#34;&#34;
        # store interpolation object
        interpolator = RegularGridInterpolator((self.lats, self.lons), self.data, method=&#39;linear&#39;)
        self._interpolator = interpolator


    def interpolate(self, lons, lats, method=&#39;linear&#39;, return_indices=False, return_distances=False):
        &#34;&#34;&#34;Samples gridded data at a set of point coordinates and interpolates points on grid. Uses either linear or 
        nearest-neighbour interpolation methods.

        Uses the grid stored in the raster object “data” attribute, and samples a series of points generated with the 
        “lons” and “lats” function parameters.
    
        Parameters
        ----------
        lons, lats : ndarray
            Longitudes and latitudes of points to sample the gridded data with. Used to generate the points ndarrays of 
            shape (..., ndim). Should have the same dimension as the grid “data” attribute.

        method : str, default=’linear’
            The method of interpolation to perform. Supported are &#34;linear&#34; and &#34;Nearest&#34;. Assumes “linear” interpolation
            if None provided.  

        return_indices : bool, default=False
            Choose whether to return indices of neighbouring sampling points. 

        return_distances : bool, default=False
            Choose whether to return normal distances between interpolated points and neighbouring sampling points.

        Returns
        -------
        data_interp : tuple of ndarrays
            The first ndarray in the output tuple holds the interpolated grid data. If sample point distances and indices are
            required, these are returned as subsequent tuple elements. 

        Raises
        ------
        ValueError
            * Raised if the string method supplied is not “linear” or “nearest”.
            * Raised if the provided lat, lon arrays generate sample points that do not have the same dimensions as the 
            supplied grid. 
            * Raised if the provided lat, lon arrays generate sample points that include any point out of grid bounds. 
            Alerts user which dimension (index) the point is located. 
        &#34;&#34;&#34;
        interp = self._interpolator
        interp.values = self.data
        data_interp = interp((lats,lons), method=method, return_indices=return_indices, return_distances=return_distances)
        return data_interp


    def resample(self, spacingX, spacingY, overwrite=False):
        &#34;&#34;&#34;Resamples the grid using linear interpolation. New grid overwrites the current grid stored in the “data” attribute.
        Optional: can also resample and overwrite the arrays in the lats and lons attributes and overwrite the interpolation
        object “_update()”.

        Generates latitude and longitude arrays based on a specific spacing in X and Y directions, and the latitude and 
        longitude extents held in the “extent” raster object attribute. These lat-lon arrays are meshed into a set of sample
        points that are linearly interpolated onto the grid currently held in the “data” attribute. This final grid overwrites
        the current “data” grid. If specified by the user, the generated lat-lon arrays can also overwrite the arrays in the
        “lats” and “lons” raster object attributes.

        Parameters
        ----------
        spacingX, spacingY : ndarray
            Specify the spacing in the X and Y directions with which to resample.

        overwrite : bool, default=False
            Choose to also overwrite lons and lats currently stored in the self.lons andself.lats attributes. Doing so will 
            also overwrite the interpolation object. By default, it is false, so only the “data” grid is overwritten in that 
            case. 

        Returns
        -------
        data : meshed ndarray grid
            A new resampled and linearly-interpolated grid stored to the “data” attribute. Overwrites the current grid held
            in “data”.  
        &#34;&#34;&#34;
        lons = np.arange(self.extent[0], self.extent[1]+spacingX, spacingX)
        lats = np.arange(self.extent[2], self.extent[3]+spacingY, spacingY)
        lonq, latq = np.meshgrid(lons, lats)

        data = self.interpolate(lonq, latq)
        if overwrite:
            self.data = data
            self.lons = lons
            self.lats = lats
            self._update()

        return data


    def resize(self, resX, resY, overwrite=False):
        &#34;&#34;&#34;Resizes the grid with a specific resolution and samples points using linear interpolation. New grid overwrites
        the current grid stored in the “data” attribute. Optional: can also resample and overwrite the arrays in the lats
        and lons attributes and overwrite the interpolation object “_update()”.

        Generates latitude and longitude arrays based on a specific resolution in X and Y directions, and the latitude and
        longitude extents held in the “extent” raster object attribute. These lat-lon arrays are meshed into a set of sample
        points that are linearly interpolated onto the grid currently held in the “data” attribute. This final grid 
        overwrites the current “data” grid. If specified by the user, the generated lat-lon arrays can also overwrite the
        arrays in the “lats” and “lons” raster object attributes.

        Parameters
        ----------
        resX, resY : ndarray
            Specify the resolution (the larger, the finer the grid and lat-lon arrays) with which to resize.

        overwrite : bool, default=False
            Choose to also overwrite lons and lats currently stored in the self.lons andself.lats attributes. Doing so will
            also overwrite the interpolation object. By default, it is false, so only the “data” grid is overwritten in 
            that case. 

        Returns
        -------
        data : meshed ndarray grid
            A new resized and linearly-interpolated grid stored to the “data” attribute. Overwrites the current grid held
            in “data”.
        &#34;&#34;&#34;
        # construct grid
        lons = np.linspace(self.extent[0], self.extent[1], resX)
        lats = np.linspace(self.extent[2], self.extent[3], resY)
        lonq, latq = np.meshgrid(lons, lats)

        data = self.interpolate(lonq, latq)
        if overwrite:
            self.data = data
            self.lons = lons
            self.lats = lats
            self._update()

        return data


    def fill_NaNs(self, overwrite=False):
        &#34;&#34;&#34;Searches for invalid ‘data’ cells containing NaN-type entries (as indicated by ‘invalid’), locates the index
        of the nearest valid data cell and replaces NaNs with the value of the nearest valid data cell.

        Searches a supplied data frame “data” for invalid data cells containing NaN-type entries. If these invalidities 
        have been replaced with a “fill_value” attribute before being passed into fill_raster, there may no longer be 
        invalid cells in the data. If so, the data’s NaN entries are recovered. Where there is an invalid cell in “data”,
        the index of the closest valid data cell entry is located. This is superimposed onto “data”’s invalid cells and
        replaces NaNs with the nearest valid value.

        Parameters
        ---------
        overwrite : bool, default=False
            Choose whether to overwrite the grid currently held in the “data” raster object attribute with the new grid
            (which will have any NaNs filled).

        Returns
        --------
        data : ndarray
            An updated grid of data where each invalid cell has been replaced with the value of its nearest valid neighbour. 
        &#34;&#34;&#34;
        data = fill_raster(self.data)
        if overwrite:
            self.data = data

        return data


    def save_to_NetCDF4(self, filename):
        &#34;&#34;&#34; Saves file to netCDF4 format&#34;&#34;&#34;
        write_netcdf_grid(str(filename), self.data, self.extent)


    def reconstruct(self, to_time, from_time=0, anchor_plate_id=0, **kwargs):

        import stripy

        lonq, latq = np.meshgrid(self.lons, self.lats)
        lonq_ = lonq.ravel()
        latq_ = latq.ravel()

        if self.points is None:
            self.points = _Points(self.PlateReconstruction_object, lonq_, latq_, from_time, anchor_plate_id)

        lons, lats = self.points.reconstruct(to_time, anchor_plate_id=anchor_plate_id, **kwargs)

        # also remove duplicate entries - # BUT this sorts the indices!!
        _, uindex = np.unique(np.c_[lons,lats], return_index=True, axis=0)
        uindex_sorted = sorted(uindex)
        ilons = lons[uindex_sorted]
        ilats = lats[uindex_sorted]
        idata = self.data.flat[uindex_sorted]


        # interpolate onto sphere
        # this is not very elegant - need to work out why stripy is struggling here.
        for i in range(10):
            try:
                mesh = stripy.sTriangulation(np.radians(ilons), np.radians(ilats), tree=True, permute=True)
            except ValueError:
                pass
            else:
                break
        zi, ierr = mesh.interpolate(np.radians(lonq_), np.radians(latq_), idata, order=1)

        # get cell spacing
        dx = np.diff(self.lons).mean()
        dy = np.diff(self.lats).mean()
        dxy = np.hypot(dx,dy)
        rxy = np.radians(dxy)

        # find angular separation / great circle distance between mesh and reconstructed points
        angles, idx = mesh.nearest_vertices(np.radians(lonq_), np.radians(latq_))

        zi[angles.ravel() &gt; rxy] = np.nan
        zi = zi.reshape(lonq.shape)
        return zi


class TimeRaster(Raster):

    def __init__(self, PlateReconstruction_object, filename=None, array=None, extent=None, resample=None):

        super(TimeRaster, self).__init__(filename, array, extent, resample)

        self.PlateReconstruction_object = PlateReconstruction_object</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gplately.grids.fill_raster"><code class="name flex">
<span>def <span class="ident">fill_raster</span></span>(<span>data, invalid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches grid for invalid ‘data’ cells containing NaN-type entries (as indicated by ‘invalid’), locates the index
of the nearest valid data cell and replaces NaNs with the value of the nearest valid data cell.</p>
<p>Searches a supplied data frame “data” for invalid data cells containing NaN-type entries. If these invalidities have been<br>
replaced with a “fill_value” attribute before being passed into fill_raster, there may no longer be invalid cells in the
data. If so, the data’s NaN entries are recovered. Where there is an invalid cell in “data”, the index of the closest
valid data cell entry is located. This is superimposed onto “data”’s invalid cells and replaces NaNs with the nearest
valid value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>A numpy array enclosing grid data that may have invalid cells (entries of type NaN), or formerly-invalid cells masked
with a fill value.</dd>
<dt><strong><code>invalid</code></strong> :&ensp;<code>ndarray</code>, optional, default=<code>None</code></dt>
<dd>A boolean-binary array with the same shape as “data”. Entries should be 1 if its corresponding entry in “data” is of
type NaN, and 0 if its corresponding entry in “data” is valid. Used to locate the indices of the nearest valid data
cells. An optional parameter; by default, this method assumes that “invalid” isn’t provided and will create it if
not supplied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>An updated grid of data where each invalid cell has been replaced with the value of its nearest valid neighbour.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_raster(data,invalid=None):
    &#34;&#34;&#34;Searches grid for invalid ‘data’ cells containing NaN-type entries (as indicated by ‘invalid’), locates the index 
    of the nearest valid data cell and replaces NaNs with the value of the nearest valid data cell.

    Searches a supplied data frame “data” for invalid data cells containing NaN-type entries. If these invalidities have been  
    replaced with a “fill_value” attribute before being passed into fill_raster, there may no longer be invalid cells in the 
    data. If so, the data’s NaN entries are recovered. Where there is an invalid cell in “data”, the index of the closest 
    valid data cell entry is located. This is superimposed onto “data”’s invalid cells and replaces NaNs with the nearest
    valid value.

    Parameters
    ----------
    data : ndarray
        A numpy array enclosing grid data that may have invalid cells (entries of type NaN), or formerly-invalid cells masked 
        with a fill value. 

    invalid : ndarray, optional, default=None
        A boolean-binary array with the same shape as “data”. Entries should be 1 if its corresponding entry in “data” is of 
        type NaN, and 0 if its corresponding entry in “data” is valid. Used to locate the indices of the nearest valid data 
        cells. An optional parameter; by default, this method assumes that “invalid” isn’t provided and will create it if 
        not supplied.

    Returns
    -------
    data : ndarray
        An updated grid of data where each invalid cell has been replaced with the value of its nearest valid neighbour. 
    &#34;&#34;&#34;
    masked_array = hasattr(data, &#34;fill_value&#34;)
    if masked_array:
        mask_fill_value = data.data == data.fill_value
        data = data.data.copy()
        data[mask_fill_value] = np.nan
    else:
        data = data.copy()

    if invalid is None:
        invalid = np.isnan(data)
        if masked_array:
            invalid += mask_fill_value
    ind = distance_transform_edt(invalid, return_distances=False, return_indices=True)
    return data[tuple(ind)]</code></pre>
</details>
</dd>
<dt id="gplately.grids.rasterise"><code class="name flex">
<span>def <span class="ident">rasterise</span></span>(<span>features, rotation_model=None, key='plate_id', time=None, resx=1.0, resy=1.0, shape=None, extent='global')</span>
</code></dt>
<dd>
<div class="desc"><p>Rasterise GPlates objects at a given reconstruction time.</p>
<p>This function is particularly useful for rasterising static polygons
to extract a grid of plate IDs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>valid argument for pygplates.FeaturesFunctionArgument</code></dt>
<dd><code>features</code> may be a single <code>pygplates.Feature</code>, a
<code>pygplates.FeatureCollection</code>, a <code>str</code> filename,
or a (potentially nested) sequence of any combination of the
above types.</dd>
<dt><strong><code>rotation_model</code></strong> :&ensp;<code>valid argument for pygplates.RotationModel</code>, optional</dt>
<dd><code>rotation_model</code> may be a <code>pygplates.RotationModel</code>, a rotation
feature collection (pygplates.FeatureCollection), a rotation filename
(<code>str</code>), a rotation feature (<code>pygplates.Feature</code>), a sequence of
rotation features, or a (potentially nested) sequence of any
combination of the above types.
Alternatively, if time not given, a rotation model is
not usually required.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code>, default <code>"plate_id"</code></dt>
<dd>The value used to create the rasterised grid. May be any of
the following values:
- "plate_id"
- "conjugate_plate_id"
- "from_age"
- "to_age"
- "left_plate"
- "right_plate"</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Reconstruction time at which to perform rasterisation. If given,
<code>rotation_model</code> must also be specified.</dd>
<dt><strong><code>resx</code></strong>, <strong><code>resy</code></strong> :&ensp;<code>float</code>, default <code>1.0</code></dt>
<dd>Resolution (in degrees) of the rasterised grid.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>If given, the output grid will have the specified shape,
overriding <code>resx</code> and <code>resy</code>.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>tuple</code> or <code>"global"</code>, default <code>"global"</code></dt>
<dd>Extent of the rasterised grid. Valid arguments are a tuple of
the form (xmin, xmax, ymin, ymax), or the string "global",
equivalent to (-180.0, 180.0, -90.0, 90.0).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The output array will have the shape specified in <code>shape</code>, if given.
The origin of the array will be in the lower-left corner of
the area specified in <code>extent</code>, unless <code>resx</code> or <code>resy</code> is negative.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If an invalid <code>key</code> value is passed.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>rotation_model</code> is not supplied and <code>time</code> is not <code>None</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function is used by gplately.grids.reconstruct_grids to rasterise
static polygons in order to extract their plate IDs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rasterise(
    features,
    rotation_model=None,
    key=&#34;plate_id&#34;,
    time=None,
    resx=1.0,
    resy=1.0,
    shape=None,
    extent=&#34;global&#34;,
):
    &#34;&#34;&#34;Rasterise GPlates objects at a given reconstruction time.

    This function is particularly useful for rasterising static polygons
    to extract a grid of plate IDs.

    Parameters
    ----------
    features : valid argument for pygplates.FeaturesFunctionArgument
        `features` may be a single `pygplates.Feature`, a
        `pygplates.FeatureCollection`, a `str` filename,
        or a (potentially nested) sequence of any combination of the
        above types.
    rotation_model : valid argument for pygplates.RotationModel, optional
        `rotation_model` may be a `pygplates.RotationModel`, a rotation
        feature collection (pygplates.FeatureCollection), a rotation filename
        (`str`), a rotation feature (`pygplates.Feature`), a sequence of
        rotation features, or a (potentially nested) sequence of any
        combination of the above types.
        Alternatively, if time not given, a rotation model is
        not usually required.
    key : str, default &#34;plate_id&#34;
        The value used to create the rasterised grid. May be any of
        the following values:
        - &#34;plate_id&#34;
        - &#34;conjugate_plate_id&#34;
        - &#34;from_age&#34;
        - &#34;to_age&#34;
        - &#34;left_plate&#34;
        - &#34;right_plate&#34;
    time : float, optional
        Reconstruction time at which to perform rasterisation. If given,
        `rotation_model` must also be specified.
    resx, resy : float, default 1.0
        Resolution (in degrees) of the rasterised grid.
    shape : tuple, optional
        If given, the output grid will have the specified shape,
        overriding `resx` and `resy`.
    extent : tuple or &#34;global&#34;, default &#34;global&#34;
        Extent of the rasterised grid. Valid arguments are a tuple of
        the form (xmin, xmax, ymin, ymax), or the string &#34;global&#34;,
        equivalent to (-180.0, 180.0, -90.0, 90.0).

    Returns
    -------
    grid : numpy.ndarray
        The output array will have the shape specified in `shape`, if given.
        The origin of the array will be in the lower-left corner of
        the area specified in `extent`, unless `resx` or `resy` is negative.

    Raises
    ------
    ValueError
        If an invalid `key` value is passed.
    TypeError
        If `rotation_model` is not supplied and `time` is not `None`.

    Notes
    -----
    This function is used by gplately.grids.reconstruct_grids to rasterise
    static polygons in order to extract their plate IDs.
    &#34;&#34;&#34;
    valid_keys = {
        &#34;plate_id&#34;,
        &#34;conjugate_plate_id&#34;,
        &#34;from_age&#34;,
        &#34;to_age&#34;,
        &#34;left_plate&#34;,
        &#34;right_plate&#34;,
    }
    try:
        key = key.lower()
    except AttributeError as err:
        raise TypeError(&#34;Invalid key type: {}&#34;.format(type(key))) from err
    if key not in valid_keys:
        raise ValueError(
            &#34;Invalid key: {}&#34;.format(key)
            + &#34;\nkey must be one of {}&#34;.format(valid_keys)
        )

    try:
        extent = extent.lower()
    except AttributeError:
        pass
    if extent == &#34;global&#34;:
        extent = (-180.0, 180.0, -90.0, 90.0)
    minx, maxx, miny, maxy = extent

    if shape is not None:
        lons = np.linspace(minx, maxx, shape[1], endpoint=True)
        lats = np.linspace(miny, maxy, shape[0], endpoint=True)
    else:
        lons = np.arange(minx, maxx + resx, resx)
        lats = np.arange(miny, maxy + resy, resy)
    nx = lons.size
    ny = lats.size

    if rotation_model is None:
        if time is not None:
            raise TypeError(
                &#34;Rotation model must be provided if `time` is not `None`&#34;
            )
        rotation_model = pygplates.RotationModel(pygplates.Feature())
        time = 0.0
    features = pygplates.FeaturesFunctionArgument(features).get_features()
    time = float(time)

    reconstructed = []
    pygplates.reconstruct(
        features,
        rotation_model,
        reconstructed,
        time,
    )
    geometries = pygplates_to_shapely(reconstructed)

    if key == &#34;plate_id&#34;:
        values = [i.get_feature().get_reconstruction_plate_id() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    elif key == &#34;conjugate_plate_id&#34;:
        values = [i.get_feature().get_conjugate_plate_id() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    elif key == &#34;from_age&#34;:
        values = [i.get_feature().get_valid_time()[0] for i in reconstructed]
        fill_value = np.nan
        dtype = np.float32
    elif key == &#34;to_age&#34;:
        values = [i.get_feature().get_valid_time()[1] for i in reconstructed]
        fill_value = np.nan
        dtype = np.float32
    elif key == &#34;left_plate&#34;:
        values = [i.get_feature().get_left_plate() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    elif key == &#34;right_plate&#34;:
        values = [i.get_feature().get_right_plate() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    else:
        raise ValueError(
            &#34;Invalid key: {}&#34;.format(key)
            + &#34;\nkey must be one of {}&#34;.format(valid_keys)
        )

    out = _rasterize(
        shapes=zip(geometries, values),
        out_shape=(ny, nx),
        fill=fill_value,
        dtype=dtype,
        merge_alg=MergeAlg.replace,
        transform=_from_bounds(minx, miny, maxx, maxy, nx, ny),
    )
    return out</code></pre>
</details>
</dd>
<dt id="gplately.grids.rasterize"><code class="name flex">
<span>def <span class="ident">rasterize</span></span>(<span>features, rotation_model=None, key='plate_id', time=None, resx=1.0, resy=1.0, shape=None, extent='global')</span>
</code></dt>
<dd>
<div class="desc"><p>Rasterise GPlates objects at a given reconstruction time.</p>
<p>This function is particularly useful for rasterising static polygons
to extract a grid of plate IDs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>valid argument for pygplates.FeaturesFunctionArgument</code></dt>
<dd><code>features</code> may be a single <code>pygplates.Feature</code>, a
<code>pygplates.FeatureCollection</code>, a <code>str</code> filename,
or a (potentially nested) sequence of any combination of the
above types.</dd>
<dt><strong><code>rotation_model</code></strong> :&ensp;<code>valid argument for pygplates.RotationModel</code>, optional</dt>
<dd><code>rotation_model</code> may be a <code>pygplates.RotationModel</code>, a rotation
feature collection (pygplates.FeatureCollection), a rotation filename
(<code>str</code>), a rotation feature (<code>pygplates.Feature</code>), a sequence of
rotation features, or a (potentially nested) sequence of any
combination of the above types.
Alternatively, if time not given, a rotation model is
not usually required.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code>, default <code>"plate_id"</code></dt>
<dd>The value used to create the rasterised grid. May be any of
the following values:
- "plate_id"
- "conjugate_plate_id"
- "from_age"
- "to_age"
- "left_plate"
- "right_plate"</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Reconstruction time at which to perform rasterisation. If given,
<code>rotation_model</code> must also be specified.</dd>
<dt><strong><code>resx</code></strong>, <strong><code>resy</code></strong> :&ensp;<code>float</code>, default <code>1.0</code></dt>
<dd>Resolution (in degrees) of the rasterised grid.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>If given, the output grid will have the specified shape,
overriding <code>resx</code> and <code>resy</code>.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>tuple</code> or <code>"global"</code>, default <code>"global"</code></dt>
<dd>Extent of the rasterised grid. Valid arguments are a tuple of
the form (xmin, xmax, ymin, ymax), or the string "global",
equivalent to (-180.0, 180.0, -90.0, 90.0).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The output array will have the shape specified in <code>shape</code>, if given.
The origin of the array will be in the lower-left corner of
the area specified in <code>extent</code>, unless <code>resx</code> or <code>resy</code> is negative.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If an invalid <code>key</code> value is passed.</dd>
<dt><code>TypeError</code></dt>
<dd>If <code>rotation_model</code> is not supplied and <code>time</code> is not <code>None</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function is used by gplately.grids.reconstruct_grids to rasterise
static polygons in order to extract their plate IDs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rasterise(
    features,
    rotation_model=None,
    key=&#34;plate_id&#34;,
    time=None,
    resx=1.0,
    resy=1.0,
    shape=None,
    extent=&#34;global&#34;,
):
    &#34;&#34;&#34;Rasterise GPlates objects at a given reconstruction time.

    This function is particularly useful for rasterising static polygons
    to extract a grid of plate IDs.

    Parameters
    ----------
    features : valid argument for pygplates.FeaturesFunctionArgument
        `features` may be a single `pygplates.Feature`, a
        `pygplates.FeatureCollection`, a `str` filename,
        or a (potentially nested) sequence of any combination of the
        above types.
    rotation_model : valid argument for pygplates.RotationModel, optional
        `rotation_model` may be a `pygplates.RotationModel`, a rotation
        feature collection (pygplates.FeatureCollection), a rotation filename
        (`str`), a rotation feature (`pygplates.Feature`), a sequence of
        rotation features, or a (potentially nested) sequence of any
        combination of the above types.
        Alternatively, if time not given, a rotation model is
        not usually required.
    key : str, default &#34;plate_id&#34;
        The value used to create the rasterised grid. May be any of
        the following values:
        - &#34;plate_id&#34;
        - &#34;conjugate_plate_id&#34;
        - &#34;from_age&#34;
        - &#34;to_age&#34;
        - &#34;left_plate&#34;
        - &#34;right_plate&#34;
    time : float, optional
        Reconstruction time at which to perform rasterisation. If given,
        `rotation_model` must also be specified.
    resx, resy : float, default 1.0
        Resolution (in degrees) of the rasterised grid.
    shape : tuple, optional
        If given, the output grid will have the specified shape,
        overriding `resx` and `resy`.
    extent : tuple or &#34;global&#34;, default &#34;global&#34;
        Extent of the rasterised grid. Valid arguments are a tuple of
        the form (xmin, xmax, ymin, ymax), or the string &#34;global&#34;,
        equivalent to (-180.0, 180.0, -90.0, 90.0).

    Returns
    -------
    grid : numpy.ndarray
        The output array will have the shape specified in `shape`, if given.
        The origin of the array will be in the lower-left corner of
        the area specified in `extent`, unless `resx` or `resy` is negative.

    Raises
    ------
    ValueError
        If an invalid `key` value is passed.
    TypeError
        If `rotation_model` is not supplied and `time` is not `None`.

    Notes
    -----
    This function is used by gplately.grids.reconstruct_grids to rasterise
    static polygons in order to extract their plate IDs.
    &#34;&#34;&#34;
    valid_keys = {
        &#34;plate_id&#34;,
        &#34;conjugate_plate_id&#34;,
        &#34;from_age&#34;,
        &#34;to_age&#34;,
        &#34;left_plate&#34;,
        &#34;right_plate&#34;,
    }
    try:
        key = key.lower()
    except AttributeError as err:
        raise TypeError(&#34;Invalid key type: {}&#34;.format(type(key))) from err
    if key not in valid_keys:
        raise ValueError(
            &#34;Invalid key: {}&#34;.format(key)
            + &#34;\nkey must be one of {}&#34;.format(valid_keys)
        )

    try:
        extent = extent.lower()
    except AttributeError:
        pass
    if extent == &#34;global&#34;:
        extent = (-180.0, 180.0, -90.0, 90.0)
    minx, maxx, miny, maxy = extent

    if shape is not None:
        lons = np.linspace(minx, maxx, shape[1], endpoint=True)
        lats = np.linspace(miny, maxy, shape[0], endpoint=True)
    else:
        lons = np.arange(minx, maxx + resx, resx)
        lats = np.arange(miny, maxy + resy, resy)
    nx = lons.size
    ny = lats.size

    if rotation_model is None:
        if time is not None:
            raise TypeError(
                &#34;Rotation model must be provided if `time` is not `None`&#34;
            )
        rotation_model = pygplates.RotationModel(pygplates.Feature())
        time = 0.0
    features = pygplates.FeaturesFunctionArgument(features).get_features()
    time = float(time)

    reconstructed = []
    pygplates.reconstruct(
        features,
        rotation_model,
        reconstructed,
        time,
    )
    geometries = pygplates_to_shapely(reconstructed)

    if key == &#34;plate_id&#34;:
        values = [i.get_feature().get_reconstruction_plate_id() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    elif key == &#34;conjugate_plate_id&#34;:
        values = [i.get_feature().get_conjugate_plate_id() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    elif key == &#34;from_age&#34;:
        values = [i.get_feature().get_valid_time()[0] for i in reconstructed]
        fill_value = np.nan
        dtype = np.float32
    elif key == &#34;to_age&#34;:
        values = [i.get_feature().get_valid_time()[1] for i in reconstructed]
        fill_value = np.nan
        dtype = np.float32
    elif key == &#34;left_plate&#34;:
        values = [i.get_feature().get_left_plate() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    elif key == &#34;right_plate&#34;:
        values = [i.get_feature().get_right_plate() for i in reconstructed]
        fill_value = -1
        dtype = np.int32
    else:
        raise ValueError(
            &#34;Invalid key: {}&#34;.format(key)
            + &#34;\nkey must be one of {}&#34;.format(valid_keys)
        )

    out = _rasterize(
        shapes=zip(geometries, values),
        out_shape=(ny, nx),
        fill=fill_value,
        dtype=dtype,
        merge_alg=MergeAlg.replace,
        transform=_from_bounds(minx, miny, maxx, maxy, nx, ny),
    )
    return out</code></pre>
</details>
</dd>
<dt id="gplately.grids.read_netcdf_grid"><code class="name flex">
<span>def <span class="ident">read_netcdf_grid</span></span>(<span>filename, return_grids=False, resample=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads in a netCDF file and re-aligns its grid, lat and lon variables from -180 to 180 degrees.</p>
<p>Can optionally resample grid if given required spacing in X and Y direction. Depending on user preference, it can
return the grid read from the file, or the grid along with its associated lat, lon arrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to netCDF file</dd>
<dt><strong><code>return_grids</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If set to True, optionally returns lon, lat arrays associated with grid.</dd>
<dt><strong><code>resample</code></strong> :&ensp;<code>tuple</code>, default=<code>None</code></dt>
<dd>Optionally resample grid, pass spacing in X and Y direction as a tuple
e.g. resample=(spacingX, spacingY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cdf_grid_z</code></strong> :&ensp;<code>array-like</code></dt>
<dd>A numpy array of the grid defined by the supplied netCDF4 file. Can be resampled if given a specific spacing in
the X and Y directions. Entries are rescaled using longitudes between -180 and 180 degrees.</dd>
<dt><strong><code>cdf_lon</code></strong>, <strong><code>cdf_lat</code></strong> :&ensp;<code>array-like</code></dt>
<dd>Numpy arrays encasing longitude and latitude variables belonging to the supplied netCDF4 file. Longitudes are
rescaled between -180 and 180 degrees.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_netcdf_grid(filename, return_grids=False, resample=None):
    &#34;&#34;&#34;Reads in a netCDF file and re-aligns its grid, lat and lon variables from -180 to 180 degrees.

    Can optionally resample grid if given required spacing in X and Y direction. Depending on user preference, it can 
    return the grid read from the file, or the grid along with its associated lat, lon arrays.
    
    Parameters
    ----------
    filename : str
        Path to netCDF file
        
    return_grids : bool, default=False
        If set to True, optionally returns lon, lat arrays associated with grid.
        
    resample : tuple, default=None
        Optionally resample grid, pass spacing in X and Y direction as a tuple
        e.g. resample=(spacingX, spacingY)

    Returns
    -------
    cdf_grid_z : array-like
        A numpy array of the grid defined by the supplied netCDF4 file. Can be resampled if given a specific spacing in 
        the X and Y directions. Entries are rescaled using longitudes between -180 and 180 degrees.

    cdf_lon, cdf_lat : array-like
        Numpy arrays encasing longitude and latitude variables belonging to the supplied netCDF4 file. Longitudes are 
        rescaled between -180 and 180 degrees.  
    &#34;&#34;&#34;
    import netCDF4
    
    # open netCDF file and re-align from -180, 180 degrees
    with netCDF4.Dataset(filename, &#39;r&#39;) as cdf:
        cdf_grid = cdf[&#34;z&#34;]
        try:
            cdf_lon = cdf[&#39;lon&#39;][:]
            cdf_lat = cdf[&#39;lat&#39;][:]
        except:
            cdf_lon = cdf[&#39;x&#39;][:]
            cdf_lat = cdf[&#39;y&#39;][:]
            
        cdf_lon_mask = cdf_lon[:] &gt; 180
        dlon = np.diff(cdf_lon[:]).mean()
        
        if cdf_lon_mask.any():
            cdf_grid_z = np.hstack([cdf_grid[:,cdf_lon_mask], cdf_grid[:,~cdf_lon_mask]])
            cdf_lon = np.hstack([cdf_lon[cdf_lon_mask]-360-dlon, cdf_lon[~cdf_lon_mask]])
        else:
            cdf_grid_z = cdf_grid[:]

    # resample
    if resample is not None:
        spacingX, spacingY = resample
        lon_grid = np.arange(cdf_lon.min(), cdf_lon.max()+spacingX, spacingX)
        lat_grid = np.arange(cdf_lat.min(), cdf_lat.max()+spacingY, spacingY)
        lonq, latq = np.meshgrid(lon_grid, lat_grid)
        interp = RegularGridInterpolator((cdf_lat, cdf_lon), cdf_grid_z, method=&#39;nearest&#39;, bounds_error=False)
        cdf_grid_z = interp((latq, lonq))
        cdf_lon = lon_grid
        cdf_lat = lat_grid
            
    if return_grids:
        return cdf_grid_z, cdf_lon, cdf_lat
    else:
        return cdf_grid_z</code></pre>
</details>
</dd>
<dt id="gplately.grids.reconstruct_grid"><code class="name flex">
<span>def <span class="ident">reconstruct_grid</span></span>(<span>grid, partitioning_features=None, rotation_model=None, to_time=0.0, from_time=0.0, extent='global', origin='upper', plate_ids=None, threads=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct a gridded dataset to a given reconstruction time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>array_like,</code> or <code>str</code></dt>
<dd>The grid to be reconstructed. If <code>grid</code> is a filename, it will be
loaded using <code><a title="gplately.grids.read_netcdf_grid" href="#gplately.grids.read_netcdf_grid">read_netcdf_grid()</a></code>.</dd>
<dt><strong><code>partitioning_features</code></strong> :&ensp;<code>valid argument to pygplates.FeaturesFunctionArgument</code></dt>
<dd>Features used to partition <code>grid</code> by plate ID, usually a static
polygons file. <code>partitioning_features</code> may be a single
feature (<code>pygplates.Feature</code>), a feature collection
(<code>pygplates.FeatureCollection</code>), a filename (<code>str</code>), or a (potentially
nested) sequence of any combination of the above types.</dd>
<dt><strong><code>rotation_model</code></strong> :&ensp;<code>valid argument to pygplates.RotationModel</code></dt>
<dd>The rotation model used to reconstruct <code>grid</code>.
<code>rotation_model</code> may be a rotation model object
(<code>pygplates.RotationModel</code>), a rotation feature collection
(<code>pygplates.FeatureCollection</code>), a rotation filename
(<code>str</code>), a rotation feature (<code>pygplates.Feature</code>), a sequence of
rotation features, or a (potentially nested) sequence of any
combination of the above types.</dd>
<dt><strong><code>to_time</code></strong> :&ensp;<code>float</code></dt>
<dd>Time to which <code>grid</code> will be reconstructed.</dd>
<dt><strong><code>from_time</code></strong> :&ensp;<code>float</code>, default <code>0.0</code></dt>
<dd>Time from which to reconstruct <code>grid</code>.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>tuple</code> or <code>"global"</code>, default <code>"global"</code></dt>
<dd>Extent of <code>grid</code>. Valid arguments are a tuple of
the form (xmin, xmax, ymin, ymax), or the string "global",
equivalent to (-180.0, 180.0, -90.0, 90.0).</dd>
<dt><strong><code>origin</code></strong> :&ensp;<code>{"upper", "lower"}</code></dt>
<dd>Origin of <code>grid</code> - either lower-left or upper-left.</dd>
<dt><strong><code>plate_ids</code></strong> :&ensp;<code>array_like</code>, optional</dt>
<dd>If a rasterised grid of plate IDs has already been obtained
(e.g. using <code><a title="gplately.grids.rasterise" href="#gplately.grids.rasterise">rasterise()</a></code>), it can be provided here
in order to avoid repeatedly rasterising <code>partitioning_features</code>.
<code>plate_ids</code> must be of the same shape as <code>grid</code>.</dd>
<dt><strong><code>threads</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Number of threads to use for certain computationally heavy subroutines.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>The reconstructed grid. Areas for which no plate ID could be obtained
from <code>partitioning_features</code> will be filled with either <code>-1</code> or
<code>np.nan</code>, depending on the dtype of <code>grid</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_grid(
    grid,
    partitioning_features=None,
    rotation_model=None,
    to_time=0.0,
    from_time=0.0,
    extent=&#34;global&#34;,
    origin=&#34;upper&#34;,
    plate_ids=None,
    threads=1,
):
    &#34;&#34;&#34;Reconstruct a gridded dataset to a given reconstruction time.

    Parameters
    ----------
    grid : array_like, or str
        The grid to be reconstructed. If `grid` is a filename, it will be
        loaded using `gplately.grids.read_netcdf_grid`.
    partitioning_features : valid argument to pygplates.FeaturesFunctionArgument
        Features used to partition `grid` by plate ID, usually a static
        polygons file. `partitioning_features` may be a single
        feature (`pygplates.Feature`), a feature collection
        (`pygplates.FeatureCollection`), a filename (`str`), or a (potentially
        nested) sequence of any combination of the above types.
    rotation_model : valid argument to pygplates.RotationModel
        The rotation model used to reconstruct `grid`.
        `rotation_model` may be a rotation model object
        (`pygplates.RotationModel`), a rotation feature collection
        (`pygplates.FeatureCollection`), a rotation filename
        (`str`), a rotation feature (`pygplates.Feature`), a sequence of
        rotation features, or a (potentially nested) sequence of any
        combination of the above types.
    to_time : float
        Time to which `grid` will be reconstructed.
    from_time : float, default 0.0
        Time from which to reconstruct `grid`.
    extent : tuple or &#34;global&#34;, default &#34;global&#34;
        Extent of `grid`. Valid arguments are a tuple of
        the form (xmin, xmax, ymin, ymax), or the string &#34;global&#34;,
        equivalent to (-180.0, 180.0, -90.0, 90.0).
    origin : {&#34;upper&#34;, &#34;lower&#34;}
        Origin of `grid` - either lower-left or upper-left.
    plate_ids : array_like, optional
        If a rasterised grid of plate IDs has already been obtained
        (e.g. using `gplately.grids.rasterise`), it can be provided here
        in order to avoid repeatedly rasterising `partitioning_features`.
        `plate_ids` must be of the same shape as `grid`.
    threads : int, default 1
        Number of threads to use for certain computationally heavy subroutines.

    Returns
    -------
    numpy.ndarray
        The reconstructed grid. Areas for which no plate ID could be obtained
        from `partitioning_features` will be filled with either `-1` or
        `np.nan`, depending on the dtype of `grid`.
    &#34;&#34;&#34;
    try:
        grid = np.array(read_netcdf_grid(grid))
    except Exception:
        pass
    if to_time == from_time:
        return grid
    elif rotation_model is None:
        raise TypeError(
            &#34;`rotation_model` must be provided if `to_time` != `from_time`&#34;
        )

    if plate_ids is not None:
        plate_ids = np.array(plate_ids)
    if plate_ids is not None and plate_ids.shape != grid.shape:
        raise ValueError(
            &#34;Shape mismatch: &#34;
            + &#34;`grid.shape` == {}, &#34;.format(grid.shape)
            + &#34;`plate_ids.shape` == {}&#34;.format(plate_ids.shape)
        )
    if origin.lower() not in {&#34;lower&#34;, &#34;upper&#34;}:
        raise ValueError(&#34;Invalid `origin` value: {}&#34;.format(origin))
    origin = origin.lower()
    dtype = grid.dtype
    if dtype.kind in (&#34;b&#34;, &#34;u&#34;):
        grid = grid.astype(int)
        dtype = grid.dtype

    if isinstance(threads, str):
        if threads.lower() in {&#34;all&#34;, &#34;max&#34;}:
            threads = cpu_count()
        else:
            raise ValueError(&#34;Invalid `threads` value: {}&#34;.format(threads))
    threads = min([int(threads), cpu_count()])
    threads = max([threads, 1])

    grid = grid.squeeze()
    if grid.ndim != 2:
        raise ValueError(&#34;`grid` has invalid shape {}&#34;.format(grid.shape))
    if extent == &#34;global&#34;:
        extent = (-180, 180, -90, 90)
    xmin, xmax, ymin, ymax = extent
    if xmin &gt; xmax:
        xmin, xmax = xmax, xmin
    if ymin &gt; ymax:
        ymin, ymax = ymax, ymin
    ny, nx = grid.shape
    resx = (xmax - xmin) / nx
    resy = (ymax - ymin) / ny

    if not isinstance(partitioning_features, pygplates.FeatureCollection):
        partitioning_features = pygplates.FeatureCollection(
            pygplates.FeaturesFunctionArgument(
                partitioning_features
            ).get_features()
        )
    if not isinstance(rotation_model, pygplates.RotationModel):
        rotation_model = pygplates.RotationModel(rotation_model)

    lats = np.arange(ymin + resy * 0.5, ymax, resy)
    lons = np.arange(xmin + resx * 0.5, xmax, resx)
    lons, lats = np.meshgrid(lons, lats)
    if plate_ids is None:
        plate_ids = rasterise(
            features=partitioning_features,
            rotation_model=rotation_model,
            key=&#34;plate_id&#34;,
            time=None if to_time == 0.0 and rotation_model is None else to_time,
            extent=extent,
            shape=grid.shape,
        )
        if origin == &#34;upper&#34;:
            plate_ids = np.flipud(plate_ids)
    plate_ids = plate_ids.flatten()

    unique_plate_ids = np.unique(plate_ids)
    rotations_dict = {}
    for plate in unique_plate_ids:
        if plate == -1:
            continue
        rot = rotation_model.get_rotation(
            float(from_time),
            int(plate),
            float(to_time),
        )
        if not isinstance(rot, pygplates.FiniteRotation):
            continue
        lat, lon, angle = rot.get_lat_lon_euler_pole_and_angle_degrees()
        angle = np.deg2rad(angle)
        vec = _lat_lon_to_vector(lat, lon, degrees=True)
        rotations_dict[plate] = (vec, angle)

    point_vecs = _lat_lon_to_vector(
        lats,
        lons,
        degrees=True,
        threads=threads,
    )

    rotated_vecs = np.full_like(point_vecs, np.nan)
    if threads &gt; 1:
        executor = concurrent.futures.ThreadPoolExecutor(threads)
        plate_ids_divided = np.array_split(unique_plate_ids, threads)

        def _fill(ids, out):
            for id in ids:
                if id == -1:
                    continue
                index = plate_ids == id
                vec_subset = point_vecs[index, :]
                rotation, angle = rotations_dict[id]
                rotated = _rotate(vec_subset, rotation, angle)
                out[index] = rotated

        futures = {}
        for i in range(threads):
            args = (
                _fill,
                plate_ids_divided[i],
                rotated_vecs,
            )
            futures[executor.submit(*args)] = i
        concurrent.futures.wait(futures)
        executor.shutdown(False)
    else:
        for plate_id in unique_plate_ids:
            if plate_id == -1:
                continue
            index = plate_ids == plate_id
            vec_subset = point_vecs[index, :]
            rotation, angle = rotations_dict[plate_id]
            rotated = _rotate(vec_subset, rotation, angle)
            rotated_vecs[index] = rotated

    x = rotated_vecs[:, 0]
    y = rotated_vecs[:, 1]
    z = rotated_vecs[:, 2]
    rotated_lats, rotated_lons = _vector_to_lat_lon(
        x,
        y,
        z,
        degrees=True,
        return_array=True,
        threads=threads,
    )
    if origin == &#34;upper&#34;:
        rotated_y = (ymax - rotated_lats) / resy
    else:
        rotated_y = (rotated_lats - ymin) / resy
    rotated_x = np.abs((rotated_lons - xmin) / resx)

    mask = plate_ids != -1
    interp_coords = np.vstack(
        (
            rotated_y.reshape((1, -1)),
            rotated_x.reshape((1, -1)),
        )
    )
    # data = np.full(rotated_lats.size, np.nan)
    if dtype.kind == &#34;i&#34;:
        fill_value = -1
    elif dtype.kind in (&#34;f&#34;, &#34;c&#34;):
        fill_value = np.nan
    else:
        fill_value = np.nan
    data = np.full(rotated_lats.size, fill_value, dtype=dtype)
    tmp = map_coordinates(
        grid,
        interp_coords[:, mask],
        mode=&#34;grid-wrap&#34;,
        order=0,
    ).squeeze()
    data[mask] = tmp
    data = data.reshape(grid.shape)
    if origin == &#34;upper&#34;:
        data = np.flipud(data)
    return data</code></pre>
</details>
</dd>
<dt id="gplately.grids.sample_grid"><code class="name flex">
<span>def <span class="ident">sample_grid</span></span>(<span>lon, lat, grid, extent=[-180, 180, -90, 90], return_indices=False, return_distances=False, method='linear')</span>
</code></dt>
<dd>
<div class="desc"><p>Samples gridded data at a set of point coordinates. Uses either linear or nearest-neighbour interpolation methods.</p>
<p>Note: if any provided sample points are out of grid bounds and a corresponding error message was suppressed (by
specifying bounds_error=False), all out-of-bound point values are replaced with the RegularGridInterpolator object’s
self.fill_value attribute (if it exists). Terminates otherwise. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lon</code></strong>, <strong><code>lat</code></strong> :&ensp;<code>1d arrays</code></dt>
<dd>Two arrays each specifying the longitude and latitude of sampling points for interpolation.</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>An array with elements that define a grid. The number of rows corresponds to the number of latitudinal points, while
the number of columns corresponds to the number of longitudinal points.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>1D numpy array</code>, default=<code>[-180,180,-90,90]</code></dt>
<dd>Four-element array to specify the [min lon, max lon, min lat, max lat] with which to constrain lat and lon sampling
points with respect to the given grid. If no extents are supplied, full global extent is assumed.</dd>
<dt><strong><code>return_indices</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Choose whether to return indices of neighbouring sampling points.</dd>
<dt><strong><code>return_distances</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Choose whether to return normal distances between interpolated points and neighbouring sampling points.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, default=<code>’linear’</code></dt>
<dd>The method of interpolation to perform. Supported are "linear" and "nearest". Assumes “linear” by default.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output_tuple</code></strong> :&ensp;<code>tuple</code> of <code>ndarrays</code></dt>
<dd>The first ndarray in the output tuple holds the interpolated grid data. If sample point distances and indices are
required, these are returned as subsequent tuple elements.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>
<ul>
<li>Raised if the string method supplied is not “linear” or “nearest”.</li>
<li>Raised if the provided sample points for interpolation (xi) do not have the same dimensions as the supplied grid. </li>
<li>Raised if the provided sample points for interpolation include any point out of grid bounds. Alerts user which
dimension (index) the point is located. Only raised if the RegularGridInterpolator attribute bounds_error is set
to True. If suppressed, out-of-bound points are replaced with a set fill_value.</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_grid(lon, lat, grid, extent=[-180,180,-90,90], return_indices=False, return_distances=False, method=&#39;linear&#39;):
    &#34;&#34;&#34;Samples gridded data at a set of point coordinates. Uses either linear or nearest-neighbour interpolation methods.
    
    Note: if any provided sample points are out of grid bounds and a corresponding error message was suppressed (by 
    specifying bounds_error=False), all out-of-bound point values are replaced with the RegularGridInterpolator object’s
    self.fill_value attribute (if it exists). Terminates otherwise. 

    Parameters
    ----------
    lon, lat : 1d arrays
        Two arrays each specifying the longitude and latitude of sampling points for interpolation.

    grid : ndarray
        An array with elements that define a grid. The number of rows corresponds to the number of latitudinal points, while
        the number of columns corresponds to the number of longitudinal points.

    extent : 1D numpy array, default=[-180,180,-90,90]
        Four-element array to specify the [min lon, max lon, min lat, max lat] with which to constrain lat and lon sampling
        points with respect to the given grid. If no extents are supplied, full global extent is assumed. 

    return_indices : bool, default=False
        Choose whether to return indices of neighbouring sampling points. 

    return_distances : bool, default=False
        Choose whether to return normal distances between interpolated points and neighbouring sampling points.

    method : str, default=’linear’
        The method of interpolation to perform. Supported are &#34;linear&#34; and &#34;nearest&#34;. Assumes “linear” by default.

    Returns
    -----
    output_tuple : tuple of ndarrays
        The first ndarray in the output tuple holds the interpolated grid data. If sample point distances and indices are
        required, these are returned as subsequent tuple elements. 

    Raises
    ------
    ValueError
        * Raised if the string method supplied is not “linear” or “nearest”.
        * Raised if the provided sample points for interpolation (xi) do not have the same dimensions as the supplied grid. 
        * Raised if the provided sample points for interpolation include any point out of grid bounds. Alerts user which 
        dimension (index) the point is located. Only raised if the RegularGridInterpolator attribute bounds_error is set 
        to True. If suppressed, out-of-bound points are replaced with a set fill_value. 
    &#34;&#34;&#34;
    interpolator = RegularGridInterpolator((np.linspace(extent[2], extent[3], grid.shape[0]),
                                            np.linspace(extent[0], extent[1], grid.shape[1])),
                                            grid, method=method)

    return interpolator(np.c_[lat, lon], return_indices=return_indices, return_distances=return_distances)</code></pre>
</details>
</dd>
<dt id="gplately.grids.write_netcdf_grid"><code class="name flex">
<span>def <span class="ident">write_netcdf_grid</span></span>(<span>filename, grid, extent=[-180, 180, -90, 90])</span>
</code></dt>
<dd>
<div class="desc"><p>Writes grid, latitude and longitude variables to a given netCDF4 file using specified longitudinal and latitudinal
extents. </p>
<p>Latitude and longitude arrays correspond to the size (num of rows and columns respectively) of the given numpy grid and
set between specified latitudinal and longitudinal angular extents. The given grid and generated lat,lon arrays are
ascribed to a given netCDF4 filename and written as additional variables of the file. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the netCDF file</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>array-like</code></dt>
<dd>An array with elements that define a grid. The number of rows corresponds to the number of latitudinal points,
while the number of columns corresponds to the number of longitudinal points.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>1D numpy array</code>, default=<code>[-180,180,-90,90]</code></dt>
<dd>Four elements must specify the [min lon, max lon, min lat, max lat] with which to constrain the lat and lon
variables to write to the netCDF file. If no extents are supplied, full global extent is assumed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cdf_lon</code></strong>, <strong><code>cdf_lat</code></strong> :&ensp;<code>1D numpy arrays</code></dt>
<dd>Longitude and latitude variables that have been written to the supplied netCDF4 file. Lengths of these arrays
equal the number of cols and rows respectively of the supplied “grid”. Defined between angular extents specified
in “extent”.</dd>
<dt><strong><code>cdf_data</code></strong> :&ensp;<code>array-like</code></dt>
<dd>The supplied grid is ascribed to the given netCDF4 file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_netcdf_grid(filename, grid, extent=[-180,180,-90,90]):
    &#34;&#34;&#34; Writes grid, latitude and longitude variables to a given netCDF4 file using specified longitudinal and latitudinal
    extents. 

    Latitude and longitude arrays correspond to the size (num of rows and columns respectively) of the given numpy grid and 
    set between specified latitudinal and longitudinal angular extents. The given grid and generated lat,lon arrays are 
    ascribed to a given netCDF4 filename and written as additional variables of the file. 

    Parameters
    ----------
    filename : str
        Path to the netCDF file

    grid : array-like
        An array with elements that define a grid. The number of rows corresponds to the number of latitudinal points, 
        while the number of columns corresponds to the number of longitudinal points.

    extent : 1D numpy array, default=[-180,180,-90,90]
        Four elements must specify the [min lon, max lon, min lat, max lat] with which to constrain the lat and lon 
        variables to write to the netCDF file. If no extents are supplied, full global extent is assumed. 

    Returns
    -------
    cdf_lon, cdf_lat : 1D numpy arrays
        Longitude and latitude variables that have been written to the supplied netCDF4 file. Lengths of these arrays 
        equal the number of cols and rows respectively of the supplied “grid”. Defined between angular extents specified 
        in “extent”.

    cdf_data : array-like
        The supplied grid is ascribed to the given netCDF4 file.
    &#34;&#34;&#34;
    import netCDF4
    
    nrows, ncols = np.shape(grid)
    
    lon_grid = np.linspace(extent[0], extent[1], ncols)
    lat_grid = np.linspace(extent[2], extent[3], nrows)
    
    with netCDF4.Dataset(filename, &#39;w&#39;) as cdf:
        cdf.createDimension(&#39;x&#39;, lon_grid.size)
        cdf.createDimension(&#39;y&#39;, lat_grid.size)
        cdf_lon = cdf.createVariable(&#39;x&#39;, lon_grid.dtype, (&#39;x&#39;,), zlib=True)
        cdf_lat = cdf.createVariable(&#39;y&#39;, lat_grid.dtype, (&#39;y&#39;,), zlib=True)
        cdf_lon[:] = lon_grid
        cdf_lat[:] = lat_grid
        cdf_lon.units = &#34;degrees&#34;
        cdf_lat.units = &#34;degrees&#34;

        cdf_data = cdf.createVariable(&#39;z&#39;, grid.dtype, (&#39;y&#39;,&#39;x&#39;), zlib=True)
        cdf_data[:,:] = grid</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.grids.Raster"><code class="flex name class">
<span>class <span class="ident">Raster</span></span>
<span>(</span><span>PlateReconstruction_object=None, filename=None, array=None, extent=None, resample=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class providing Scipy’s RegularGridInterpolator functionalities for interpolation. </p>
<p>Gridded data are sampled at a set of point coordinates using either linear or nearest-neighbour interpolation.
These grids can also be resampled using X and Y-direction spacing, and can be resized using X and Y resolutions.
Grids can be searched for invalid, NaN-type data cells. These can be replaced with the values of their nearest
valid neighbours. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>PlateReconstruction_object</code></strong> :&ensp;<code>object pointer</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>filename</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>array</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>extent</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>Resample</code></strong></dt>
<dd>&nbsp;</dd>
<dt>data</dt>
<dt><strong><code>lons</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>lats</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>method</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="methods">Methods</h2>
<p><strong>init</strong>(self, filename=None, array=None, extent=None, resample=None)
Constructs all necessary attributes for the Raster object.</p>
<p>_update(self)
Allows RegularGridInterpolator attributes ((self.lats, self.lons), self.data, method='linear') and methods
(<strong>call</strong>(), or RegularGridInterpolator) to be accessible from the Raster object.</p>
<p>interpolate(self, lons, lats, method='linear', return_indices=False, return_distances=False)
Sample gridded data on a set of points using interpolation from RegularGridInterpolator.</p>
<p>resample(self, spacingX, spacingY, overwrite=False)
Resamples the grid using X &amp; Y-spaced lat-lon arrays, meshed with linear interpolation.</p>
<p>resize(self, resX, resY, overwrite=False)
Resizes the grid with a specific resolution and samples points using linear interpolation.</p>
<p>fill_NaNs(self, overwrite=False)
Searches for invalid ‘data’ cells containing NaN-type entries and replaces NaNs with the value of the nearest
valid data cell.</p>
<p>Constructs all necessary attributes for the raster object.</p>
<p>Note: either a str path to a netCDF file OR an ndarray representing a grid must be specified. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>PlateReconstruction_object</code></strong> :&ensp;<code>object pointer</code></dt>
<dd>Allows for the accessibility of PlateReconstruction object attributes. Namely, PlateReconstruction object
attributes rotation_model, topology_featues and static_polygons can be used in the points object if called using
“self.PlateReconstruction_object.X”, where X is the attribute.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>Path to netCDF file</dd>
<dt><strong><code>OR</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>array</code></strong> :&ensp;<code>ndarray</code>, default=<code>None</code></dt>
<dd>An array with elements that define a grid. The number of rows corresponds to the number of latitudinal points, while
the number of columns corresponds to the number of longitudinal points.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>1D numpy array</code>, default=<code>None</code></dt>
<dd>Four-element array to specify [min lon, max lon, min lat, max lat] extents of any sampling points. If no extents are
supplied, full global extent [-180,180,-90,90] is assumed.</dd>
<dt><strong><code>resample</code></strong> :&ensp;<code>tuple</code>, default=<code>None</code></dt>
<dd>Optionally resample grid, pass spacing in X and Y direction as a tuple
e.g. resample=(spacingX, spacingY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>__init__ generates the following attributes for the raster object:</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The grid - either a read netCDF4 file, or the ndarray supplied to <strong>init</strong>.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>1d array</code></dt>
<dd>The [min lon, max lon, min lat, max lat] extents supplied to <strong>init</strong>. If not supplied, it is taken to be
[-180,180,-90,90].</dd>
<dt><strong><code>lons</code></strong>, <strong><code>lats</code></strong> :&ensp;<code>1d arrays</code></dt>
<dd>Either the longitude and latitude variables belonging to the netCDF4 file provided, or arrays linearly spaced
between the given lon &amp; lat extents to match the dimensions of the grid array.</dd>
<dt><code>The following objects + methods can be accessed in the raster object:</code></dt>
<dd>&nbsp;</dd>
<dt><code>_update() : method</code> of <code><a title="gplately.grids.RegularGridInterpolator" href="#gplately.grids.RegularGridInterpolator">RegularGridInterpolator</a></code></dt>
<dd>Stored as _interpolator, this samples the “data” attribute at a set of point coordinates (generated from the
attributes “lats” &amp; “lons”). Uses linear interpolation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Raster(object):
    &#34;&#34;&#34;A class providing Scipy’s RegularGridInterpolator functionalities for interpolation. 

    Gridded data are sampled at a set of point coordinates using either linear or nearest-neighbour interpolation. 
    These grids can also be resampled using X and Y-direction spacing, and can be resized using X and Y resolutions.
    Grids can be searched for invalid, NaN-type data cells. These can be replaced with the values of their nearest
    valid neighbours. 

    Attributes
    ----------
    PlateReconstruction_object : object pointer
    filename
    array
    extent
    Resample
    data 
    lons
    lats
    method

    Methods
    -------
    __init__(self, filename=None, array=None, extent=None, resample=None)
        Constructs all necessary attributes for the Raster object.
        
    _update(self)
        Allows RegularGridInterpolator attributes ((self.lats, self.lons), self.data, method=&#39;linear&#39;) and methods 
        (__call__(), or RegularGridInterpolator) to be accessible from the Raster object.
        
    interpolate(self, lons, lats, method=&#39;linear&#39;, return_indices=False, return_distances=False)
        Sample gridded data on a set of points using interpolation from RegularGridInterpolator.
        
    resample(self, spacingX, spacingY, overwrite=False)
        Resamples the grid using X &amp; Y-spaced lat-lon arrays, meshed with linear interpolation.
        
    resize(self, resX, resY, overwrite=False)
        Resizes the grid with a specific resolution and samples points using linear interpolation.
        
    fill_NaNs(self, overwrite=False)
        Searches for invalid ‘data’ cells containing NaN-type entries and replaces NaNs with the value of the nearest
        valid data cell.
    &#34;&#34;&#34;
    def __init__(self, PlateReconstruction_object=None, filename=None, array=None, extent=None, resample=None):
        &#34;&#34;&#34;Constructs all necessary attributes for the raster object.

        Note: either a str path to a netCDF file OR an ndarray representing a grid must be specified. 

        Parameters
        ----------
        PlateReconstruction_object : object pointer
            Allows for the accessibility of PlateReconstruction object attributes. Namely, PlateReconstruction object 
            attributes rotation_model, topology_featues and static_polygons can be used in the points object if called using
            “self.PlateReconstruction_object.X”, where X is the attribute.

        filename : str, default=None
            Path to netCDF file
        OR
        array : ndarray, default=None
            An array with elements that define a grid. The number of rows corresponds to the number of latitudinal points, while
            the number of columns corresponds to the number of longitudinal points.

        extent : 1D numpy array, default=None
            Four-element array to specify [min lon, max lon, min lat, max lat] extents of any sampling points. If no extents are 
            supplied, full global extent [-180,180,-90,90] is assumed. 

        resample : tuple, default=None
            Optionally resample grid, pass spacing in X and Y direction as a tuple
            e.g. resample=(spacingX, spacingY)

        Returns
        -------
        __init__ generates the following attributes for the raster object:
        data : ndarray
            The grid - either a read netCDF4 file, or the ndarray supplied to __init__.

        extent : 1d array
            The [min lon, max lon, min lat, max lat] extents supplied to __init__. If not supplied, it is taken to be
            [-180,180,-90,90].

        lons, lats : 1d arrays
            Either the longitude and latitude variables belonging to the netCDF4 file provided, or arrays linearly spaced 
            between the given lon &amp; lat extents to match the dimensions of the grid array.


        The following objects + methods can be accessed in the raster object:
        _update() : method of RegularGridInterpolator
            Stored as _interpolator, this samples the “data” attribute at a set of point coordinates (generated from the 
            attributes “lats” &amp; “lons”). Uses linear interpolation.
        &#34;&#34;&#34;

        self.PlateReconstruction_object = PlateReconstruction_object

        # we initialise an empty points object as we do not want to build this before any resampling takes place.
        self.points = None

        if filename is None and array is None:
            raise ValueError(&#34;Supply either a filename or numpy array&#34;)

        elif filename and array:
            raise ValueError(&#34;Supply either a filename or numpy array&#34;)

        elif filename is not None:
            self.data, lons, lats = read_netcdf_grid(filename, return_grids=True, resample=resample)
            self.extent = [lons.min(), lons.max(), lats.min(), lats.max()]
            self.lons = lons
            self.lats = lats

        elif array is not None:
            if extent is None:
                extent = [-180,180,-90,90]
            self.data = array
            self.extent = extent
            self.lons = np.linspace(extent[0], extent[1], self.data.shape[1])
            self.lats = np.linspace(extent[2], extent[3], self.data.shape[0])

        self._update()

        if array is not None and resample is not None:
            self.resample(*resample, override=True)


    def _update(self):
        &#34;&#34;&#34;Stores the RegularGridInterpolator object’s method for sampling gridded data at a set of point coordinates. 

        Allows methods of the Raster object to access grid sampling functionalities. The gridded data used is the “data” 
        attribute - either read from a netCDF4 file, or supplied as an ndarray. Points to sample are either variables of the 
        netCDF4 file, or are generated from the “extent” attribute and scaled to fit the grid “data”.
        &#34;&#34;&#34;
        # store interpolation object
        interpolator = RegularGridInterpolator((self.lats, self.lons), self.data, method=&#39;linear&#39;)
        self._interpolator = interpolator


    def interpolate(self, lons, lats, method=&#39;linear&#39;, return_indices=False, return_distances=False):
        &#34;&#34;&#34;Samples gridded data at a set of point coordinates and interpolates points on grid. Uses either linear or 
        nearest-neighbour interpolation methods.

        Uses the grid stored in the raster object “data” attribute, and samples a series of points generated with the 
        “lons” and “lats” function parameters.
    
        Parameters
        ----------
        lons, lats : ndarray
            Longitudes and latitudes of points to sample the gridded data with. Used to generate the points ndarrays of 
            shape (..., ndim). Should have the same dimension as the grid “data” attribute.

        method : str, default=’linear’
            The method of interpolation to perform. Supported are &#34;linear&#34; and &#34;Nearest&#34;. Assumes “linear” interpolation
            if None provided.  

        return_indices : bool, default=False
            Choose whether to return indices of neighbouring sampling points. 

        return_distances : bool, default=False
            Choose whether to return normal distances between interpolated points and neighbouring sampling points.

        Returns
        -------
        data_interp : tuple of ndarrays
            The first ndarray in the output tuple holds the interpolated grid data. If sample point distances and indices are
            required, these are returned as subsequent tuple elements. 

        Raises
        ------
        ValueError
            * Raised if the string method supplied is not “linear” or “nearest”.
            * Raised if the provided lat, lon arrays generate sample points that do not have the same dimensions as the 
            supplied grid. 
            * Raised if the provided lat, lon arrays generate sample points that include any point out of grid bounds. 
            Alerts user which dimension (index) the point is located. 
        &#34;&#34;&#34;
        interp = self._interpolator
        interp.values = self.data
        data_interp = interp((lats,lons), method=method, return_indices=return_indices, return_distances=return_distances)
        return data_interp


    def resample(self, spacingX, spacingY, overwrite=False):
        &#34;&#34;&#34;Resamples the grid using linear interpolation. New grid overwrites the current grid stored in the “data” attribute.
        Optional: can also resample and overwrite the arrays in the lats and lons attributes and overwrite the interpolation
        object “_update()”.

        Generates latitude and longitude arrays based on a specific spacing in X and Y directions, and the latitude and 
        longitude extents held in the “extent” raster object attribute. These lat-lon arrays are meshed into a set of sample
        points that are linearly interpolated onto the grid currently held in the “data” attribute. This final grid overwrites
        the current “data” grid. If specified by the user, the generated lat-lon arrays can also overwrite the arrays in the
        “lats” and “lons” raster object attributes.

        Parameters
        ----------
        spacingX, spacingY : ndarray
            Specify the spacing in the X and Y directions with which to resample.

        overwrite : bool, default=False
            Choose to also overwrite lons and lats currently stored in the self.lons andself.lats attributes. Doing so will 
            also overwrite the interpolation object. By default, it is false, so only the “data” grid is overwritten in that 
            case. 

        Returns
        -------
        data : meshed ndarray grid
            A new resampled and linearly-interpolated grid stored to the “data” attribute. Overwrites the current grid held
            in “data”.  
        &#34;&#34;&#34;
        lons = np.arange(self.extent[0], self.extent[1]+spacingX, spacingX)
        lats = np.arange(self.extent[2], self.extent[3]+spacingY, spacingY)
        lonq, latq = np.meshgrid(lons, lats)

        data = self.interpolate(lonq, latq)
        if overwrite:
            self.data = data
            self.lons = lons
            self.lats = lats
            self._update()

        return data


    def resize(self, resX, resY, overwrite=False):
        &#34;&#34;&#34;Resizes the grid with a specific resolution and samples points using linear interpolation. New grid overwrites
        the current grid stored in the “data” attribute. Optional: can also resample and overwrite the arrays in the lats
        and lons attributes and overwrite the interpolation object “_update()”.

        Generates latitude and longitude arrays based on a specific resolution in X and Y directions, and the latitude and
        longitude extents held in the “extent” raster object attribute. These lat-lon arrays are meshed into a set of sample
        points that are linearly interpolated onto the grid currently held in the “data” attribute. This final grid 
        overwrites the current “data” grid. If specified by the user, the generated lat-lon arrays can also overwrite the
        arrays in the “lats” and “lons” raster object attributes.

        Parameters
        ----------
        resX, resY : ndarray
            Specify the resolution (the larger, the finer the grid and lat-lon arrays) with which to resize.

        overwrite : bool, default=False
            Choose to also overwrite lons and lats currently stored in the self.lons andself.lats attributes. Doing so will
            also overwrite the interpolation object. By default, it is false, so only the “data” grid is overwritten in 
            that case. 

        Returns
        -------
        data : meshed ndarray grid
            A new resized and linearly-interpolated grid stored to the “data” attribute. Overwrites the current grid held
            in “data”.
        &#34;&#34;&#34;
        # construct grid
        lons = np.linspace(self.extent[0], self.extent[1], resX)
        lats = np.linspace(self.extent[2], self.extent[3], resY)
        lonq, latq = np.meshgrid(lons, lats)

        data = self.interpolate(lonq, latq)
        if overwrite:
            self.data = data
            self.lons = lons
            self.lats = lats
            self._update()

        return data


    def fill_NaNs(self, overwrite=False):
        &#34;&#34;&#34;Searches for invalid ‘data’ cells containing NaN-type entries (as indicated by ‘invalid’), locates the index
        of the nearest valid data cell and replaces NaNs with the value of the nearest valid data cell.

        Searches a supplied data frame “data” for invalid data cells containing NaN-type entries. If these invalidities 
        have been replaced with a “fill_value” attribute before being passed into fill_raster, there may no longer be 
        invalid cells in the data. If so, the data’s NaN entries are recovered. Where there is an invalid cell in “data”,
        the index of the closest valid data cell entry is located. This is superimposed onto “data”’s invalid cells and
        replaces NaNs with the nearest valid value.

        Parameters
        ---------
        overwrite : bool, default=False
            Choose whether to overwrite the grid currently held in the “data” raster object attribute with the new grid
            (which will have any NaNs filled).

        Returns
        --------
        data : ndarray
            An updated grid of data where each invalid cell has been replaced with the value of its nearest valid neighbour. 
        &#34;&#34;&#34;
        data = fill_raster(self.data)
        if overwrite:
            self.data = data

        return data


    def save_to_NetCDF4(self, filename):
        &#34;&#34;&#34; Saves file to netCDF4 format&#34;&#34;&#34;
        write_netcdf_grid(str(filename), self.data, self.extent)


    def reconstruct(self, to_time, from_time=0, anchor_plate_id=0, **kwargs):

        import stripy

        lonq, latq = np.meshgrid(self.lons, self.lats)
        lonq_ = lonq.ravel()
        latq_ = latq.ravel()

        if self.points is None:
            self.points = _Points(self.PlateReconstruction_object, lonq_, latq_, from_time, anchor_plate_id)

        lons, lats = self.points.reconstruct(to_time, anchor_plate_id=anchor_plate_id, **kwargs)

        # also remove duplicate entries - # BUT this sorts the indices!!
        _, uindex = np.unique(np.c_[lons,lats], return_index=True, axis=0)
        uindex_sorted = sorted(uindex)
        ilons = lons[uindex_sorted]
        ilats = lats[uindex_sorted]
        idata = self.data.flat[uindex_sorted]


        # interpolate onto sphere
        # this is not very elegant - need to work out why stripy is struggling here.
        for i in range(10):
            try:
                mesh = stripy.sTriangulation(np.radians(ilons), np.radians(ilats), tree=True, permute=True)
            except ValueError:
                pass
            else:
                break
        zi, ierr = mesh.interpolate(np.radians(lonq_), np.radians(latq_), idata, order=1)

        # get cell spacing
        dx = np.diff(self.lons).mean()
        dy = np.diff(self.lats).mean()
        dxy = np.hypot(dx,dy)
        rxy = np.radians(dxy)

        # find angular separation / great circle distance between mesh and reconstructed points
        angles, idx = mesh.nearest_vertices(np.radians(lonq_), np.radians(latq_))

        zi[angles.ravel() &gt; rxy] = np.nan
        zi = zi.reshape(lonq.shape)
        return zi</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gplately.grids.TimeRaster" href="#gplately.grids.TimeRaster">TimeRaster</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gplately.grids.Raster.fill_NaNs"><code class="name flex">
<span>def <span class="ident">fill_NaNs</span></span>(<span>self, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for invalid ‘data’ cells containing NaN-type entries (as indicated by ‘invalid’), locates the index
of the nearest valid data cell and replaces NaNs with the value of the nearest valid data cell.</p>
<p>Searches a supplied data frame “data” for invalid data cells containing NaN-type entries. If these invalidities
have been replaced with a “fill_value” attribute before being passed into fill_raster, there may no longer be
invalid cells in the data. If so, the data’s NaN entries are recovered. Where there is an invalid cell in “data”,
the index of the closest valid data cell entry is located. This is superimposed onto “data”’s invalid cells and
replaces NaNs with the nearest valid value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Choose whether to overwrite the grid currently held in the “data” raster object attribute with the new grid
(which will have any NaNs filled).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>An updated grid of data where each invalid cell has been replaced with the value of its nearest valid neighbour.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_NaNs(self, overwrite=False):
    &#34;&#34;&#34;Searches for invalid ‘data’ cells containing NaN-type entries (as indicated by ‘invalid’), locates the index
    of the nearest valid data cell and replaces NaNs with the value of the nearest valid data cell.

    Searches a supplied data frame “data” for invalid data cells containing NaN-type entries. If these invalidities 
    have been replaced with a “fill_value” attribute before being passed into fill_raster, there may no longer be 
    invalid cells in the data. If so, the data’s NaN entries are recovered. Where there is an invalid cell in “data”,
    the index of the closest valid data cell entry is located. This is superimposed onto “data”’s invalid cells and
    replaces NaNs with the nearest valid value.

    Parameters
    ---------
    overwrite : bool, default=False
        Choose whether to overwrite the grid currently held in the “data” raster object attribute with the new grid
        (which will have any NaNs filled).

    Returns
    --------
    data : ndarray
        An updated grid of data where each invalid cell has been replaced with the value of its nearest valid neighbour. 
    &#34;&#34;&#34;
    data = fill_raster(self.data)
    if overwrite:
        self.data = data

    return data</code></pre>
</details>
</dd>
<dt id="gplately.grids.Raster.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, lons, lats, method='linear', return_indices=False, return_distances=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Samples gridded data at a set of point coordinates and interpolates points on grid. Uses either linear or
nearest-neighbour interpolation methods.</p>
<p>Uses the grid stored in the raster object “data” attribute, and samples a series of points generated with the
“lons” and “lats” function parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lons</code></strong>, <strong><code>lats</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Longitudes and latitudes of points to sample the gridded data with. Used to generate the points ndarrays of
shape (&hellip;, ndim). Should have the same dimension as the grid “data” attribute.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, default=<code>’linear’</code></dt>
<dd>The method of interpolation to perform. Supported are "linear" and "Nearest". Assumes “linear” interpolation
if None provided.</dd>
<dt><strong><code>return_indices</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Choose whether to return indices of neighbouring sampling points.</dd>
<dt><strong><code>return_distances</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Choose whether to return normal distances between interpolated points and neighbouring sampling points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data_interp</code></strong> :&ensp;<code>tuple</code> of <code>ndarrays</code></dt>
<dd>The first ndarray in the output tuple holds the interpolated grid data. If sample point distances and indices are
required, these are returned as subsequent tuple elements.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>
<ul>
<li>Raised if the string method supplied is not “linear” or “nearest”.</li>
<li>Raised if the provided lat, lon arrays generate sample points that do not have the same dimensions as the
supplied grid. </li>
<li>Raised if the provided lat, lon arrays generate sample points that include any point out of grid bounds.
Alerts user which dimension (index) the point is located.</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(self, lons, lats, method=&#39;linear&#39;, return_indices=False, return_distances=False):
    &#34;&#34;&#34;Samples gridded data at a set of point coordinates and interpolates points on grid. Uses either linear or 
    nearest-neighbour interpolation methods.

    Uses the grid stored in the raster object “data” attribute, and samples a series of points generated with the 
    “lons” and “lats” function parameters.

    Parameters
    ----------
    lons, lats : ndarray
        Longitudes and latitudes of points to sample the gridded data with. Used to generate the points ndarrays of 
        shape (..., ndim). Should have the same dimension as the grid “data” attribute.

    method : str, default=’linear’
        The method of interpolation to perform. Supported are &#34;linear&#34; and &#34;Nearest&#34;. Assumes “linear” interpolation
        if None provided.  

    return_indices : bool, default=False
        Choose whether to return indices of neighbouring sampling points. 

    return_distances : bool, default=False
        Choose whether to return normal distances between interpolated points and neighbouring sampling points.

    Returns
    -------
    data_interp : tuple of ndarrays
        The first ndarray in the output tuple holds the interpolated grid data. If sample point distances and indices are
        required, these are returned as subsequent tuple elements. 

    Raises
    ------
    ValueError
        * Raised if the string method supplied is not “linear” or “nearest”.
        * Raised if the provided lat, lon arrays generate sample points that do not have the same dimensions as the 
        supplied grid. 
        * Raised if the provided lat, lon arrays generate sample points that include any point out of grid bounds. 
        Alerts user which dimension (index) the point is located. 
    &#34;&#34;&#34;
    interp = self._interpolator
    interp.values = self.data
    data_interp = interp((lats,lons), method=method, return_indices=return_indices, return_distances=return_distances)
    return data_interp</code></pre>
</details>
</dd>
<dt id="gplately.grids.Raster.reconstruct"><code class="name flex">
<span>def <span class="ident">reconstruct</span></span>(<span>self, to_time, from_time=0, anchor_plate_id=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct(self, to_time, from_time=0, anchor_plate_id=0, **kwargs):

    import stripy

    lonq, latq = np.meshgrid(self.lons, self.lats)
    lonq_ = lonq.ravel()
    latq_ = latq.ravel()

    if self.points is None:
        self.points = _Points(self.PlateReconstruction_object, lonq_, latq_, from_time, anchor_plate_id)

    lons, lats = self.points.reconstruct(to_time, anchor_plate_id=anchor_plate_id, **kwargs)

    # also remove duplicate entries - # BUT this sorts the indices!!
    _, uindex = np.unique(np.c_[lons,lats], return_index=True, axis=0)
    uindex_sorted = sorted(uindex)
    ilons = lons[uindex_sorted]
    ilats = lats[uindex_sorted]
    idata = self.data.flat[uindex_sorted]


    # interpolate onto sphere
    # this is not very elegant - need to work out why stripy is struggling here.
    for i in range(10):
        try:
            mesh = stripy.sTriangulation(np.radians(ilons), np.radians(ilats), tree=True, permute=True)
        except ValueError:
            pass
        else:
            break
    zi, ierr = mesh.interpolate(np.radians(lonq_), np.radians(latq_), idata, order=1)

    # get cell spacing
    dx = np.diff(self.lons).mean()
    dy = np.diff(self.lats).mean()
    dxy = np.hypot(dx,dy)
    rxy = np.radians(dxy)

    # find angular separation / great circle distance between mesh and reconstructed points
    angles, idx = mesh.nearest_vertices(np.radians(lonq_), np.radians(latq_))

    zi[angles.ravel() &gt; rxy] = np.nan
    zi = zi.reshape(lonq.shape)
    return zi</code></pre>
</details>
</dd>
<dt id="gplately.grids.Raster.resample"><code class="name flex">
<span>def <span class="ident">resample</span></span>(<span>self, spacingX, spacingY, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Resamples the grid using linear interpolation. New grid overwrites the current grid stored in the “data” attribute.
Optional: can also resample and overwrite the arrays in the lats and lons attributes and overwrite the interpolation
object “_update()”.</p>
<p>Generates latitude and longitude arrays based on a specific spacing in X and Y directions, and the latitude and
longitude extents held in the “extent” raster object attribute. These lat-lon arrays are meshed into a set of sample
points that are linearly interpolated onto the grid currently held in the “data” attribute. This final grid overwrites
the current “data” grid. If specified by the user, the generated lat-lon arrays can also overwrite the arrays in the
“lats” and “lons” raster object attributes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spacingX</code></strong>, <strong><code>spacingY</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Specify the spacing in the X and Y directions with which to resample.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Choose to also overwrite lons and lats currently stored in the self.lons andself.lats attributes. Doing so will
also overwrite the interpolation object. By default, it is false, so only the “data” grid is overwritten in that
case.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>meshed ndarray grid</code></dt>
<dd>A new resampled and linearly-interpolated grid stored to the “data” attribute. Overwrites the current grid held
in “data”.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resample(self, spacingX, spacingY, overwrite=False):
    &#34;&#34;&#34;Resamples the grid using linear interpolation. New grid overwrites the current grid stored in the “data” attribute.
    Optional: can also resample and overwrite the arrays in the lats and lons attributes and overwrite the interpolation
    object “_update()”.

    Generates latitude and longitude arrays based on a specific spacing in X and Y directions, and the latitude and 
    longitude extents held in the “extent” raster object attribute. These lat-lon arrays are meshed into a set of sample
    points that are linearly interpolated onto the grid currently held in the “data” attribute. This final grid overwrites
    the current “data” grid. If specified by the user, the generated lat-lon arrays can also overwrite the arrays in the
    “lats” and “lons” raster object attributes.

    Parameters
    ----------
    spacingX, spacingY : ndarray
        Specify the spacing in the X and Y directions with which to resample.

    overwrite : bool, default=False
        Choose to also overwrite lons and lats currently stored in the self.lons andself.lats attributes. Doing so will 
        also overwrite the interpolation object. By default, it is false, so only the “data” grid is overwritten in that 
        case. 

    Returns
    -------
    data : meshed ndarray grid
        A new resampled and linearly-interpolated grid stored to the “data” attribute. Overwrites the current grid held
        in “data”.  
    &#34;&#34;&#34;
    lons = np.arange(self.extent[0], self.extent[1]+spacingX, spacingX)
    lats = np.arange(self.extent[2], self.extent[3]+spacingY, spacingY)
    lonq, latq = np.meshgrid(lons, lats)

    data = self.interpolate(lonq, latq)
    if overwrite:
        self.data = data
        self.lons = lons
        self.lats = lats
        self._update()

    return data</code></pre>
</details>
</dd>
<dt id="gplately.grids.Raster.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, resX, resY, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Resizes the grid with a specific resolution and samples points using linear interpolation. New grid overwrites
the current grid stored in the “data” attribute. Optional: can also resample and overwrite the arrays in the lats
and lons attributes and overwrite the interpolation object “_update()”.</p>
<p>Generates latitude and longitude arrays based on a specific resolution in X and Y directions, and the latitude and
longitude extents held in the “extent” raster object attribute. These lat-lon arrays are meshed into a set of sample
points that are linearly interpolated onto the grid currently held in the “data” attribute. This final grid
overwrites the current “data” grid. If specified by the user, the generated lat-lon arrays can also overwrite the
arrays in the “lats” and “lons” raster object attributes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resX</code></strong>, <strong><code>resY</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Specify the resolution (the larger, the finer the grid and lat-lon arrays) with which to resize.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Choose to also overwrite lons and lats currently stored in the self.lons andself.lats attributes. Doing so will
also overwrite the interpolation object. By default, it is false, so only the “data” grid is overwritten in
that case.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>meshed ndarray grid</code></dt>
<dd>A new resized and linearly-interpolated grid stored to the “data” attribute. Overwrites the current grid held
in “data”.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize(self, resX, resY, overwrite=False):
    &#34;&#34;&#34;Resizes the grid with a specific resolution and samples points using linear interpolation. New grid overwrites
    the current grid stored in the “data” attribute. Optional: can also resample and overwrite the arrays in the lats
    and lons attributes and overwrite the interpolation object “_update()”.

    Generates latitude and longitude arrays based on a specific resolution in X and Y directions, and the latitude and
    longitude extents held in the “extent” raster object attribute. These lat-lon arrays are meshed into a set of sample
    points that are linearly interpolated onto the grid currently held in the “data” attribute. This final grid 
    overwrites the current “data” grid. If specified by the user, the generated lat-lon arrays can also overwrite the
    arrays in the “lats” and “lons” raster object attributes.

    Parameters
    ----------
    resX, resY : ndarray
        Specify the resolution (the larger, the finer the grid and lat-lon arrays) with which to resize.

    overwrite : bool, default=False
        Choose to also overwrite lons and lats currently stored in the self.lons andself.lats attributes. Doing so will
        also overwrite the interpolation object. By default, it is false, so only the “data” grid is overwritten in 
        that case. 

    Returns
    -------
    data : meshed ndarray grid
        A new resized and linearly-interpolated grid stored to the “data” attribute. Overwrites the current grid held
        in “data”.
    &#34;&#34;&#34;
    # construct grid
    lons = np.linspace(self.extent[0], self.extent[1], resX)
    lats = np.linspace(self.extent[2], self.extent[3], resY)
    lonq, latq = np.meshgrid(lons, lats)

    data = self.interpolate(lonq, latq)
    if overwrite:
        self.data = data
        self.lons = lons
        self.lats = lats
        self._update()

    return data</code></pre>
</details>
</dd>
<dt id="gplately.grids.Raster.save_to_NetCDF4"><code class="name flex">
<span>def <span class="ident">save_to_NetCDF4</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves file to netCDF4 format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_to_NetCDF4(self, filename):
    &#34;&#34;&#34; Saves file to netCDF4 format&#34;&#34;&#34;
    write_netcdf_grid(str(filename), self.data, self.extent)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gplately.grids.RegularGridInterpolator"><code class="flex name class">
<span>class <span class="ident">RegularGridInterpolator</span></span>
<span>(</span><span>points, values, method='linear', bounds_error=False, fill_value=nan)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to sample gridded data at a set of point coordinates using either linear or nearest-neighbour
interpolation methods.</p>
<p>It is a child class of the scipy.interpolate module’s RegularGridInterpolator class. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>values</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>method</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>bounds_error</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>Fill_value</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="methods">Methods</h2>
<p><strong>init</strong>(self, points, values, method="linear", bounds_error=False, fill_value=np.nan)
Constructs all necessary attributes for the RegularGridInterpolator object.
<strong>call</strong>(self, xi, method=None, return_indices=False, return_distances=False)
Allows the RegularGridInterpolator object to be called as a method.</p>
<p>Constructs all necessary attributes for the RegularGridInterpolator object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>tuple</code> of <code>1d arrays</code></dt>
<dd>Each array contains point coordinates (e.g. 2 arrays; 1 for each point’s lat, 1 for each point’s lon).
Defines the points to sample data with.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Defines a grid. The number of rows corresponds to the number of latitudinal points, while the number
of columns corresponds to the number of longitudinal points.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, default=<code>’linear’</code></dt>
<dd>The method of interpolation to perform. Supported are "linear" and "nearest". Assumes “linear” by default.</dd>
<dt><strong><code>bounds_error</code></strong> :&ensp;<code>bool</code>, default=<code>false</code></dt>
<dd>Choose whether to return a ValueError and terminate the interpolation if any provided sample points are out
of grid bounds. By default, it is set to false. In this case, all out-of-bound point values are replaced
with the fill_value (defined below) if supplied.</dd>
<dt><strong><code>fill_value</code></strong> :&ensp;<code>float</code>, default=<code>np.nan</code></dt>
<dd>Used to replace point values that are out of grid bounds, provided that ‘bounds_error’ is false.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegularGridInterpolator(_RGI):
    &#34;&#34;&#34;A class to sample gridded data at a set of point coordinates using either linear or nearest-neighbour 
    interpolation methods.

    It is a child class of the scipy.interpolate module’s RegularGridInterpolator class. 

    Attributes
    ----------
    points
    values
    method
    bounds_error
    Fill_value

    Methods
    -------
    __init__(self, points, values, method=&#34;linear&#34;, bounds_error=False, fill_value=np.nan)
        Constructs all necessary attributes for the RegularGridInterpolator object.
    __call__(self, xi, method=None, return_indices=False, return_distances=False)
        Allows the RegularGridInterpolator object to be called as a method.
    &#34;&#34;&#34;
    def __init__(self, points, values, method=&#34;linear&#34;, bounds_error=False, fill_value=np.nan):
        &#34;&#34;&#34;Constructs all necessary attributes for the RegularGridInterpolator object.

        Parameters
        ----------
        points : tuple of 1d arrays
            Each array contains point coordinates (e.g. 2 arrays; 1 for each point’s lat, 1 for each point’s lon).
            Defines the points to sample data with. 
        values : ndarray
            Defines a grid. The number of rows corresponds to the number of latitudinal points, while the number
            of columns corresponds to the number of longitudinal points.
        method : str, default=’linear’
            The method of interpolation to perform. Supported are &#34;linear&#34; and &#34;nearest&#34;. Assumes “linear” by default.
        bounds_error : bool, default=false
            Choose whether to return a ValueError and terminate the interpolation if any provided sample points are out
            of grid bounds. By default, it is set to false. In this case, all out-of-bound point values are replaced 
            with the fill_value (defined below) if supplied.
        fill_value : float, default=np.nan
            Used to replace point values that are out of grid bounds, provided that ‘bounds_error’ is false.
        &#34;&#34;&#34; 
        super(RegularGridInterpolator, self).__init__(points, values, method, bounds_error, fill_value)

    def __call__(self, xi, method=None, return_indices=False, return_distances=False):
        &#34;&#34;&#34;Samples gridded data at a set of point coordinates. Uses either linear or nearest-neighbour interpolation methods.

        Uses the gridded data specified in the sample_grid method parameter. Note: if any provided sample points are out of 
        grid bounds and a corresponding error message was suppressed (by specifying bounds_error=False), all out-of-bound 
        point values are replaced with the self.fill_value attribute ascribed to the RegularGridInterpolator object (if it
        exists). Terminates otherwise.
    
        Parameters
        ----------
        xi : ndarray of shape (..., ndim)
            The coordinates of points to sample the gridded data at.

        method : str, default=None
            The method of interpolation to perform. Supported are &#34;linear&#34; and &#34;Nearest&#34;. Assumes “linear” interpolation
            if None provided.  

        return_indices : bool, default=False
            Choose whether to return indices of neighbouring sampling points. 

        return_distances : bool, default=False
            Choose whether to return normal distances between interpolated points and neighbouring sampling points.

        Returns
        -------
        output_tuple : tuple of ndarrays
            The first ndarray in the output tuple holds the interpolated grid data. If sample point distances and indices are
            required, these are returned as subsequent tuple elements. 

        Raises
        ------
        ValueError
            * Raised if the string method supplied is not “linear” or “nearest”.
            * Raised if the provided sample points for interpolation (xi) do not have the same dimensions as the supplied grid. 
            * Raised if the provided sample points for interpolation include any point out of grid bounds. Alerts user which
            dimension (index) the point is located. Only raised if the RegularGridInterpolator attribute bounds_error is set
            to True. If suppressed, out-of-bound points are replaced with a set fill_value. 
        &#34;&#34;&#34;
        from scipy.interpolate.interpnd import _ndim_coords_from_arrays
        method = self.method if method is None else method
        if method not in [&#34;linear&#34;, &#34;nearest&#34;]:
            raise ValueError(&#34;Method &#39;%s&#39; is not defined&#34; % method)

        ndim = len(self.grid)
        xi = _ndim_coords_from_arrays(xi, ndim=ndim)
        if xi.shape[-1] != len(self.grid):
            raise ValueError(&#34;The requested sample points xi have dimension &#34;
                             &#34;%d, but this RegularGridInterpolator has &#34;
                             &#34;dimension %d&#34; % (xi.shape[1], ndim))

        xi_shape = xi.shape
        xi = xi.reshape(-1, xi_shape[-1])

        if self.bounds_error:
            for i, p in enumerate(xi.T):
                if not np.logical_and(np.all(self.grid[i][0] &lt;= p),
                                      np.all(p &lt;= self.grid[i][-1])):
                    raise ValueError(&#34;One of the requested xi is out of bounds &#34;
                                     &#34;in dimension %d&#34; % i)

        indices, norm_distances, out_of_bounds = self._find_indices(xi.T)
        if method == &#34;linear&#34;:
            result = self._evaluate_linear(indices,
                                           norm_distances,
                                           out_of_bounds)
        elif method == &#34;nearest&#34;:
            result = self._evaluate_nearest(indices,
                                            norm_distances,
                                            out_of_bounds)
        if not self.bounds_error and self.fill_value is not None:
            result[out_of_bounds] = self.fill_value
            
        interp_output = result.reshape(xi_shape[:-1] + self.values.shape[ndim:])
        output_tuple = [interp_output]

        if return_indices:
            output_tuple.append(indices)
        if return_distances:
            output_tuple.append(norm_distances)
        
        if return_distances or return_indices:
            return tuple(output_tuple)
        else:
            return output_tuple[0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scipy.interpolate._interpolate.RegularGridInterpolator</li>
</ul>
</dd>
<dt id="gplately.grids.TimeRaster"><code class="flex name class">
<span>class <span class="ident">TimeRaster</span></span>
<span>(</span><span>PlateReconstruction_object, filename=None, array=None, extent=None, resample=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class providing Scipy’s RegularGridInterpolator functionalities for interpolation. </p>
<p>Gridded data are sampled at a set of point coordinates using either linear or nearest-neighbour interpolation.
These grids can also be resampled using X and Y-direction spacing, and can be resized using X and Y resolutions.
Grids can be searched for invalid, NaN-type data cells. These can be replaced with the values of their nearest
valid neighbours. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>PlateReconstruction_object</code></strong> :&ensp;<code>object pointer</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>filename</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>array</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>extent</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>Resample</code></strong></dt>
<dd>&nbsp;</dd>
<dt>data</dt>
<dt><strong><code>lons</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>lats</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>method</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="methods">Methods</h2>
<p><strong>init</strong>(self, filename=None, array=None, extent=None, resample=None)
Constructs all necessary attributes for the Raster object.</p>
<p>_update(self)
Allows RegularGridInterpolator attributes ((self.lats, self.lons), self.data, method='linear') and methods
(<strong>call</strong>(), or RegularGridInterpolator) to be accessible from the Raster object.</p>
<p>interpolate(self, lons, lats, method='linear', return_indices=False, return_distances=False)
Sample gridded data on a set of points using interpolation from RegularGridInterpolator.</p>
<p>resample(self, spacingX, spacingY, overwrite=False)
Resamples the grid using X &amp; Y-spaced lat-lon arrays, meshed with linear interpolation.</p>
<p>resize(self, resX, resY, overwrite=False)
Resizes the grid with a specific resolution and samples points using linear interpolation.</p>
<p>fill_NaNs(self, overwrite=False)
Searches for invalid ‘data’ cells containing NaN-type entries and replaces NaNs with the value of the nearest
valid data cell.</p>
<p>Constructs all necessary attributes for the raster object.</p>
<p>Note: either a str path to a netCDF file OR an ndarray representing a grid must be specified. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>PlateReconstruction_object</code></strong> :&ensp;<code>object pointer</code></dt>
<dd>Allows for the accessibility of PlateReconstruction object attributes. Namely, PlateReconstruction object
attributes rotation_model, topology_featues and static_polygons can be used in the points object if called using
“self.PlateReconstruction_object.X”, where X is the attribute.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>Path to netCDF file</dd>
<dt><strong><code>OR</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>array</code></strong> :&ensp;<code>ndarray</code>, default=<code>None</code></dt>
<dd>An array with elements that define a grid. The number of rows corresponds to the number of latitudinal points, while
the number of columns corresponds to the number of longitudinal points.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>1D numpy array</code>, default=<code>None</code></dt>
<dd>Four-element array to specify [min lon, max lon, min lat, max lat] extents of any sampling points. If no extents are
supplied, full global extent [-180,180,-90,90] is assumed.</dd>
<dt><strong><code>resample</code></strong> :&ensp;<code>tuple</code>, default=<code>None</code></dt>
<dd>Optionally resample grid, pass spacing in X and Y direction as a tuple
e.g. resample=(spacingX, spacingY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>__init__ generates the following attributes for the raster object:</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The grid - either a read netCDF4 file, or the ndarray supplied to <strong>init</strong>.</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>1d array</code></dt>
<dd>The [min lon, max lon, min lat, max lat] extents supplied to <strong>init</strong>. If not supplied, it is taken to be
[-180,180,-90,90].</dd>
<dt><strong><code>lons</code></strong>, <strong><code>lats</code></strong> :&ensp;<code>1d arrays</code></dt>
<dd>Either the longitude and latitude variables belonging to the netCDF4 file provided, or arrays linearly spaced
between the given lon &amp; lat extents to match the dimensions of the grid array.</dd>
<dt><code>The following objects + methods can be accessed in the raster object:</code></dt>
<dd>&nbsp;</dd>
<dt><code>_update() : method</code> of <code><a title="gplately.grids.RegularGridInterpolator" href="#gplately.grids.RegularGridInterpolator">RegularGridInterpolator</a></code></dt>
<dd>Stored as _interpolator, this samples the “data” attribute at a set of point coordinates (generated from the
attributes “lats” &amp; “lons”). Uses linear interpolation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeRaster(Raster):

    def __init__(self, PlateReconstruction_object, filename=None, array=None, extent=None, resample=None):

        super(TimeRaster, self).__init__(filename, array, extent, resample)

        self.PlateReconstruction_object = PlateReconstruction_object</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gplately.grids.Raster" href="#gplately.grids.Raster">Raster</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gplately.grids.Raster" href="#gplately.grids.Raster">Raster</a></b></code>:
<ul class="hlist">
<li><code><a title="gplately.grids.Raster.fill_NaNs" href="#gplately.grids.Raster.fill_NaNs">fill_NaNs</a></code></li>
<li><code><a title="gplately.grids.Raster.interpolate" href="#gplately.grids.Raster.interpolate">interpolate</a></code></li>
<li><code><a title="gplately.grids.Raster.resample" href="#gplately.grids.Raster.resample">resample</a></code></li>
<li><code><a title="gplately.grids.Raster.resize" href="#gplately.grids.Raster.resize">resize</a></code></li>
<li><code><a title="gplately.grids.Raster.save_to_NetCDF4" href="#gplately.grids.Raster.save_to_NetCDF4">save_to_NetCDF4</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#classes">Classes</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="gplately.grids.fill_raster" href="#gplately.grids.fill_raster">fill_raster</a></code></li>
<li><code><a title="gplately.grids.rasterise" href="#gplately.grids.rasterise">rasterise</a></code></li>
<li><code><a title="gplately.grids.rasterize" href="#gplately.grids.rasterize">rasterize</a></code></li>
<li><code><a title="gplately.grids.read_netcdf_grid" href="#gplately.grids.read_netcdf_grid">read_netcdf_grid</a></code></li>
<li><code><a title="gplately.grids.reconstruct_grid" href="#gplately.grids.reconstruct_grid">reconstruct_grid</a></code></li>
<li><code><a title="gplately.grids.sample_grid" href="#gplately.grids.sample_grid">sample_grid</a></code></li>
<li><code><a title="gplately.grids.write_netcdf_grid" href="#gplately.grids.write_netcdf_grid">write_netcdf_grid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.grids.Raster" href="#gplately.grids.Raster">Raster</a></code></h4>
<ul class="two-column">
<li><code><a title="gplately.grids.Raster.fill_NaNs" href="#gplately.grids.Raster.fill_NaNs">fill_NaNs</a></code></li>
<li><code><a title="gplately.grids.Raster.interpolate" href="#gplately.grids.Raster.interpolate">interpolate</a></code></li>
<li><code><a title="gplately.grids.Raster.reconstruct" href="#gplately.grids.Raster.reconstruct">reconstruct</a></code></li>
<li><code><a title="gplately.grids.Raster.resample" href="#gplately.grids.Raster.resample">resample</a></code></li>
<li><code><a title="gplately.grids.Raster.resize" href="#gplately.grids.Raster.resize">resize</a></code></li>
<li><code><a title="gplately.grids.Raster.save_to_NetCDF4" href="#gplately.grids.Raster.save_to_NetCDF4">save_to_NetCDF4</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.grids.RegularGridInterpolator" href="#gplately.grids.RegularGridInterpolator">RegularGridInterpolator</a></code></h4>
</li>
<li>
<h4><code><a title="gplately.grids.TimeRaster" href="#gplately.grids.TimeRaster">TimeRaster</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>