

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gplately.oceans &mdash; gplately 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            gplately
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basic_usages.html">Minimal Working Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../use_cases.html">Common Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Troubleshooting and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../command_line_interface.html">Command Line Interface (CLI)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Main Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../secondaries.html">Other Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plate_models.html">Plate Models</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">gplately</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gplately.oceans</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gplately.oceans</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">#    Copyright (C) 2024-2025 The University of Sydney, Australia</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1">#    the terms of the GNU General Public License, version 2, as published by</span>
<span class="c1">#    the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c1">#    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c1">#    for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License along</span>
<span class="c1">#    with this program; if not, write to Free Software Foundation, Inc.,</span>
<span class="c1">#    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;A module to generate grids of seafloor age, seafloor spreading rate</span>
<span class="sd">and other oceanic data from the `gplately.PlateReconstruction` and</span>
<span class="sd">`gplately.plot.PlotTopologies` objects.</span>

<span class="sd">Gridding methods in this module have been adapted from Simon Williams&#39;</span>
<span class="sd">development repository for an</span>
<span class="sd">[auto-age-gridding workflow](https://github.com/siwill22/agegrid-0.1), and are kept</span>
<span class="sd">within the `SeafloorGrid` object.</span>

<span class="sd">The sample jupyter notebook</span>
<span class="sd">[10-SeafloorGrid](https://github.com/GPlates/gplately/blob/master/Notebooks/10-SeafloorGrids.ipynb)</span>
<span class="sd">demonstrates how the functionalities within `SeafloorGrid` work. Below you can find</span>
<span class="sd">documentation for each of `SeafloorGrid`&#39;s functions.</span>

<span class="sd">`SeafloorGrid` Methodology</span>
<span class="sd">--------------------------</span>
<span class="sd">There are two main steps that `SeafloorGrid` follows to generate grids:</span>

<span class="sd">1. Preparation for reconstruction by topologies</span>
<span class="sd">2. Reconstruction by topologies</span>

<span class="sd">The preparation step involves building a:</span>

<span class="sd">* global domain of initial points that populate the seafloor at `max_time`,</span>
<span class="sd">* continental mask that separates ocean points from continent regions per timestep, and</span>
<span class="sd">* set of points that emerge to the left and right of mid-ocean</span>
<span class="sd">ridge segments per timestep, as well as the z-value to allocate to these</span>
<span class="sd">points.</span>

<span class="sd">First, the global domain of initial points is created using</span>
<span class="sd">[stripy&#39;s](https://github.com/underworldcode/stripy/blob/master/stripy/spherical_meshes.py#L27)</span>
<span class="sd">icosahedral triangulated mesh. The number of points in this mesh can be</span>
<span class="sd">controlled using a `refinement_levels` integer (the larger this integer,</span>
<span class="sd">the more resolved the continent masks will be).</span>

<span class="sd">![RefinementLevels](https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/pdoc_Files/seafloorgrid_refinement.png)</span>

<span class="sd">These points are spatially partitioned by plate ID so they can be passed</span>
<span class="sd">into a</span>
<span class="sd">[point-in-polygon routine](https://gplates.github.io/gplately/oceans.html#gplately.oceans.point_in_polygon_routine).</span>
<span class="sd">This identifies points that lie within</span>
<span class="sd">continental polygon boundaries and those that are in the ocean. From this,</span>
<span class="sd">[continental masks are built](https://gplates.github.io/gplately/oceans.html#gplately.oceans.SeafloorGrid.build_all_continental_masks)</span>
<span class="sd">per timestep, and the initial seed points are</span>
<span class="sd">allocated ages at the first reconstruction timestep `max_time`. Each point&#39;s</span>
<span class="sd">initial age is calculated by dividing its proximity to the nearest</span>
<span class="sd">MOR segment by half its assumed spreading rate. This spreading rate</span>
<span class="sd">(`initial_ocean_mean_spreading_rate`) is assumed to be uniform for all points.</span>

<span class="sd">These initial points momentarily fill the global ocean basin, and all have uniform spreading rates.</span>
<span class="sd">Thus, the spreading rate grid at `max_time` will be uniformly populated with the `initial_ocean_mean_spreading_rate` (mm/yr).</span>
<span class="sd">The age grid at `max_time` will look like a series of smooth, linear age gradients clearly partitioned by</span>
<span class="sd">tectonic plates with unique plate IDs:</span>

<span class="sd">![MaxTimeGrids](https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/pdoc_Files/max_time_grids.png)</span>

<span class="sd">[Ridge &quot;line&quot; topologies](https://gplates.github.io/gplately/oceans.html#gplately.oceans.SeafloorGrid.build_all_MOR_seedpoints)</span>
<span class="sd">are resolved at each reconstruction time step and partitioned</span>
<span class="sd">into segments with a valid stage rotation. Each segment is further divided into points</span>
<span class="sd">at a specified ridge sampling spacing (`ridge_sampling`). Each point is</span>
<span class="sd">ascribed a latitude, longitude, spreading rate and age (from plate reconstruction</span>
<span class="sd">model files, as opposed to ages of the initial ocean mesh points), a point index</span>
<span class="sd">and the general z-value that will be gridded onto it.</span>

<span class="sd">![NewRidgePoints](https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/pdoc_Files/new_ridge_points.png)</span>

<span class="sd">Reconstruction by topologies involves determining which points are active and</span>
<span class="sd">inactive (collided with a continent or subducted at a trench) for each reconstruction</span>
<span class="sd">time step. This is done using a hidden object in `PlateReconstruction` called</span>
<span class="sd">`ReconstructByTopologies`.</span>

<span class="sd">If an ocean point with a certain velocity on one plate ID transitions into another</span>
<span class="sd">rigid plate ID at another timestep (with another velocity), the velocity difference</span>
<span class="sd">between both plates is calculated. The point may have subducted/collided with a continent</span>
<span class="sd">if this velocity difference is higher than a specified velocity threshold (which can be</span>
<span class="sd">controlled with `subduction_collision_parameters`). To ascertain whether the point</span>
<span class="sd">should be deactivated, a displacement test is conducted. If the proximity of the</span>
<span class="sd">point&#39;s previous time position to the polygon boundary it is approaching is higher than</span>
<span class="sd">a set distance threshold, then the point is far enough away from the boundary that it</span>
<span class="sd">cannot be subducted or consumed by it, and hence the point is still active. Otherwise,</span>
<span class="sd">it is deemed inactive and deleted from the ocean basin mesh.</span>

<span class="sd">With each reconstruction time step, points from mid-ocean ridges (which have more</span>
<span class="sd">accurate spreading rates and attributed valid times) will spread across the ocean</span>
<span class="sd">floor. Eventually, points will be pushed into continental boundaries or subduction</span>
<span class="sd">zones, where they are deleted. Ideally, all initial ocean points (from the Stripy</span>
<span class="sd">icosahedral mesh) should be deleted over time. However, not all will be deleted -</span>
<span class="sd">such points typically reside near continental boundaries. This happens if the</span>
<span class="sd">emerged ridge points do not spread far enough to &quot;phase out&quot; these points at</span>
<span class="sd">collision regions - likely due to insufficient reconstruction detail. These</span>
<span class="sd">undeleted points form artefacts of anomalously high seafloor age that append</span>
<span class="sd">over the reconstruction time range.</span>

<span class="sd">Once reconstruction by topologies determines the ocean basin snapshot per timestep,</span>
<span class="sd">a data frame of all longitudes, latitudes, seafloor ages, spreading rates and any other</span>
<span class="sd">attributed z values will be written to a gridding input file per timestep.</span>

<span class="sd">Each active longitude, latitude and chosen z value (identified by a gridding input file</span>
<span class="sd">column index integer, i.e. `2` is seafloor age) is gridded using nearest-neighbour</span>
<span class="sd">interpolation and written to a netCDF4 format.</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">* SeafloorGrid</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pygplates</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">grids</span><span class="p">,</span> <span class="n">tools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib.reconstruct_by_topologies</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_ContinentCollision</span><span class="p">,</span>
    <span class="n">_DefaultCollision</span><span class="p">,</span>
    <span class="n">_ReconstructByTopologies</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.ptt</span><span class="w"> </span><span class="kn">import</span> <span class="n">continent_contours</span><span class="p">,</span> <span class="n">separate_ridge_transform_segments</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">_deg2pixels</span><span class="p">,</span> <span class="n">_pixels2deg</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">seafloor_grid_utils</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils.log_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_debug_level</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;gplately&quot;</span><span class="p">)</span>


<span class="c1"># JUST FOR PYDOC TO GENERATE THE SAME DOC AS BEFORE</span>
<span class="k">def</span><span class="w"> </span><span class="nf">create_icosahedral_mesh</span><span class="p">(</span><span class="n">refinement_levels</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">seafloor_grid_utils</span><span class="o">.</span><span class="n">create_icosahedral_mesh</span><span class="p">(</span><span class="n">refinement_levels</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">ensure_polygon_geometry</span><span class="p">(</span><span class="n">reconstructed_polygons</span><span class="p">,</span> <span class="n">rotation_model</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">seafloor_grid_utils</span><span class="o">.</span><span class="n">ensure_polygon_geometry</span><span class="p">(</span>
        <span class="n">reconstructed_polygons</span><span class="p">,</span> <span class="n">rotation_model</span><span class="p">,</span> <span class="n">time</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">point_in_polygon_routine</span><span class="p">(</span><span class="n">multi_point</span><span class="p">,</span> <span class="n">COB_polygons</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">seafloor_grid_utils</span><span class="o">.</span><span class="n">point_in_polygon_routine</span><span class="p">(</span><span class="n">multi_point</span><span class="p">,</span> <span class="n">COB_polygons</span><span class="p">)</span>


<span class="n">create_icosahedral_mesh</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">seafloor_grid_utils</span><span class="o">.</span><span class="n">create_icosahedral_mesh</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">ensure_polygon_geometry</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">seafloor_grid_utils</span><span class="o">.</span><span class="n">ensure_polygon_geometry</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">point_in_polygon_routine</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">seafloor_grid_utils</span><span class="o">.</span><span class="n">point_in_polygon_routine</span><span class="o">.</span><span class="vm">__doc__</span>

<span class="n">MOR_PKL_FILE_NAME</span> <span class="o">=</span> <span class="s2">&quot;MOR_df_</span><span class="si">{:0.2f}</span><span class="s2">_Ma.pkl&quot;</span>
<span class="n">MOR_GPMLZ_FILE_NAME</span> <span class="o">=</span> <span class="s2">&quot;MOR_plus_one_points_</span><span class="si">{:0.2f}</span><span class="s2">.gpmlz&quot;</span>
<span class="n">SAMPLE_POINTS_GPMLZ_FILE_NAME</span> <span class="o">=</span> <span class="s2">&quot;sample_points_</span><span class="si">{:0.2f}</span><span class="s2">_Ma.gpmlz&quot;</span>
<span class="n">SAMPLE_POINTS_PKL_FILE_NAME</span> <span class="o">=</span> <span class="s2">&quot;sample_points_</span><span class="si">{:0.2f}</span><span class="s2">_Ma.pkl&quot;</span>


<div class="viewcode-block" id="SeafloorGrid">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SeafloorGrid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate grids that track data atop global ocean basin points (which emerge from mid-ocean ridges) through geological time.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SeafloorGrid.__init__">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">PlateReconstruction_object</span><span class="p">,</span>
        <span class="n">PlotTopologies_object</span><span class="p">,</span>
        <span class="n">max_time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">min_time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">ridge_time_step</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">save_directory</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;seafloor-grid-output&quot;</span><span class="p">,</span>
        <span class="n">file_collection</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">refinement_levels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">ridge_sampling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">extent</span><span class="p">:</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span>
        <span class="n">grid_spacing</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">subduction_collision_parameters</span><span class="o">=</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">),</span>
        <span class="n">initial_ocean_mean_spreading_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">75.0</span><span class="p">,</span>
        <span class="n">resume_from_checkpoints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">zval_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SPREADING_RATE&quot;</span><span class="p">],</span>
        <span class="n">continent_mask_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_continent_contouring</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor. Create a :class:`SeafloorGrid` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        PlateReconstruction_object : PlateReconstruction</span>
<span class="sd">            A :class:`PlateReconstruction` object with a `pygplates.RotationModel`_ and</span>
<span class="sd">            a `pygplates.FeatureCollection`_ containing topology features.</span>
<span class="sd">        PlotTopologies_object : PlotTopologies</span>
<span class="sd">            A :class:`PlotTopologies` object with a continental polygon or COB terrane polygon file to mask grids with.</span>
<span class="sd">        max_time : float</span>
<span class="sd">            The maximum time for age gridding.</span>
<span class="sd">        min_time : float</span>
<span class="sd">            The minimum time for age gridding.</span>
<span class="sd">        ridge_time_step : float</span>
<span class="sd">            The delta time for resolving ridges (and thus age gridding).</span>
<span class="sd">        save_directory : str, default=None</span>
<span class="sd">            The top-level directory to save all outputs to.</span>
<span class="sd">        file_collection : str, default=&quot;&quot;</span>
<span class="sd">            A string to identify the plate model used (will be automated later).</span>
<span class="sd">        refinement_levels : int, default=5</span>
<span class="sd">            Control the number of points in the icosahedral mesh (higher integer means higher resolution of continent masks).</span>
<span class="sd">        ridge_sampling : float, default=0.5</span>
<span class="sd">            Spatial resolution (in degrees) at which points that emerge from ridges are tessellated.</span>
<span class="sd">        extent : tuple of 4, default=(-180.,180.,-90.,90.)</span>
<span class="sd">            A tuple containing the mininum longitude, maximum longitude, minimum latitude and</span>
<span class="sd">            maximum latitude extents for all masking and final grids.</span>
<span class="sd">        grid_spacing : float, default=0.1</span>
<span class="sd">            The degree spacing/interval with which to space grid points across all masking and</span>
<span class="sd">            final grids. If ``grid_spacing`` is provided, all grids will use it. If not, ``grid_spacing`` defaults to 0.1.</span>
<span class="sd">        subduction_collision_parameters : len-2 tuple of float, default=(5.0, 10.0)</span>
<span class="sd">            A 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my)</span>
<span class="sd">        initial_ocean_mean_spreading_rate : float, default=75.</span>
<span class="sd">            A spreading rate to uniformly allocate to points that define the initial ocean</span>
<span class="sd">            basin. These points will have inaccurate ages, but most of them will be phased</span>
<span class="sd">            out after points with plate-model prescribed ages emerge from ridges and spread</span>
<span class="sd">            to push them towards collision boundaries (where they are deleted).</span>
<span class="sd">        resume_from_checkpoints : bool, default=False</span>
<span class="sd">            If set to ``True``, and the gridding preparation stage (continental masking and/or</span>
<span class="sd">            ridge seed building) is interrupted, SeafloorGrids will resume gridding preparation</span>
<span class="sd">            from the last successful preparation time.</span>
<span class="sd">            If set to ``False``, SeafloorGrids will automatically overwrite all files in the</span>
<span class="sd">            ``save_directory`` if re-run after interruption, or normally re-run, thus beginning</span>
<span class="sd">            gridding preparation from scratch. ``False`` will be useful if data allocated to the</span>
<span class="sd">            MOR seed points need to be augmented.</span>
<span class="sd">        zval_names : list of :class:`str`</span>
<span class="sd">            A list containing string labels for the z values to attribute to points.</span>
<span class="sd">            Will be used as column headers for z value point dataframes.</span>
<span class="sd">        continent_mask_filename : str</span>
<span class="sd">            An optional parameter pointing to the full path to a continental mask for each timestep.</span>
<span class="sd">            Assuming the time is in the filename, i.e. ``/path/to/continent_mask_0Ma.nc``, it should be</span>
<span class="sd">            passed as ``/path/to/continent_mask_{}Ma.nc`` with curly brackets. Include decimal formatting if needed.</span>


<span class="sd">        .. _pygplates.RotationModel: https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel</span>
<span class="sd">        .. _pygplates.Feature: https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature</span>
<span class="sd">        .. _pygplates.FeatureCollection: https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Provides a rotation model, topology features and reconstruction time for the SeafloorGrid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PlateReconstruction_object</span> <span class="o">=</span> <span class="n">PlateReconstruction_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PlateReconstruction_object</span><span class="o">.</span><span class="n">rotation_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PlateReconstruction_object</span><span class="o">.</span><span class="n">topology_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span> <span class="o">=</span> <span class="n">PlotTopologies_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topological_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">TopologicalModel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span> <span class="o">=</span> <span class="n">file_collection</span>

        <span class="k">if</span> <span class="n">continent_mask_filename</span><span class="p">:</span>
            <span class="c1"># Filename for continental masks that the user can provide instead of building it here</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span> <span class="o">=</span> <span class="n">continent_mask_filename</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_is_provided</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_is_provided</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_continent_contouring</span> <span class="o">=</span> <span class="n">use_continent_contouring</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_output_paths</span><span class="p">(</span><span class="n">save_directory</span><span class="p">)</span>

        <span class="c1"># Topological parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span> <span class="o">=</span> <span class="n">refinement_levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ridge_sampling</span> <span class="o">=</span> <span class="n">ridge_sampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subduction_collision_parameters</span> <span class="o">=</span> <span class="n">subduction_collision_parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_ocean_mean_spreading_rate</span> <span class="o">=</span> <span class="n">initial_ocean_mean_spreading_rate</span>

        <span class="c1"># Gridding parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="n">extent</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_grid_resolution</span><span class="p">(</span><span class="n">grid_spacing</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">resume_from_checkpoints</span> <span class="o">=</span> <span class="n">resume_from_checkpoints</span>

        <span class="c1"># Temporal parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span> <span class="o">=</span> <span class="n">max_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_time</span> <span class="o">=</span> <span class="n">min_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ridge_time_step</span> <span class="o">=</span> <span class="n">ridge_time_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_time</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_ridge_time_step</span>
        <span class="p">)</span>

        <span class="c1"># ensure the time for continental masking is consistent.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span>

        <span class="c1"># Essential features and meshes for the SeafloorGrid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">continental_polygons</span> <span class="o">=</span> <span class="n">ensure_polygon_geometry</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">continents</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">continents</span> <span class="o">=</span> <span class="n">PlotTopologies_object</span><span class="o">.</span><span class="n">continents</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">icosahedral_multi_point</span> <span class="o">=</span> <span class="n">create_icosahedral_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">)</span>

        <span class="c1"># Z value parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span> <span class="o">=</span> <span class="n">zval_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_column_headers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;CURRENT_LONGITUDES&quot;</span><span class="p">,</span>
            <span class="s2">&quot;CURRENT_LATITUDES&quot;</span><span class="p">,</span>
            <span class="s2">&quot;SEAFLOOR_AGE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;BIRTH_LAT_SNAPSHOT&quot;</span><span class="p">,</span>
            <span class="s2">&quot;POINT_ID_SNAPSHOT&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_column_headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_column_headers</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_map_res_to_node_percentage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">continent_mask_filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine which percentage to use to scale the continent mask resolution at max time.&quot;&quot;&quot;</span>
        <span class="n">maskY</span><span class="p">,</span> <span class="n">maskX</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">read_netcdf_grid</span><span class="p">(</span>
            <span class="n">continent_mask_filename</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">mask_deg</span> <span class="o">=</span> <span class="n">_pixels2deg</span><span class="p">(</span><span class="n">maskX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">mask_deg</span> <span class="o">&lt;=</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="k">elif</span> <span class="n">mask_deg</span> <span class="o">&lt;=</span> <span class="mf">0.25</span><span class="p">:</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="mf">0.3</span>
        <span class="k">elif</span> <span class="n">mask_deg</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="k">elif</span> <span class="n">mask_deg</span> <span class="o">&lt;</span> <span class="mf">0.75</span><span class="p">:</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="mf">0.6</span>
        <span class="k">elif</span> <span class="n">mask_deg</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="mf">0.75</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Unable to determine percentage. The code here is suspicious. I am unsure about it.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">mask_deg</span><span class="p">,</span> <span class="n">percentage</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_output_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save_directory</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create various folders for output files.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">save_directory</span><span class="p">)</span>

        <span class="c1"># zvalue files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zvalues_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span><span class="p">,</span> <span class="s2">&quot;zvalues&quot;</span><span class="p">)</span>
        <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues_directory</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">zvalues_file_basename</span> <span class="o">=</span> <span class="s2">&quot;point_data_dataframe_</span><span class="si">{:0.2f}</span><span class="s2">Ma.npz&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">:</span>
            <span class="n">zvalues_file_basename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">zvalues_file_basename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zvalues_file_basepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zvalues_directory</span><span class="p">,</span> <span class="n">zvalues_file_basename</span>
        <span class="p">)</span>

        <span class="c1"># middle ocean ridge files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span><span class="p">,</span> <span class="s2">&quot;middle_ocean_ridges&quot;</span>
        <span class="p">)</span>
        <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_dir</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">MOR_PKL_FILE_NAME</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_dir</span><span class="p">,</span> <span class="n">MOR_PKL_FILE_NAME</span>
            <span class="p">)</span>

        <span class="c1"># continent mask files</span>
        <span class="c1"># only generate continent mask files if user does not provide them</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_is_provided</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span><span class="p">,</span> <span class="s2">&quot;continent_mask&quot;</span>
            <span class="p">)</span>
            <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_directory</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_continent_contouring</span><span class="p">:</span>
                <span class="n">continent_mask_file_basename</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;continent_mask_ptt_continent_contouring_</span><span class="si">{:0.2f}</span><span class="s2">Ma.nc&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">continent_mask_file_basename</span> <span class="o">=</span> <span class="s2">&quot;continent_mask_</span><span class="si">{:0.2f}</span><span class="s2">Ma.nc&quot;</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">:</span>
                <span class="n">continent_mask_file_basename</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">continent_mask_file_basename</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_directory</span><span class="p">,</span> <span class="n">continent_mask_file_basename</span>
            <span class="p">)</span>

        <span class="c1"># sample points files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_points_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span><span class="p">,</span> <span class="s2">&quot;sample_points&quot;</span><span class="p">)</span>
        <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_points_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_points_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_points_dir</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">SAMPLE_POINTS_PKL_FILE_NAME</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_points_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_points_dir</span><span class="p">,</span> <span class="n">SAMPLE_POINTS_PKL_FILE_NAME</span>
            <span class="p">)</span>

        <span class="c1"># gridding input files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridding_input_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span><span class="p">,</span> <span class="s2">&quot;gridding_input&quot;</span>
        <span class="p">)</span>
        <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridding_input_directory</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">gridding_input_basename</span> <span class="o">=</span> <span class="s2">&quot;gridding_input_</span><span class="si">{:0.2f}</span><span class="s2">Ma.npz&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">:</span>
            <span class="n">gridding_input_basename</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">gridding_input_basename</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridding_input_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gridding_input_directory</span><span class="p">,</span> <span class="n">gridding_input_basename</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_grid_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the output grid resolution.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grid_spacing</span><span class="p">:</span>
            <span class="n">grid_spacing</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="c1"># A list of degree spacings that allow an even division of the global lat-lon extent.</span>
        <span class="n">divisible_degree_spacings</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>

        <span class="c1"># If the provided degree spacing is in the list of permissible spacings, use it</span>
        <span class="c1"># and prepare the number of pixels in x and y (spacingX and spacingY)</span>
        <span class="k">if</span> <span class="n">grid_spacing</span> <span class="ow">in</span> <span class="n">divisible_degree_spacings</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="n">grid_spacing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacingX</span> <span class="o">=</span> <span class="n">_deg2pixels</span><span class="p">(</span><span class="n">grid_spacing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacingY</span> <span class="o">=</span> <span class="n">_deg2pixels</span><span class="p">(</span><span class="n">grid_spacing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="c1"># If the provided spacing is &gt;&gt;1 degree, use 1 degree</span>
        <span class="k">elif</span> <span class="n">grid_spacing</span> <span class="o">&gt;=</span> <span class="n">divisible_degree_spacings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="n">divisible_degree_spacings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacingX</span> <span class="o">=</span> <span class="n">_deg2pixels</span><span class="p">(</span>
                <span class="n">divisible_degree_spacings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacingY</span> <span class="o">=</span> <span class="n">_deg2pixels</span><span class="p">(</span>
                <span class="n">divisible_degree_spacings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The provided grid_spacing of </span><span class="si">{</span><span class="n">grid_spacing</span><span class="si">}</span><span class="s2"> is quite large. To preserve the grid resolution, a </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span><span class="si">}</span><span class="s2"> degree spacing has been employed instead.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># If the provided degree spacing is not in the list of permissible spacings, but below</span>
        <span class="c1"># a degree, find the closest permissible degree spacing. Use this and find</span>
        <span class="c1"># spacingX and spacingY.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">divisible_degree_spacing</span> <span class="ow">in</span> <span class="n">divisible_degree_spacings</span><span class="p">:</span>
                <span class="c1"># The tolerance is half the difference between consecutive divisible spacings.</span>
                <span class="c1"># Max is 1 degree for now - other integers work but may provide too little of a</span>
                <span class="c1"># grid resolution.</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">grid_spacing</span> <span class="o">-</span> <span class="n">divisible_degree_spacing</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.125</span><span class="p">:</span>
                    <span class="n">new_deg_res</span> <span class="o">=</span> <span class="n">divisible_degree_spacing</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="n">new_deg_res</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spacingX</span> <span class="o">=</span> <span class="n">_deg2pixels</span><span class="p">(</span>
                        <span class="n">new_deg_res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spacingY</span> <span class="o">=</span> <span class="n">_deg2pixels</span><span class="p">(</span>
                        <span class="n">new_deg_res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="p">)</span>

            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The provided grid_spacing of </span><span class="si">{</span><span class="n">grid_spacing</span><span class="si">}</span><span class="s2"> does not cleanly divide into the global extent. A degree spacing of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span><span class="si">}</span><span class="s2"> has been employed instead.&quot;</span>
                <span class="p">)</span>

    <span class="c1"># Allow SeafloorGrid time to be updated, and to update the internally-used</span>
    <span class="c1"># PlotTopologies&#39; time attribute too. If PlotTopologies is used outside the</span>
    <span class="c1"># object, its `time` attribute is not updated.</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The reconstruction time.</span>

<span class="sd">        :type: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">PlotTopologiesTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The :attr:`PlotTopologies.time` attribute.</span>

<span class="sd">        :type: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">time</span>

    <span class="nd">@max_time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">var</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_time</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Enter a valid time &gt;= 0&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SeafloorGrid.update_time">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid.update_time">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the new reconstruction time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_time: float</span>
<span class="sd">            The new reconstruction time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_time</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_collect_point_data_in_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_collection</span><span class="p">,</span> <span class="n">zval_ndarray</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;At a given timestep, create a pandas dataframe holding all attributes of point features.</span>
<span class="sd">        Rather than store z values as shapefile attributes, store them in a dataframe indexed by feature ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_collect_point_data_in_dataframe</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zvalues_file_basepath</span><span class="p">,</span>
            <span class="n">feature_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span><span class="p">,</span>
            <span class="n">zval_ndarray</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_ocean_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate ocean points by using the icosahedral mesh.&quot;&quot;&quot;</span>
        <span class="c1"># Ensure COB terranes at max time have reconstruction IDs and valid times</span>
        <span class="n">COB_polygons</span> <span class="o">=</span> <span class="n">ensure_polygon_geometry</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">continents</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># zval is a binary array encoding whether a point</span>
        <span class="c1"># coordinate is within a COB terrane polygon or not.</span>
        <span class="c1"># Use the icosahedral mesh MultiPointOnSphere attribute</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ocean_basin_point_mesh</span><span class="p">,</span> <span class="n">zvals</span> <span class="o">=</span> <span class="n">point_in_polygon_routine</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">icosahedral_multi_point</span><span class="p">,</span> <span class="n">COB_polygons</span>
        <span class="p">)</span>

        <span class="c1"># Plates to partition with</span>
        <span class="n">plate_partitioner</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PlatePartitioner</span><span class="p">(</span>
            <span class="n">COB_polygons</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Plate partition the ocean basin points</span>
        <span class="n">meshnode_feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="p">(</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">create_from_qualified_string</span><span class="p">(</span><span class="s2">&quot;gpml:MeshNode&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">meshnode_feature</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span>
            <span class="n">ocean_basin_point_mesh</span>
            <span class="c1"># multi_point</span>
        <span class="p">)</span>
        <span class="n">ocean_basin_meshnode</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">meshnode_feature</span><span class="p">)</span>

        <span class="n">paleogeography</span> <span class="o">=</span> <span class="n">plate_partitioner</span><span class="o">.</span><span class="n">partition_features</span><span class="p">(</span>
            <span class="n">ocean_basin_meshnode</span><span class="p">,</span>
            <span class="n">partition_return</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PartitionReturn</span><span class="o">.</span><span class="n">separate_partitioned_and_unpartitioned</span><span class="p">,</span>
            <span class="n">properties_to_copy</span><span class="o">=</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PropertyName</span><span class="o">.</span><span class="n">gpml_shapefile_attributes</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">paleogeography</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># points in oceans</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_ocean_points_from_continent_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the ocean points from continent mask grid.&quot;&quot;&quot;</span>
        <span class="n">max_time_cont_mask</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">Raster</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># If the user provides a continental mask filename, we need to downsize the mask</span>
        <span class="c1"># resolution for when we create the initial ocean mesh. The mesh does not need to be high-res.</span>
        <span class="c1"># If the input grid is at 0.5 degree uniform spacing, then the input</span>
        <span class="c1"># grid is 7x more populated than a 6-level stripy icosahedral mesh and</span>
        <span class="c1"># using this resolution for the initial ocean mesh will dramatically slow down reconstruction by topologies.</span>
        <span class="c1"># Scale down the resolution based on the input mask resolution</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">percentage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_res_to_node_percentage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="p">)</span>
        <span class="n">max_time_cont_mask</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">max_time_cont_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">percentage</span><span class="p">),</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">max_time_cont_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">percentage</span><span class="p">),</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">max_time_cont_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="n">max_time_cont_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">llon</span><span class="p">,</span> <span class="n">llat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>

        <span class="n">mask_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_time_cont_mask</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">mask_vals</span> <span class="o">=</span> <span class="n">max_time_cont_mask</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">mask_lon</span> <span class="o">=</span> <span class="n">llon</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">mask_inds</span><span class="p">]</span>
        <span class="n">mask_lat</span> <span class="o">=</span> <span class="n">llat</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">mask_inds</span><span class="p">]</span>

        <span class="n">ocean_pt_feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="p">()</span>
        <span class="n">ocean_pt_feature</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mask_lat</span><span class="p">,</span> <span class="n">mask_lon</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ocean_pt_feature</span><span class="p">]</span>

<div class="viewcode-block" id="SeafloorGrid.create_initial_ocean_seed_points">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid.create_initial_ocean_seed_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_initial_ocean_seed_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the initial ocean basin seed point domain (at ``max_time`` only)</span>
<span class="sd">        using Stripy&#39;s icosahedral triangulation with the specified ``self.refinement_levels``.</span>

<span class="sd">        The ocean mesh starts off as a global-spanning Stripy icosahedral mesh.</span>
<span class="sd">        ``create_initial_ocean_seed_points`` passes the automatically-resolved-to-current-time</span>
<span class="sd">        continental polygons from the :attr:`PlotTopologies.continents` attribute</span>
<span class="sd">        (which can be from a COB terrane file or a continental polygon file) into</span>
<span class="sd">        Plate Tectonic Tools&#39; point-in-polygon routine. It identifies ocean basin points that lie:</span>

<span class="sd">        * outside the polygons (for the ocean basin point domain)</span>
<span class="sd">        * inside the polygons (for the continental mask)</span>

<span class="sd">        Points from the mesh outside the continental polygons make up the ocean basin seed</span>
<span class="sd">        point mesh. The masked mesh is outputted as a compressed GPML (GPMLZ) file with</span>
<span class="sd">        the filename: ``ocean_basin_seed_points_{}Ma.gpmlz`` if a ``save_directory`` is passed.</span>
<span class="sd">        Otherwise, the mesh is returned as a `pygplates.FeatureCollection`_ object.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This point mesh represents ocean basin seafloor that was produced</span>
<span class="sd">            before :attr:`SeafloorGrid.max_time`, and thus has unknown properties like valid</span>
<span class="sd">            time and spreading rate. As time passes, the plate reconstruction model sees</span>
<span class="sd">            points emerging from MORs. These new points spread to occupy the ocean basins,</span>
<span class="sd">            moving the initial filler points closer to subduction zones and continental</span>
<span class="sd">            polygons with which they can collide. If a collision is detected, these points are deleted.</span>

<span class="sd">            Ideally, if a reconstruction tree spans a large time range, **all** initial mesh</span>
<span class="sd">            points would collide with a continent or be subducted, leaving behind a mesh of</span>
<span class="sd">            well-defined MOR-emerged ocean basin points that data can be attributed to.</span>
<span class="sd">            However, some of these initial points situated close to contiental boundaries are</span>
<span class="sd">            retained through time - these form point artefacts with anomalously high ages. Even</span>
<span class="sd">            deep-time plate models (e.g. 1 Ga) will have these artefacts - removing them would</span>
<span class="sd">            require more detail to be added to the reconstruction model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ocean_basin_point_mesh : `pygplates.FeatureCollection`_</span>
<span class="sd">            A `pygplates.FeatureCollection`_ object containing the seed points on the ocean basin.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">))</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_is_provided</span>
        <span class="p">):</span>
            <span class="c1"># If a set of continent masks was passed, we can use max_time&#39;s continental</span>
            <span class="c1"># mask to build the initial profile of seafloor age.</span>
            <span class="n">ocean_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ocean_points_from_continent_mask</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ocean_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_ocean_points</span><span class="p">()</span>

        <span class="c1"># Now that we have ocean points...</span>
        <span class="c1"># Determine age of ocean basin points using their proximity to MOR features</span>
        <span class="c1"># and an assumed globally-uniform ocean basin mean spreading rate.</span>
        <span class="c1"># We need resolved topologies at the `max_time` to pass into the proximity function</span>
        <span class="n">resolved_topologies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">shared_boundary_sections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">resolve_topologies</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
            <span class="n">resolved_topologies</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">,</span>
            <span class="n">shared_boundary_sections</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">pX</span><span class="p">,</span> <span class="n">pY</span><span class="p">,</span> <span class="n">pZ</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">find_distance_to_nearest_ridge</span><span class="p">(</span>
            <span class="n">resolved_topologies</span><span class="p">,</span>
            <span class="n">shared_boundary_sections</span><span class="p">,</span>
            <span class="n">ocean_points</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Divide spreading rate by 2 to use half the mean spreading rate</span>
        <span class="n">pAge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pZ</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_ocean_mean_spreading_rate</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_current_active_points</span><span class="p">(</span>
            <span class="n">pX</span><span class="p">,</span>
            <span class="n">pY</span><span class="p">,</span>
            <span class="n">pAge</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">,</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pX</span><span class="p">),</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_ocean_mean_spreading_rate</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pX</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_ocean_point_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span>

        <span class="c1"># the code below is for debug purpose only</span>
        <span class="k">if</span> <span class="n">get_debug_level</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">initial_ocean_point_features</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pX</span><span class="p">,</span> <span class="n">pY</span><span class="p">,</span> <span class="n">pAge</span><span class="p">):</span>
                <span class="n">point_feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="p">()</span>
                <span class="n">point_feature</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

                <span class="c1"># Add &#39;time&#39; to the age at the time of computation, to get the valid time in Ma</span>
                <span class="n">point_feature</span><span class="o">.</span><span class="n">set_valid_time</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># For now: custom zvals are added as shapefile attributes - will attempt pandas data frames</span>
                <span class="c1"># point_feature = set_shapefile_attribute(point_feature, self.initial_ocean_mean_spreading_rate, &quot;SPREADING_RATE&quot;)  # Seems like static data</span>
                <span class="n">initial_ocean_point_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_feature</span><span class="p">)</span>

            <span class="n">basename</span> <span class="o">=</span> <span class="s2">&quot;ocean_basin_seed_points_</span><span class="si">{}</span><span class="s2">_RLs_</span><span class="si">{}</span><span class="s2">Ma.gpmlz&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">:</span>
                <span class="n">basename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">,</span> <span class="n">basename</span><span class="p">)</span>
            <span class="n">initial_ocean_feature_collection</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span>
                <span class="n">initial_ocean_point_features</span>
            <span class="p">)</span>
            <span class="n">initial_ocean_feature_collection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span><span class="p">,</span> <span class="n">basename</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># save the zvalue(spreading rate) of the initial ocean points to file &quot;point_data_dataframe_{max_time}Ma.npz&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collect_point_data_in_dataframe</span><span class="p">(</span>
                <span class="n">initial_ocean_feature_collection</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_ocean_mean_spreading_rate</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pX</span><span class="p">)</span>
                <span class="p">),</span>  <span class="c1"># for now, spreading rate is one zvalue for initial ocean points. will other zvalues need to have a generalised workflow?</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="SeafloorGrid.build_all_MOR_seedpoints">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid.build_all_MOR_seedpoints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_all_MOR_seedpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resolve mid-ocean ridges for all times between ``min_time`` and ``max_time``, divide them</span>
<span class="sd">        into points that make up their shared sub-segments. Rotate these points to the left</span>
<span class="sd">        and right of the ridge using their stage rotation so that they spread from the ridge.</span>

<span class="sd">        Z-value allocation to each point is done here. In future, a function (like</span>
<span class="sd">        the spreading rate function) to calculate general z-data will be an input parameter.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If MOR seed point building is interrupted, progress is safeguarded as long as</span>
<span class="sd">            ``resume_from_checkpoints`` is set to ``True``.</span>

<span class="sd">            This assumes that points spread from ridges symmetrically, with the exception of</span>
<span class="sd">            large ridge jumps at successive timesteps. Therefore, z-values allocated to ridge-emerging</span>
<span class="sd">            points will appear symmetrical until changes in spreading ridge geometries create</span>
<span class="sd">            asymmetries.</span>

<span class="sd">            In future, this will have a checkpoint save feature so that execution</span>
<span class="sd">            (which occurs during preparation for ``ReconstructByTopologies`` and can take several hours)</span>
<span class="sd">            can be safeguarded against run interruptions.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            `Get tessellated points along a mid ocean ridge &lt;https://github.com/siwill22/agegrid-0.1/blob/master/automatic_age_grid_seeding.py#L117&gt;`__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resume_from_checkpoints</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">num_cpus</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">num_cpus</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">num_cpus</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">num_cpus</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="n">partial</span><span class="p">(</span>
                        <span class="n">_generate_mid_ocean_ridge_points</span><span class="p">,</span>
                        <span class="n">delta_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ridge_time_step</span><span class="p">,</span>
                        <span class="n">mid_ocean_ridges_file_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_file_path</span><span class="p">,</span>
                        <span class="n">rotation_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                        <span class="n">topology_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span><span class="p">,</span>
                        <span class="n">zvalues_file_basepath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues_file_basepath</span><span class="p">,</span>
                        <span class="n">zval_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span><span class="p">,</span>
                        <span class="n">ridge_sampling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ridge_sampling</span><span class="p">,</span>
                        <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_times</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">_generate_mid_ocean_ridge_points</span><span class="p">(</span>
                    <span class="n">time</span><span class="p">,</span>
                    <span class="n">delta_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ridge_time_step</span><span class="p">,</span>
                    <span class="n">mid_ocean_ridges_file_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_file_path</span><span class="p">,</span>
                    <span class="n">rotation_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                    <span class="n">topology_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span><span class="p">,</span>
                    <span class="n">zvalues_file_basepath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues_file_basepath</span><span class="p">,</span>
                    <span class="n">zval_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span><span class="p">,</span>
                    <span class="n">ridge_sampling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ridge_sampling</span><span class="p">,</span>
                    <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
                <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_continental_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a continental mask for each timestep.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Masking interrupted - resuming continental mask building at </span><span class="si">{}</span><span class="s2"> Ma!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">time_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">time_array</span><span class="p">:</span>
            <span class="n">mask_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">mask_fn</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Continent mask file exists and will not create again -- </span><span class="si">{</span><span class="n">mask_fn</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
            <span class="n">geoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">continents</span>
            <span class="n">final_grid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">rasterise</span><span class="p">(</span>
                <span class="n">geoms</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacingY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacingX</span><span class="p">),</span>
                <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span>
                <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">final_grid</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">final_grid</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">grids</span><span class="o">.</span><span class="n">write_netcdf_grid</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">),</span>
                <span class="n">final_grid</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;i1&quot;</span><span class="p">),</span>
                <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished building a continental mask at </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2"> Ma!&quot;</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_continental_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a continental mask for a given time.&quot;&quot;&quot;</span>
        <span class="n">mask_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">mask_fn</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Continent mask file exists and will not create again -- </span><span class="si">{</span><span class="n">mask_fn</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">final_grid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">rasterise</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">continents</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacingY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacingX</span><span class="p">),</span>
            <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">final_grid</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">final_grid</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">grids</span><span class="o">.</span><span class="n">write_netcdf_grid</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">),</span>
            <span class="n">final_grid</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;i1&quot;</span><span class="p">),</span>
            <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished building a continental mask at </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2"> Ma!&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SeafloorGrid.build_all_continental_masks">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid.build_all_continental_masks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_all_continental_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a continental mask to define the ocean basin for all times between ``min_time`` and ``max_time``.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Continental masking progress is safeguarded if ever masking is interrupted,</span>
<span class="sd">            provided that ``resume_from_checkpoints`` is set to ``True``.</span>

<span class="sd">            The continental masks will be saved to ``continent_mask_{time}Ma.nc`` as compressed netCDF4 files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_is_provided</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resume_from_checkpoints</span><span class="p">:</span>
                <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_continent_contouring</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">num_cpus</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="n">num_cpus</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">num_cpus</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">num_cpus</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                        <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                            <span class="n">partial</span><span class="p">(</span>
                                <span class="n">_build_continental_mask_with_contouring</span><span class="p">,</span>
                                <span class="n">continent_mask_filepath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="p">,</span>
                                <span class="n">rotation_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                                <span class="n">continent_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">_continents</span><span class="p">,</span>
                                <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
                            <span class="p">),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_times</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times</span><span class="p">:</span>
                        <span class="n">_build_continental_mask_with_contouring</span><span class="p">(</span>
                            <span class="n">time</span><span class="p">,</span>
                            <span class="n">continent_mask_filepath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="p">,</span>
                            <span class="n">rotation_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                            <span class="n">continent_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_PlotTopologies_object</span><span class="o">.</span><span class="n">_continents</span><span class="p">,</span>
                            <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
                        <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_build_continental_mask</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_zvalues_from_npz_to_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">featurecollection</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="c1"># NPZ file of seedpoint z values that emerged at this time</span>
        <span class="n">loaded_npz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues_file_basepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>

        <span class="n">curr_zvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">featurecollection</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span><span class="p">)):</span>
            <span class="c1"># Account for the 0th index being for point feature IDs</span>
            <span class="n">curr_zvalues</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loaded_npz</span><span class="p">[</span><span class="s2">&quot;arr_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">curr_zvalues</span>

<div class="viewcode-block" id="SeafloorGrid.prepare_for_reconstruction_by_topologies">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid.prepare_for_reconstruction_by_topologies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_for_reconstruction_by_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare three main auxiliary files for seafloor data gridding:</span>

<span class="sd">        * Initial ocean seed points (at ``max_time``)</span>
<span class="sd">        * Continental masks (from ``max_time`` to ``min_time``)</span>
<span class="sd">        * MOR points (from ``max_time`` to ``min_time``)</span>

<span class="sd">        Return lists of all attributes for the initial ocean point mesh and</span>
<span class="sd">        all ridge points for all times in the reconstruction time array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># INITIAL OCEAN SEED POINT MESH ----------------------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_initial_ocean_seed_points</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished building initial_ocean_seed_points!&quot;</span><span class="p">)</span>

        <span class="c1"># MOR SEED POINTS AND CONTINENTAL MASKS --------------------------------------------</span>

        <span class="c1"># The start time for seeding is controlled by whether the overwrite_existing_gridding_inputs</span>
        <span class="c1"># parameter is set to `True` (in which case the start time is `max_time`). If it is `False`</span>
        <span class="c1"># and;</span>
        <span class="c1"># - a run of seeding and continental masking was interrupted, and ridge points were</span>
        <span class="c1"># checkpointed at n Ma, seeding resumes at n-1 Ma until `min_time` or another interruption</span>
        <span class="c1"># occurs;</span>
        <span class="c1"># - seeding was completed but the subsequent gridding input creation was interrupted,</span>
        <span class="c1"># seeding is assumed completed and skipped. The workflow automatically proceeds to re-gridding.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">build_all_continental_masks</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">build_all_MOR_seedpoints</span><span class="p">()</span>

        <span class="c1"># load the initial ocean seed points</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_ocean_point_df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_ocean_point_df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">active_points</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">appearance_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_ocean_point_df</span><span class="p">[</span><span class="s2">&quot;begin_time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">birth_lat</span> <span class="o">=</span> <span class="n">lats</span>
        <span class="n">prev_lat</span> <span class="o">=</span> <span class="n">lats</span>
        <span class="n">prev_lon</span> <span class="o">=</span> <span class="n">lons</span>
        <span class="n">zvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span><span class="p">)))</span>
        <span class="n">zvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">zvalues</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_ocean_point_df</span><span class="p">[</span><span class="s2">&quot;SPREADING_RATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
            <span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="c1"># load MOR points for each time step</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_file_path</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">active_points</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">appearance_time</span> <span class="o">+=</span> <span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
            <span class="n">birth_lat</span> <span class="o">+=</span> <span class="n">lats</span>
            <span class="n">prev_lat</span> <span class="o">+=</span> <span class="n">lats</span>
            <span class="n">prev_lon</span> <span class="o">+=</span> <span class="n">lons</span>

            <span class="n">zvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">zvalues</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">active_points</span><span class="p">,</span> <span class="n">appearance_time</span><span class="p">,</span> <span class="n">birth_lat</span><span class="p">,</span> <span class="n">prev_lat</span><span class="p">,</span> <span class="n">prev_lon</span><span class="p">,</span> <span class="n">zvalues</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_update_current_active_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">begin_times</span><span class="p">,</span> <span class="n">end_times</span><span class="p">,</span> <span class="n">spread_rates</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If the `replace` is true, use the new data to replace self.current_active_points_df.</span>
<span class="sd">        Otherwise, append the new data to the end of self.current_active_points_df&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">lons</span><span class="p">,</span>
            <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">lats</span><span class="p">,</span>
            <span class="s2">&quot;begin_time&quot;</span><span class="p">:</span> <span class="n">begin_times</span><span class="p">,</span>
            <span class="s2">&quot;end_time&quot;</span><span class="p">:</span> <span class="n">end_times</span><span class="p">,</span>
            <span class="s2">&quot;SPREADING_RATE&quot;</span><span class="p">:</span> <span class="n">spread_rates</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">,</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">),</span>
                <span class="p">],</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_current_active_points_coordinates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">reconstructed_points</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">]</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the current active points with the reconstructed coordinates.</span>
<span class="sd">        The length of `reconstructed_points` must be the same with the length of self.current_active_points_df</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">reconstructed_points</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">)</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">begin_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">end_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spread_rates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reconstructed_points</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">reconstructed_points</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">lat_lon</span> <span class="o">=</span> <span class="n">reconstructed_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>
                <span class="n">lons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lat_lon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lat_lon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">begin_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;begin_time&quot;</span><span class="p">])</span>
                <span class="n">end_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;end_time&quot;</span><span class="p">])</span>
                <span class="n">spread_rates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;SPREADING_RATE&quot;</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_current_active_points</span><span class="p">(</span>
            <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">begin_times</span><span class="p">,</span> <span class="n">end_times</span><span class="p">,</span> <span class="n">spread_rates</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_remove_continental_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;remove all the points which are inside continents at `time` from self.current_active_points_df&quot;&quot;&quot;</span>
        <span class="n">gridZ</span><span class="p">,</span> <span class="n">gridX</span><span class="p">,</span> <span class="n">gridY</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">read_netcdf_grid</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">return_grids</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">ni</span><span class="p">,</span> <span class="n">nj</span> <span class="o">=</span> <span class="n">gridZ</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">gridX</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">gridX</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">gridY</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">gridY</span><span class="p">)</span>

        <span class="c1"># TODO</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">remove_points_on_continents</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">row</span><span class="o">.</span><span class="n">lat</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">))))</span>
            <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">nj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">row</span><span class="o">.</span><span class="n">lon</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">))))</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">i</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">j</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">i</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">nj</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">nj</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">j</span>

            <span class="k">if</span> <span class="n">gridZ</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">remove_points_on_continents</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_middle_ocean_ridge_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;add middle ocean ridge points at `time` to current_active_points_df&quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_file_path</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_current_active_points</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">],</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;SPREADING_RATE&quot;</span><span class="p">],</span>
            <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># obsolete code. keep here for a while. will delete later. -- 2024-05-30</span>
        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fc</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mid_ocean_ridges_file_path</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">begin_times</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">end_times</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">fc</span><span class="p">:</span>
                <span class="n">lat_lon</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">get_geometry</span><span class="p">()</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>
                <span class="n">valid_time</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">get_valid_time</span><span class="p">()</span>
                <span class="n">lons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lat_lon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lat_lon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">begin_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">end_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_time</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">curr_zvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_zvalues_from_npz_to_ndarray</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_current_active_points</span><span class="p">(</span>
                <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">begin_times</span><span class="p">,</span> <span class="n">end_times</span><span class="p">,</span> <span class="n">curr_zvalues</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_save_gridding_input_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;save the data into file for creating netcdf file later&quot;&quot;&quot;</span>
        <span class="n">data_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">])</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gridding_input_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">),</span>
            <span class="n">CURRENT_LONGITUDES</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">],</span>
            <span class="n">CURRENT_LATITUDES</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">],</span>
            <span class="n">SEAFLOOR_AGE</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">[</span><span class="s2">&quot;begin_time&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">,</span>
            <span class="n">BIRTH_LAT_SNAPSHOT</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_len</span><span class="p">,</span>
            <span class="n">POINT_ID_SNAPSHOT</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_len</span><span class="p">,</span>
            <span class="n">SPREADING_RATE</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">[</span><span class="s2">&quot;SPREADING_RATE&quot;</span><span class="p">],</span>
        <span class="p">)</span>

<div class="viewcode-block" id="SeafloorGrid.reconstruct_by_topological_model">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid.reconstruct_by_topological_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstruct_by_topological_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use `pygplates.TopologicalModel`_ class to reconstruct seed points.</span>
<span class="sd">        This method is an alternative to :meth:`reconstruct_by_topologies()` which uses Python code to do the reconstruction.</span>

<span class="sd">        .. _pygplates.TopologicalModel: https://www.gplates.org/docs/pygplates/generated/pygplates.topologicalmodel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_initial_ocean_seed_points</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished building initial_ocean_seed_points!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">build_all_continental_masks</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_all_MOR_seedpoints</span><span class="p">()</span>

        <span class="c1"># not necessary, but put here for readability purpose only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_ocean_point_df</span>

        <span class="n">time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_points_file_path</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_gridding_input_data</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="c1"># save debug file</span>
            <span class="k">if</span> <span class="n">get_debug_level</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="n">_save_seed_points_as_multipoint_coverage</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">[</span><span class="s2">&quot;begin_time&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">,</span>
                    <span class="n">time</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_points_dir</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">next_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ridge_time_step</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_time</span> <span class="o">&gt;=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_min_time</span><span class="p">):</span>
                <span class="n">points</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()</span>
                <span class="p">]</span>
                <span class="c1"># reconstruct_geometry() needs time to be integral value</span>
                <span class="c1"># https://www.gplates.org/docs/pygplates/generated/pygplates.topologicalmodel#pygplates.TopologicalModel.reconstruct_geometry</span>
                <span class="n">reconstructed_time_span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
                    <span class="n">points</span><span class="p">,</span>
                    <span class="n">initial_time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">youngest_time</span><span class="o">=</span><span class="n">next_time</span><span class="p">,</span>
                    <span class="n">time_increment</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ridge_time_step</span><span class="p">),</span>
                    <span class="n">deactivate_points</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ReconstructedGeometryTimeSpan</span><span class="o">.</span><span class="n">DefaultDeactivatePoints</span><span class="p">(</span>
                        <span class="n">threshold_velocity_delta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subduction_collision_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">/</span> <span class="mi">10</span><span class="p">,</span>  <span class="c1"># cms/yr</span>
                        <span class="n">threshold_distance_to_boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subduction_collision_parameters</span><span class="p">[</span>
                            <span class="mi">1</span>
                        <span class="p">],</span>  <span class="c1"># kms/myr</span>
                        <span class="n">deactivate_points_that_fall_outside_a_network</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>

                <span class="n">reconstructed_points</span> <span class="o">=</span> <span class="n">reconstructed_time_span</span><span class="o">.</span><span class="n">get_geometry_points</span><span class="p">(</span>
                    <span class="n">next_time</span><span class="p">,</span> <span class="n">return_inactive_points</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Finished topological reconstruction of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_active_points_df</span><span class="p">)</span><span class="si">}</span><span class="s2"> points from </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">next_time</span><span class="si">}</span><span class="s2"> Ma.&quot;</span>
                <span class="p">)</span>
                <span class="c1"># update the current activate points to prepare for the reconstruction to &quot;next time&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_current_active_points_coordinates</span><span class="p">(</span><span class="n">reconstructed_points</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_remove_continental_points</span><span class="p">(</span><span class="n">next_time</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_middle_ocean_ridge_points</span><span class="p">(</span><span class="n">next_time</span><span class="p">)</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">next_time</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span></div>


<div class="viewcode-block" id="SeafloorGrid.reconstruct_by_topologies">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid.reconstruct_by_topologies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstruct_by_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Obtain all active ocean seed points which are points that have not been consumed at subduction zones</span>
<span class="sd">        or have not collided with continental polygons. Active points&#39; latitudes, longitues, seafloor ages, spreading rates and all</span>
<span class="sd">        other general z-values are saved to a gridding input file (.npz).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing all initial files...&quot;</span><span class="p">)</span>

        <span class="c1"># Obtain all info from the ocean seed points and all MOR points through time, store in</span>
        <span class="c1"># arrays</span>
        <span class="p">(</span>
            <span class="n">active_points</span><span class="p">,</span>
            <span class="n">appearance_time</span><span class="p">,</span>
            <span class="n">birth_lat</span><span class="p">,</span>
            <span class="n">prev_lat</span><span class="p">,</span>
            <span class="n">prev_lon</span><span class="p">,</span>
            <span class="n">zvalues</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_reconstruction_by_topologies</span><span class="p">()</span>

        <span class="c1">####  Begin reconstruction by topology process:</span>
        <span class="c1"># Indices for all points (`active_points`) that have existed from `max_time` to `min_time`.</span>
        <span class="n">point_id</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">active_points</span><span class="p">))</span>

        <span class="c1"># Specify the default collision detection region as subduction zones</span>
        <span class="n">default_collision</span> <span class="o">=</span> <span class="n">_DefaultCollision</span><span class="p">(</span>
            <span class="n">feature_specific_collision_parameters</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">gpml_subduction_zone</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">subduction_collision_parameters</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># In addition to the default subduction detection, also detect continental collisions</span>
        <span class="n">collision_spec</span> <span class="o">=</span> <span class="n">_ContinentCollision</span><span class="p">(</span>
            <span class="c1"># This filename string should not have a time formatted into it - this is</span>
            <span class="c1"># taken care of later.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="p">,</span>
            <span class="n">default_collision</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Call the reconstruct by topologies object</span>
        <span class="n">topology_reconstruction</span> <span class="o">=</span> <span class="n">_ReconstructByTopologies</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_time</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_min_time</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ridge_time_step</span><span class="p">,</span>
            <span class="n">active_points</span><span class="p">,</span>
            <span class="n">point_begin_times</span><span class="o">=</span><span class="n">appearance_time</span><span class="p">,</span>
            <span class="n">detect_collisions</span><span class="o">=</span><span class="n">collision_spec</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Initialise the reconstruction.</span>
        <span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">begin_reconstruction</span><span class="p">()</span>

        <span class="c1"># Loop over the reconstruction times until the end of the reconstruction time span, or until</span>
        <span class="c1"># all points have entered their valid time range *and* either exited their time range or</span>
        <span class="c1"># have been deactivated (subducted forward in time or consumed by MOR backward in time).</span>
        <span class="n">reconstruction_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Reconstruct by topologies: working on time </span><span class="si">{</span><span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">get_current_time</span><span class="p">()</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> Ma&quot;</span>
            <span class="p">)</span>

            <span class="c1"># NOTE:</span>
            <span class="c1"># topology_reconstruction.get_active_current_points() and topology_reconstruction.get_all_current_points()</span>
            <span class="c1"># are different. The former is a subset of the latter, and it represents all points at the timestep that</span>
            <span class="c1"># have not collided with a continental or subduction boundary. The remainders in the latter are inactive</span>
            <span class="c1"># (NoneType) points, which represent the collided points.</span>

            <span class="c1"># We need to access active point data from topology_reconstruction.get_all_current_points() because it has</span>
            <span class="c1"># the same length as the list of all initial ocean points and MOR seed points that have ever emerged from</span>
            <span class="c1"># spreading ridge topologies through `max_time` to `min_time`. Therefore, it protects the time and space</span>
            <span class="c1"># order in which all MOR points through time were seeded by pyGPlates. At any given timestep, not all these</span>
            <span class="c1"># points will be active, but their indices are retained. Thus, z value allocation, point latitudes and</span>
            <span class="c1"># longitudes of active points will be correctly indexed if taking it from</span>
            <span class="c1"># topology_reconstruction.get_all_current_points().</span>
            <span class="n">curr_points</span> <span class="o">=</span> <span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">get_active_current_points</span><span class="p">()</span>
            <span class="n">curr_points_including_inactive</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">get_all_current_points</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the number of current active points is :</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_points</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;the number of all current  points is :</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_points_including_inactive</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Collect latitudes and longitudes of currently ACTIVE points in the ocean basin</span>
            <span class="n">curr_lat_lon_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">curr_points</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">curr_lat_lon_points</span><span class="p">:</span>
                <span class="c1"># Get the number of active points at this timestep.</span>
                <span class="n">num_current_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_points</span><span class="p">)</span>

                <span class="c1"># ndarray to fill with active point lats, lons and zvalues</span>
                <span class="c1"># FOR NOW, the number of gridding input columns is 6:</span>
                <span class="c1"># 0 = longitude</span>
                <span class="c1"># 1 = latitude</span>
                <span class="c1"># 2 = seafloor age</span>
                <span class="c1"># 3 = birth latitude snapshot</span>
                <span class="c1"># 4 = point id</span>

                <span class="c1"># 5 for the default gridding columns above, plus additional zvalues added next</span>
                <span class="n">total_number_of_columns</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span><span class="p">)</span>
                <span class="n">gridding_input_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">num_current_points</span><span class="p">,</span> <span class="n">total_number_of_columns</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="c1"># Lons and lats are first and second columns of the ndarray respectively</span>
                <span class="n">gridding_input_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">gridding_input_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">curr_lat_lon_points</span>
                <span class="p">)</span>

                <span class="c1"># NOTE: We need a single index to access data from curr_points_including_inactive AND allocate</span>
                <span class="c1"># this data to an ndarray with a number of rows equal to num_current_points. This index will</span>
                <span class="c1"># append +1 after each loop through curr_points_including_inactive.</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Get indices and points of all points at `time`, both active and inactive (which are NoneType points that</span>
                <span class="c1"># have undergone continental collision or subduction at `time`).</span>
                <span class="k">for</span> <span class="n">point_index</span><span class="p">,</span> <span class="n">current_point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="n">curr_points_including_inactive</span>
                <span class="p">):</span>
                    <span class="c1"># Look at all active points (these have not collided with a continent or trench)</span>
                    <span class="k">if</span> <span class="n">current_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Seafloor age</span>
                        <span class="n">gridding_input_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">appearance_time</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                            <span class="o">-</span> <span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">get_current_time</span><span class="p">()</span>
                        <span class="p">)</span>
                        <span class="c1"># Birth latitude (snapshot)</span>
                        <span class="n">gridding_input_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">birth_lat</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                        <span class="c1"># Point ID (snapshot)</span>
                        <span class="n">gridding_input_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">point_id</span><span class="p">[</span>
                            <span class="n">point_index</span>
                        <span class="p">]</span>  <span class="c1"># The ID of a corresponding point from the original list of all MOR-resolved points</span>

                        <span class="c1"># GENERAL Z-VALUE ALLOCATION</span>
                        <span class="c1"># Z values are 1st index onwards; 0th belongs to the point feature ID (thus +1)</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zval_names</span><span class="p">)):</span>
                            <span class="c1"># Adjusted index - and we have to add j to 5 to account for lat, lon, age, birth lat and point ID,</span>
                            <span class="n">adjusted_index</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">j</span>

                            <span class="c1"># Spreading rate would be first</span>
                            <span class="c1"># Access current zval from the master list of all zvalues for all points that ever existed in time_array</span>
                            <span class="n">gridding_input_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">adjusted_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">zvalues</span><span class="p">[</span>
                                <span class="n">point_index</span><span class="p">,</span> <span class="n">j</span>
                            <span class="p">]</span>

                        <span class="c1"># Go to the next active point</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">gridding_input_dictionary</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">total_number_of_columns</span><span class="p">)):</span>
                    <span class="n">gridding_input_dictionary</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">total_column_headers</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="nb">list</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">gridding_input_data</span><span class="p">)</span>
                    <span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">data_to_store</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">gridding_input_dictionary</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gridding_input_dictionary</span>
                    <span class="p">]</span>

                <span class="c1"># save debug file</span>
                <span class="k">if</span> <span class="n">get_debug_level</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="n">seafloor_ages</span> <span class="o">=</span> <span class="n">gridding_input_dictionary</span><span class="p">[</span><span class="s2">&quot;SEAFLOOR_AGE&quot;</span><span class="p">]</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The max and min values of seafloor age are: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">seafloor_ages</span><span class="p">)</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">seafloor_ages</span><span class="p">)</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">get_current_time</span><span class="p">()</span><span class="si">}</span><span class="s2">Ma)&quot;</span>
                    <span class="p">)</span>
                    <span class="n">_save_seed_points_as_multipoint_coverage</span><span class="p">(</span>
                        <span class="n">gridding_input_dictionary</span><span class="p">[</span><span class="s2">&quot;CURRENT_LONGITUDES&quot;</span><span class="p">],</span>
                        <span class="n">gridding_input_dictionary</span><span class="p">[</span><span class="s2">&quot;CURRENT_LATITUDES&quot;</span><span class="p">],</span>
                        <span class="n">gridding_input_dictionary</span><span class="p">[</span><span class="s2">&quot;SEAFLOOR_AGE&quot;</span><span class="p">],</span>
                        <span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">get_current_time</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_points_dir</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gridding_input_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">get_current_time</span><span class="p">()</span>
                    <span class="p">),</span>
                    <span class="o">*</span><span class="n">data_to_store</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">reconstruct_to_next_time</span><span class="p">():</span>
                <span class="k">break</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Reconstruction has been done for </span><span class="si">{</span><span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">get_current_time</span><span class="p">()</span><span class="si">}</span><span class="s2">!&quot;</span>
            <span class="p">)</span></div>

        <span class="c1"># return reconstruction_data</span>

<div class="viewcode-block" id="SeafloorGrid.lat_lon_z_to_netCDF">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid.lat_lon_z_to_netCDF">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lat_lon_z_to_netCDF</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">zval_name</span><span class="p">,</span>
        <span class="n">time_arr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">unmasked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Produce a netCDF4 grid of a z-value identified by its ``zval_name`` for a given time range in ``time_arr``.</span>

<span class="sd">        Seafloor age can be gridded by passing ``zval_name`` as ``SEAFLOOR_AGE``, and spreading</span>
<span class="sd">        rate can be gridded with ``SPREADING_RATE``.</span>

<span class="sd">        Saves all grids to compressed netCDF format in the attributed directory. Grids</span>
<span class="sd">        can be read into ndarray format using :func:`gplately.read_netcdf_grid()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        zval_name : str</span>
<span class="sd">            A string identifier for the z-value.</span>
<span class="sd">        time_arr : list of float, default=None</span>
<span class="sd">            A time range to turn lons, lats and z-values into netCDF4 grids. If not provided,</span>
<span class="sd">            ``time_arr`` defaults to the full ``time_array`` provided to :class:`SeafloorGrid`.</span>
<span class="sd">        unmasked : bool, default=False</span>
<span class="sd">            Save unmasked grids, in addition to masked versions.</span>
<span class="sd">        nprocs : int, defaullt=1</span>
<span class="sd">            Number of processes to use for certain operations (requires joblib).</span>
<span class="sd">            Passed to ``joblib.Parallel``, so -1 means all available processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parallel</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">nprocs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nprocs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nprocs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span>

                <span class="n">parallel</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">nprocs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Could not import joblib; falling back to serial execution&quot;</span>
                <span class="p">)</span>

        <span class="c1"># User can put any time array within SeafloorGrid bounds, but if none</span>
        <span class="c1"># is provided, it defaults to the attributed time array</span>
        <span class="k">if</span> <span class="n">time_arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times</span>

        <span class="k">if</span> <span class="n">parallel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">time_arr</span><span class="p">:</span>
                <span class="n">_lat_lon_z_to_netCDF_time</span><span class="p">(</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">zval_name</span><span class="o">=</span><span class="n">zval_name</span><span class="p">,</span>
                    <span class="n">file_collection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">,</span>
                    <span class="n">save_directory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span><span class="p">,</span>
                    <span class="n">total_column_headers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">total_column_headers</span><span class="p">,</span>
                    <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span>
                    <span class="n">resX</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spacingX</span><span class="p">,</span>
                    <span class="n">resY</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spacingY</span><span class="p">,</span>
                    <span class="n">unmasked</span><span class="o">=</span><span class="n">unmasked</span><span class="p">,</span>
                    <span class="n">continent_mask_filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="p">,</span>
                    <span class="n">gridding_input_filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gridding_input_filepath</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">delayed</span>

            <span class="n">parallel</span><span class="p">(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="n">_lat_lon_z_to_netCDF_time</span><span class="p">)(</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">zval_name</span><span class="o">=</span><span class="n">zval_name</span><span class="p">,</span>
                    <span class="n">file_collection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">,</span>
                    <span class="n">save_directory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span><span class="p">,</span>
                    <span class="n">total_column_headers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">total_column_headers</span><span class="p">,</span>
                    <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span>
                    <span class="n">resX</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spacingX</span><span class="p">,</span>
                    <span class="n">resY</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spacingY</span><span class="p">,</span>
                    <span class="n">unmasked</span><span class="o">=</span><span class="n">unmasked</span><span class="p">,</span>
                    <span class="n">continent_mask_filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="p">,</span>
                    <span class="n">gridding_input_filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gridding_input_filepath</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">time_arr</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="SeafloorGrid.save_netcdf_files">
<a class="viewcode-back" href="../../generated/gplately.SeafloorGrid.html#gplately.SeafloorGrid.save_netcdf_files">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_netcdf_files</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">unmasked</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">nprocs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate the sample points to create regular grids and save as NetCDF files.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name: str</span>
<span class="sd">            The variable name, such as ``SEAFLOOR_AGE`` or ``SPREADING_RATE``.</span>
<span class="sd">        times: list</span>
<span class="sd">            A list of times of interest.</span>
<span class="sd">        unmasked: bool</span>
<span class="sd">            A flag to indicate if the unmasked grids should be saved.</span>
<span class="sd">        nprocs: int</span>
<span class="sd">            The number of processes to use for multiprocessing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times</span>
        <span class="k">if</span> <span class="n">nprocs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nprocs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">nprocs</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">nprocs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">nprocs</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="n">partial</span><span class="p">(</span>
                        <span class="n">_save_netcdf_file</span><span class="p">,</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">file_collection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">,</span>
                        <span class="n">save_directory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span><span class="p">,</span>
                        <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span>
                        <span class="n">resX</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spacingX</span><span class="p">,</span>
                        <span class="n">resY</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spacingY</span><span class="p">,</span>
                        <span class="n">unmasked</span><span class="o">=</span><span class="n">unmasked</span><span class="p">,</span>
                        <span class="n">continent_mask_filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="p">,</span>
                        <span class="n">sample_points_file_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_points_file_path</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">times</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
                <span class="n">_save_netcdf_file</span><span class="p">(</span>
                    <span class="n">time</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">file_collection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">,</span>
                    <span class="n">save_directory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_directory</span><span class="p">,</span>
                    <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span>
                    <span class="n">resX</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spacingX</span><span class="p">,</span>
                    <span class="n">resY</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spacingY</span><span class="p">,</span>
                    <span class="n">unmasked</span><span class="o">=</span><span class="n">unmasked</span><span class="p">,</span>
                    <span class="n">continent_mask_filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">continent_mask_filepath</span><span class="p">,</span>
                    <span class="n">sample_points_file_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_points_file_path</span><span class="p">,</span>
                <span class="p">)</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">_save_netcdf_file</span><span class="p">(</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">name</span><span class="p">,</span>
    <span class="n">file_collection</span><span class="p">,</span>
    <span class="n">save_directory</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
    <span class="n">extent</span><span class="p">,</span>
    <span class="n">resX</span><span class="p">,</span>
    <span class="n">resY</span><span class="p">,</span>
    <span class="n">continent_mask_filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">sample_points_file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">unmasked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="n">sample_points_file_path</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
    <span class="c1"># drop invalid data</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
    <span class="c1"># Drop duplicate latitudes and longitudes</span>
    <span class="n">unique_data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">])</span>

    <span class="c1"># Acquire lons, lats and zvalues for each time</span>
    <span class="n">lons</span> <span class="o">=</span> <span class="n">unique_data</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="n">lats</span> <span class="o">=</span> <span class="n">unique_data</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;SEAFLOOR_AGE&quot;</span><span class="p">:</span>
        <span class="n">zdata</span> <span class="o">=</span> <span class="p">(</span><span class="n">unique_data</span><span class="p">[</span><span class="s2">&quot;begin_time&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;SPREADING_RATE&quot;</span><span class="p">:</span>
        <span class="n">zdata</span> <span class="o">=</span> <span class="n">unique_data</span><span class="p">[</span><span class="s2">&quot;SPREADING_RATE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown variable name: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Create a regular grid on which to interpolate lats, lons and zdata</span>
    <span class="n">extent_globe</span> <span class="o">=</span> <span class="n">extent</span>
    <span class="n">grid_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent_globe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extent_globe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">resX</span><span class="p">)</span>
    <span class="n">grid_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent_globe</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">extent_globe</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">resY</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">grid_lon</span><span class="p">,</span> <span class="n">grid_lat</span><span class="p">)</span>

    <span class="c1"># Interpolate lons, lats and zvals over a regular grid using nearest neighbour interpolation</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">griddata_sphere</span><span class="p">((</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">),</span> <span class="n">zdata</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;f4&quot;</span><span class="p">)</span>

    <span class="n">unmasked_basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_grid_unmasked_</span><span class="si">{</span><span class="n">time</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2">_Ma.nc&quot;</span>
    <span class="n">grid_basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_grid_</span><span class="si">{</span><span class="n">time</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2">_Ma.nc&quot;</span>
    <span class="k">if</span> <span class="n">file_collection</span><span class="p">:</span>
        <span class="n">unmasked_basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_collection</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">unmasked_basename</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">grid_basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_collection</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">grid_basename</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">output_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_directory</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">grid_output_unmasked</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">unmasked_basename</span><span class="p">)</span>
    <span class="n">grid_output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">grid_basename</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">unmasked</span><span class="p">:</span>
        <span class="n">grids</span><span class="o">.</span><span class="n">write_netcdf_grid</span><span class="p">(</span>
            <span class="n">grid_output_unmasked</span><span class="p">,</span>
            <span class="n">Z</span><span class="p">,</span>
            <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
            <span class="n">significant_digits</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Identify regions in the grid in the continental mask</span>
    <span class="c1"># We need the continental mask to match the number of nodes</span>
    <span class="c1"># in the uniform grid defined above. This is important if we</span>
    <span class="c1"># pass our own continental mask to SeafloorGrid</span>
    <span class="n">cont_mask</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">read_netcdf_grid</span><span class="p">(</span>
        <span class="n">continent_mask_filename</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">resize</span><span class="o">=</span><span class="p">(</span><span class="n">resX</span><span class="p">,</span> <span class="n">resY</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Use the continental mask to mask out continents</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">cont_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">grids</span><span class="o">.</span><span class="n">write_netcdf_grid</span><span class="p">(</span>
        <span class="n">grid_output</span><span class="p">,</span>
        <span class="n">Z</span><span class="p">,</span>
        <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
        <span class="n">significant_digits</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Save </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> netCDF grid at </span><span class="si">{</span><span class="n">time</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> Ma completed!&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_lat_lon_z_to_netCDF_time</span><span class="p">(</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">zval_name</span><span class="p">,</span>
    <span class="n">file_collection</span><span class="p">,</span>
    <span class="n">save_directory</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
    <span class="n">total_column_headers</span><span class="p">,</span>
    <span class="n">extent</span><span class="p">,</span>
    <span class="n">resX</span><span class="p">,</span>
    <span class="n">resY</span><span class="p">,</span>
    <span class="n">continent_mask_filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">gridding_input_filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">unmasked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># Read the gridding input made by ReconstructByTopologies:</span>
    <span class="c1"># Use pandas to load in lons, lats and z values from npz files</span>
    <span class="n">npz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">gridding_input_filename</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
    <span class="n">curr_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
        <span class="p">{</span><span class="n">item</span><span class="p">:</span> <span class="n">npz</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">npz</span><span class="o">.</span><span class="n">files</span><span class="p">},</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;columns&quot;</span>
    <span class="p">)</span>
    <span class="n">curr_data</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">total_column_headers</span>

    <span class="c1"># drop invalid data</span>
    <span class="n">curr_data</span> <span class="o">=</span> <span class="n">curr_data</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">curr_data</span> <span class="o">=</span> <span class="n">curr_data</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span>
        <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CURRENT_LONGITUDES&quot;</span><span class="p">,</span> <span class="s2">&quot;CURRENT_LATITUDES&quot;</span><span class="p">,</span> <span class="n">zval_name</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;SEAFLOOR_AGE&quot;</span> <span class="o">==</span> <span class="n">zval_name</span><span class="p">:</span>
        <span class="n">curr_data</span> <span class="o">=</span> <span class="n">curr_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">curr_data</span><span class="p">[</span><span class="n">curr_data</span><span class="o">.</span><span class="n">SEAFLOOR_AGE</span> <span class="o">&gt;</span> <span class="mi">350</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Drop duplicate latitudes and longitudes</span>
    <span class="n">unique_data</span> <span class="o">=</span> <span class="n">curr_data</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
        <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CURRENT_LONGITUDES&quot;</span><span class="p">,</span> <span class="s2">&quot;CURRENT_LATITUDES&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Acquire lons, lats and zvalues for each time</span>
    <span class="n">lons</span> <span class="o">=</span> <span class="n">unique_data</span><span class="p">[</span><span class="s2">&quot;CURRENT_LONGITUDES&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="n">lats</span> <span class="o">=</span> <span class="n">unique_data</span><span class="p">[</span><span class="s2">&quot;CURRENT_LATITUDES&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="n">zdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unique_data</span><span class="p">[</span><span class="n">zval_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>

    <span class="c1"># zdata = np.where(zdata &gt; 375, float(&quot;nan&quot;), zdata), to deal with vmax in the future</span>
    <span class="c1"># zdata = np.nan_to_num(zdata)</span>

    <span class="c1"># Create a regular grid on which to interpolate lats, lons and zdata</span>
    <span class="n">extent_globe</span> <span class="o">=</span> <span class="n">extent</span>
    <span class="n">grid_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent_globe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extent_globe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">resX</span><span class="p">)</span>
    <span class="n">grid_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent_globe</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">extent_globe</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">resY</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">grid_lon</span><span class="p">,</span> <span class="n">grid_lat</span><span class="p">)</span>

    <span class="c1"># Interpolate lons, lats and zvals over a regular grid using nearest neighbour interpolation</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">griddata_sphere</span><span class="p">((</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">),</span> <span class="n">zdata</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;f4&quot;</span><span class="p">)</span>  <span class="c1"># float32 precision</span>

    <span class="n">unmasked_basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">zval_name</span><span class="si">}</span><span class="s2">_grid_unmasked_</span><span class="si">{</span><span class="n">time</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2">Ma.nc&quot;</span>
    <span class="n">grid_basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">zval_name</span><span class="si">}</span><span class="s2">_grid_</span><span class="si">{</span><span class="n">time</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2">Ma.nc&quot;</span>
    <span class="k">if</span> <span class="n">file_collection</span><span class="p">:</span>
        <span class="n">unmasked_basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_collection</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">unmasked_basename</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">grid_basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_collection</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">grid_basename</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">output_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_directory</span><span class="p">,</span> <span class="n">zval_name</span><span class="p">)</span>
    <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">grid_output_unmasked</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">unmasked_basename</span><span class="p">)</span>
    <span class="n">grid_output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">grid_basename</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">unmasked</span><span class="p">:</span>
        <span class="n">grids</span><span class="o">.</span><span class="n">write_netcdf_grid</span><span class="p">(</span>
            <span class="n">grid_output_unmasked</span><span class="p">,</span>
            <span class="n">Z</span><span class="p">,</span>
            <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
            <span class="n">significant_digits</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Identify regions in the grid in the continental mask</span>
    <span class="c1"># We need the continental mask to match the number of nodes</span>
    <span class="c1"># in the uniform grid defined above. This is important if we</span>
    <span class="c1"># pass our own continental mask to SeafloorGrid</span>
    <span class="n">cont_mask</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">read_netcdf_grid</span><span class="p">(</span>
        <span class="n">continent_mask_filename</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">resize</span><span class="o">=</span><span class="p">(</span><span class="n">resX</span><span class="p">,</span> <span class="n">resY</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Use the continental mask to mask out continents</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">cont_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">grids</span><span class="o">.</span><span class="n">write_netcdf_grid</span><span class="p">(</span>
        <span class="n">grid_output</span><span class="p">,</span>
        <span class="n">Z</span><span class="p">,</span>
        <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
        <span class="n">significant_digits</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">zval_name</span><span class="si">}</span><span class="s2"> netCDF grids for </span><span class="si">{</span><span class="n">time</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> Ma complete!&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_save_age_grid_sample_points_to_gpml</span><span class="p">(</span>
    <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">seafloor_ages</span><span class="p">,</span> <span class="n">paleo_time</span><span class="p">,</span> <span class="n">output_file_dir</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;save sample points to .gpmlz for debug purpose&quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;saving age grid sample points to gpml file -- </span><span class="si">{</span><span class="n">paleo_time</span><span class="si">}</span><span class="s2"> Ma&quot;</span><span class="p">)</span>
    <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">age</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">seafloor_ages</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="p">()</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_valid_time</span><span class="p">(</span><span class="n">age</span> <span class="o">+</span> <span class="n">paleo_time</span><span class="p">,</span> <span class="n">paleo_time</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">features</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_file_dir</span><span class="p">,</span> <span class="n">SAMPLE_POINTS_GPMLZ_FILE_NAME</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">paleo_time</span><span class="p">))</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_save_seed_points_as_multipoint_coverage</span><span class="p">(</span>
    <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">seafloor_ages</span><span class="p">,</span> <span class="n">paleo_time</span><span class="p">,</span> <span class="n">output_file_dir</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;save seed points to .gpmlz as multipoint coverage for debug purpose&quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="p">()</span>
    <span class="n">coverage_geometry</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">))</span>
    <span class="n">coverage_scalars</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;SeafloorAge&quot;</span><span class="p">):</span> <span class="n">seafloor_ages</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">f</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">((</span><span class="n">coverage_geometry</span><span class="p">,</span> <span class="n">coverage_scalars</span><span class="p">))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">set_valid_time</span><span class="p">(</span><span class="n">paleo_time</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">paleo_time</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">([</span><span class="n">f</span><span class="p">])</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">output_file_dir</span><span class="p">,</span> <span class="s2">&quot;seed_points_coverage_</span><span class="si">{:0.2f}</span><span class="s2">_Ma.gpmlz&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">paleo_time</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_build_continental_mask_with_contouring</span><span class="p">(</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">continent_mask_filepath</span><span class="p">,</span>
    <span class="n">rotation_model</span><span class="p">,</span>
    <span class="n">continent_features</span><span class="p">,</span>
    <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build the continent mask for a given time using ptt&#39;s &#39;continent contouring&#39; method.</span>
<span class="sd">    For more information about &#39;Continent Contouring&#39;, visit https://gplates.github.io/gplately/dev-doc/ptt/continent_contours.html.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask_fn</span> <span class="o">=</span> <span class="n">continent_mask_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">mask_fn</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Continent mask file exists and will not create again -- </span><span class="si">{</span><span class="n">mask_fn</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span>

    <span class="n">continent_contouring_point_spacing_degrees</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">continent_contouring_area_threshold_square_kms</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">continent_contouring_area_threshold_steradians</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">continent_contouring_area_threshold_square_kms</span>
        <span class="o">/</span> <span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span> <span class="o">*</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">continent_exclusion_area_threshold_square_kms</span> <span class="o">=</span> <span class="mi">800000</span>
    <span class="n">continent_exclusion_area_threshold_steradians</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">continent_exclusion_area_threshold_square_kms</span>
        <span class="o">/</span> <span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span> <span class="o">*</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">continent_separation_distance_threshold_radians</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">continent_contours</span><span class="o">.</span><span class="n">DEFAULT_CONTINENT_SEPARATION_DISTANCE_THRESHOLD_RADIANS</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">continent_contouring_buffer_and_gap_distance_radians</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">contoured_continent</span><span class="p">):</span>
        <span class="c1"># One distance for time interval [1000, 300] and another for time interval [250, 0].</span>
        <span class="c1"># And linearly interpolate between them over the time interval [300, 250].</span>
        <span class="n">pre_pangea_distance_radians</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>  <span class="c1"># convert degrees to radians</span>
        <span class="n">post_pangea_distance_radians</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>  <span class="c1"># convert degrees to radians</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span>
            <span class="n">buffer_and_gap_distance_radians</span> <span class="o">=</span> <span class="n">pre_pangea_distance_radians</span>
        <span class="k">elif</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="mi">250</span><span class="p">:</span>
            <span class="n">buffer_and_gap_distance_radians</span> <span class="o">=</span> <span class="n">post_pangea_distance_radians</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Linearly interpolate between 250 and 300 Ma.</span>
            <span class="n">interp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="mi">250</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">300</span> <span class="o">-</span> <span class="mi">250</span><span class="p">)</span>
            <span class="n">buffer_and_gap_distance_radians</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">interp</span> <span class="o">*</span> <span class="n">pre_pangea_distance_radians</span>
                <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">interp</span><span class="p">)</span> <span class="o">*</span> <span class="n">post_pangea_distance_radians</span>
            <span class="p">)</span>

        <span class="c1"># Area of the contoured continent.</span>
        <span class="n">area_steradians</span> <span class="o">=</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>

        <span class="c1"># Linearly reduce the buffer/gap distance for contoured continents with area smaller than 1 million km^2.</span>
        <span class="n">area_threshold_square_kms</span> <span class="o">=</span> <span class="mi">500000</span>
        <span class="n">area_threshold_steradians</span> <span class="o">=</span> <span class="n">area_threshold_square_kms</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span> <span class="o">*</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">area_steradians</span> <span class="o">&lt;</span> <span class="n">area_threshold_steradians</span><span class="p">:</span>
            <span class="n">buffer_and_gap_distance_radians</span> <span class="o">*=</span> <span class="p">(</span>
                <span class="n">area_steradians</span> <span class="o">/</span> <span class="n">area_threshold_steradians</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">buffer_and_gap_distance_radians</span>

    <span class="n">continent_contouring</span> <span class="o">=</span> <span class="n">continent_contours</span><span class="o">.</span><span class="n">ContinentContouring</span><span class="p">(</span>
        <span class="n">rotation_model</span><span class="p">,</span>
        <span class="n">continent_features</span><span class="p">,</span>
        <span class="n">continent_contouring_point_spacing_degrees</span><span class="p">,</span>
        <span class="n">continent_contouring_area_threshold_steradians</span><span class="p">,</span>
        <span class="n">continent_contouring_buffer_and_gap_distance_radians</span><span class="p">,</span>
        <span class="n">continent_exclusion_area_threshold_steradians</span><span class="p">,</span>
        <span class="n">continent_separation_distance_threshold_radians</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">continent_mask</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">continent_contouring</span><span class="o">.</span><span class="n">get_continent_mask_and_contoured_continents</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">grids</span><span class="o">.</span><span class="n">write_netcdf_grid</span><span class="p">(</span>
        <span class="n">continent_mask_filepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">),</span>
        <span class="n">continent_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;i1&quot;</span><span class="p">),</span>
        <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Finished building a continental mask at </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2"> Ma using ptt&#39;s &#39;Continent Contouring&#39;!&quot;</span>
        <span class="o">+</span> <span class="s2">&quot; For more information about &#39;Continent Contouring&#39;, visit https://gplates.github.io/gplately/dev-doc/ptt/continent_contours.html.&quot;</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_generate_mid_ocean_ridge_points</span><span class="p">(</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">delta_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">mid_ocean_ridges_file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">rotation_model</span><span class="p">,</span>
    <span class="n">topology_features</span><span class="p">,</span>
    <span class="n">zvalues_file_basepath</span><span class="p">,</span>
    <span class="n">zval_names</span><span class="p">,</span>
    <span class="n">ridge_sampling</span><span class="p">,</span>
    <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;generate middle ocean ridge seed points at a given time&quot;&quot;&quot;</span>
    <span class="n">mor_fn</span> <span class="o">=</span> <span class="n">mid_ocean_ridges_file_path</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">mor_fn</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Middle ocean ridge file exists and will not create again.</span><span class="se">\n</span><span class="si">{</span><span class="n">mor_fn</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Points and their z values that emerge from MORs at this time.</span>
    <span class="n">shifted_mor_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">point_spreading_rates</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Resolve topologies to the current time.</span>
    <span class="n">resolved_topologies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">shared_boundary_sections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pygplates</span><span class="o">.</span><span class="n">resolve_topologies</span><span class="p">(</span>
        <span class="n">topology_features</span><span class="p">,</span>
        <span class="n">rotation_model</span><span class="p">,</span>
        <span class="n">resolved_topologies</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">shared_boundary_sections</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># pygplates.ResolvedTopologicalSection objects.</span>
    <span class="k">for</span> <span class="n">shared_boundary_section</span> <span class="ow">in</span> <span class="n">shared_boundary_sections</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">shared_boundary_section</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_feature_type</span><span class="p">()</span>
            <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;MidOceanRidge&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">spreading_feature</span> <span class="o">=</span> <span class="n">shared_boundary_section</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span>

            <span class="c1"># Find the stage rotation of the spreading feature in the</span>
            <span class="c1"># frame of reference of its geometry at the current</span>
            <span class="c1"># reconstruction time (the MOR is currently actively spreading).</span>
            <span class="c1"># The stage pole can then be directly geometrically compared</span>
            <span class="c1"># to the *reconstructed* spreading geometry.</span>
            <span class="n">stage_rotation</span> <span class="o">=</span> <span class="n">separate_ridge_transform_segments</span><span class="o">.</span><span class="n">get_stage_rotation_for_reconstructed_geometry</span><span class="p">(</span>
                <span class="n">spreading_feature</span><span class="p">,</span> <span class="n">rotation_model</span><span class="p">,</span> <span class="n">time</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stage_rotation</span><span class="p">:</span>
                <span class="c1"># Skip current feature - it&#39;s not a spreading feature.</span>
                <span class="k">continue</span>

            <span class="c1"># Get the stage pole of the stage rotation.</span>
            <span class="c1"># Note that the stage rotation is already in frame of</span>
            <span class="c1"># reference of the *reconstructed* geometry at the spreading time.</span>
            <span class="n">stage_pole</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stage_rotation</span><span class="o">.</span><span class="n">get_euler_pole_and_angle</span><span class="p">()</span>

            <span class="c1"># One way rotates left and the other right, but don&#39;t know</span>
            <span class="c1"># which - doesn&#39;t matter in our example though.</span>
            <span class="n">rotate_slightly_off_mor_one_way</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span>
                <span class="n">stage_pole</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">rotate_slightly_off_mor_opposite_way</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">rotate_slightly_off_mor_one_way</span><span class="o">.</span><span class="n">get_inverse</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="c1"># Iterate over the shared sub-segments.</span>
            <span class="k">for</span> <span class="n">shared_sub_segment</span> <span class="ow">in</span> <span class="n">shared_boundary_section</span><span class="o">.</span><span class="n">get_shared_sub_segments</span><span class="p">():</span>
                <span class="c1"># Tessellate MOR section.</span>
                <span class="n">mor_points</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span>
                    <span class="n">shared_sub_segment</span><span class="o">.</span><span class="n">get_resolved_geometry</span><span class="p">()</span><span class="o">.</span><span class="n">to_tessellated</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ridge_sampling</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="n">mor_points</span><span class="o">.</span><span class="n">to_lat_lon_list</span><span class="p">()</span>
                <span class="n">lats</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
                <span class="n">lons</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
                <span class="n">boundary_feature</span> <span class="o">=</span> <span class="n">shared_boundary_section</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span>
                <span class="n">left_plate</span> <span class="o">=</span> <span class="n">boundary_feature</span><span class="o">.</span><span class="n">get_left_plate</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">right_plate</span> <span class="o">=</span> <span class="n">boundary_feature</span><span class="o">.</span><span class="n">get_right_plate</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">left_plate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">right_plate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Get the spreading rates for all points in this sub segment</span>
                    <span class="p">(</span>
                        <span class="n">spreading_rates</span><span class="p">,</span>
                        <span class="n">_</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">calculate_spreading_rates</span><span class="p">(</span>
                        <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                        <span class="n">lons</span><span class="o">=</span><span class="n">lons</span><span class="p">,</span>
                        <span class="n">lats</span><span class="o">=</span><span class="n">lats</span><span class="p">,</span>
                        <span class="n">left_plates</span><span class="o">=</span><span class="p">[</span><span class="n">left_plate</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span>
                        <span class="n">right_plates</span><span class="o">=</span><span class="p">[</span><span class="n">right_plate</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span>
                        <span class="n">rotation_model</span><span class="o">=</span><span class="n">rotation_model</span><span class="p">,</span>
                        <span class="n">delta_time</span><span class="o">=</span><span class="n">delta_time</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">spreading_rates</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>

                <span class="c1"># Loop through all but the 1st and last points in the current sub segment</span>
                <span class="k">for</span> <span class="n">point</span><span class="p">,</span> <span class="n">rate</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">mor_points</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">spreading_rates</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="p">):</span>
                    <span class="c1"># Add the point &quot;twice&quot; to the main shifted_mor_points list; once for a L-side</span>
                    <span class="c1"># spread, another for a R-side spread. Then add the same spreading rate twice</span>
                    <span class="c1"># to the list - this therefore assumes spreading rate is symmetric.</span>
                    <span class="n">shifted_mor_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotate_slightly_off_mor_one_way</span> <span class="o">*</span> <span class="n">point</span><span class="p">)</span>
                    <span class="n">shifted_mor_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">rotate_slightly_off_mor_opposite_way</span> <span class="o">*</span> <span class="n">point</span>
                    <span class="p">)</span>
                    <span class="n">point_spreading_rates</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">rate</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># save the middle ocean ridges points to .pkl file</span>
    <span class="n">lats_lons</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">())</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">shifted_mor_points</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lats_lons</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;SPREADING_RATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">point_spreading_rates</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="n">mor_fn</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">get_debug_level</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="c1"># Summarising get_isochrons_for_ridge_snapshot;</span>
        <span class="c1"># Write out the ridge point born at &#39;ridge_time&#39; but their position at &#39;ridge_time - time_step&#39;.</span>
        <span class="n">mor_point_features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">curr_point</span> <span class="ow">in</span> <span class="n">shifted_mor_points</span><span class="p">:</span>
            <span class="n">feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="p">()</span>
            <span class="n">feature</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">curr_point</span><span class="p">)</span>
            <span class="n">feature</span><span class="o">.</span><span class="n">set_valid_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="o">-</span><span class="mi">999</span><span class="p">)</span>  <span class="c1"># delete - time_step</span>
            <span class="n">mor_point_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>

        <span class="n">mor_points</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">mor_point_features</span><span class="p">)</span>

        <span class="c1"># Write MOR points at `time` to gpmlz</span>
        <span class="n">mor_points</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">mor_fn</span><span class="p">),</span> <span class="n">MOR_GPMLZ_FILE_NAME</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># write zvalue spreading rates to file point_data_dataframe_{time}Ma.npz</span>
        <span class="n">_collect_point_data_in_dataframe</span><span class="p">(</span>
            <span class="n">zvalues_file_basepath</span><span class="p">,</span> <span class="n">mor_points</span><span class="p">,</span> <span class="n">zval_names</span><span class="p">,</span> <span class="n">point_spreading_rates</span><span class="p">,</span> <span class="n">time</span>
        <span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished building MOR seedpoints at </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2"> Ma!&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_collect_point_data_in_dataframe</span><span class="p">(</span>
    <span class="n">zvalues_file_basepath</span><span class="p">,</span> <span class="n">feature_collection</span><span class="p">,</span> <span class="n">zval_names</span><span class="p">,</span> <span class="n">zval_ndarray</span><span class="p">,</span> <span class="n">time</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;At a given timestep, create a pandas dataframe holding all attributes of point features.</span>

<span class="sd">    Rather than store z values as shapefile attributes, store them in a dataframe indexed by feature ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Turn the zval_ndarray into a numPy array</span>
    <span class="n">zval_ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zval_ndarray</span><span class="p">)</span>

    <span class="c1"># Prepare the zval ndarray (can be of any shape) to be saved with default point data</span>
    <span class="n">zvals_to_store</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># If only one zvalue (for now, spreading rate)</span>
    <span class="k">if</span> <span class="n">zval_ndarray</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">zvals_to_store</span><span class="p">[</span><span class="n">zval_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">zval_ndarray</span>
        <span class="n">data_to_store</span> <span class="o">=</span> <span class="p">[</span><span class="n">zvals_to_store</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">zvals_to_store</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">zval_ndarray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">zvals_to_store</span><span class="p">[</span><span class="n">zval_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zval_ndarray</span><span class="p">)][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">data_to_store</span> <span class="o">=</span> <span class="p">[</span><span class="n">zvals_to_store</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">zvals_to_store</span><span class="p">]</span>

    <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span>
        <span class="n">zvalues_file_basepath</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">),</span>
        <span class="n">FEATURE_ID</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">get_feature_id</span><span class="p">())</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">feature_collection</span><span class="p">],</span>
        <span class="o">*</span><span class="n">data_to_store</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, The University of Sydney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>