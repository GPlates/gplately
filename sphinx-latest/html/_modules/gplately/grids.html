

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gplately.grids &mdash; gplately 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            gplately
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basic_usages.html">Minimal working example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../use_cases.html">Common Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Trouble-shooting and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../command_line_interface.html">Command Line Interface (CLI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primer.html">Primer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Main Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../secondaries.html">Other Classes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">gplately</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gplately.grids</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gplately.grids</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">#    Copyright (C) 2024 The University of Sydney, Australia</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1">#    the terms of the GNU General Public License, version 2, as published by</span>
<span class="c1">#    the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c1">#    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c1">#    for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License along</span>
<span class="c1">#    with this program; if not, write to Free Software Foundation, Inc.,</span>
<span class="c1">#    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This sub-module contains tools for working with MaskedArray, ndarray and netCDF4 rasters, as well as</span>
<span class="sd">gridded-data.</span>

<span class="sd">Some methods available in `grids`:</span>

<span class="sd">* Point data can be interpolated onto a raster or grid with Scipy using linear or</span>
<span class="sd">nearest-neighbour interpolation.</span>
<span class="sd">* Rasters can be resampled with a set of X and Y-direction spacings, and can be resized</span>
<span class="sd">using given X and Y resolutions.</span>
<span class="sd">* Grids with invalid (NaN-type) data cells can have their NaN entries replaced</span>
<span class="sd">with the values of their nearest valid neighbours.</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">* RegularGridInterpolator</span>
<span class="sd">* Raster</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">cpu_count</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.colors</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">netCDF4</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pygplates</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cartopy.crs</span><span class="w"> </span><span class="kn">import</span> <span class="n">PlateCarree</span> <span class="k">as</span> <span class="n">_PlateCarree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cartopy.mpl.geoaxes</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeoAxes</span> <span class="k">as</span> <span class="n">_GeoAxes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.enums</span><span class="w"> </span><span class="kn">import</span> <span class="n">MergeAlg</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.features</span><span class="w"> </span><span class="kn">import</span> <span class="n">rasterize</span> <span class="k">as</span> <span class="n">_rasterize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_bounds</span> <span class="k">as</span> <span class="n">_from_bounds</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">RegularGridInterpolator</span> <span class="k">as</span> <span class="n">_RGI</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">griddata</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.ndimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance_transform_edt</span><span class="p">,</span> <span class="n">map_coordinates</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">cKDTree</span> <span class="k">as</span> <span class="n">_cKDTree</span>  <span class="c1"># type: ignore</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">_Rotation</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">pygplates_to_shapely</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.reconstruction</span><span class="w"> </span><span class="kn">import</span> <span class="n">PlateReconstruction</span> <span class="k">as</span> <span class="n">_PlateReconstruction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">_deg2pixels</span><span class="p">,</span> <span class="n">griddata_sphere</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;gplately&quot;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;fill_raster&quot;</span><span class="p">,</span>
    <span class="s2">&quot;read_netcdf_grid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;write_netcdf_grid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RegularGridInterpolator&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sample_grid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;reconstruct_grid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rasterise&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rasterize&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Raster&quot;</span><span class="p">,</span>
    <span class="c1"># &quot;TimeRaster&quot;,</span>
<span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">fill_raster</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Search a grid of ``data`` for invalid cells (i.e NaN-type entries) and fill each</span>
<span class="sd">    invalid cell with the value of its nearest valid neighbour.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Uses scipy&#39;s ``distance_transform_edt`` function to perform an Exact Euclidean</span>
<span class="sd">        Distance Transform (EEDT). This locates the nearest valid neighbours of an invalid</span>
<span class="sd">        ``data`` cell.</span>

<span class="sd">        An optional parameter, ``invalid``, is a binary ndarray with the same dimensions</span>
<span class="sd">        as ``data`` and the following entries:</span>

<span class="sd">        * 1 if its corresponding entry in ``data`` is of NaN-type;</span>
<span class="sd">        * 0 if not NaN-type</span>

<span class="sd">        This will be used to locate nearest neighbour fill values during the Exact Euclidian</span>
<span class="sd">        Distance Transform. If ``invalid`` is not passed to ``fill_raster``, it will be created</span>
<span class="sd">        for the user.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : MaskedArray</span>
<span class="sd">        A MaskedArray of data that may have invalid cells (i.e. entries of type NaN).</span>

<span class="sd">    invalid : ndarray, optional, default=None</span>
<span class="sd">        An ndarray with the same shape as ``data`` whose elements are 1 if its corresponding</span>
<span class="sd">        elements in ``data`` are of type ``NaN``, and 0 if its corresponding entries in ``data``</span>
<span class="sd">        are valid. An optional parameter - this will be created for the user if it isn&#39;t</span>
<span class="sd">        provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        An updated ``data`` array where each invalid cell has been replaced with the value</span>
<span class="sd">        of its nearest valid neighbour.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">masked_array</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;fill_value&quot;</span><span class="p">)</span>
    <span class="n">mask_fill_value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">masked_array</span><span class="p">:</span>
        <span class="n">mask_fill_value</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">fill_value</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="n">mask_fill_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">invalid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">masked_array</span><span class="p">:</span>
            <span class="n">invalid</span> <span class="o">+=</span> <span class="n">mask_fill_value</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">invalid</span><span class="p">,</span> <span class="n">return_distances</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_realign_grid</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;realigns grid to -180/180 and flips the array if the latitudinal coordinates are decreasing.&quot;&quot;&quot;</span>
    <span class="n">mask_lons</span> <span class="o">=</span> <span class="n">lons</span> <span class="o">&gt;</span> <span class="mi">180</span>

    <span class="c1"># realign to -180/180</span>
    <span class="k">if</span> <span class="n">mask_lons</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">dlon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">array</span><span class="p">[:,</span> <span class="n">mask_lons</span><span class="p">],</span> <span class="n">array</span><span class="p">[:,</span> <span class="o">~</span><span class="n">mask_lons</span><span class="p">]])</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">lons</span><span class="p">[</span><span class="n">mask_lons</span><span class="p">]</span> <span class="o">-</span> <span class="mi">360</span> <span class="o">-</span> <span class="n">dlon</span><span class="p">,</span> <span class="n">lons</span><span class="p">[</span><span class="o">~</span><span class="n">mask_lons</span><span class="p">]])</span>

    <span class="k">if</span> <span class="n">lats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_guess_data_variable_name</span><span class="p">(</span><span class="n">cdf</span><span class="p">:</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">x_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>  <span class="c1"># type: ignore</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;best effort to find out the data variable name&quot;&quot;&quot;</span>
    <span class="nb">vars</span> <span class="o">=</span> <span class="n">cdf</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">cdf</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># only consider two-dimensional data</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y_name</span> <span class="ow">and</span> <span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x_name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">var</span>
    <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="read_netcdf_grid">
<a class="viewcode-back" href="../../generated/gplately.grids.read_netcdf_grid.html#gplately.read_netcdf_grid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_netcdf_grid</span><span class="p">(</span>
    <span class="n">filename</span><span class="p">,</span>
    <span class="n">return_grids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">realign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">resample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">resize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x_dimension_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">y_dimension_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">data_variable_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read a `netCDF` (.nc) grid from a given `filename` and return its data as a</span>
<span class="sd">    `MaskedArray`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If a `resample` tuple is passed with X and Y spacings (`spacingX`, `spacingY`),</span>
<span class="sd">    the gridded data in `filename` will be resampled with these resolutions.</span>

<span class="sd">    By default, only the `MaskedArray` is returned to the user. However, if `return_grids` is</span>
<span class="sd">    set to `True`, the `MaskedArray` will be returned along with two additional arrays</span>
<span class="sd">    in a `tuple`:</span>

<span class="sd">    * A 1d `MaskedArray` containing the longitudes of the `netCDF` gridded data</span>
<span class="sd">    * A 1d `MaskedArray` containing the latitudes of the `netCDF` gridded data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Full path to the `netCDF` raster file.</span>

<span class="sd">    return_grids : bool, optional, default=False</span>
<span class="sd">        If set to `True`, returns lon, lat arrays associated with the grid data.</span>

<span class="sd">    realign : bool, optional, default=False</span>
<span class="sd">        if set to `True`, realigns grid to -180/180 and flips the array if the</span>
<span class="sd">        latitudinal coordinates are decreasing.</span>

<span class="sd">    resample : tuple, optional, default=None</span>
<span class="sd">        If passed as `resample = (spacingX, spacingY)`, the given `netCDF` grid is resampled</span>
<span class="sd">        with these x and y resolutions.</span>

<span class="sd">    resize : tuple, optional, default=None</span>
<span class="sd">        If passed as `resample = (resX, resY)`, the given `netCDF` grid is resized</span>
<span class="sd">        to the number of columns (resX) and rows (resY).</span>

<span class="sd">    x_dimension_name : str, optional, default=&quot;&quot;</span>
<span class="sd">        If the grid file uses comman names, such as &quot;x&quot;, &quot;lon&quot;, &quot;lons&quot; or &quot;longitude&quot;, you need not set this parameter.</span>
<span class="sd">        Otherwise, you need to tell us what the x dimension name is.</span>

<span class="sd">    y_dimension_name : str, optional, default=&quot;&quot;</span>
<span class="sd">        If the grid file uses comman names, such as &quot;y&quot;, &quot;lat&quot;, &quot;lats&quot; or &quot;latitude&quot;, you need not set this parameter.</span>
<span class="sd">        Otherwise, you need to tell us what the y dimension name is.</span>

<span class="sd">    data_variable_name : str, optional, default=&quot;&quot;</span>
<span class="sd">        The program will try its best to determine the data variable name.</span>
<span class="sd">        However, it would be better if you could tell us what the data variable name is.</span>
<span class="sd">        Otherwise, the program will guess. The result may/may not be correct.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grid_z : MaskedArray</span>
<span class="sd">        A `MaskedArray` containing the gridded data from the supplied netCDF4 `filename`.</span>
<span class="sd">        Entries&#39; longitudes are re-aligned between -180 and 180 degrees.</span>

<span class="sd">    lon, lat : 1d MaskedArrays</span>
<span class="sd">        `MaskedArrays` encasing longitude and latitude variables belonging to the</span>
<span class="sd">        supplied netCDF4 file. Longitudes are rescaled between -180 and 180 degrees.</span>
<span class="sd">        An example output of `cdf_lat` is:</span>

<span class="sd">            masked_array(data=[-90. , -89.9, -89.8, ...,  89.8,  89.9,  90. ], mask=False, fill_value=1e+20)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find_label</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">label</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># possible permutations of lon/lat/z</span>
    <span class="n">label_lon</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;lons&quot;</span><span class="p">,</span> <span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;east&quot;</span><span class="p">,</span> <span class="s2">&quot;easting&quot;</span><span class="p">,</span> <span class="s2">&quot;eastings&quot;</span><span class="p">]</span>
    <span class="n">label_lat</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lats&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;north&quot;</span><span class="p">,</span> <span class="s2">&quot;northing&quot;</span><span class="p">,</span> <span class="s2">&quot;northings&quot;</span><span class="p">]</span>
    <span class="n">label_z</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="s2">&quot;Band1&quot;</span><span class="p">,</span> <span class="s2">&quot;__xarray_dataarray_variable__&quot;</span><span class="p">]</span>

    <span class="c1"># add capitalise and upper case permutations</span>
    <span class="n">label_lon</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">label_lon</span>
        <span class="o">+</span> <span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_lon</span><span class="p">]</span>
        <span class="o">+</span> <span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_lon</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">label_lat</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">label_lat</span>
        <span class="o">+</span> <span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_lat</span><span class="p">]</span>
        <span class="o">+</span> <span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_lat</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">label_z</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">label_z</span>
        <span class="o">+</span> <span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_z</span><span class="p">]</span>
        <span class="o">+</span> <span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_z</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># open netCDF file and re-align from -180, 180 degrees</span>
    <span class="k">with</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cdf</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">cdf</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># find the names of variables</span>
        <span class="k">if</span> <span class="n">data_variable_name</span><span class="p">:</span>
            <span class="n">key_z</span> <span class="o">=</span> <span class="n">data_variable_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key_z</span> <span class="o">=</span> <span class="n">find_label</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">label_z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_dimension_name</span><span class="p">:</span>
            <span class="n">key_lon</span> <span class="o">=</span> <span class="n">x_dimension_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key_lon</span> <span class="o">=</span> <span class="n">find_label</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">label_lon</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y_dimension_name</span><span class="p">:</span>
            <span class="n">key_lat</span> <span class="o">=</span> <span class="n">y_dimension_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key_lat</span> <span class="o">=</span> <span class="n">find_label</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">label_lat</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key_lon</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key_lat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot find x,y or lon/lat coordinates in netcdf. The dimensions in the file are </span><span class="si">{</span><span class="n">cdf</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">key_z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key_z</span> <span class="o">=</span> <span class="n">_guess_data_variable_name</span><span class="p">(</span><span class="n">cdf</span><span class="p">,</span> <span class="n">key_lon</span><span class="p">,</span> <span class="n">key_lat</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key_z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot find z data in netcdf. The variables in the file are </span><span class="si">{</span><span class="n">cdf</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># extract data from cdf variables</span>
        <span class="c1"># TODO: the dimensions of data may not be (lat, lon). It is possible(but unlikely?) that the dimensions are(lon, lat).</span>
        <span class="c1"># just note you may need numpy.swapaxes() here.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cdf</span><span class="p">[</span><span class="n">key_z</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The data in the netcdf file is not two-dimensional. This function can only handle two-dimensional data.&quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;The dimensions in the file are </span><span class="si">{</span><span class="n">cdf</span><span class="p">[</span><span class="n">key_z</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">cdf_grid</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">[</span><span class="n">key_z</span><span class="p">][:]</span>
        <span class="n">cdf_lon</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">[</span><span class="n">key_lon</span><span class="p">][:]</span>
        <span class="n">cdf_lat</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">[</span><span class="n">key_lat</span><span class="p">][:]</span>

        <span class="c1"># fill missing values</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cdf</span><span class="p">[</span><span class="n">key_z</span><span class="p">],</span> <span class="s2">&quot;missing_value&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span>
            <span class="n">cdf_grid</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span>
        <span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">[</span><span class="n">key_z</span><span class="p">]</span><span class="o">.</span><span class="n">missing_value</span>
            <span class="n">cdf_grid</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">cdf_grid</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># convert to boolean array</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">cdf_grid</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">unique_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cdf_grid</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unique_grid</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">cdf_grid</span> <span class="o">=</span> <span class="n">cdf_grid</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">realign</span><span class="p">:</span>
        <span class="c1"># realign longitudes to -180/180 dateline</span>
        <span class="n">cdf_grid_z</span><span class="p">,</span> <span class="n">cdf_lon</span><span class="p">,</span> <span class="n">cdf_lat</span> <span class="o">=</span> <span class="n">_realign_grid</span><span class="p">(</span><span class="n">cdf_grid</span><span class="p">,</span> <span class="n">cdf_lon</span><span class="p">,</span> <span class="n">cdf_lat</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cdf_grid_z</span> <span class="o">=</span> <span class="n">cdf_grid</span>

    <span class="c1"># resample</span>
    <span class="k">if</span> <span class="n">resample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spacingX</span><span class="p">,</span> <span class="n">spacingY</span> <span class="o">=</span> <span class="n">resample</span>

        <span class="c1"># don&#39;t resample if already the same resolution</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cdf_lon</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">dY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cdf_lat</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">spacingX</span> <span class="o">!=</span> <span class="n">dX</span> <span class="ow">or</span> <span class="n">spacingY</span> <span class="o">!=</span> <span class="n">dY</span><span class="p">:</span>
            <span class="n">lon_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cdf_lon</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">cdf_lon</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">spacingX</span><span class="p">,</span> <span class="n">spacingX</span><span class="p">)</span>
            <span class="n">lat_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cdf_lat</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">cdf_lat</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">spacingY</span><span class="p">,</span> <span class="n">spacingY</span><span class="p">)</span>
            <span class="n">lonq</span><span class="p">,</span> <span class="n">latq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">lon_grid</span><span class="p">,</span> <span class="n">lat_grid</span><span class="p">)</span>
            <span class="n">original_extent</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cdf_lon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">cdf_lon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">cdf_lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">cdf_lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">cdf_grid_z</span> <span class="o">=</span> <span class="n">sample_grid</span><span class="p">(</span>
                <span class="n">lonq</span><span class="p">,</span>
                <span class="n">latq</span><span class="p">,</span>
                <span class="n">cdf_grid_z</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="n">original_extent</span><span class="p">,</span>
                <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">cdf_lon</span> <span class="o">=</span> <span class="n">lon_grid</span>
            <span class="n">cdf_lat</span> <span class="o">=</span> <span class="n">lat_grid</span>

    <span class="c1"># resize</span>
    <span class="k">if</span> <span class="n">resize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">resX</span><span class="p">,</span> <span class="n">resY</span> <span class="o">=</span> <span class="n">resize</span>

        <span class="c1"># don&#39;t resize if already the same shape</span>
        <span class="k">if</span> <span class="n">resX</span> <span class="o">!=</span> <span class="n">cdf_grid_z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">resY</span> <span class="o">!=</span> <span class="n">cdf_grid_z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">original_extent</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cdf_lon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">cdf_lon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">cdf_lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">cdf_lat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">lon_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">original_extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">original_extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">resX</span><span class="p">)</span>
            <span class="n">lat_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">original_extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">original_extent</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">resY</span><span class="p">)</span>
            <span class="n">lonq</span><span class="p">,</span> <span class="n">latq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">lon_grid</span><span class="p">,</span> <span class="n">lat_grid</span><span class="p">)</span>

            <span class="n">cdf_grid_z</span> <span class="o">=</span> <span class="n">sample_grid</span><span class="p">(</span>
                <span class="n">lonq</span><span class="p">,</span>
                <span class="n">latq</span><span class="p">,</span>
                <span class="n">cdf_grid_z</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="n">original_extent</span><span class="p">,</span>
                <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">cdf_lon</span> <span class="o">=</span> <span class="n">lon_grid</span>
            <span class="n">cdf_lat</span> <span class="o">=</span> <span class="n">lat_grid</span>

    <span class="c1"># Fix grids with 9e36 as the fill value for nan.</span>
    <span class="c1"># cdf_grid_z.fill_value = float(&#39;nan&#39;)</span>
    <span class="c1"># cdf_grid_z.data[cdf_grid_z.data &gt; 1e36] = cdf_grid_z.fill_value</span>

    <span class="k">if</span> <span class="n">return_grids</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cdf_grid_z</span><span class="p">,</span> <span class="n">cdf_lon</span><span class="p">,</span> <span class="n">cdf_lat</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cdf_grid_z</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">write_netcdf_grid</span><span class="p">(</span>
    <span class="n">filename</span><span class="p">,</span>
    <span class="n">grid</span><span class="p">,</span>
    <span class="n">extent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span>
    <span class="n">significant_digits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write geological data contained in a `grid` to a netCDF4 grid with a specified `filename`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The written netCDF4 grid has the same latitudinal and longitudinal (row and column) dimensions as `grid`.</span>
<span class="sd">    It has three variables:</span>

<span class="sd">    * Latitudes of `grid` data</span>
<span class="sd">    * Longitudes of `grid` data</span>
<span class="sd">    * The data stored in `grid`</span>

<span class="sd">    However, the latitudes and longitudes of the grid returned to the user are constrained to those</span>
<span class="sd">    specified in `extent`.</span>
<span class="sd">    By default, `extent` assumes a global latitudinal and longitudinal span: `extent=[-180,180,-90,90]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        The full path (including a filename and the &quot;.nc&quot; extension) to save the created netCDF4 `grid` to.</span>

<span class="sd">    grid : array-like</span>
<span class="sd">        An ndarray grid containing data to be written into a `netCDF` (.nc) file. Note: Rows correspond to</span>
<span class="sd">        the data&#39;s latitudes, while the columns correspond to the data&#39;s longitudes.</span>

<span class="sd">    extent : list, default=[-180,180,-90,90]</span>
<span class="sd">        Four elements that specify the [min lon, max lon, min lat, max lat] to constrain the lat and lon</span>
<span class="sd">        variables of the netCDF grid to. If no extents are supplied, full global extent `[-180, 180, -90, 90]`</span>
<span class="sd">        is assumed.</span>

<span class="sd">    significant_digits : int</span>
<span class="sd">        Applies lossy data compression up to a specified number of significant digits.</span>
<span class="sd">        This significantly reduces file size, but make sure the required precision is preserved in the</span>
<span class="sd">        saved netcdf file.</span>

<span class="sd">    fill_value : scalar, NoneType, default: np.nan</span>
<span class="sd">        Value used to fill in missing data. By default this is np.nan.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A netCDF grid will be saved to the path specified in `filename`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">netCDF4</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">gplately</span><span class="w"> </span><span class="kn">import</span> <span class="n">__version__</span> <span class="k">as</span> <span class="n">_version</span>

    <span class="k">if</span> <span class="n">extent</span> <span class="o">==</span> <span class="s2">&quot;global&quot;</span><span class="p">:</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;specify the [min lon, max lon, min lat, max lat]&quot;</span>

    <span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="n">lon_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ncols</span><span class="p">)</span>
    <span class="n">lat_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">nrows</span><span class="p">)</span>

    <span class="n">data_kwds</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;compression&quot;</span><span class="p">:</span> <span class="s2">&quot;zlib&quot;</span><span class="p">,</span> <span class="s2">&quot;complevel&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">}</span>

    <span class="k">with</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">as</span> <span class="n">cdf</span><span class="p">:</span>
        <span class="n">cdf</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Grid produced by gplately &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_version</span><span class="p">)</span>
        <span class="n">cdf</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="n">lon_grid</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">cdf</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="n">lat_grid</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">cdf_lon</span> <span class="o">=</span> <span class="n">cdf</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="n">lon_grid</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;lon&quot;</span><span class="p">,),</span> <span class="o">**</span><span class="n">data_kwds</span><span class="p">)</span>
        <span class="n">cdf_lat</span> <span class="o">=</span> <span class="n">cdf</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="n">lat_grid</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,),</span> <span class="o">**</span><span class="n">data_kwds</span><span class="p">)</span>
        <span class="n">cdf_lon</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lon_grid</span>
        <span class="n">cdf_lat</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lat_grid</span>

        <span class="c1"># Units for Geographic Grid type</span>
        <span class="n">cdf_lon</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s2">&quot;degrees_east&quot;</span>
        <span class="n">cdf_lon</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s2">&quot;lon&quot;</span>
        <span class="n">cdf_lon</span><span class="o">.</span><span class="n">actual_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">lon_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lon_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">cdf_lat</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s2">&quot;degrees_north&quot;</span>
        <span class="n">cdf_lat</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s2">&quot;lat&quot;</span>
        <span class="n">cdf_lat</span><span class="o">.</span><span class="n">actual_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">lat_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lat_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># create container variable for CRS: lon/lat WGS84 datum</span>
        <span class="n">crso</span> <span class="o">=</span> <span class="n">cdf</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s2">&quot;crs&quot;</span><span class="p">,</span> <span class="s2">&quot;i4&quot;</span><span class="p">)</span>
        <span class="n">crso</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s2">&quot;Lon/Lat Coords in WGS84&quot;</span>
        <span class="n">crso</span><span class="o">.</span><span class="n">grid_mapping_name</span> <span class="o">=</span> <span class="s2">&quot;latitude_longitude&quot;</span>
        <span class="n">crso</span><span class="o">.</span><span class="n">longitude_of_prime_meridian</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">crso</span><span class="o">.</span><span class="n">semi_major_axis</span> <span class="o">=</span> <span class="mf">6378137.0</span>
        <span class="n">crso</span><span class="o">.</span><span class="n">inverse_flattening</span> <span class="o">=</span> <span class="mf">298.257223563</span>
        <span class="n">crso</span><span class="o">.</span><span class="n">spatial_ref</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;GEOGCS[&quot;WGS 84&quot;,DATUM[&quot;WGS_1984&quot;,SPHEROID[&quot;WGS 84&quot;,6378137,298.257223563,AUTHORITY[&quot;EPSG&quot;,&quot;7030&quot;]],AUTHORITY[&quot;EPSG&quot;,&quot;6326&quot;]],PRIMEM[&quot;Greenwich&quot;,0,AUTHORITY[&quot;EPSG&quot;,&quot;8901&quot;]],UNIT[&quot;degree&quot;,0.01745329251994328,AUTHORITY[&quot;EPSG&quot;,&quot;9122&quot;]],AUTHORITY[&quot;EPSG&quot;,&quot;4326&quot;]]&quot;&quot;&quot;</span>

        <span class="c1"># add more keyword arguments for quantizing data</span>
        <span class="k">if</span> <span class="n">significant_digits</span><span class="p">:</span>
            <span class="c1"># significant_digits needs to be &gt;= 2 so that NaNs are preserved</span>
            <span class="n">data_kwds</span><span class="p">[</span><span class="s2">&quot;significant_digits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">significant_digits</span><span class="p">))</span>
            <span class="n">data_kwds</span><span class="p">[</span><span class="s2">&quot;quantize_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;GranularBitRound&quot;</span>

        <span class="c1"># boolean arrays need to be converted to integers</span>
        <span class="c1"># no such thing as a mask on a boolean array</span>
        <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">bool</span><span class="p">):</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;i1&quot;</span><span class="p">)</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">cdf_data</span> <span class="o">=</span> <span class="n">cdf</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">),</span> <span class="o">**</span><span class="n">data_kwds</span><span class="p">)</span>

        <span class="c1"># netCDF4 uses the missing_value attribute as the default _FillValue</span>
        <span class="c1"># without this, _FillValue defaults to 9.969209968386869e+36</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cdf_data</span><span class="o">.</span><span class="n">missing_value</span> <span class="o">=</span> <span class="n">fill_value</span>
            <span class="n">grid_mask</span> <span class="o">=</span> <span class="n">grid</span> <span class="o">!=</span> <span class="n">fill_value</span>

            <span class="n">cdf_data</span><span class="o">.</span><span class="n">actual_range</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grid_mask</span><span class="p">]),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grid_mask</span><span class="p">]),</span>
            <span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ensure min and max z values are properly registered</span>
            <span class="n">cdf_data</span><span class="o">.</span><span class="n">actual_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">grid</span><span class="p">)]</span>

        <span class="n">cdf_data</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s2">&quot;z&quot;</span>

        <span class="c1"># cdf_data.add_offset = 0.0</span>
        <span class="n">cdf_data</span><span class="o">.</span><span class="n">grid_mapping</span> <span class="o">=</span> <span class="s2">&quot;crs&quot;</span>
        <span class="c1"># cdf_data.set_auto_maskandscale(False)</span>

        <span class="c1"># write data</span>
        <span class="n">cdf_data</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grid</span>


<span class="k">class</span><span class="w"> </span><span class="nc">RegularGridInterpolator</span><span class="p">(</span><span class="n">_RGI</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class to sample gridded data at a set of point coordinates using either linear or nearest-neighbour</span>
<span class="sd">    interpolation methods. It is a child class of `scipy 1.10`&#39;s [`RegularGridInterpolator`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RegularGridInterpolator.html) class.</span>

<span class="sd">    This will only work for scipy version 1.10 onwards.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    points : tuple of ndarrays of float with shapes (m1, ), , (mn, )</span>
<span class="sd">        Each array contains point coordinates that define the regular grid in n dimensions.</span>
<span class="sd">    values : ndarray</span>
<span class="sd">        The data on a regular grid. Note: the number of rows corresponds to the number of point latitudes, while the number</span>
<span class="sd">        of columns corresponds to the number of point longitudes.</span>
<span class="sd">    method : str, default=linear</span>
<span class="sd">        The method of interpolation to perform. Supported are &quot;linear&quot; and &quot;nearest&quot;. Assumes linear by default.</span>
<span class="sd">    bounds_error : bool, default=false</span>
<span class="sd">        Choose whether to return a ValueError and terminate the interpolation if any provided sample points are out</span>
<span class="sd">        of grid bounds. By default, it is set to `False`. In this case, all out-of-bound point values are replaced</span>
<span class="sd">        with the `fill_value` (defined below) if supplied.</span>
<span class="sd">    fill_value : float, default=np.nan</span>
<span class="sd">        Used to replace point values that are out of grid bounds, provided that bounds_error is false.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RegularGridInterpolator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">bounds_error</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_distances</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Samples gridded data at a set of point coordinates. Uses either a linear or nearest-neighbour interpolation `method`.</span>

<span class="sd">        Uses the gridded data specified in the sample_grid method parameter. Note: if any provided sample points are out of</span>
<span class="sd">        grid bounds and a corresponding error message was suppressed (by specifying bounds_error=False), all out-of-bound</span>
<span class="sd">        point values are replaced with the self.fill_value attribute ascribed to the RegularGridInterpolator object (if it</span>
<span class="sd">        exists). Terminates otherwise.</span>

<span class="sd">        This is identical to scipy 1.10&#39;s RGI object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi : ndarray of shape (..., ndim)</span>
<span class="sd">            The coordinates of points to sample the gridded data at.</span>

<span class="sd">        method : str, default=None</span>
<span class="sd">            The method of interpolation to perform. Supported are &quot;linear&quot; and &quot;Nearest&quot;. Assumes linear interpolation</span>
<span class="sd">            if None provided.</span>

<span class="sd">        return_indices : bool, default=False</span>
<span class="sd">            Choose whether to return indices of neighbouring sampling points.</span>

<span class="sd">        return_distances : bool, default=False</span>
<span class="sd">            Choose whether to return normal distances between interpolated points and neighbouring sampling points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output_tuple : tuple of ndarrays</span>
<span class="sd">            The first ndarray in the output tuple holds the interpolated grid data. If sample point distances and indices are</span>
<span class="sd">            required, these are returned as subsequent tuple elements.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * Raised if the string method supplied is not linear or nearest.</span>
<span class="sd">            * Raised if the provided sample points for interpolation (xi) do not have the same dimensions as the supplied grid.</span>
<span class="sd">            * Raised if the provided sample points for interpolation include any point out of grid bounds. Alerts user which</span>
<span class="sd">            dimension (index) the point is located. Only raised if the RegularGridInterpolator attribute bounds_error is set</span>
<span class="sd">            to True. If suppressed, out-of-bound points are replaced with a set fill_value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">method</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Method &#39;</span><span class="si">%s</span><span class="s2">&#39; is not defined&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

        <span class="n">xi</span><span class="p">,</span> <span class="n">xi_shape</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">nans</span><span class="p">,</span> <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_xi</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

        <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_indices</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_linear</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_nearest</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">out_of_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

        <span class="n">interp_output</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xi_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ndim</span><span class="p">:])</span>
        <span class="n">output_tuple</span> <span class="o">=</span> <span class="p">[</span><span class="n">interp_output</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
            <span class="n">output_tuple</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_distances</span><span class="p">:</span>
            <span class="n">output_tuple</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm_distances</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_distances</span> <span class="ow">or</span> <span class="n">return_indices</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output_tuple</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_xi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate.interpnd</span><span class="w"> </span><span class="kn">import</span> <span class="n">_ndim_coords_from_arrays</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="c1"># SciPy 1.15 renamed interpnd to _interpnd (see https://github.com/scipy/scipy/pull/21754).</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate._interpnd</span><span class="w"> </span><span class="kn">import</span> <span class="n">_ndim_coords_from_arrays</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">_ndim_coords_from_arrays</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The requested sample points xi have dimension &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> but this &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;RegularGridInterpolator has dimension </span><span class="si">{</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">xi_shape</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xi_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># find nans in input</span>
        <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;One of the requested xi is out of bounds &quot;</span>
                        <span class="s2">&quot;in dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span>
                    <span class="p">)</span>
            <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_out_of_bounds</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xi_shape</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">nans</span><span class="p">,</span> <span class="n">out_of_bounds</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_out_of_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">):</span>
        <span class="c1"># check for out of bounds xi</span>
        <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="c1"># iterate through dimensions</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="n">out_of_bounds</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out_of_bounds</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out_of_bounds</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Index identifier outsourced from scipy 1.9&#39;s</span>
<span class="sd">        RegularGridInterpolator to ensure stable</span>
<span class="sd">        operations with all versions of scipy &gt;1.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find relevant edges between which xi are situated</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># compute distance to lower edge in unity units</span>
        <span class="n">norm_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># iterate through dimensions</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># compute norm_distances, incl length-1 grids,</span>
            <span class="c1"># where `grid[i+1] == grid[i]`</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">norm_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">denom</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">norm_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm_dist</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Linear interpolator outsourced from scipy 1.9&#39;s</span>
<span class="sd">        RegularGridInterpolator to ensure stable</span>
<span class="sd">        operations with all versions of scipy &gt;1.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

        <span class="c1"># slice for broadcasting over trailing dimensions in self.values</span>
        <span class="n">vslice</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>

        <span class="c1"># Compute shifting up front before zipping everything together</span>
        <span class="n">shift_norm_distances</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">yi</span> <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="n">norm_distances</span><span class="p">]</span>
        <span class="n">shift_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="c1"># The formula for linear interpolation in 2d takes the form:</span>
        <span class="c1"># values = self.values[(i0, i1)] * (1 - y0) * (1 - y1) + \</span>
        <span class="c1">#          self.values[(i0, i1 + 1)] * (1 - y0) * y1 + \</span>
        <span class="c1">#          self.values[(i0 + 1, i1)] * y0 * (1 - y1) + \</span>
        <span class="c1">#          self.values[(i0 + 1, i1 + 1)] * y0 * y1</span>
        <span class="c1"># We pair i with 1 - yi (zipped1) and i + 1 with yi (zipped2)</span>
        <span class="n">zipped1</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">shift_norm_distances</span><span class="p">)</span>
        <span class="n">zipped2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shift_indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">)</span>

        <span class="c1"># Take all products of zipped1 and zipped2 and iterate over them</span>
        <span class="c1"># to get the terms in the above formula. This corresponds to iterating</span>
        <span class="c1"># over the vertices of a hypercube.</span>
        <span class="n">hypercube</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="n">zipped1</span><span class="p">,</span> <span class="n">zipped2</span><span class="p">))</span>
        <span class="n">values</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hypercube</span><span class="p">:</span>
            <span class="n">edge_indices</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">*=</span> <span class="n">w</span>
            <span class="n">values</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">])</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">vslice</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate_nearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Nearest neighbour interpolator outsourced from scipy 1.9&#39;s</span>
<span class="sd">        RegularGridInterpolator to ensure stable</span>
<span class="sd">        operations with all versions of scipy &gt;1.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx_res</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yi</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_res</span><span class="p">)]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sample_grid</span><span class="p">(</span>
    <span class="n">lon</span><span class="p">,</span>
    <span class="n">lat</span><span class="p">,</span>
    <span class="n">grid</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
    <span class="n">extent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span>
    <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample point data with given `lon` and `lat` coordinates onto a `grid`</span>
<span class="sd">    using spline interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lon, lat : array_like</span>
<span class="sd">        The longitudes and latitudes of the points to interpolate onto the</span>
<span class="sd">        gridded data. Must be broadcastable to a common shape.</span>
<span class="sd">    grid : Raster or array_like</span>
<span class="sd">        An array whose elements define a grid. The number of rows corresponds</span>
<span class="sd">        to the number of point latitudes, while the number of columns</span>
<span class="sd">        corresponds to the number of point longitudes.</span>
<span class="sd">    method : str or int; default: &#39;linear&#39;</span>
<span class="sd">        The order of spline interpolation. Must be an integer in the range</span>
<span class="sd">        0-5. &#39;nearest&#39;, &#39;linear&#39;, and &#39;cubic&#39; are aliases for 0, 1, and 3,</span>
<span class="sd">        respectively.</span>
<span class="sd">    extent : str or 4-tuple, default: &#39;global&#39;</span>
<span class="sd">        4-tuple to specify (min_lon, max_lon, min_lat, max_lat) extents</span>
<span class="sd">        of the raster. If no extents are supplied, full global extent</span>
<span class="sd">        [-180,180,-90,90] is assumed (equivalent to `extent=&#39;global&#39;`).</span>
<span class="sd">        For array data with an upper-left origin, make sure `min_lat` is</span>
<span class="sd">        greater than `max_lat`, or specify `origin` parameter.</span>
<span class="sd">    origin : {&#39;lower&#39;, &#39;upper&#39;}, optional</span>
<span class="sd">        When `data` is an array, use this parameter to specify the origin</span>
<span class="sd">        (upper left or lower left) of the data (overriding `extent`).</span>
<span class="sd">    return_indices : bool, default=False</span>
<span class="sd">        Whether to return the row and column indices of the nearest grid</span>
<span class="sd">        points.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The values interpolated at the input points.</span>
<span class="sd">    indices : 2-tuple of numpy.ndarray</span>
<span class="sd">        The i- and j-indices of the nearest grid points to the input</span>
<span class="sd">        points, only present if `return_indices=True`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If an invalid `method` is provided.</span>
<span class="sd">    RuntimeWarning</span>
<span class="sd">        If `lat` contains any invalid values outside of the interval</span>
<span class="sd">        [-90, 90]. Invalid values will be clipped to this interval.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `return_indices` is set to `True`, the nearest array indices</span>
<span class="sd">    are returned as a tuple of arrays, in (i, j) or (lat, lon) format.</span>

<span class="sd">    An example output:</span>

<span class="sd">        # The first array holds the rows of the raster where point data spatially falls near.</span>
<span class="sd">        # The second array holds the columns of the raster where point data spatially falls near.</span>
<span class="sd">        sampled_indices = (array([1019, 1019, 1019, ..., 1086, 1086, 1087]), array([2237, 2237, 2237, ...,  983,  983,  983]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;nearest&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;cubic&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid `method` parameter: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">extent</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">_parse_extent_origin</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_check_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="c1"># Do not wrap from North to South Pole (or vice versa)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">90.0</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Invalid values encountered in lat; clipping to [-90, 90]&quot;</span><span class="p">,</span>
            <span class="ne">RuntimeWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="o">-</span><span class="mf">90.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">)</span>

    <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">grid</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">point_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">lat</span> <span class="o">-</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">dy</span>
    <span class="n">point_j</span> <span class="o">=</span> <span class="p">(</span><span class="n">lon</span> <span class="o">-</span> <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span>

    <span class="n">point_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">point_i</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">point_j</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">interpolated</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">),</span>
            <span class="n">point_coords</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;grid-wrap&quot;</span><span class="p">,</span>
            <span class="n">prefilter</span><span class="o">=</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">interpolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">interpolated</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># ndim(grid) == 3</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">grid</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">interpolated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">interpolated_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
            <span class="n">interpolated_k</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span>
                <span class="n">grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span>
                <span class="n">point_coords</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;grid-wrap&quot;</span><span class="p">,</span>
                <span class="n">prefilter</span><span class="o">=</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">interpolated_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">interpolated_k</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">interpolated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolated_k</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">interpolated_k</span>
        <span class="n">interpolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">interpolated</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">interpolated</span> <span class="o">=</span> <span class="n">interpolated</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">point_i</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">point_j</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">interpolated</span><span class="p">,</span> <span class="n">indices</span>
    <span class="k">return</span> <span class="n">interpolated</span>


<span class="k">def</span><span class="w"> </span><span class="nf">reconstruct_grid</span><span class="p">(</span>
    <span class="n">grid</span><span class="p">,</span>
    <span class="n">partitioning_features</span><span class="p">,</span>
    <span class="n">rotation_model</span><span class="p">,</span>
    <span class="n">to_time</span><span class="p">,</span>
    <span class="n">from_time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">extent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span>
    <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x_dimension_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">y_dimension_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">data_variable_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruct a gridded dataset to a given reconstruction time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid : array_like, or str</span>
<span class="sd">        The grid to be reconstructed. If ``grid`` is a filename, it will be</span>
<span class="sd">        loaded using :meth:`gplately.grids.read_netcdf_grid`.</span>
<span class="sd">    partitioning_features : valid argument to pygplates.FeaturesFunctionArgument</span>
<span class="sd">        Features used to partition ``grid`` by plate ID, usually a static</span>
<span class="sd">        polygons file. ``partitioning_features`` may be a single</span>
<span class="sd">        feature (``pygplates.Feature``), a feature collection</span>
<span class="sd">        (``pygplates.FeatureCollection``), a filename (``str``), or a (potentially</span>
<span class="sd">        nested) sequence of any combination of the above types.</span>
<span class="sd">    rotation_model : valid argument to pygplates.RotationModel</span>
<span class="sd">        The rotation model used to reconstruct ``grid``.</span>
<span class="sd">        ``rotation_model`` may be a rotation model object</span>
<span class="sd">        (``pygplates.RotationModel``), a rotation feature collection</span>
<span class="sd">        (``pygplates.FeatureCollection``), a rotation filename</span>
<span class="sd">        (``str``), a rotation feature (``pygplates.Feature``), a sequence of</span>
<span class="sd">        rotation features, or a (potentially nested) sequence of any combination of the above types.</span>
<span class="sd">    to_time : float</span>
<span class="sd">        Time to which ``grid`` will be reconstructed.</span>
<span class="sd">    from_time : float, default 0.0</span>
<span class="sd">        Time from which to reconstruct ``grid``.</span>
<span class="sd">    extent : tuple or &quot;global&quot;, default &quot;global&quot;</span>
<span class="sd">        Extent of ``grid``. Valid arguments are a tuple of</span>
<span class="sd">        the form (xmin, xmax, ymin, ymax), or the string &quot;global&quot;,</span>
<span class="sd">        equivalent to (-180.0, 180.0, -90.0, 90.0).</span>
<span class="sd">    origin : {&quot;upper&quot;, &quot;lower&quot;}, optional</span>
<span class="sd">        Origin of ``grid`` - either lower-left or upper-left. By default,</span>
<span class="sd">        determined from `extent`.</span>
<span class="sd">    fill_value : float, int, or tuple, optional</span>
<span class="sd">        The value to be used for regions outside of ``partitioning_features``</span>
<span class="sd">        at ``to_time``. By default (``fill_value=None``), this value will be</span>
<span class="sd">        determined based on the input.</span>
<span class="sd">    threads : int, default 1</span>
<span class="sd">        Number of threads to use for certain computationally heavy routines.</span>
<span class="sd">    anchor_plate_id : int, optional</span>
<span class="sd">        ID of the anchored plate. By default, reconstructions are made with respect to the</span>
<span class="sd">        default anchor plate ID of ``rotation_model`` if it&#39;s a ``pygplates.RotationModel`` (otherwise zero).</span>
<span class="sd">    x_dimension_name : str, optional, default=&quot;&quot;</span>
<span class="sd">        If the grid file uses comman names, such as &quot;x&quot;, &quot;lon&quot;, &quot;lons&quot; or &quot;longitude&quot;, you need not set this parameter.</span>
<span class="sd">        Otherwise, you need to tell us what the x dimension name is.</span>
<span class="sd">    y_dimension_name : str, optional, default=&quot;&quot;</span>
<span class="sd">        If the grid file uses comman names, such as &quot;y&quot;, &quot;lat&quot;, &quot;lats&quot; or &quot;latitude&quot;, you need not set this parameter.</span>
<span class="sd">        Otherwise, you need to tell us what the y dimension name is.</span>
<span class="sd">    data_variable_name : str, optional, default=&quot;&quot;</span>
<span class="sd">        The program will try its best to determine the data variable name.</span>
<span class="sd">        However, it would be better if you could tell us what the data variable name is.</span>
<span class="sd">        Otherwise, the program will guess. The result may/may not be correct.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The reconstructed grid. Areas for which no plate ID could be</span>
<span class="sd">        determined from ``partitioning_features`` will be filled with</span>
<span class="sd">        ``fill_value``.</span>

<span class="sd">    .. note::</span>

<span class="sd">        For two-dimensional grids, ``fill_value`` should be a single</span>
<span class="sd">        number. The default value will be ``np.nan`` for float or</span>
<span class="sd">        complex types, the minimum value for integer types, and the</span>
<span class="sd">        maximum value for unsigned types.</span>
<span class="sd">        For RGB image grids, ``fill_value`` should be a 3-tuple RGB</span>
<span class="sd">        colour code or a matplotlib colour string. The default value</span>
<span class="sd">        will be black (0.0, 0.0, 0.0) or (0, 0, 0).</span>
<span class="sd">        For RGBA image grids, ``fill_value`` should be a 4-tuple RGBA</span>
<span class="sd">        colour code or a matplotlib colour string. The default fill</span>
<span class="sd">        value will be transparent black (0.0, 0.0, 0.0, 0.0) or</span>
<span class="sd">        (0, 0, 0, 0).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">read_netcdf_grid</span><span class="p">(</span>
                <span class="n">grid</span><span class="p">,</span>
                <span class="n">x_dimension_name</span><span class="o">=</span><span class="n">x_dimension_name</span><span class="p">,</span>
                <span class="n">y_dimension_name</span><span class="o">=</span><span class="n">y_dimension_name</span><span class="p">,</span>
                <span class="n">data_variable_name</span><span class="o">=</span><span class="n">data_variable_name</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># load grid data from file</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>  <span class="c1"># copy grid data to array</span>
    <span class="k">if</span> <span class="n">to_time</span> <span class="o">==</span> <span class="n">from_time</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">grid</span>
    <span class="k">elif</span> <span class="n">rotation_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`rotation_model` must be provided if `to_time` != `from_time`&quot;</span><span class="p">)</span>

    <span class="n">extent</span> <span class="o">=</span> <span class="n">_parse_extent_origin</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threads</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">threads</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">}:</span>
            <span class="n">threads</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid `threads` value: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threads</span><span class="p">))</span>
    <span class="n">threads</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">threads</span><span class="p">),</span> <span class="n">cpu_count</span><span class="p">()])</span>
    <span class="n">threads</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">threads</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">_check_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="c1"># Determine fill_value</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">min</span>
            <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;u&quot;</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># dtype.kind in (&quot;f&quot;, &quot;c&quot;)</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># grid.ndim == 3</span>
            <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">):</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># dtype.kind == &quot;f&quot;</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid fill_value for 2D grid: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;u&quot;</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill_value</span> <span class="o">*</span> <span class="mf">255.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;u1&quot;</span><span class="p">)</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)[:</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="ow">and</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span>
        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="p">):</span>  <span class="c1"># give fill colour maximum alpha value if not specified</span>
        <span class="n">fill_alpha</span> <span class="o">=</span> <span class="mi">255</span> <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">fill_alpha</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Shape mismatch: &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;fill_value size: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
            <span class="o">+</span> <span class="s2">&quot;, grid shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">extent</span>
    <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">partitioning_features</span><span class="p">,</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeaturesFunctionArgument</span><span class="p">):</span>
        <span class="n">partitioning_features</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span>
            <span class="n">partitioning_features</span><span class="o">.</span><span class="n">get_features</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">partitioning_features</span><span class="p">,</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">):</span>
        <span class="n">partitioning_features</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">FeaturesFunctionArgument</span><span class="p">(</span><span class="n">partitioning_features</span><span class="p">)</span><span class="o">.</span><span class="n">get_features</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotation_model</span><span class="p">,</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">):</span>
        <span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">rotation_model</span><span class="p">)</span>

    <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
    <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
    <span class="n">m_lons</span><span class="p">,</span> <span class="n">m_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>

    <span class="n">valid_partitioning_features</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">partitioning_features</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_valid_at_time</span><span class="p">(</span><span class="n">from_time</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">is_valid_at_time</span><span class="p">(</span><span class="n">to_time</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">plate_ids</span> <span class="o">=</span> <span class="n">rasterise</span><span class="p">(</span>
        <span class="n">features</span><span class="o">=</span><span class="n">valid_partitioning_features</span><span class="p">,</span>
        <span class="n">rotation_model</span><span class="o">=</span><span class="n">rotation_model</span><span class="p">,</span>
        <span class="n">key</span><span class="o">=</span><span class="s2">&quot;plate_id&quot;</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="n">from_time</span><span class="p">,</span>
        <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">valid_output_mask</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">rasterise</span><span class="p">(</span>
            <span class="n">features</span><span class="o">=</span><span class="n">valid_partitioning_features</span><span class="p">,</span>
            <span class="n">rotation_model</span><span class="o">=</span><span class="n">rotation_model</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="s2">&quot;plate_id&quot;</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">to_time</span><span class="p">,</span>
            <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">plate_ids</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">valid_m_lons</span> <span class="o">=</span> <span class="n">m_lons</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
    <span class="n">valid_m_lats</span> <span class="o">=</span> <span class="n">m_lats</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
    <span class="n">valid_plate_ids</span> <span class="o">=</span> <span class="n">plate_ids</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">valid_data</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">valid_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">valid_data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">k</span><span class="p">][</span><span class="n">valid_mask</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">output_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">output_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="n">output_lons</span> <span class="o">=</span> <span class="n">m_lons</span><span class="p">[</span><span class="n">valid_output_mask</span><span class="p">]</span>
    <span class="n">output_lats</span> <span class="o">=</span> <span class="n">m_lats</span><span class="p">[</span><span class="n">valid_output_mask</span><span class="p">]</span>

    <span class="n">unique_plate_ids</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">valid_plate_ids</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rotations_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">plate</span> <span class="ow">in</span> <span class="n">unique_plate_ids</span><span class="p">:</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
            <span class="n">to_time</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">to_time</span><span class="p">),</span>
            <span class="n">from_time</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">from_time</span><span class="p">),</span>
            <span class="n">moving_plate_id</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">plate</span><span class="p">),</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses default anchor plate of &#39;rotation_model&#39;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No rotation found for plate ID: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">plate</span><span class="p">))</span>
        <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">get_lat_lon_euler_pole_and_angle_degrees</span><span class="p">()</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">_lat_lon_to_vector</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">rotations_dict</span><span class="p">[</span><span class="n">plate</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span> <span class="o">*</span> <span class="n">angle</span>
    <span class="n">rotations_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rotations_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">unique_plate_ids</span><span class="p">])[</span><span class="n">inv</span><span class="p">]</span>
    <span class="n">combined_rotations</span> <span class="o">=</span> <span class="n">_Rotation</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotations_array</span><span class="p">)</span>

    <span class="n">point_vecs</span> <span class="o">=</span> <span class="n">_lat_lon_to_vector</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">valid_m_lats</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">valid_m_lons</span><span class="p">),</span>
        <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">rotated_vecs</span> <span class="o">=</span> <span class="n">combined_rotations</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">point_vecs</span><span class="p">)</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">_cKDTree</span><span class="p">(</span><span class="n">rotated_vecs</span><span class="p">)</span>
    <span class="n">output_vecs</span> <span class="o">=</span> <span class="n">_lat_lon_to_vector</span><span class="p">(</span>
        <span class="n">output_lats</span><span class="p">,</span>
        <span class="n">output_lons</span><span class="p">,</span>
        <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Compatibility with older versions of SciPy:</span>
    <span class="c1"># &#39;n_jobs&#39; argument was replaced with &#39;workers&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">output_vecs</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">workers</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;Unexpected keyword argument&quot;</span> <span class="ow">in</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="s2">&quot;workers&quot;</span> <span class="ow">in</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">output_vecs</span><span class="p">,</span>
                <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">err</span>

    <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">output_data</span> <span class="o">=</span> <span class="n">valid_data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">output_grid</span><span class="p">[</span><span class="n">valid_output_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">output_data</span> <span class="o">=</span> <span class="n">valid_data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">indices</span><span class="p">]</span>
            <span class="n">output_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">k</span><span class="p">][</span><span class="n">valid_output_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_data</span>

    <span class="k">return</span> <span class="n">output_grid</span>


<span class="k">def</span><span class="w"> </span><span class="nf">rasterise</span><span class="p">(</span>
    <span class="n">features</span><span class="p">,</span>
    <span class="n">rotation_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key</span><span class="o">=</span><span class="s2">&quot;plate_id&quot;</span><span class="p">,</span>
    <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">resx</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">resy</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">extent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span>
    <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">tessellate_degrees</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rasterise GPlates objects at a given reconstruction time.</span>

<span class="sd">    This function is particularly useful for rasterising static polygons</span>
<span class="sd">    to extract a grid of plate IDs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    features : geometries or features</span>
<span class="sd">        `features` may be a single `pygplates.Feature`, a</span>
<span class="sd">        `pygplates.FeatureCollection`, a `str` filename,</span>
<span class="sd">        or a (potentially nested) sequence of any combination of the</span>
<span class="sd">        above types.</span>
<span class="sd">        Alternatively, `features` may also be a sequence of geometry types</span>
<span class="sd">        (`pygplates.GeometryOnSphere` or `pygplates.ReconstructionGeometry`).</span>
<span class="sd">        In this case, `rotation_model` and `time` will be ignored, and</span>
<span class="sd">        `key` must be an array_like of the same length as `features`.</span>
<span class="sd">    rotation_model : valid argument for pygplates.RotationModel, optional</span>
<span class="sd">        `rotation_model` may be a `pygplates.RotationModel`, a rotation</span>
<span class="sd">        feature collection (pygplates.FeatureCollection), a rotation filename</span>
<span class="sd">        (`str`), a rotation feature (`pygplates.Feature`), a sequence of</span>
<span class="sd">        rotation features, or a (potentially nested) sequence of any</span>
<span class="sd">        combination of the above types.</span>
<span class="sd">        Alternatively, if time not given, a rotation model is</span>
<span class="sd">        not usually required.</span>
<span class="sd">    key : str or array_like, default &quot;plate_id&quot;</span>
<span class="sd">        The value used to create the rasterised grid. May be any of</span>
<span class="sd">        the following values:</span>
<span class="sd">        - &quot;plate_id&quot;</span>
<span class="sd">        - &quot;conjugate_plate_id&quot;</span>
<span class="sd">        - &quot;from_age&quot;</span>
<span class="sd">        - &quot;to_age&quot;</span>
<span class="sd">        - &quot;left_plate&quot;</span>
<span class="sd">        - &quot;right_plate&quot;</span>
<span class="sd">        Alternatively, `key` may be a sequence of the same length as</span>
<span class="sd">        `features`.</span>
<span class="sd">    time : float, optional</span>
<span class="sd">        Reconstruction time at which to perform rasterisation. If given,</span>
<span class="sd">        `rotation_model` must also be specified.</span>
<span class="sd">    resx, resy : float, default 1.0</span>
<span class="sd">        Resolution (in degrees) of the rasterised grid.</span>
<span class="sd">    shape : tuple, optional</span>
<span class="sd">        If given, the output grid will have the specified shape,</span>
<span class="sd">        overriding `resx` and `resy`.</span>
<span class="sd">    extent : tuple or &quot;global&quot;, default &quot;global&quot;</span>
<span class="sd">        Extent of the rasterised grid. Valid arguments are a tuple of</span>
<span class="sd">        the form (xmin, xmax, ymin, ymax), or the string &quot;global&quot;,</span>
<span class="sd">        equivalent to (-180.0, 180.0, -90.0, 90.0).</span>
<span class="sd">    origin : {&quot;upper&quot;, &quot;lower&quot;}, optional</span>
<span class="sd">        Origin (upper-left or lower-left) of the output array. By default,</span>
<span class="sd">        determined from `extent`.</span>
<span class="sd">    tessellate_degrees : float, default 0.1</span>
<span class="sd">        Densify pyGPlates geometries to this resolution before conversion.</span>
<span class="sd">        Can be disabled by specifying `tessellate_degrees=None`, but this</span>
<span class="sd">        may provide inaccurate results for low-resolution input geometries.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grid : numpy.ndarray</span>
<span class="sd">        The output array will have the shape specified in `shape`, if given.</span>
<span class="sd">        The origin of the array will be in the lower-left corner of</span>
<span class="sd">        the area specified in `extent`, unless `resx` or `resy` is negative.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If an invalid `key` value is passed.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If `rotation_model` is not supplied and `time` is not `None`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is used by gplately.grids.reconstruct_grids to rasterise</span>
<span class="sd">    static polygons in order to extract their plate IDs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">valid_keys</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;plate_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;conjugate_plate_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;from_age&quot;</span><span class="p">,</span>
        <span class="s2">&quot;to_age&quot;</span><span class="p">,</span>
        <span class="s2">&quot;left_plate&quot;</span><span class="p">,</span>
        <span class="s2">&quot;right_plate&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid key: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">key must be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">valid_keys</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="n">extent</span> <span class="o">=</span> <span class="n">_parse_extent_origin</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">extent</span>

    <span class="k">if</span> <span class="n">minx</span> <span class="o">&gt;</span> <span class="n">maxx</span><span class="p">:</span>
        <span class="n">resx</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">resx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">miny</span> <span class="o">&gt;</span> <span class="n">maxy</span><span class="p">:</span>
        <span class="n">resy</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">resy</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span> <span class="o">+</span> <span class="n">resx</span><span class="p">,</span> <span class="n">resx</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">+</span> <span class="n">resy</span><span class="p">,</span> <span class="n">resy</span><span class="p">)</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">size</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">size</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeaturesFunctionArgument</span><span class="p">(</span><span class="n">features</span><span class="p">)</span><span class="o">.</span><span class="n">get_features</span><span class="p">()</span>
        <span class="n">geometries</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Python argument types in&quot;</span><span class="p">):</span>
            <span class="c1"># Not a Boost.Python.ArgumentError</span>
            <span class="k">raise</span> <span class="n">err</span>
        <span class="n">geometries</span> <span class="o">=</span> <span class="n">pygplates_to_shapely</span><span class="p">(</span>
            <span class="n">features</span><span class="p">,</span>
            <span class="n">tessellate_degrees</span><span class="o">=</span><span class="n">tessellate_degrees</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">reconstructed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">geometries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rotation_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Rotation model must be provided if `time` is not `None`&quot;</span>
                <span class="p">)</span>
            <span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="p">())</span>
            <span class="n">time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeaturesFunctionArgument</span><span class="p">(</span><span class="n">features</span><span class="p">)</span><span class="o">.</span><span class="n">get_features</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="n">pygplates</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
            <span class="n">features</span><span class="p">,</span>
            <span class="n">rotation_model</span><span class="p">,</span>
            <span class="n">reconstructed</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">geometries</span> <span class="o">=</span> <span class="n">pygplates_to_shapely</span><span class="p">(</span>
            <span class="n">reconstructed</span><span class="p">,</span>
            <span class="n">tessellate_degrees</span><span class="o">=</span><span class="n">tessellate_degrees</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometries</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">geometries</span> <span class="o">=</span> <span class="p">[</span><span class="n">geometries</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">values</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">_get_rasterise_values</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">reconstructed</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">geometries</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">geometries</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Shape mismatch: len(key) = </span><span class="si">{}</span><span class="s2">, &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;len(geometries) = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">geometries</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;u&quot;</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unrecognised dtype for `key`: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">_rasterise_geometries</span><span class="p">(</span>
        <span class="n">geometries</span><span class="o">=</span><span class="n">geometries</span><span class="p">,</span>
        <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
        <span class="n">out_shape</span><span class="o">=</span><span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">merge_alg</span><span class="o">=</span><span class="n">MergeAlg</span><span class="o">.</span><span class="n">replace</span><span class="p">,</span>
        <span class="n">transform</span><span class="o">=</span><span class="n">_from_bounds</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_rasterise_values</span><span class="p">(</span>
    <span class="n">key</span><span class="p">,</span>
    <span class="n">reconstructed</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">valid_keys</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;plate_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;conjugate_plate_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;from_age&quot;</span><span class="p">,</span>
        <span class="s2">&quot;to_age&quot;</span><span class="p">,</span>
        <span class="s2">&quot;left_plate&quot;</span><span class="p">,</span>
        <span class="s2">&quot;right_plate&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;plate_id&quot;</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reconstructed</span><span class="p">]</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;conjugate_plate_id&quot;</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_conjugate_plate_id</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reconstructed</span><span class="p">]</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;from_age&quot;</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_valid_time</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reconstructed</span><span class="p">]</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;to_age&quot;</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_valid_time</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reconstructed</span><span class="p">]</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;left_plate&quot;</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_left_plate</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reconstructed</span><span class="p">]</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;right_plate&quot;</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_right_plate</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reconstructed</span><span class="p">]</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid key: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">key must be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">valid_keys</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_rasterise_geometries</span><span class="p">(</span>
    <span class="n">geometries</span><span class="p">,</span>
    <span class="n">values</span><span class="p">,</span>
    <span class="n">out_shape</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">,</span>
    <span class="n">transform</span><span class="p">,</span>
    <span class="n">merge_alg</span><span class="o">=</span><span class="n">MergeAlg</span><span class="o">.</span><span class="n">replace</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">geometries</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">_rasterize</span><span class="p">(</span>
        <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
        <span class="n">out_shape</span><span class="o">=</span><span class="n">out_shape</span><span class="p">,</span>
        <span class="n">fill</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">merge_alg</span><span class="o">=</span><span class="n">merge_alg</span><span class="p">,</span>
        <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>


<span class="n">rasterize</span> <span class="o">=</span> <span class="n">rasterise</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_lat_lon_to_vector</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert (lat, lon) coordinates (degrees or radians) to vectors on</span>
<span class="sd">    the unit sphere. Returns a vector of shape (3,) if `lat` and `lon` are</span>
<span class="sd">    single values, else an array of shape (N, 3) containing N (x, y, z)</span>
<span class="sd">    row vectors, where N is the size of `lat` and `lon`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">degrees</span><span class="p">:</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">z</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_vector_to_lat_lon</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="n">z</span><span class="p">,</span>
    <span class="n">degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert one or more (x, y, z) vectors (on the unit sphere) to</span>
<span class="sd">    (lat, lon) coordinate pairs, in degrees or radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">degrees</span><span class="p">:</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lat</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_array</span><span class="p">:</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">lat</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">lon</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span>

    <span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">lon</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_grid_shape</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check data is a 2D grid or a 3D RGB(A) image.&quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="c1"># ndim == 2: greyscale image/grid</span>
        <span class="c1"># ndim == 3: colour RGB(A) image</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="c1"># shape[2] == 3: colour image (RGB)</span>
        <span class="c1"># shape[2] == 4: colour image w/ transparency (RGBA)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid grid shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_image_values</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check values are within correct range for an RGB(A) image.&quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;u1&quot;</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">min_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for RGB(A) image: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_value</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span> <span class="ow">and</span> <span class="n">max_value</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;u&quot;</span> <span class="ow">and</span> <span class="n">max_value</span> <span class="o">&gt;</span> <span class="mi">255</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for RGB(A) image: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_value</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_grid</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check grid shape and values make sense.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">_check_grid_shape</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># data is an RGB(A) image</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_check_image_values</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_extent_origin</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Default values: extent=&#39;global&#39;, origin=None&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">):</span>  <span class="c1"># i.e. a string</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">extent</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">extent</span> <span class="o">==</span> <span class="s2">&quot;global&quot;</span><span class="p">:</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">180.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">90.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`extent` must be a four-element tuple, &#39;global&#39;, or None&quot;</span><span class="p">)</span>
    <span class="n">extent</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">extent</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span> <span class="ow">and</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span> <span class="ow">and</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">extent</span>


<div class="viewcode-block" id="Raster">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Raster</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The functionalities of :class:`Raster` class include sampling data at points using spline</span>
<span class="sd">    interpolation, resampling rasters with new X and Y-direction spacings and</span>
<span class="sd">    resizing rasters using new X and Y grid pixel resolutions. NaN-type data</span>
<span class="sd">    in rasters can be replaced with the values of their nearest valid neighbours.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Raster.__init__">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plate_reconstruction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span>
        <span class="n">realign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">resample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">resize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_dimension_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">y_dimension_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">data_variable_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor. Create a :class:`Raster` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : str or array-like</span>
<span class="sd">            The raster data, either as a file path (:class:`str`) or array data.</span>

<span class="sd">        plate_reconstruction : PlateReconstruction</span>
<span class="sd">            A :class:`PlateReconstruction` object to provide the following essential components for reconstructing points.</span>

<span class="sd">            * :py:attr:`PlateReconstruction.rotation_model`</span>
<span class="sd">            * :py:attr:`PlateReconstruction.topology_featues`</span>
<span class="sd">            * :py:attr:`PlateReconstruction.static_polygons`</span>

<span class="sd">        extent : str or 4-tuple, default: &#39;global&#39;</span>
<span class="sd">            4-tuple to specify (min_lon, max_lon, min_lat, max_lat) extents</span>
<span class="sd">            of the raster. If no extents are supplied, full global extent</span>
<span class="sd">            (-180, 180, -90, 90) is assumed (equivalent to ``extent=&#39;global&#39;``).</span>
<span class="sd">            For array data with an upper-left origin, make sure ``min_lat`` is</span>
<span class="sd">            greater than ``max_lat``, or specify ``origin`` parameter.</span>

<span class="sd">        resample : 2-tuple, optional</span>
<span class="sd">            Optionally resample grid, pass spacing in X and Y direction as a</span>
<span class="sd">            2-tuple e.g. resample=(spacingX, spacingY).</span>

<span class="sd">        resize : 2-tuple, optional</span>
<span class="sd">            Optionally resample grid to X-columns, Y-rows as a</span>
<span class="sd">            2-tuple e.g. resample=(resX, resY).</span>

<span class="sd">        time : float, default: 0.0</span>
<span class="sd">            The geological time the time-dependant raster data.</span>

<span class="sd">        origin : {&#39;lower&#39;, &#39;upper&#39;}, optional</span>
<span class="sd">            When ``data`` is an array, use this parameter to specify the origin</span>
<span class="sd">            (upper left or lower left) of the data (overriding ``extent``).</span>

<span class="sd">        x_dimension_name : str, optional, default=&quot;&quot;</span>
<span class="sd">            If the grid file uses the comman names, such as ``x``, ``lon``, ``lons`` or ``longitude``,</span>
<span class="sd">            you need not to provide this parameter. Otherwise, you need to tell us what the x dimension name is.</span>

<span class="sd">        y_dimension_name : str, optional, default=&quot;&quot;</span>
<span class="sd">            If the grid file uses the comman names, such as ``y``, ``lat``, ``lats`` or ``latitude``,</span>
<span class="sd">            you need not to provide this parameter. Otherwise, you need to tell us what the y dimension name is.</span>

<span class="sd">        data_variable_name : str, optional, default=&quot;&quot;</span>
<span class="sd">            GPlately will try its best to guess the data variable name.</span>
<span class="sd">            However, it would be much better if you tell us what the data variable name is.</span>
<span class="sd">            Otherwise, GPlately&#39;s guess may/may not be correct.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Handle deprecated arguments such as ``PlateReconstruction_object``, ``filename``, and ``array``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">plate_reconstruction</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_lons</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_lats</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_time</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="s2">&quot;PlateReconstruction_object&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;`PlateReconstruction_object` keyword argument has been &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;deprecated, use `plate_reconstruction` instead&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">plate_reconstruction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plate_reconstruction</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;PlateReconstruction_object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;filename&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="s2">&quot;array&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Both `filename` and `array` were provided; use &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;one or the other, or use the `data` argument&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;filename&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;`filename` keyword argument has been deprecated, &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;use `data` instead&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;filename&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;array&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;`array` keyword argument has been deprecated, &quot;</span> <span class="o">+</span> <span class="s2">&quot;use `data` instead&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Raster.__init__() got an unexpected keyword argument &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span> <span class="o">=</span> <span class="n">plate_reconstruction</span>

        <span class="k">if</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid time: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
        <span class="n">time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">time</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`data` argument (or `filename` or `array`) is required&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Filename</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="n">read_netcdf_grid</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">return_grids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">realign</span><span class="o">=</span><span class="n">realign</span><span class="p">,</span>
                <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span>
                <span class="n">resize</span><span class="o">=</span><span class="n">resize</span><span class="p">,</span>
                <span class="n">x_dimension_name</span><span class="o">=</span><span class="n">x_dimension_name</span><span class="p">,</span>
                <span class="n">y_dimension_name</span><span class="o">=</span><span class="n">y_dimension_name</span><span class="p">,</span>
                <span class="n">data_variable_name</span><span class="o">=</span><span class="n">data_variable_name</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span> <span class="o">=</span> <span class="n">lons</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span> <span class="o">=</span> <span class="n">lats</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># numpy array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">_parse_extent_origin</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_check_grid</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">realign</span><span class="p">:</span>
                <span class="c1"># realign to -180,180 and flip grid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span> <span class="o">=</span> <span class="n">_realign_grid</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">resample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="o">*</span><span class="n">resample</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">resize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="o">*</span><span class="n">resize</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The geological time for the time-dependant raster data.</span>

<span class="sd">        :type: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Array containing the raster data. This attribute can be modified after creating the :class:`Raster` object.</span>

<span class="sd">        :type: ndarray, shape (ny, nx)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Shape mismatch: old dimensions are </span><span class="si">{}</span><span class="s2">, new are </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
                    <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">z</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The x-coordinates of the raster data. This attribute can be modified after creating the :class:`Raster` object.</span>

<span class="sd">        :type: ndarray, shape (nx,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span>

    <span class="nd">@lons</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Shape mismatch: data x-dimension is </span><span class="si">{}</span><span class="s2">, new value is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span> <span class="o">=</span> <span class="n">x</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The y-coordinates of the raster data. This attribute can be modified after creating the :class:`Raster` object.</span>

<span class="sd">        :type: ndarray, shape (ny,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span>

    <span class="nd">@lats</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Shape mismatch: data y-dimension is </span><span class="si">{}</span><span class="s2">, new value is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span> <span class="o">=</span> <span class="n">y</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The spatial extent ``(x0, x1, y0, y1)`` of the data. If not supplied, global extent ``(-180, 180, -90, 90)`` is assumed.</span>

<span class="sd">        If y0 &lt; y1, the origin is the lower-left corner; else the upper-left.</span>

<span class="sd">        :type:  tuple of 4 floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The origin (``lower`` or ``upper``) of the data array.</span>

<span class="sd">        :type: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;lower&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;upper&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shape of the data array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The size of the data array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The data type of the array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of dimensions in the array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">filename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The filename used to create the :class:`Raster` object.</span>
<span class="sd">        If the object was created directly from an array, this attribute is ``None``.</span>

<span class="sd">        :type: str or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plate_reconstruction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A :class:`PlateReconstruction` object to provide the following essential components for reconstructing points.</span>

<span class="sd">            * :py:attr:`PlateReconstruction.rotation_model`</span>
<span class="sd">            * :py:attr:`PlateReconstruction.topology_featues`</span>
<span class="sd">            * :py:attr:`PlateReconstruction.static_polygons`</span>

<span class="sd">        :type: PlateReconstruction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plate_reconstruction</span>

    <span class="nd">@plate_reconstruction</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plate_reconstruction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reconstruction</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">reconstruction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Remove `plate_reconstruction` attribute</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reconstruction</span><span class="p">,</span> <span class="n">_PlateReconstruction</span><span class="p">):</span>
            <span class="c1"># Convert to a `PlateReconstruction` if possible</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">reconstruction</span> <span class="o">=</span> <span class="n">_PlateReconstruction</span><span class="p">(</span><span class="o">*</span><span class="n">reconstruction</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">reconstruction</span> <span class="o">=</span> <span class="n">_PlateReconstruction</span><span class="p">(</span><span class="n">reconstruction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plate_reconstruction</span> <span class="o">=</span> <span class="n">reconstruction</span>

<div class="viewcode-block" id="Raster.copy">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the :class:`Raster` object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Raster</span>
<span class="sd">            A copy of the current :class:`Raster` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Raster</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Raster.interpolate">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.interpolate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interpolate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lons</span><span class="p">,</span>
        <span class="n">lats</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample grid data at a set of points using spline interpolation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lons, lats : array_like</span>
<span class="sd">            The longitudes and latitudes of the points to interpolate onto the</span>
<span class="sd">            gridded data. Must be broadcastable to a common shape.</span>
<span class="sd">        method : str or int; default: &#39;linear&#39;</span>
<span class="sd">            The order of spline interpolation. Must be an integer in the range</span>
<span class="sd">            0-5. ``nearest``, ``linear``, and ``cubic`` are aliases for 0, 1, and 3,</span>
<span class="sd">            respectively.</span>
<span class="sd">        return_indices : bool, default=False</span>
<span class="sd">            Whether to return the row and column indices of the nearest grid</span>
<span class="sd">            points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values interpolated at the input points.</span>
<span class="sd">        indices : 2-tuple of numpy.ndarray</span>
<span class="sd">            The i- and j-indices of the nearest grid points to the input</span>
<span class="sd">            points, only present if ``return_indices=True``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If an invalid ``method`` is provided.</span>
<span class="sd">        RuntimeWarning</span>
<span class="sd">            If ``lats`` contains any invalid values outside of the interval</span>
<span class="sd">            [-90, 90]. Invalid values will be clipped to this interval.</span>


<span class="sd">        .. note::</span>

<span class="sd">            If ``return_indices`` is set to ``True``, the nearest array indices</span>
<span class="sd">            are returned as a tuple of arrays, in ``(i, j)`` or ``(lat, lon)`` format.</span>


<span class="sd">        An example output:</span>

<span class="sd">        .. code:: console</span>

<span class="sd">            # The first array holds the rows of the raster where point data spatially falls near.</span>
<span class="sd">            # The second array holds the columns of the raster where point data spatially falls near.</span>
<span class="sd">            sampled_indices = (array([1019, 1019, 1019, ..., 1086, 1086, 1087]), array([2237, 2237, 2237, ...,  983,  983,  983]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sample_grid</span><span class="p">(</span>
            <span class="n">lon</span><span class="o">=</span><span class="n">lons</span><span class="p">,</span>
            <span class="n">lat</span><span class="o">=</span><span class="n">lats</span><span class="p">,</span>
            <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">return_indices</span><span class="o">=</span><span class="n">return_indices</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Raster.resample">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.resample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spacingX</span><span class="p">,</span> <span class="n">spacingY</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resamples the grid with a new ``spacingX`` and ``spacingY``, meshed with linear interpolation.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Ultimately, the :meth:`resample` changes the lat-lon resolution of the gridded data. The</span>
<span class="sd">            larger the x and y spacings given are, the larger the pixellation of raster data.</span>

<span class="sd">            The :meth:`resample` creates new latitude and longitude arrays with specified spacings in the</span>
<span class="sd">            X and Y directions (``spacingX`` and ``spacingY``). These arrays are linearly interpolated</span>
<span class="sd">            into a new raster. If ``inplace`` is set to ``True``, the respaced latitude array, longitude</span>
<span class="sd">            array and raster will inplace the ones currently attributed to the :class:`Raster` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spacingX, spacingY : ndarray</span>
<span class="sd">            Specify the spacing in the X and Y directions with which to resample. The larger</span>
<span class="sd">            ``spacingX`` and ``spacingY`` are, the larger the raster pixels become (less resolved).</span>
<span class="sd">            Note: to keep the size of the raster consistent, set ``spacingX = spacingY``;</span>
<span class="sd">            otherwise, if for example ``spacingX &gt; spacingY``, the raster will appear stretched</span>
<span class="sd">            longitudinally.</span>

<span class="sd">        method : str or int; default: &#39;linear&#39;</span>
<span class="sd">            The order of spline interpolation. Must be an integer in the range</span>
<span class="sd">            0-5. &#39;nearest&#39;, &#39;linear&#39;, and &#39;cubic&#39; are aliases for 0, 1, and 3,</span>
<span class="sd">            respectively.</span>

<span class="sd">        inplace : bool, default=False</span>
<span class="sd">            Choose to overwrite the data (the ``self.data`` attribute), latitude array</span>
<span class="sd">            (``self.lats``) and longitude array (``self.lons``) currently attributed to the</span>
<span class="sd">            :class:`Raster` object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Raster</span>
<span class="sd">            The resampled grid. If ``inplace`` is set to ``True``, this raster overwrites the</span>
<span class="sd">            one attributed to ``data``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spacingX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spacingX</span><span class="p">)</span>
        <span class="n">spacingY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spacingY</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">spacingY</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">spacingX</span><span class="p">,</span> <span class="n">spacingX</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">spacingY</span><span class="p">,</span> <span class="n">spacingY</span><span class="p">)</span>
        <span class="n">lonq</span><span class="p">,</span> <span class="n">latq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">lonq</span><span class="p">,</span> <span class="n">latq</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span> <span class="o">=</span> <span class="n">lons</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span> <span class="o">=</span> <span class="n">lats</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Raster</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span></div>


<div class="viewcode-block" id="Raster.resize">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.resize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resX</span><span class="p">,</span> <span class="n">resY</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resize the grid with a new resolution (``resX`` and ``resY``) using linear interpolation.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Ultimately, The :meth:`resize` &quot;stretches&quot; a raster in the x and y directions. The larger</span>
<span class="sd">            the resolutions in x and y, the more stretched the raster appears in x and y.</span>

<span class="sd">            It creates new latitude and longitude arrays with specific resolutions in</span>
<span class="sd">            the X and Y directions (``resX`` and ``resY``). These arrays are linearly interpolated</span>
<span class="sd">            into a new raster. If ``inplace`` is set to ``True``, the resized latitude, longitude</span>
<span class="sd">            arrays and raster will inplace the ones currently attributed to the :class:`Raster` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resX, resY : ndarray</span>
<span class="sd">            Specify the resolutions with which to resize the raster. The larger ``resX`` is,</span>
<span class="sd">            the more longitudinally-stretched the raster becomes. The larger ``resY`` is, the</span>
<span class="sd">            more latitudinally-stretched the raster becomes.</span>

<span class="sd">        method : str or int; default: &#39;linear&#39;</span>
<span class="sd">            The order of spline interpolation. Must be an integer in the range</span>
<span class="sd">            0-5. &#39;nearest&#39;, &#39;linear&#39;, and &#39;cubic&#39; are aliases for 0, 1, and 3,</span>
<span class="sd">            respectively.</span>

<span class="sd">        inplace : bool, default=False</span>
<span class="sd">            Choose to overwrite the data (the ``self.data`` attribute), latitude array</span>
<span class="sd">            (``self.lats``) and longitude array (``self.lons``) currently attributed to the</span>
<span class="sd">            :class:`Raster` object.</span>

<span class="sd">        return_array : bool, default False</span>
<span class="sd">            Return a ``numpy.ndarray``, rather than a :class:`Raster` object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Raster</span>
<span class="sd">            The resized grid. If ``inplace`` is set to ``True``, the data in :attr:`Raster.data` will be overwritten.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># construct grid</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">resX</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">resY</span><span class="p">)</span>
        <span class="n">lonq</span><span class="p">,</span> <span class="n">latq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">lonq</span><span class="p">,</span> <span class="n">latq</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span> <span class="o">=</span> <span class="n">lons</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span> <span class="o">=</span> <span class="n">lats</span>
        <span class="k">if</span> <span class="n">return_array</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Raster</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span></div>


<div class="viewcode-block" id="Raster.fill_NaNs">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.fill_NaNs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fill_NaNs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Search for the invalid ``data`` cells containing NaN-type entries and</span>
<span class="sd">        replaces NaNs with the value of the nearest valid data cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        inplace : bool, default=False</span>
<span class="sd">            Choose whether to overwrite the grid currently held in the ``data`` attribute with the filled grid.</span>

<span class="sd">        return_array : bool, default False</span>
<span class="sd">            Return a ``numpy.ndarray``, rather than a :class:`Raster`.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Raster</span>
<span class="sd">            The resized grid. If ``inplace`` is set to ``True``, the data in :attr:`Raster.data` will be overwritten.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">fill_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="n">return_array</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Raster</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span></div>


<div class="viewcode-block" id="Raster.save_to_netcdf4">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.save_to_netcdf4">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_to_netcdf4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">significant_digits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves the grid attributed to the :class:`Raster` object to the given ``filename`` (including</span>
<span class="sd">        the &quot;.nc&quot; extension) in netCDF4 format.&quot;&quot;&quot;</span>
        <span class="n">write_netcdf_grid</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span> <span class="n">significant_digits</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Raster.reconstruct">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.reconstruct">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstruct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">partitioning_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconstruct the raster from its initial time (``self.time``) to a new time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : float</span>
<span class="sd">            Time to which the data will be reconstructed.</span>
<span class="sd">        fill_value : float, int, str, or tuple, optional</span>
<span class="sd">            The value to be used for regions outside of the static polygons</span>
<span class="sd">            at ``time``. By default (``fill_value=None``), this value will be</span>
<span class="sd">            determined based on the input.</span>
<span class="sd">        partitioning_features : sequence of Feature or str, optional</span>
<span class="sd">            The features used to partition the raster grid and assign plate</span>
<span class="sd">            IDs. By default, ``self.plate_reconstruction.static_polygons``</span>
<span class="sd">            will be used, but alternatively any valid argument to</span>
<span class="sd">            ``pygplates.FeaturesFunctionArgument`` can be specified here.</span>
<span class="sd">        threads : int, default 1</span>
<span class="sd">            Number of threads to use for certain computationally heavy routines.</span>
<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            ID of the anchored plate. By default, reconstructions are made with respect to</span>
<span class="sd">            the anchor plate ID specified in the :class:`PlateReconstruction` object.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Perform the reconstruction in-place (replace the raster&#39;s data with the reconstructed data).</span>
<span class="sd">        return_array : bool, default False</span>
<span class="sd">            Return a ``numpy.ndarray``, rather than a :class:`Raster`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Raster or np.ndarray</span>
<span class="sd">            The reconstructed grid. Areas for which no plate ID could be determined will be filled with ``fill_value``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If this :class:`Raster` object has no a valid ``plate_reconstruction`` object.</span>


<span class="sd">        .. note::</span>

<span class="sd">            For two-dimensional grids, ``fill_value`` should be a single</span>
<span class="sd">            number. The default value will be ``np.nan`` for float or</span>
<span class="sd">            complex types, the minimum value for integer types, and the</span>
<span class="sd">            maximum value for unsigned types.</span>
<span class="sd">            For RGB image grids, ``fill_value`` should be a 3-tuple RGB</span>
<span class="sd">            colour code or a matplotlib colour string. The default value</span>
<span class="sd">            will be black (0.0, 0.0, 0.0) or (0, 0, 0).</span>
<span class="sd">            For RGBA image grids, ``fill_value`` should be a 4-tuple RGBA</span>
<span class="sd">            colour code or a matplotlib colour string. The default fill</span>
<span class="sd">            value will be transparent black (0.0, 0.0, 0.0, 0.0) or</span>
<span class="sd">            (0, 0, 0, 0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid time: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
        <span class="n">time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot perform reconstruction - &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;`plate_reconstruction` has not been set&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">partitioning_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">partitioning_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">static_polygons</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">reconstruct_grid</span><span class="p">(</span>
            <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">partitioning_features</span><span class="o">=</span><span class="n">partitioning_features</span><span class="p">,</span>
            <span class="n">rotation_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
            <span class="n">from_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">to_time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">time</span>
            <span class="k">if</span> <span class="n">return_array</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_array</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">result</span><span class="p">,</span>
                <span class="n">plate_reconstruction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Raster.imshow">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.imshow">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">imshow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display raster data.</span>

<span class="sd">        A pre-existing matplotlib ``Axes`` instance is used if available,</span>
<span class="sd">        else a new one is created. The ``origin`` and ``extent`` of the image</span>
<span class="sd">        are determined automatically and should not be specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib.axes.Axes, optional</span>
<span class="sd">            If specified, the image will be drawn within these axes.</span>
<span class="sd">        projection : cartopy.crs.Projection, optional</span>
<span class="sd">            The map projection to be used. If both ``ax`` and ``projection``</span>
<span class="sd">            are specified, this will be checked against the ``projection``</span>
<span class="sd">            attribute of ``ax``, if it exists.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Any further keyword arguments are passed to</span>
<span class="sd">            ``matplotlib.pyplot.imshow`` or ``matplotlib.axes.Axes.imshow``,</span>
<span class="sd">            where appropriate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.image.AxesImage</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``ax`` and ``projection`` are both specified, but do not match (i.e. ``ax.projection != projection``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;extent&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;imshow got an unexpected keyword argument: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">existing_figure</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">get_fignums</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">current_axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">projection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">current_axes</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_axes</span><span class="p">,</span> <span class="n">_GeoAxes</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">current_axes</span><span class="o">.</span><span class="n">projection</span> <span class="o">==</span> <span class="n">projection</span>
            <span class="p">):</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">current_axes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">existing_figure</span><span class="p">:</span>
                    <span class="n">current_axes</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="n">projection</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">projection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># projection and ax both specified</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">_GeoAxes</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ax</span><span class="o">.</span><span class="n">projection</span> <span class="o">==</span> <span class="n">projection</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># projections match</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Both `projection` and `ax` were specified, but&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; `projection` does not match `ax.projection`&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">_GeoAxes</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;transform&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_PlateCarree</span><span class="p">()</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">im</span></div>


    <span class="n">plot</span> <span class="o">=</span> <span class="n">imshow</span>

<div class="viewcode-block" id="Raster.rotate_reference_frames">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.rotate_reference_frames">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate_reference_frames</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">grid_spacing_degrees</span><span class="p">,</span>
        <span class="n">reconstruction_time</span><span class="p">,</span>
        <span class="n">from_rotation_features_or_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># filename(s), or pyGPlates feature(s)/collection(s) or a RotationModel</span>
        <span class="n">to_rotation_features_or_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># filename(s), or pyGPlates feature(s)/collection(s) or a RotationModel</span>
        <span class="n">from_rotation_reference_plate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">to_rotation_reference_plate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">non_reference_plate</span><span class="o">=</span><span class="mi">701</span><span class="p">,</span>
        <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate a grid defined in one plate model reference frame</span>
<span class="sd">        within a :class:`Raster` object to another plate reconstruction model reference frame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid_spacing_degrees : float</span>
<span class="sd">            The spacing (in degrees) for the output rotated grid.</span>
<span class="sd">        reconstruction_time : float</span>
<span class="sd">            The time at which to rotate the input grid.</span>
<span class="sd">        from_rotation_features_or_model : str, list of str, or instance of pygplates.RotationModel</span>
<span class="sd">            A filename, or a list of filenames, or a pyGPlates</span>
<span class="sd">            RotationModel object that defines the rotation model</span>
<span class="sd">            that the input grid is currently associated with.</span>
<span class="sd">        to_rotation_features_or_model : str, list of str, or instance of pygplates.RotationModel</span>
<span class="sd">            A filename, or a list of filenames, or a pyGPlates</span>
<span class="sd">            RotationModel object that defines the rotation model</span>
<span class="sd">            that the input grid shall be rotated with.</span>
<span class="sd">        from_rotation_reference_plate : int, default = 0</span>
<span class="sd">            The current reference plate for the plate model the grid</span>
<span class="sd">            is defined in. Defaults to the anchor plate 0.</span>
<span class="sd">        to_rotation_reference_plate : int, default = 0</span>
<span class="sd">            The desired reference plate for the plate model the grid</span>
<span class="sd">            is being rotated to. Defaults to the anchor plate 0.</span>
<span class="sd">        non_reference_plate : int, default = 701</span>
<span class="sd">            An arbitrary placeholder reference frame with which</span>
<span class="sd">            to define the &quot;from&quot; and &quot;to&quot; reference frames.</span>
<span class="sd">        output_name : str, default None</span>
<span class="sd">            If passed, the rotated grid is saved as a netCDF grid to this filename.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Raster</span>
<span class="sd">            An instance of the :class:`Raster` object containing the rotated grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">from_rotation_features_or_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Set a plate reconstruction model&quot;</span><span class="p">)</span>
            <span class="n">from_rotation_features_or_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span>
        <span class="k">if</span> <span class="n">to_rotation_features_or_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Set a plate reconstruction model&quot;</span><span class="p">)</span>
            <span class="n">to_rotation_features_or_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span>

        <span class="c1"># Create the pygplates.FiniteRotation that rotates</span>
        <span class="c1"># between the two reference frames.</span>
        <span class="n">from_rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">from_rotation_features_or_model</span><span class="p">)</span>
        <span class="n">to_rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">to_rotation_features_or_model</span><span class="p">)</span>
        <span class="n">from_rotation</span> <span class="o">=</span> <span class="n">from_rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
            <span class="n">reconstruction_time</span><span class="p">,</span>
            <span class="n">non_reference_plate</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">from_rotation_reference_plate</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">to_rotation</span> <span class="o">=</span> <span class="n">to_rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
            <span class="n">reconstruction_time</span><span class="p">,</span>
            <span class="n">non_reference_plate</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">to_rotation_reference_plate</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">reference_frame_conversion_rotation</span> <span class="o">=</span> <span class="n">to_rotation</span> <span class="o">*</span> <span class="n">from_rotation</span><span class="o">.</span><span class="n">get_inverse</span><span class="p">()</span>

        <span class="c1"># Resize the input grid to the specified output resolution before rotating</span>
        <span class="n">resX</span> <span class="o">=</span> <span class="n">_deg2pixels</span><span class="p">(</span><span class="n">grid_spacing_degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">resY</span> <span class="o">=</span> <span class="n">_deg2pixels</span><span class="p">(</span><span class="n">grid_spacing_degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">resized_input_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">resX</span><span class="p">,</span> <span class="n">resY</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Get the flattened lons, lats</span>
        <span class="n">llons</span><span class="p">,</span> <span class="n">llats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">resized_input_grid</span><span class="o">.</span><span class="n">lons</span><span class="p">,</span> <span class="n">resized_input_grid</span><span class="o">.</span><span class="n">lats</span><span class="p">)</span>
        <span class="n">llons</span> <span class="o">=</span> <span class="n">llons</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">llats</span> <span class="o">=</span> <span class="n">llats</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Convert lon-lat points of Raster grid to pyGPlates points</span>
        <span class="n">input_points</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span>
            <span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">llons</span><span class="p">,</span> <span class="n">llats</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Get grid values of the resized Raster object</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">resized_input_grid</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Rotate grid nodes to the other reference frame</span>
        <span class="n">output_points</span> <span class="o">=</span> <span class="n">reference_frame_conversion_rotation</span> <span class="o">*</span> <span class="n">input_points</span>

        <span class="c1"># Assemble rotated points with grid values.</span>
        <span class="n">out_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">llons</span><span class="p">)</span>
        <span class="n">out_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">llats</span><span class="p">)</span>
        <span class="n">zdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_points</span><span class="p">):</span>
            <span class="n">out_lat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">out_lon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>
            <span class="n">zdata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Create a regular grid on which to interpolate lats, lons and zdata</span>
        <span class="c1"># Use the extent of the original Raster object</span>
        <span class="n">extent_globe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>

        <span class="n">resX</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">extent_globe</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">extent_globe</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">grid_spacing_degrees</span><span class="p">))</span>
            <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">resY</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">extent_globe</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">extent_globe</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">grid_spacing_degrees</span><span class="p">))</span>
            <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">grid_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent_globe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extent_globe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">resX</span><span class="p">)</span>
        <span class="n">grid_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent_globe</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">extent_globe</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">resY</span><span class="p">)</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">grid_lon</span><span class="p">,</span> <span class="n">grid_lat</span><span class="p">)</span>

        <span class="c1"># Interpolate lons, lats and zvals over a regular grid using nearest</span>
        <span class="c1"># neighbour interpolation</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">griddata_sphere</span><span class="p">((</span><span class="n">out_lon</span><span class="p">,</span> <span class="n">out_lat</span><span class="p">),</span> <span class="n">zdata</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>

        <span class="c1"># Write output grid to netCDF if requested.</span>
        <span class="k">if</span> <span class="n">output_name</span><span class="p">:</span>
            <span class="n">write_netcdf_grid</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent_globe</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Raster</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">Z</span><span class="p">)</span></div>


<div class="viewcode-block" id="Raster.query">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.query">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">region_of_interest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given a set of location coordinates, return the grid values at these locations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lons: list</span>
<span class="sd">            a list of longitudes of the location coordinates</span>
<span class="sd">        lats: list</span>
<span class="sd">            a list of latitude of the location coordinates</span>
<span class="sd">        region_of_interest: float</span>
<span class="sd">            the radius of the region of interest in km</span>
<span class="sd">            this is the arch length. we need to calculate the straight distance between the two points in 3D space from this arch length.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            a list of grid values for the given locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;spatial_cKDTree&quot;</span><span class="p">):</span>
            <span class="c1"># build the spatial tree if the tree has not been built yet</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">yn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># we assume the grid is Grid-line Registration, not Pixel Registration</span>
            <span class="c1"># http://www.soest.hawaii.edu/pwessel/courses/gg710-01/GMT_grid.pdf</span>
            <span class="c1"># TODO: support both Grid-line and Pixel Registration</span>
            <span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">xn</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">yn</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># in degrees</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_cell_radius</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(((</span><span class="n">y0</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="n">yn</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(((</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">/</span> <span class="n">xn</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
                <span class="o">/</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">grid_points</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span><span class="o">.</span><span class="n">to_xyz</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span><span class="p">))[</span><span class="bp">self</span><span class="o">.</span><span class="n">data_mask</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;building the spatial tree...&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatial_cKDTree</span> <span class="o">=</span> <span class="n">_cKDTree</span><span class="p">(</span><span class="n">grid_points</span><span class="p">)</span>

        <span class="n">query_points</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span><span class="o">.</span><span class="n">to_xyz</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">region_of_interest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># convert the arch length(in degrees) to direct length in 3D space</span>
            <span class="n">roi</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_cell_radius</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">roi</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span>
                <span class="n">region_of_interest</span> <span class="o">/</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="p">)</span>

        <span class="n">dists</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_cKDTree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">query_points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">distance_upper_bound</span><span class="o">=</span><span class="n">roi</span>
        <span class="p">)</span>
        <span class="c1"># print(dists, indices)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data_mask</span><span class="p">],</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">]))[</span><span class="n">indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="Raster.clip_by_extent">
<a class="viewcode-back" href="../../generated/gplately.Raster.html#gplately.Raster.clip_by_extent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clip_by_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip the raster according to a given extent ``(x_min, x_max, y_min, y_max)``.</span>
<span class="sd">        The extent of the returned raster may be slightly bigger than the given extent.</span>
<span class="sd">        This happens when the border of the given extent fall between two gird lines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extent: tuple</span>
<span class="sd">            A tuple of 4 (min_lon, max_lon, min_lat, max_lat) extent.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Raster</span>
<span class="sd">            The clipped grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="ow">or</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="ow">or</span> <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">180</span>
            <span class="ow">or</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">180</span>
            <span class="ow">or</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">90</span>
            <span class="ow">or</span> <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">90</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid extent: </span><span class="si">{</span><span class="n">extent</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">or</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="ow">or</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="ow">or</span> <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The given extent is out of scope. </span><span class="si">{</span><span class="n">extent</span><span class="si">}</span><span class="s2"> -- </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">y_len</span><span class="p">,</span> <span class="n">x_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the shape of raster data x:</span><span class="si">{</span><span class="n">x_len</span><span class="si">}</span><span class="s2"> y:</span><span class="si">{</span><span class="n">y_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
            <span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">x_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">x_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># print(x0, x1)</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
            <span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">y_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">y_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># print(y0, y1)</span>
        <span class="n">new_extent</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">x0</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">180</span><span class="p">,</span>
            <span class="n">x1</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">180</span><span class="p">,</span>
            <span class="n">y0</span> <span class="o">/</span> <span class="p">(</span><span class="n">y_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">90</span><span class="p">,</span>
            <span class="n">y1</span> <span class="o">/</span> <span class="p">(</span><span class="n">y_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">90</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># print(new_extent)</span>
        <span class="c1"># print(self.data[y0 : y1 + 1, x0 : x1 + 1].shape)</span>
        <span class="k">return</span> <span class="n">Raster</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">y0</span> <span class="p">:</span> <span class="n">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x0</span> <span class="p">:</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">extent</span><span class="o">=</span><span class="n">new_extent</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_clip_by_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;TODO:&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">other</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">other</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">other</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">other</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">other</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">//</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">//</span> <span class="n">other</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">other</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">%</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">%</span> <span class="n">other</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">other</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">**</span><span class="n">other</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">**</span><span class="n">other</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Raster</span><span class="p">):</span>
            <span class="c1"># Return array, since we don&#39;t know which Raster</span>
            <span class="c1"># to take properties from</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Return Raster with new data</span>
        <span class="n">new_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">other</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">new_raster</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_raster</span></div>



<span class="c1"># class TimeRaster(Raster):</span>
<span class="c1">#     &quot;&quot;&quot;A class for the temporal manipulation of raster data. To be added soon!&quot;&quot;&quot;</span>
<span class="c1">#     def __init__(self, PlateReconstruction_object=None, filename=None, array=None, extent=None, resample=None):</span>
<span class="c1">#         raise NotImplementedError(</span>
<span class="c1">#             &quot;This class has not been implemented; use `Raster` instead&quot;</span>
<span class="c1">#         )</span>
<span class="c1">#         super(TimeRaster, self).__init__(PlateReconstruction_object)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, The University of Sydney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>