

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gplately.ptt.separate_ridge_transform_segments &mdash; gplately 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            gplately
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">GPlately v2.0.0</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basic_usages.html">Minimal working example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../use_cases.html">Common Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Trouble-shooting and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_line_interface.html">Command Line Interface (CLI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../primer.html">Primer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">gplately</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gplately</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gplately.ptt.separate_ridge_transform_segments</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gplately.ptt.separate_ridge_transform_segments</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">#    Copyright (C) 2017 The University of Sydney, Australia</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1">#    the terms of the GNU General Public License, version 2, as published by</span>
<span class="c1">#    the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c1">#    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c1">#    for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License along</span>
<span class="c1">#    with this program; if not, write to Free Software Foundation, Inc.,</span>
<span class="c1">#    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="c1">#</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Split the geometries of isochrons and mid-ocean ridges into ridge and transform segments</span>
<span class="sd">based on each segment’s alignment with the geometry’s stage pole at its time of appearance.</span>

<span class="sd">Source code is based on:</span>
<span class="sd">   http://www.gplates.org/docs/pygplates/sample-code/pygplates_split_isochron_into_ridges_and_transforms.html</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">argparse</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os.path</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pygplates</span>

<span class="c1"># How much a segment can deviate from the stage pole before it&#39;s considered a transform segment.</span>
<span class="c1">#</span>
<span class="c1"># Use a 70 degree angle.</span>
<span class="c1"># This used to be an even 45 degree split, but we need to gravitate towards favouring ridge segments (by increasing the angle).</span>
<span class="c1"># This is because, according to Dietmar, there are self-inconsistencies in the plate model (between the way plate boundaries are drawn</span>
<span class="c1"># and labelled and their correspondence to associated plate velocities) that are more apparent in deep time (eg, before 200 Ma) where</span>
<span class="c1"># there are mid-ocean ridges in large oceans NOT surrounding by passive margins.</span>
<span class="n">DEFAULT_TRANSFORM_SEGMENT_DEVIATION_DEGREES</span> <span class="o">=</span> <span class="mi">70</span>
<span class="n">DEFAULT_TRANSFORM_SEGMENT_DEVIATION_RADIANS</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span>
    <span class="n">DEFAULT_TRANSFORM_SEGMENT_DEVIATION_DEGREES</span>
<span class="p">)</span>


<div class="viewcode-block" id="separate_features_into_ridges_and_transforms">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.separate_ridge_transform_segments.separate_features_into_ridges_and_transforms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">separate_features_into_ridges_and_transforms</span><span class="p">(</span>
    <span class="n">rotation_features_or_model</span><span class="p">,</span>
    <span class="n">spreading_features</span><span class="p">,</span>
    <span class="n">spreading_feature_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">transform_segment_deviation_in_radians</span><span class="o">=</span><span class="n">DEFAULT_TRANSFORM_SEGMENT_DEVIATION_RADIANS</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split the geometries of isochrons and mid-ocean ridges into ridge and transform segments based</span>
<span class="sd">    on each segment’s alignment with the geometry’s stage pole at its time of appearance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rotation_features_or_model : rotation model or feature collection(s), or list of features, or filename(s)</span>
<span class="sd">        rotation features or model</span>

<span class="sd">    spreading_features : spreading feature collection(s), or list of features, or filename(s) or any combination of those</span>
<span class="sd">        spreading features</span>

<span class="sd">    spreading_feature_types</span>
<span class="sd">        Only spreading features with a feature type contained in this list are considered.</span>
<span class="sd">        If None then all spreading features are considered.</span>

<span class="sd">    transform_segment_deviation_in_radians: number</span>
<span class="sd">        How much a segment can deviate from the stage pole before</span>
<span class="sd">        it&#39;s considered a transform segment (in radians).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    2-tuple (list of pygplates.Feature, list of pygplates.Feature)</span>
<span class="sd">        The separated ridge and transform features respectively.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Turn rotation data into a RotationModel (if not already).</span>
    <span class="c1">#</span>
    <span class="c1"># OPTIMISATION:</span>
    <span class="c1"># We will be reconstructing (and reverse reconstructing) mid-ocean ridges in groups, where ridges in each</span>
    <span class="c1"># group have the same time-of-appearance. They need to have the same time of appearance because, in pyGPlates,</span>
    <span class="c1"># version 3 half-stage rotations start spreading from the time-of-appearance in 10 My intervals</span>
    <span class="c1"># (ie, the 10My intervals are &#39;begin_time&#39;, &#39;begin_time-10&#39;, begin_time-20&#39;, ..., reconstruction_time).</span>
    <span class="c1"># And because the mid-ocean ridges with the same time-of-appearance also have the same time intervals</span>
    <span class="c1"># they&#39;ll reuse the cached reconstruction trees (one cached tree per time interval).</span>
    <span class="c1"># This will avoid a lot of wasted time recreating these trees if the cache is continually flushed</span>
    <span class="c1"># (eg, by mixing mid-ocean ridges with different appearance times).</span>
    <span class="c1">#</span>
    <span class="c1"># A cache size of 100 is enough to go back to 1,000Ma (100 entries * 10My interval).</span>
    <span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">rotation_features_or_model</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

    <span class="c1"># Turn spreading feature data into a list of features (if not already).</span>
    <span class="n">spreading_features</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeaturesFunctionArgument</span><span class="p">(</span><span class="n">spreading_features</span><span class="p">)</span>

    <span class="c1"># Gather all spreading features with the same begin time (time-of-appearance) into groups.</span>
    <span class="c1">#</span>
    <span class="c1"># This is an optimisation that enables reconstructing multiple mid-ocean ridges with the same begin time together.</span>
    <span class="c1"># This can make a *big* difference to the running time (see note above regarding rotation model cache size).</span>
    <span class="n">spreading_features_grouped_by_begin_time</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Iterate over all geometries in spreading features.</span>
    <span class="k">for</span> <span class="n">spreading_feature</span> <span class="ow">in</span> <span class="n">spreading_features</span><span class="o">.</span><span class="n">get_features</span><span class="p">():</span>
        <span class="c1"># Filter spreading feature types if requested.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">spreading_feature_types</span>
            <span class="ow">and</span> <span class="n">spreading_feature</span><span class="o">.</span><span class="n">get_feature_type</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spreading_feature_types</span>
        <span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">begin_time</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spreading_feature</span><span class="o">.</span><span class="n">get_valid_time</span><span class="p">()</span>

        <span class="c1"># Add to list of spreading features with same begin time.</span>
        <span class="k">if</span> <span class="n">begin_time</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spreading_features_grouped_by_begin_time</span><span class="p">:</span>
            <span class="n">spreading_features_grouped_by_begin_time</span><span class="p">[</span><span class="n">begin_time</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spreading_features_grouped_by_begin_time</span><span class="p">[</span><span class="n">begin_time</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spreading_feature</span><span class="p">)</span>

    <span class="c1"># The separated ridge/transform segment features.</span>
    <span class="c1"># Both types of segment feature will have the same feature type as the feature they are extracted from.</span>
    <span class="n">ridge_segment_features</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">transform_segment_features</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate over groups of spreading features with the same begin time (time-of-appearance).</span>
    <span class="k">for</span> <span class="p">(</span>
        <span class="n">begin_time</span><span class="p">,</span>
        <span class="n">spreading_features_with_begin_time</span><span class="p">,</span>
    <span class="p">)</span> <span class="ow">in</span> <span class="n">spreading_features_grouped_by_begin_time</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Reconstruct the spreading features to their common birth time.</span>
        <span class="n">reconstructed_spreading_features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span>
            <span class="n">spreading_features_with_begin_time</span><span class="p">,</span>
            <span class="n">rotation_model</span><span class="p">,</span>
            <span class="n">reconstructed_spreading_features</span><span class="p">,</span>
            <span class="n">begin_time</span><span class="p">,</span>
            <span class="n">group_with_feature</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">ridge_segment_features_with_begin_time</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">transform_segment_features_with_begin_time</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate over reconstructed spreading features.</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">spreading_feature</span><span class="p">,</span>
            <span class="n">reconstructed_spreading_geometries</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="n">reconstructed_spreading_features</span><span class="p">:</span>
            <span class="c1"># Find the stage rotation of the spreading feature in the frame of reference of its</span>
            <span class="c1"># geometry at its birth time. The stage pole can then be directly geometrically compared</span>
            <span class="c1"># to the reconstructed spreading geometry.</span>
            <span class="n">stage_rotation</span> <span class="o">=</span> <span class="n">get_stage_rotation_for_reconstructed_geometry</span><span class="p">(</span>
                <span class="n">spreading_feature</span><span class="p">,</span> <span class="n">rotation_model</span><span class="p">,</span> <span class="n">begin_time</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stage_rotation</span><span class="p">:</span>
                <span class="c1"># Skip current feature - it&#39;s not a spreading feature.</span>
                <span class="k">continue</span>

            <span class="n">ridge_segment_geometries</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">transform_segment_geometries</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># A feature usually has a single geometry but it could have more - iterate over them all.</span>
            <span class="k">for</span> <span class="n">reconstructed_spreading_geometry</span> <span class="ow">in</span> <span class="n">reconstructed_spreading_geometries</span><span class="p">:</span>
                <span class="n">ridge_and_transform_segment_geometries</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">separate_geometry_into_ridges_and_transforms</span><span class="p">(</span>
                        <span class="n">stage_rotation</span><span class="p">,</span>
                        <span class="n">reconstructed_spreading_geometry</span><span class="o">.</span><span class="n">get_reconstructed_geometry</span><span class="p">(),</span>
                        <span class="n">transform_segment_deviation_in_radians</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">ridge_and_transform_segment_geometries</span><span class="p">:</span>
                    <span class="n">ridge_segment_geometries</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="n">ridge_and_transform_segment_geometries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">transform_segment_geometries</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="n">ridge_and_transform_segment_geometries</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">)</span>

            <span class="c1"># Put all ridge segment geometries into one feature and transform segment geometries into another.</span>
            <span class="k">if</span> <span class="n">ridge_segment_geometries</span><span class="p">:</span>
                <span class="n">ridge_segment_feature</span> <span class="o">=</span> <span class="n">spreading_feature</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="n">ridge_segment_feature</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">ridge_segment_geometries</span><span class="p">)</span>
                <span class="n">ridge_segment_features_with_begin_time</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ridge_segment_feature</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transform_segment_geometries</span><span class="p">:</span>
                <span class="n">transform_segment_feature</span> <span class="o">=</span> <span class="n">spreading_feature</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="n">transform_segment_feature</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">transform_segment_geometries</span><span class="p">)</span>
                <span class="n">transform_segment_features_with_begin_time</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">transform_segment_feature</span>
                <span class="p">)</span>

        <span class="c1"># Reverse reconstruct the segmented spreading features from their common birth time.</span>
        <span class="c1">#</span>
        <span class="c1"># Each new feature needs to be reverse reconstructed from birth time to present day because the</span>
        <span class="c1"># geometries are reconstructed (but need to be stored in present day positions within the feature).</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">reverse_reconstruct</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">ridge_segment_features_with_begin_time</span><span class="p">,</span>
                <span class="n">transform_segment_features_with_begin_time</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">rotation_model</span><span class="p">,</span>
            <span class="n">begin_time</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">ridge_segment_features</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ridge_segment_features_with_begin_time</span><span class="p">)</span>
        <span class="n">transform_segment_features</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">transform_segment_features_with_begin_time</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ridge_segment_features</span><span class="p">,</span> <span class="n">transform_segment_features</span></div>



<div class="viewcode-block" id="separate_geometry_into_ridges_and_transforms">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.separate_ridge_transform_segments.separate_geometry_into_ridges_and_transforms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">separate_geometry_into_ridges_and_transforms</span><span class="p">(</span>
    <span class="n">stage_rotation</span><span class="p">,</span>
    <span class="n">geometry_at_spreading_time</span><span class="p">,</span>
    <span class="n">transform_segment_deviation_in_radians</span><span class="o">=</span><span class="n">DEFAULT_TRANSFORM_SEGMENT_DEVIATION_RADIANS</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split the geometry of an isochron or mid-ocean ridge (at a time when there is spreading) into ridge and</span>
<span class="sd">    transform segments based on each segment’s alignment with the geometry’s stage pole at its time of appearance.</span>

<span class="sd">    For isochrons the geometry should be at its time of appearance (ie, when formed at mid-ocean ridge).</span>
<span class="sd">    For mid-ocean ridges the geometry can be any time when the ridge is actively spreading.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stage_rotation</span>
<span class="sd">        The stage rotation that can be applied to the geometry at the spreading time.</span>
<span class="sd">        NOTE: It must have already had transforms to and from the stage pole reference frame applied.</span>
<span class="sd">        In other words, if you get the stage pole from it, using &#39;get_euler_pole_and_angle()&#39;, then it</span>
<span class="sd">        should be the stage pole in the frame of reference of the geometry at the spreading time.</span>

<span class="sd">    geometry_at_spreading_time: number</span>
<span class="sd">        The polyline (or polygon) at the spreading time.</span>

<span class="sd">    transform_segment_deviation_in_radians: number</span>
<span class="sd">        How much a segment can deviate from the stage pole before</span>
<span class="sd">        it&#39;s considered a transform segment (in radians).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    2-tuple (list of pygplates.Polyline, list of pygplates.Polyline), None if &#39;geometry_at_spreading_time&#39; is not a polyline (or polygon)</span>
<span class="sd">        The separated ridge and transform geometries respectively.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Iterate over the segments of the geometry.</span>
    <span class="c1"># Note that we&#39;re assuming the geometry is a polyline (or polygon) - otherwise we ignore the geometry.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">geometry_at_spreading_time</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># Get the stage pole of the stage rotation.</span>
    <span class="c1"># Note that the stage rotation is already in frame of reference of the geometry at the spreading time.</span>
    <span class="n">stage_pole</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stage_rotation</span><span class="o">.</span><span class="n">get_euler_pole_and_angle</span><span class="p">()</span>

    <span class="n">ridge_segment_geometries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">transform_segment_geometries</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Points of contiguous segments belonging either to a ridge or transform.</span>
    <span class="n">contiguous_segment_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">is_transform</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
        <span class="c1"># Ignore zero length segments - they don&#39;t have a direction.</span>
        <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">is_zero_length</span><span class="p">():</span>
            <span class="k">continue</span>

        <span class="c1"># Get the point in the middle of the segment and its tangential direction.</span>
        <span class="n">segment_midpoint</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">get_arc_point</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">segment_direction_at_midpoint</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">get_arc_direction</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Get the direction from the segment midpoint to the stage pole.</span>
        <span class="c1"># This is the tangential direction at the start of an arc from the segment</span>
        <span class="c1"># midpoint to the stage pole (the zero parameter indicates the arc start point</span>
        <span class="c1"># which is the segment midpoint).</span>
        <span class="n">segment_to_stage_pole_direction</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GreatCircleArc</span><span class="p">(</span>
            <span class="n">segment_midpoint</span><span class="p">,</span> <span class="n">stage_pole</span>
        <span class="p">)</span><span class="o">.</span><span class="n">get_arc_direction</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># The angle that the segment deviates from the stage pole direction.</span>
        <span class="n">deviation_of_segment_direction_from_stage_pole</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">angle_between</span><span class="p">(</span>
                <span class="n">segment_direction_at_midpoint</span><span class="p">,</span> <span class="n">segment_to_stage_pole_direction</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># When comparing the deviation angle we need to consider the case where the two</span>
        <span class="c1"># direction vectors are aligned but pointing in opposite directions.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">deviation_of_segment_direction_from_stage_pole</span>
            <span class="o">&lt;</span> <span class="n">transform_segment_deviation_in_radians</span>
            <span class="ow">or</span> <span class="n">deviation_of_segment_direction_from_stage_pole</span>
            <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">transform_segment_deviation_in_radians</span>
        <span class="p">):</span>
            <span class="c1"># If switching from transform to ridge.</span>
            <span class="k">if</span> <span class="n">is_transform</span><span class="p">:</span>
                <span class="c1"># Emit transform polyline (if any) and restart contiguous segments.</span>
                <span class="k">if</span> <span class="n">contiguous_segment_points</span><span class="p">:</span>
                    <span class="n">transform_segment_geometries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">contiguous_segment_points</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">contiguous_segment_points</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">is_transform</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># transform</span>
            <span class="c1"># If switching from ridge to transform.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_transform</span><span class="p">:</span>
                <span class="c1"># Emit ridge polyline (if any) and restart contiguous segments.</span>
                <span class="k">if</span> <span class="n">contiguous_segment_points</span><span class="p">:</span>
                    <span class="n">ridge_segment_geometries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">contiguous_segment_points</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">contiguous_segment_points</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">is_transform</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Add segment start point if first segment.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">contiguous_segment_points</span><span class="p">:</span>
            <span class="n">contiguous_segment_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment</span><span class="o">.</span><span class="n">get_start_point</span><span class="p">())</span>

        <span class="c1"># Add segment end point.</span>
        <span class="n">contiguous_segment_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment</span><span class="o">.</span><span class="n">get_end_point</span><span class="p">())</span>

    <span class="c1"># Emit last ridge or transform polyline (if any).</span>
    <span class="k">if</span> <span class="n">contiguous_segment_points</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_transform</span><span class="p">:</span>
            <span class="n">transform_segment_geometries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">contiguous_segment_points</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ridge_segment_geometries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">contiguous_segment_points</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">ridge_segment_geometries</span><span class="p">,</span> <span class="n">transform_segment_geometries</span></div>



<div class="viewcode-block" id="get_stage_rotation_for_reconstructed_geometry">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.separate_ridge_transform_segments.get_stage_rotation_for_reconstructed_geometry">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_stage_rotation_for_reconstructed_geometry</span><span class="p">(</span>
    <span class="n">spreading_feature</span><span class="p">,</span>
    <span class="n">rotation_model</span><span class="p">,</span>
    <span class="n">spreading_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_left_right_plates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the stage rotation of the spreading feature in the frame of reference of its geometry at the spreading time.</span>
<span class="sd">    The stage pole can then be directly geometrically compared to the reconstructed spreading geometry.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spreading_feature</span>
<span class="sd">        Can be a feature with half-stage rotation reconstruction (using left/right plate IDs)</span>
<span class="sd">        or a regular feature with a conjugate plate ID.</span>
<span class="sd">        An example of the former is a mid-ocean ridge, and of the latter an isochron.</span>

<span class="sd">    rotation_model: pygplates.RotationModel</span>
<span class="sd">        Rotation model</span>

<span class="sd">    spreading_time: number, optional</span>
<span class="sd">        A time at which spreading is happening.</span>
<span class="sd">        For isochrons this should be its time of appearance (ie, when formed at mid-ocean ridge).</span>
<span class="sd">        For mid-ocean ridges this can be any time when the ridge is actively spreading.</span>
<span class="sd">        Defaults to the time of appearance of &#39;spreading_feature&#39;.</span>

<span class="sd">    return_left_right_plates: bool, default=False</span>
<span class="sd">        Also return the left and right plate IDs (as a 3-tuple of (stage rotation, left plate, right plate)).</span>
<span class="sd">        Defaults to False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    the stage rotation that can be applied to the geometry at the spreading time</span>
<span class="sd">        NOTE: It has already had transforms to and from the stage pole reference frame applied.</span>
<span class="sd">        So if you get the stage pole from it, using &#39;get_euler_pole_and_angle()&#39;, then it</span>
<span class="sd">        will be the stage pole in the frame of reference of the geometry at the spreading time.</span>

<span class="sd">        Returns None if &#39;spreading_feature&#39; does not satisfy requirements of a spreading feature.</span>
<span class="sd">        (ie, have left/right plate IDs or reconstruction/conjugate plate IDs, and</span>
<span class="sd">        have spreading time not in distant past or future, and</span>
<span class="sd">        have non-zero stage rotation from &#39;spreading_time + 1&#39; to &#39;spreading_time&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># If the spreading time is not specified then default to the feature&#39;s time of appearance.</span>
    <span class="k">if</span> <span class="n">spreading_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spreading_time</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spreading_feature</span><span class="o">.</span><span class="n">get_valid_time</span><span class="p">()</span>

    <span class="c1"># Spreading time must not be distant past or future.</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">GeoTimeInstant</span><span class="p">(</span><span class="n">spreading_time</span><span class="p">)</span><span class="o">.</span><span class="n">is_distant_past</span><span class="p">()</span>
        <span class="ow">or</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeoTimeInstant</span><span class="p">(</span><span class="n">spreading_time</span><span class="p">)</span><span class="o">.</span><span class="n">is_distant_future</span><span class="p">()</span>
    <span class="p">):</span>
        <span class="k">return</span>

    <span class="c1"># Reconstructing either by plate ID or by half stage rotation.</span>
    <span class="k">if</span> <span class="n">spreading_feature</span><span class="o">.</span><span class="n">get_reconstruction_method</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;ByPlateId&quot;</span><span class="p">:</span>
        <span class="c1"># See if spreading feature has reconstruction and conjugate plate ids.</span>
        <span class="n">reconstruction_and_conjugate_plate_ids</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_get_reconstruction_and_conjugate_plate_ids</span><span class="p">(</span><span class="n">spreading_feature</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reconstruction_and_conjugate_plate_ids</span><span class="p">:</span>
            <span class="c1"># Spreading feature has no reconstruction/conjugate plate pair.</span>
            <span class="k">return</span>

        <span class="p">(</span>
            <span class="n">reconstruction_plate_id</span><span class="p">,</span>
            <span class="n">conjugate_plate_id</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">reconstruction_and_conjugate_plate_ids</span>

        <span class="c1">#</span>
        <span class="c1"># In order to compare spreading geometries with the pole of the stage rotation at spreading time</span>
        <span class="c1"># we need to transform either (1) present day spreading geometries, or (2) geometries reconstructed</span>
        <span class="c1"># to spreading time, into the reference frame of the stage rotation (so can compare to stage pole).</span>
        <span class="c1">#</span>
        <span class="c1"># To help us decide this we start by writing the equation for a regular feature (with a conjugate plate)...</span>
        <span class="c1">#</span>
        <span class="c1">#   geometry_reconstructed = R(0-&gt;t, A-&gt;Recon) * geometry_present_day</span>
        <span class="c1">#                          = R(0-&gt;t, A-&gt;Conj) * R(0-&gt;t, Conj-&gt;Recon) * geometry_present_day</span>
        <span class="c1">#                          = R(0-&gt;t, A-&gt;Conj) * R(t+1-&gt;t, Conj-&gt;Recon) * R(0-&gt;t+1, Conj-&gt;Recon) * geometry_present_day</span>
        <span class="c1">#</span>
        <span class="c1"># ...where &#39;Recon&#39; is reconstruction plate ID and &#39;Conj&#39; is conjugate plate ID.</span>
        <span class="c1">#</span>
        <span class="c1"># We want to transform the spreading geometry into the stage pole reference frame at time &#39;t=spreading_time&#39;.</span>
        <span class="c1"># The easiest way to do this is to transform &#39;geometry_reconstructed&#39; instead of &#39;geometry_present_day&#39; since</span>
        <span class="c1"># it&#39;s easier to get into the reference frame of the &#39;R(t+1-&gt;t, Conj-&gt;Recon)&#39; rotation</span>
        <span class="c1"># which is the stage rotation we&#39;re interested in when &#39;t=spreading_time&#39;.</span>
        <span class="c1"># Rearranging the above equation we get...</span>
        <span class="c1">#</span>
        <span class="c1">#   geometry_present_day = inverse[R(0-&gt;spreading_time+1, Conj-&gt;Recon)]</span>
        <span class="c1">#                          * inverse[R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)]</span>
        <span class="c1">#                          * inverse[R(0-&gt;spreading_time, A-&gt;Conj)]</span>
        <span class="c1">#                          * geometry_reconstructed</span>
        <span class="c1">#                        = inverse[R(0-&gt;spreading_time+1, Conj-&gt;Recon)]</span>
        <span class="c1">#                          * inverse[R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)]</span>
        <span class="c1">#                          * geometry_in_stage_pole_reference_frame</span>
        <span class="c1">#</span>
        <span class="c1">#   geometry_in_stage_pole_reference_frame = inverse[R(0-&gt;spreading_time, A-&gt;Conj)] * geometry_reconstructed</span>
        <span class="c1">#</span>
        <span class="c1"># ...where &#39;geometry_in_stage_pole_reference_frame&#39; is in the stage pole reference frame because it gets rotated by</span>
        <span class="c1"># the stage pole rotation &#39;inverse[R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)]&#39; which differs from</span>
        <span class="c1"># &#39;R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)&#39; only in angle (has negated angle but pole remains the same).</span>
        <span class="c1">#</span>
        <span class="c1"># So to get reconstructed spreading geometry in the stage pole reference frame we reverse rotate &#39;geometry_reconstructed&#39;</span>
        <span class="c1"># by &#39;inverse[R(0-&gt;spreading_time, A-&gt;Conj)]&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># So to apply the stage rotation to the reconstructed spreading geometry we rotate it in stage pole reference frame,</span>
        <span class="c1"># then apply stage rotation and then rotate back from the stage pole reference frame...</span>
        <span class="c1">#</span>
        <span class="c1">#   stage_rotate_geometry_reconstructed = R(0-&gt;spreading_time, A-&gt;Conj)</span>
        <span class="c1">#                                         * R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)</span>
        <span class="c1">#                                         * inverse[R(0-&gt;spreading_time, A-&gt;Conj)]</span>
        <span class="c1">#                                         * geometry_reconstructed</span>
        <span class="c1">#</span>
        <span class="c1"># For more detail see:</span>
        <span class="c1">#   http://www.gplates.org/docs/pygplates/sample-code/pygplates_split_isochron_into_ridges_and_transforms.html</span>
        <span class="c1">#</span>
        <span class="n">stage_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
            <span class="n">spreading_time</span><span class="p">,</span>
            <span class="n">reconstruction_plate_id</span><span class="p">,</span>
            <span class="n">spreading_time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">conjugate_plate_id</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">stage_rotation</span><span class="o">.</span><span class="n">represents_identity_rotation</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">from_stage_pole_reference_frame</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
            <span class="n">spreading_time</span><span class="p">,</span> <span class="n">conjugate_plate_id</span>
        <span class="p">)</span>
        <span class="n">to_stage_pole_reference_frame</span> <span class="o">=</span> <span class="n">from_stage_pole_reference_frame</span><span class="o">.</span><span class="n">get_inverse</span><span class="p">()</span>
        <span class="n">stage_rotation</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">from_stage_pole_reference_frame</span>
            <span class="o">*</span> <span class="n">stage_rotation</span>
            <span class="o">*</span> <span class="n">to_stage_pole_reference_frame</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_left_right_plates</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stage_rotation</span><span class="p">,</span> <span class="n">conjugate_plate_id</span><span class="p">,</span> <span class="n">reconstruction_plate_id</span>

        <span class="k">return</span> <span class="n">stage_rotation</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Reconstruction is by half stage rotation...</span>
        <span class="c1"># See if spreading feature has left and right plate ids (it should).</span>
        <span class="n">left_and_right_plate_ids</span> <span class="o">=</span> <span class="n">_get_left_and_right_plate_ids</span><span class="p">(</span><span class="n">spreading_feature</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left_and_right_plate_ids</span><span class="p">:</span>
            <span class="c1"># Spreading feature has no left/right plate pair.</span>
            <span class="k">return</span>

        <span class="n">left_plate_id</span><span class="p">,</span> <span class="n">right_plate_id</span> <span class="o">=</span> <span class="n">left_and_right_plate_ids</span>

        <span class="c1">#</span>
        <span class="c1"># In order to compare spreading geometries with the pole of the stage rotation at birth time</span>
        <span class="c1"># we need to transform either (1) present day spreading geometries, or (2) geometries reconstructed</span>
        <span class="c1"># to birth time, into the reference frame of the stage rotation (so can compare to stage pole).</span>
        <span class="c1">#</span>
        <span class="c1"># To help us decide this we start by writing the equation for a mid-ocean ridge (MOR)...</span>
        <span class="c1">#</span>
        <span class="c1">#   geometry_reconstructed = R(0-&gt;t, A-&gt;MOR) * geometry_present_day</span>
        <span class="c1">#                          = R(0-&gt;t, A-&gt;Left) * R(0-&gt;t, Left-&gt;MOR) * geometry_present_day</span>
        <span class="c1">#                          = R(0-&gt;t, A-&gt;Left) * spread(ts-&gt;t, Left-&gt;Right) * geometry_present_day</span>
        <span class="c1">#</span>
        <span class="c1"># ...where &#39;MOR&#39; is not a plate ID, which is why we do half-spreading (or asymmetric spreading) of</span>
        <span class="c1"># right plate relative to left plate. The function &#39;spread()&#39; usually splits the time interval from</span>
        <span class="c1"># spreading start time &#39;ts&#39; to time &#39;t&#39; into N stages and accumulates spreading over those N stages...</span>
        <span class="c1">#</span>
        <span class="c1">#   geometry_reconstructed = R(0-&gt;t, A-&gt;Left) * spread(ts-&gt;t, Left-&gt;Right) * geometry_present_day</span>
        <span class="c1">#                          = R(0-&gt;t, A-&gt;Left)</span>
        <span class="c1">#                            * spread(t[N-1]-&gt;t, Left-&gt;Right) * spread(t[N-2]-&gt;t[N-1], Left-&gt;Right) * ... * spread(t1-&gt;t2, Left-&gt;Right) * spread(ts-&gt;t1, Left-&gt;Right)</span>
        <span class="c1">#                            * geometry_present_day</span>
        <span class="c1">#</span>
        <span class="c1"># ...in GPlates the &quot;gpml:ReconstructionMethodEnumeration&quot; property currently supports &#39;HalfStageRotation&#39; versions 1, 2 and 3.</span>
        <span class="c1"># They only differ in the spreading start time &#39;ts&#39; and the number of stages N.</span>
        <span class="c1"># Version 1 has &#39;ts=0&#39; and &#39;N=1&#39;.</span>
        <span class="c1"># Version 2 has &#39;ts=0&#39; and &#39;N&gt;1&#39;.</span>
        <span class="c1"># Version 3 has &#39;ts=spreading_time&#39; and &#39;N&gt;1&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># We want to transform the spreading geometry into the stage pole reference frame at time &#39;t=spreading_time&#39;.</span>
        <span class="c1"># The easiest way to do this is to transform &#39;geometry_reconstructed&#39; instead of &#39;geometry_present_day&#39; since</span>
        <span class="c1"># it&#39;s easier to get into the reference frame of the &#39;spread(t[N-1]-&gt;t, Left-&gt;Right)&#39; rotation</span>
        <span class="c1"># which is the stage rotation we&#39;re interested in when &#39;t=spreading_time&#39;.</span>
        <span class="c1"># Rearranging the above equation we get...</span>
        <span class="c1">#</span>
        <span class="c1">#   geometry_present_day = inverse[spread(ts-&gt;t1, Left-&gt;Right)] * ... * inverse[spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)]</span>
        <span class="c1">#                          * inverse[R(0-&gt;t, A-&gt;Left)]</span>
        <span class="c1">#                          * geometry_reconstructed</span>
        <span class="c1">#                        = inverse[spread(ts-&gt;t1, Left-&gt;Right)] * ... * inverse[spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)]</span>
        <span class="c1">#                          * geometry_in_stage_pole_reference_frame</span>
        <span class="c1">#</span>
        <span class="c1">#   geometry_in_stage_pole_reference_frame = inverse[R(0-&gt;spreading_time, A-&gt;Left)] * geometry_reconstructed</span>
        <span class="c1">#</span>
        <span class="c1"># ...where &#39;geometry_in_stage_pole_reference_frame&#39; is in the stage pole reference frame because it gets rotated by</span>
        <span class="c1"># the stage pole rotation &#39;inverse[spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)]&#39; which differs from</span>
        <span class="c1"># &#39;spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)&#39; only in angle (has negated angle but pole remains the same).</span>
        <span class="c1">#</span>
        <span class="c1"># So to get reconstructed spreading geometry in the stage pole reference frame we reverse rotate &#39;geometry_reconstructed&#39; by &#39;inverse[R(0-&gt;spreading_time, A-&gt;Left)]&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># So to apply the stage rotation to the reconstructed spreading geometry we rotate it in stage pole reference frame,</span>
        <span class="c1"># then apply stage rotation and then rotate back from the stage pole reference frame...</span>
        <span class="c1">#</span>
        <span class="c1">#   stage_rotate_geometry_reconstructed = R(0-&gt;spreading_time, A-&gt;Left)</span>
        <span class="c1">#                                         * R(spreading_time+1-&gt;spreading_time, Left-&gt;Right)</span>
        <span class="c1">#                                         * inverse[R(0-&gt;spreading_time, A-&gt;Left)]</span>
        <span class="c1">#                                         * geometry_reconstructed</span>
        <span class="c1">#</span>
        <span class="n">stage_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
            <span class="n">spreading_time</span><span class="p">,</span> <span class="n">right_plate_id</span><span class="p">,</span> <span class="n">spreading_time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left_plate_id</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">stage_rotation</span><span class="o">.</span><span class="n">represents_identity_rotation</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">from_stage_pole_reference_frame</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
            <span class="n">spreading_time</span><span class="p">,</span> <span class="n">left_plate_id</span>
        <span class="p">)</span>
        <span class="n">to_stage_pole_reference_frame</span> <span class="o">=</span> <span class="n">from_stage_pole_reference_frame</span><span class="o">.</span><span class="n">get_inverse</span><span class="p">()</span>
        <span class="n">stage_rotation</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">from_stage_pole_reference_frame</span>
            <span class="o">*</span> <span class="n">stage_rotation</span>
            <span class="o">*</span> <span class="n">to_stage_pole_reference_frame</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_left_right_plates</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stage_rotation</span><span class="p">,</span> <span class="n">left_plate_id</span><span class="p">,</span> <span class="n">right_plate_id</span>

        <span class="k">return</span> <span class="n">stage_rotation</span></div>



<span class="c1">#</span>
<span class="c1"># Private function.</span>
<span class="c1">#</span>
<span class="c1"># Returns a tuple of left and right plate ids from a &#39;feature&#39;, or None if not found.</span>
<span class="c1">#</span>
<div class="viewcode-block" id="_get_left_and_right_plate_ids">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.separate_ridge_transform_segments._get_left_and_right_plate_ids">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_get_left_and_right_plate_ids</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
    <span class="c1"># Get left and right plate ids (if any).</span>
    <span class="n">left_plate_id</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">get_left_plate</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">right_plate_id</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">get_right_plate</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">left_plate_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">right_plate_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">left_plate_id</span><span class="p">,</span> <span class="n">right_plate_id</span></div>



<span class="c1">#</span>
<span class="c1"># Private function.</span>
<span class="c1">#</span>
<span class="c1"># Returns a tuple of reconstruction and conjugate plate ids from a &#39;feature&#39;,</span>
<span class="c1"># otherwise looks for plate/conjugate ids if feature came from a PLATES data file,</span>
<span class="c1"># otherwise returns None.</span>
<span class="c1">#</span>
<div class="viewcode-block" id="_get_reconstruction_and_conjugate_plate_ids">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.separate_ridge_transform_segments._get_reconstruction_and_conjugate_plate_ids">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_get_reconstruction_and_conjugate_plate_ids</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
    <span class="n">reconstruction_plate_id</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">conjugate_plate_id</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">get_conjugate_plate_id</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="c1"># If missing either then attempt to get reconstruction/conjugate from the &#39;gpml:OldPlatesHeader&#39; property.</span>
    <span class="k">if</span> <span class="n">reconstruction_plate_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">conjugate_plate_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reconstruction_plate_id</span><span class="p">,</span> <span class="n">conjugate_plate_id</span>

    <span class="n">gpml_old_plates_header</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">PropertyName</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;oldPlatesHeader&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">gpml_old_plates_header</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">reconstruction_plate_id</span> <span class="o">=</span> <span class="n">gpml_old_plates_header</span><span class="o">.</span><span class="n">get_plate_id_number</span><span class="p">()</span>
            <span class="n">conjugate_plate_id</span> <span class="o">=</span> <span class="n">gpml_old_plates_header</span><span class="o">.</span><span class="n">get_conjugate_plate_id_number</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">reconstruction_plate_id</span><span class="p">,</span> <span class="n">conjugate_plate_id</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># The property value type did not match the property name.</span>
            <span class="c1"># This indicates the data does not conform to the GPlates Geological Information Model (GPGIM).</span>
            <span class="k">pass</span></div>



<span class="n">DEFAULT_OUTPUT_RIDGES_FILENAME_SUFFIX</span> <span class="o">=</span> <span class="s2">&quot;_ridges&quot;</span>
<span class="n">DEFAULT_OUTPUT_TRANSFORMS_FILENAME_SUFFIX</span> <span class="o">=</span> <span class="s2">&quot;_transforms&quot;</span>

<span class="n">__description__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Split the geometries of isochrons and mid-ocean ridges into ridge and transform segments.</span>

<span class="s2">The splitting is based on each segment&#39;s alignment with the geometry&#39;s stage pole at its time of appearance.</span>

<span class="s2">NOTE: Separate the positional and optional arguments with &#39;--&#39; (workaround for bug in argparse module).</span>
<span class="s2">For example...</span>

<span class="si">%(prog)s</span><span class="s2"> -r rotations.rot -d 45 -s _ridges -t _transforms -- spreading_features.gpml</span>
<span class="s2">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="add_arguments">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.separate_ridge_transform_segments.add_arguments">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">add_arguments</span><span class="p">(</span><span class="n">parser</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;add command line argument parser&quot;&quot;&quot;</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">formatter_class</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">RawDescriptionHelpFormatter</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">__description__</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">main</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-r&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--rotation_filenames&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;rotation_filename&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;One or more rotation files.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-s&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--output_ridges_filename_suffix&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEFAULT_OUTPUT_RIDGES_FILENAME_SUFFIX</span><span class="p">),</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The suffix to append to each input filename to get each output ridges filename - &quot;</span>
        <span class="s2">&quot;the default suffix is &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEFAULT_OUTPUT_RIDGES_FILENAME_SUFFIX</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-t&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--output_transforms_filename_suffix&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEFAULT_OUTPUT_TRANSFORMS_FILENAME_SUFFIX</span><span class="p">),</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The suffix to append to each input filename to get each output transforms filename - &quot;</span>
        <span class="s2">&quot;the default suffix is &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEFAULT_OUTPUT_TRANSFORMS_FILENAME_SUFFIX</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-d&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--transform_segment_deviation_degrees&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEFAULT_TRANSFORM_SEGMENT_DEVIATION_DEGREES</span><span class="p">),</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;How many degrees a spreading segment can deviate from the stage pole before it&#39;s considered a transform segment - &quot;</span>
        <span class="s2">&quot;default is &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEFAULT_TRANSFORM_SEGMENT_DEVIATION_DEGREES</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-f&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--spreading_feature_types&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;spreading_feature_type&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The feature type(s) to split into ridge/transform segments. &quot;</span>
        <span class="s2">&quot;All other feature types will be ignored (and not end up in separated ridge/transform output files). &quot;</span>
        <span class="s2">&quot;The format should match the format of &quot;</span>
        <span class="s2">&quot;http://www.gplates.org/docs/pygplates/generated/pygplates.FeatureType.html#pygplates.FeatureType.get_name . &quot;</span>
        <span class="s2">&quot;For example, mid-ocean ridges are specified as MidOceanRidge (without the gpml: prefix). &quot;</span>
        <span class="s2">&quot;Defaults to splitting all features (although features that are not spreading are ignored).&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;input_filenames&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;input_filename&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;One or more input filenames (original files).&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="main">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.separate_ridge_transform_segments.main">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># Convert strings into feature types.</span>
    <span class="c1"># For example, &#39;MidOceanRidge&#39; into pygplates.FeatureType.create_gpml(&#39;MidOceanRidge&#39;)</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">spreading_feature_types</span><span class="p">:</span>
        <span class="n">args</span><span class="o">.</span><span class="n">spreading_feature_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="n">feature_type</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">feature_type</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">spreading_feature_types</span>
        <span class="p">]</span>

    <span class="k">for</span> <span class="n">input_filename</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">input_filenames</span><span class="p">:</span>
        <span class="p">(</span>
            <span class="n">ridge_features</span><span class="p">,</span>
            <span class="n">transform_features</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">separate_features_into_ridges_and_transforms</span><span class="p">(</span>
            <span class="n">args</span><span class="o">.</span><span class="n">rotation_filenames</span><span class="p">,</span>
            <span class="n">args</span><span class="o">.</span><span class="n">input_filenames</span><span class="p">,</span>
            <span class="n">args</span><span class="o">.</span><span class="n">spreading_feature_types</span><span class="p">,</span>
            <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">transform_segment_deviation_degrees</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Each output filename is the input filename with a suffix appended.</span>
        <span class="n">filename_root</span><span class="p">,</span> <span class="n">filename_ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">input_filename</span><span class="p">)</span>
        <span class="n">output_ridges_filename</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">output_ridges_filename_suffix</span><span class="p">,</span> <span class="n">filename_ext</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">ridge_features</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output_ridges_filename</span><span class="p">)</span>

        <span class="c1"># Each output filename is the input filename with a suffix appended.</span>
        <span class="n">filename_root</span><span class="p">,</span> <span class="n">filename_ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">input_filename</span><span class="p">)</span>
        <span class="n">output_transforms_filename</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">output_transforms_filename_suffix</span><span class="p">,</span> <span class="n">filename_ext</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">transform_features</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">output_transforms_filename</span>
        <span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># The command-line parser.</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="n">__description__</span><span class="p">,</span>
        <span class="n">formatter_class</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">RawDescriptionHelpFormatter</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># add arguments</span>
    <span class="n">add_arguments</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>

    <span class="c1"># Parse command-line options.</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="c1"># call main function</span>
    <span class="n">main</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, The University of Sydney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>