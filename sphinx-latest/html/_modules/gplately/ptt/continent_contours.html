

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gplately.ptt.continent_contours &mdash; gplately 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            gplately
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basic_usages.html">Minimal working example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../use_cases.html">Common Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Trouble-shooting and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_line_interface.html">Command Line Interface (CLI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../primer.html">Primer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">gplately</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gplately</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gplately.ptt.continent_contours</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gplately.ptt.continent_contours</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">#    Copyright (C) 2023 The University of Sydney, Australia</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1">#    the terms of the GNU General Public License, version 2, as published by</span>
<span class="c1">#    the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c1">#    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c1">#    for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License along</span>
<span class="c1">#    with this program; if not, write to Free Software Foundation, Inc.,</span>
<span class="c1">#    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Calculate continent contours, and fragmentation index (global perimeter-to-area ratio), at various times.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os.path</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inspect</span><span class="w"> </span><span class="kn">import</span> <span class="n">signature</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pygplates</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">points_in_polygons</span><span class="p">,</span> <span class="n">points_spatial_tree</span><span class="p">,</span> <span class="n">proximity_query</span>

<span class="c1"># TODO: Replace the internal uniform lat/lon sampling with a sampling that&#39;s uniform across the sphere</span>
<span class="c1">#       (so that the contour resolution doesn&#39;t favour contours near the North/South poles).</span>


<div class="viewcode-block" id="ContouredContinent">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContouredContinent">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ContouredContinent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to represent the contour around overlapping/abutting continental blocks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_including_continent</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="ContouredContinent._add_continent">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContouredContinent._add_continent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_continent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">continent_polygon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a continent (landmass) polygon to this contoured continent.</span>

<span class="sd">        This is a polygon whose interior represents continental crust.</span>
<span class="sd">        And it can have interior rings (holes) which represent oceanic crust.</span>

<span class="sd">        Note that it&#39;s possible for a continent polygon to be inside the interior hole of another continent polygon.</span>
<span class="sd">        For example, a continental island inside an ocean basin that, in turn, is inside a larger continent.</span>
<span class="sd">        It&#39;s also possible for a continent polygon to be inside an ocean polygon.</span>
<span class="sd">        For example, a continental island inside an ocean basin (that itself has no continent containing it).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_including_continent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">continent_polygon</span><span class="p">)</span></div>


<div class="viewcode-block" id="ContouredContinent._add_ocean">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContouredContinent._add_ocean">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_ocean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ocean_polygon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an ocean polygon to this contoured continent.</span>

<span class="sd">        This is a polygon whose interior represents oceanic crust, but it has no continent that contains it.</span>
<span class="sd">        Unlike a continent polygon, an ocean polygon cannot have interior rings (holes). If there are any continent islands</span>
<span class="sd">        inside this ocean then they should be added as a separate (continent) polygons.</span>

<span class="sd">        Usually only a single continent polygon is needed to define a landmass.</span>
<span class="sd">        However, one or more ocean polygons can instead be needed if the landmass is actually a landmass that covers the entire globe</span>
<span class="sd">        except for a few oceanic holes. In which case the specified ocean polygon is actually one of those oceanic holes.</span>
<span class="sd">        This is a special case because you can&#39;t have a single global continent polygon with only interior holes (and no exterior ring).</span>
<span class="sd">        So intead we allow for multiple ocean polygons that represent these oceanic holes (and treat them specially).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ocean_polygon</span><span class="o">.</span><span class="n">get_number_of_interior_rings</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Ocean polygons cannot have interior rings&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ocean_polygon</span><span class="p">)</span></div>


<div class="viewcode-block" id="ContouredContinent.get_contours">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContouredContinent.get_contours">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_contours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the *polyline* contours representing the boundaries of continental crust.&quot;&quot;&quot;</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Add each ring (of polygons *including* continent) as a polyline contour.</span>
        <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_including_continent</span><span class="p">:</span>
            <span class="n">exterior_polyline_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">get_exterior_ring_points</span><span class="p">())</span>
            <span class="n">exterior_polyline_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">exterior_polyline_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># polyline&#39;s last point should match first point</span>
            <span class="n">contours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">exterior_polyline_points</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">interior_ring_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">get_number_of_interior_rings</span><span class="p">()):</span>
                <span class="n">interior_polyline_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">polygon</span><span class="o">.</span><span class="n">get_interior_ring_points</span><span class="p">(</span><span class="n">interior_ring_index</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">interior_polyline_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">interior_polyline_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># polyline&#39;s last point should match first point</span>
                <span class="n">contours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">interior_polyline_points</span><span class="p">))</span>

        <span class="c1"># Add each *exterior* ring (of polygons *excluding* continent) as a polyline contour.</span>
        <span class="c1"># Note: Polygons that *exclude* continental crust have no interior rings.</span>
        <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span><span class="p">:</span>
            <span class="n">exterior_polyline_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">get_exterior_ring_points</span><span class="p">())</span>
            <span class="n">exterior_polyline_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">exterior_polyline_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># polyline&#39;s last point should match first point</span>
            <span class="n">contours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">exterior_polyline_points</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">contours</span></div>


<div class="viewcode-block" id="ContouredContinent.are_points_inside">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContouredContinent.are_points_inside">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">are_points_inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">points_spatial_tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a numpy 1D boolean array with same length as &#39;points&#39; (and in same order) containing True for each point inside this contoured continent.&quot;&quot;&quot;</span>

        <span class="c1"># A special (unlikely) case is a single continent covering the entire globe (area 4*pi).</span>
        <span class="c1"># This happens when there are no inclusive polygons and no exclusive polygons.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_including_continent</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span>
        <span class="p">):</span>
            <span class="c1"># All points *include* continent.</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Improve efficiency by re-using spatial tree of points if caller provides it (otherwise create our own).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">points_spatial_tree</span><span class="p">:</span>
            <span class="n">points_spatial_tree</span> <span class="o">=</span> <span class="n">points_spatial_tree</span><span class="o">.</span><span class="n">PointsSpatialTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># If we have any polygons that *exclude* continent then it means the continent landmass covers the entire globe</span>
        <span class="c1"># except these excluding polygons.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span><span class="p">:</span>
            <span class="c1"># By default all points are considered *inside* this contoured continent unless proven *outside*.</span>
            <span class="n">points_inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>

            <span class="c1"># See if the points are inside any of the exclusive polygons.</span>
            <span class="n">exclusive_polygons_containing_points</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">points_in_polygons</span><span class="o">.</span><span class="n">find_polygons_using_points_spatial_tree</span><span class="p">(</span>
                    <span class="n">points</span><span class="p">,</span> <span class="n">points_spatial_tree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Any points *inside* an exclusive polygon are considered to be *outside* this contoured continent.</span>
            <span class="c1">#</span>
            <span class="c1"># Note: If there are any inclusive polygons (which must be inside these exclusive polygons) then later</span>
            <span class="c1">#       they will include some of these points that we just excluded.</span>
            <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">exclusive_polygons_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]:</span>
                    <span class="n">points_inside</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># else all polygons *include* continent (ie, none exclude continent)...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># By default all points are considered *outside* this contoured continent unless proven *inside*.</span>
            <span class="n">points_inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_including_continent</span><span class="p">:</span>
            <span class="c1"># See if the points are inside any of the inclusive polygons.</span>
            <span class="n">inclusive_polygons_containing_points</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">points_in_polygons</span><span class="o">.</span><span class="n">find_polygons_using_points_spatial_tree</span><span class="p">(</span>
                    <span class="n">points</span><span class="p">,</span> <span class="n">points_spatial_tree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_including_continent</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Any points *inside* an inclusive polygon are considered to be *inside* this contoured continent.</span>
            <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">inclusive_polygons_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]:</span>
                    <span class="n">points_inside</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">points_inside</span></div>


<div class="viewcode-block" id="ContouredContinent.get_perimeter">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContouredContinent.get_perimeter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sum of the length of the contour boundaries of this contoured continent (in radians).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">fsum</span><span class="p">(</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">get_arc_length</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_including_continent</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ContouredContinent.get_area">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContouredContinent.get_area">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The area of this contoured continent (in square radians, as known as steradians).&quot;&quot;&quot;</span>

        <span class="c1"># A special (unlikely) case is a single continent covering the entire globe (area 4*pi).</span>
        <span class="c1"># This happens when there are no inclusive polygons and no exclusive polygons.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_including_continent</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>

        <span class="n">area</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Note that we can get one or more polygons that *exclude* continent.</span>
        <span class="c1"># This can happen when contouring a large landmass such that there is no contour that is an exterior ring.</span>
        <span class="c1"># In this case the landmass covers the entire globe except for a few oceanic holes.</span>
        <span class="c1"># However you can&#39;t have a single polygon with only interior holes (and no exterior ring).</span>
        <span class="c1"># So intead we allow for multiple exterior ring polygons to represent these holes (and treat this as a special case).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span><span class="p">:</span>
            <span class="c1"># And since we can&#39;t have an exterior ring covering the entire globe we need to explicitly add the area of the entire globe.</span>
            <span class="n">area</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>

            <span class="c1"># Subtract the area of the exclusive holes.</span>
            <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span><span class="p">:</span>
                <span class="n">area</span> <span class="o">-=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>

        <span class="c1"># Add the areas of polygons that include continent.</span>
        <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons_including_continent</span><span class="p">:</span>
            <span class="n">area</span> <span class="o">+=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">area</span></div>


<div class="viewcode-block" id="ContouredContinent.get_perimeter_area_ratio">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContouredContinent.get_perimeter_area_ratio">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_perimeter_area_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The perimeter divided by the area (in units of 1/radians).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_perimeter</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span></div>
</div>



<span class="c1"># Default distance threshold (in radians) above which continents are separated.</span>
<span class="c1">#</span>
<span class="c1"># This is a small value to avoid numerical tolerance issues when two continent polygons abutt each other but actually</span>
<span class="c1"># have a very tiny non-zero distance between them (which would cause them to belong to separate continents, for a zero threshold,</span>
<span class="c1"># when they probably should belong to the same continent).</span>
<span class="n">DEFAULT_CONTINENT_SEPARATION_DISTANCE_THRESHOLD_RADIANS</span> <span class="o">=</span> <span class="mf">1e-4</span>  <span class="c1"># ~1km</span>


<div class="viewcode-block" id="ContinentContouring">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ContinentContouring</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to calculate continent mask, contours, and fragmentation index (global perimeter-to-area ratio), at various times.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rotaton_model_or_features</span><span class="p">,</span>
        <span class="n">continent_features</span><span class="p">,</span>  <span class="c1"># regular features (not topologies)</span>
        <span class="c1"># The grid spacing (in degrees) between points in the grid used for contouring/aggregrating blocks of continental polygons.</span>
        <span class="n">continent_contouring_point_spacing_degrees</span><span class="p">,</span>
        <span class="c1"># Optional parameter specifying a minimum area threshold (in square radians) for including contoured continents.</span>
        <span class="c1">#</span>
        <span class="c1"># Contoured continents with area smaller than this threshold will be excluded.</span>
        <span class="c1"># If this parameter is not specified then no area threshold is applied.</span>
        <span class="c1">#</span>
        <span class="c1"># Can also be a function (accepting time in Ma) and returning the area threshold.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: Units here are for normalised sphere (ie, steradians or square radians) so full Earth area is 4*pi.</span>
        <span class="c1">#       So 0.1 covers an area of approximately 4,000,000 km^2 (ie, 0.1 * 6371^2, where Earth radius is 6371km).</span>
        <span class="c1">#       Conversely 4,000,000 km^2 is equivalent to (4,000,000 / 6371^2) steradians.</span>
        <span class="n">continent_contouring_area_threshold_steradians</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># Optional parameter specifying a distance (in radians) to expand contours ocean-ward - this also</span>
        <span class="c1"># ensures small gaps between continents are ignored during contouring.</span>
        <span class="c1">#</span>
        <span class="c1"># The continent(s) will be expanded by a buffer of this distance (in radians) when contouring/aggregrating blocks of continental polygons.</span>
        <span class="c1"># If this parameter is not specified then buffer expansion is not applied (to continent contours).</span>
        <span class="c1">#</span>
        <span class="c1"># This parameter can also be a function (that returns the distance).</span>
        <span class="c1"># The function can have a single function argument, accepting time (in Ma).</span>
        <span class="c1"># Or it can have two function arguments, with the second accepting the contoured continent (a &#39;ContouredContinent&#39; object)</span>
        <span class="c1"># of the (unexpanded) contoured continent that the buffer/gap distance will apply to.</span>
        <span class="c1"># Or it can have three function arguments, with the third accepting a list of reconstructed polygons (&#39;pygplates.ReconstructedFeatureGeometry&#39; objects)</span>
        <span class="c1"># used to contour the (unexpanded) contoured continent that the buffer/gap distance will apply to.</span>
        <span class="c1"># Hence a function with *two* arguments means a different buffer/gap distance can be specified for each contoured continent (eg, based on its area).</span>
        <span class="c1"># And a function with *three* arguments can also use the feature properties (eg, plate ID) of the reconstructed polygons in the contoured continent.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: Units here are for normalised sphere (ie, radians).</span>
        <span class="c1">#       So 1.0 radian is approximately 6371 km (where Earth radius is 6371 km).</span>
        <span class="c1">#       Also 1.0 degree is approximately 110 km.</span>
        <span class="c1">#</span>
        <span class="c1"># NOTE: This cannot be specified if &#39;continent_polygon_buffer_and_gap_distance_radians&#39; is specified.</span>
        <span class="c1">#       You can only specify one or the other (or neither).</span>
        <span class="n">continent_contouring_buffer_and_gap_distance_radians</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># Optional parameter specifying a minimum area threshold (in square radians) for contours that exclude continental crust.</span>
        <span class="c1">#</span>
        <span class="c1"># Polygon contours that exclude continental crust and have an area smaller than this threshold will be excluded</span>
        <span class="c1"># (meaning they will now *include* continental crust, thus removing the contour).</span>
        <span class="c1"># This is useful for removing small holes inside continents.</span>
        <span class="c1"># If this parameter is not specified then no area threshold is applied.</span>
        <span class="c1">#</span>
        <span class="c1"># Can also be a function (accepting time in Ma) and returning the area threshold.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: Units here are for normalised sphere (ie, steradians or square radians) so full Earth area is 4*pi.</span>
        <span class="c1">#       So 0.1 covers an area of approximately 4,000,000 km^2 (ie, 0.1 * 6371^2, where Earth radius is 6371km).</span>
        <span class="c1">#       Conversely 4,000,000 km^2 is equivalent to (4,000,000 / 6371^2) steradians.</span>
        <span class="n">continent_exclusion_area_threshold_steradians</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># Optional parameter specifying the distance threshold (in radians) above which continents are separated.</span>
        <span class="c1">#</span>
        <span class="c1"># Any continent polygons separated by a distance that is less than this threshold will become part of the same continent.</span>
        <span class="c1">#</span>
        <span class="c1"># If this parameter is not specified then it defaults to a small value to avoid numerical tolerance issues when two</span>
        <span class="c1"># continent polygons abutt each other but actually have a very tiny non-zero distance between them</span>
        <span class="c1"># (which would cause them to belong to separate continents, for a zero threshold, when they probably should belong to the same continent).</span>
        <span class="c1">#</span>
        <span class="c1"># Specifying None is the same as specifying a zero distance threshold.</span>
        <span class="c1">#</span>
        <span class="c1"># Can also be a function (accepting time in Ma) and returning the distance threshold.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: Units here are for normalised sphere (ie, radians).</span>
        <span class="c1">#       So 1.0 radian is approximately 6371 km (where Earth radius is 6371 km).</span>
        <span class="c1">#       Also 1.0 degree is approximately 110 km.</span>
        <span class="n">continent_separation_distance_threshold_radians</span><span class="o">=</span><span class="n">DEFAULT_CONTINENT_SEPARATION_DISTANCE_THRESHOLD_RADIANS</span><span class="p">,</span>
        <span class="c1"># Optional parameter specifying a distance (in radians) to expand each individual continental polygon ocean-ward - this also</span>
        <span class="c1"># ensures small gaps between continents are ignored during contouring.</span>
        <span class="c1">#</span>
        <span class="c1"># NOTE: This is similar to &#39;continent_contouring_buffer_and_gap_distance_radians&#39; except it applies to each continental polygon</span>
        <span class="c1">#       (instead of applying to each aggregate block of continental polygons forming a continent contour).</span>
        <span class="c1">#</span>
        <span class="c1"># The continent polygons will be expanded by a buffer of this distance (in radians).</span>
        <span class="c1"># If this parameter is not specified then buffer expansion is not applied (to continental polygons).</span>
        <span class="c1">#</span>
        <span class="c1"># This parameter can also be a function (that returns the distance).</span>
        <span class="c1"># The function can have a single function argument, accepting time (in Ma).</span>
        <span class="c1"># Or it can have two function arguments, with the second accepting the reconstructed continental feature polygon</span>
        <span class="c1"># (a &#39;pygplates.ReconstructedFeatureGeometry&#39; object) that the buffer/gap distance will apply to.</span>
        <span class="c1"># Hence a function with *two* arguments means a different buffer/gap distance can be specified for each continental polygon.</span>
        <span class="c1"># For example, you can use its feature properties (eg, plate ID), and/or its reconstructed polygon (eg, area).</span>
        <span class="c1">#</span>
        <span class="c1"># Note: Units here are for normalised sphere (ie, radians).</span>
        <span class="c1">#       So 1.0 radian is approximately 6371 km (where Earth radius is 6371 km).</span>
        <span class="c1">#       Also 1.0 degree is approximately 110 km.</span>
        <span class="c1">#</span>
        <span class="c1"># NOTE: This cannot be specified if &#39;continent_contouring_buffer_and_gap_distance_radians&#39; is specified.</span>
        <span class="c1">#       You can only specify one or the other (or neither).</span>
        <span class="n">continent_polygon_buffer_and_gap_distance_radians</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">rotaton_model_or_features</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">continent_features</span> <span class="o">=</span> <span class="n">continent_features</span>

        <span class="k">if</span> <span class="n">continent_contouring_area_threshold_steradians</span><span class="p">:</span>
            <span class="c1"># Convert area threshold to a function of time, if not already a function.</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">continent_contouring_area_threshold_steradians</span><span class="p">):</span>
                <span class="c1"># We can call the specified function directly.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_area_threshold_steradians_function</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">continent_contouring_area_threshold_steradians</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use a delegate function that returns the specified parameter.</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">continent_contouring_area_threshold_steradians_function</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">continent_contouring_area_threshold_steradians</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_area_threshold_steradians_function</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">continent_contouring_area_threshold_steradians_function</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># no area threshold (specified either None or zero)</span>
            <span class="c1"># Use a delegate function that returns zero.</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">continent_contouring_area_threshold_steradians_function</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_area_threshold_steradians_function</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">continent_contouring_area_threshold_steradians_function</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">continent_contouring_buffer_and_gap_distance_radians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">continent_polygon_buffer_and_gap_distance_radians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;You cannot specify both &#39;continent_contouring_buffer_and_gap_distance_radians&#39; and &quot;</span>
                <span class="s2">&quot;&#39;continent_polygon_buffer_and_gap_distance_radians&#39;. You can only specify one or the other (or neither).&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">continent_contouring_buffer_and_gap_distance_radians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Convert continent contouring buffer/gap threshold to a function, if not already a function.</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">continent_contouring_buffer_and_gap_distance_radians</span><span class="p">):</span>
                <span class="n">callable_signature</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span>
                    <span class="n">continent_contouring_buffer_and_gap_distance_radians</span>
                <span class="p">)</span>
                <span class="n">callable_num_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">callable_signature</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">callable_num_args</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="ow">or</span> <span class="n">callable_num_args</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="ow">or</span> <span class="n">callable_num_args</span> <span class="o">==</span> <span class="mi">3</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Continent contouring buffer/gap distance is a callable but does not have 1 or 2 or 3 arguments&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">callable_num_args</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># We can call the specified function directly.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_buffer_and_gap_distance_radians_function</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">continent_contouring_buffer_and_gap_distance_radians</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable_num_args</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># The specified function only accepts age and contoured continent (not continent feature polygons).</span>
                    <span class="c1"># So use a delegate function that calls it and ignores continent feature polygons.</span>
                    <span class="k">def</span><span class="w"> </span><span class="nf">continent_contouring_buffer_and_gap_distance_radians_function</span><span class="p">(</span>
                        <span class="n">age</span><span class="p">,</span> <span class="n">contoured_continent</span><span class="p">,</span> <span class="n">continent_feature_polygons</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">continent_contouring_buffer_and_gap_distance_radians</span><span class="p">(</span>
                            <span class="n">age</span><span class="p">,</span> <span class="n">contoured_continent</span>
                        <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_buffer_and_gap_distance_radians_function</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">continent_contouring_buffer_and_gap_distance_radians_function</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># callable_num_args == 1</span>
                    <span class="c1"># The specified function only accepts age (not contoured continent or continent feature polygons).</span>
                    <span class="c1"># So use a delegate function that calls it and ignores contoured continent and continent feature polygons.</span>
                    <span class="k">def</span><span class="w"> </span><span class="nf">continent_contouring_buffer_and_gap_distance_radians_function</span><span class="p">(</span>
                        <span class="n">age</span><span class="p">,</span> <span class="n">contoured_continent</span><span class="p">,</span> <span class="n">continent_feature_polygons</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">continent_contouring_buffer_and_gap_distance_radians</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_buffer_and_gap_distance_radians_function</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">continent_contouring_buffer_and_gap_distance_radians_function</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use a delegate function that returns the specified parameter.</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">continent_contouring_buffer_and_gap_distance_radians_function</span><span class="p">(</span>
                    <span class="n">age</span><span class="p">,</span> <span class="n">contoured_continent</span><span class="p">,</span> <span class="n">continent_feature_polygons</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="n">continent_contouring_buffer_and_gap_distance_radians</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_buffer_and_gap_distance_radians_function</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">continent_contouring_buffer_and_gap_distance_radians_function</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_buffer_and_gap_distance_radians_function</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">continent_polygon_buffer_and_gap_distance_radians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Convert continent polygon buffer/gap threshold to a function, if not already a function.</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">continent_polygon_buffer_and_gap_distance_radians</span><span class="p">):</span>
                <span class="n">callable_signature</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span>
                    <span class="n">continent_polygon_buffer_and_gap_distance_radians</span>
                <span class="p">)</span>
                <span class="n">callable_num_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">callable_signature</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">callable_num_args</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">callable_num_args</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Continent polygon buffer/gap distance is a callable but does not have 1 or 2 arguments&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">callable_num_args</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># We can call the specified function directly.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">continent_polygon_buffer_and_gap_distance_radians_function</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">continent_polygon_buffer_and_gap_distance_radians</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># callable_num_args == 1</span>
                    <span class="c1"># The specified function only accepts age (not continent feature polygon).</span>
                    <span class="c1"># So use a delegate function that calls it and ignores the continent feature polygon.</span>
                    <span class="k">def</span><span class="w"> </span><span class="nf">continent_polygon_buffer_and_gap_distance_radians_function</span><span class="p">(</span>
                        <span class="n">age</span><span class="p">,</span> <span class="n">continent_feature_polygon</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">continent_polygon_buffer_and_gap_distance_radians</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">continent_polygon_buffer_and_gap_distance_radians_function</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">continent_polygon_buffer_and_gap_distance_radians_function</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use a delegate function that returns the specified parameter.</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">continent_polygon_buffer_and_gap_distance_radians_function</span><span class="p">(</span>
                    <span class="n">age</span><span class="p">,</span> <span class="n">continent_feature_polygon</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="n">continent_polygon_buffer_and_gap_distance_radians</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">continent_polygon_buffer_and_gap_distance_radians_function</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">continent_polygon_buffer_and_gap_distance_radians_function</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_polygon_buffer_and_gap_distance_radians_function</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">continent_exclusion_area_threshold_steradians</span><span class="p">:</span>
            <span class="c1"># Convert area threshold to a function of time, if not already a function.</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">continent_exclusion_area_threshold_steradians</span><span class="p">):</span>
                <span class="c1"># We can call the specified function directly.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">continent_exclusion_area_threshold_steradians_function</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">continent_exclusion_area_threshold_steradians</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use a delegate function that returns the specified parameter.</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">continent_exclusion_area_threshold_steradians_function</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">continent_exclusion_area_threshold_steradians</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">continent_exclusion_area_threshold_steradians_function</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">continent_exclusion_area_threshold_steradians_function</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># no area threshold (specified either None or zero)</span>
            <span class="c1"># Use a delegate function that returns zero.</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">continent_exclusion_area_threshold_steradians_function</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">continent_exclusion_area_threshold_steradians_function</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">continent_exclusion_area_threshold_steradians_function</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">continent_separation_distance_threshold_radians</span><span class="p">:</span>
            <span class="c1"># Convert distance threshold to a function of time, if not already a function.</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">continent_separation_distance_threshold_radians</span><span class="p">):</span>
                <span class="c1"># We can call the specified function directly.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">continent_separation_distance_threshold_radians_function</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">continent_separation_distance_threshold_radians</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use a delegate function that returns the specified parameter.</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">continent_separation_distance_threshold_radians_function</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">continent_separation_distance_threshold_radians</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">continent_separation_distance_threshold_radians_function</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">continent_separation_distance_threshold_radians_function</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># no distance threshold (specified either None or zero)</span>
            <span class="c1"># Use a delegate function that returns zero.</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">continent_separation_distance_threshold_radians_function</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">continent_separation_distance_threshold_radians_function</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">continent_separation_distance_threshold_radians_function</span>
            <span class="p">)</span>

        <span class="c1"># The number of latitudes (including -90 and 90).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">180.0</span> <span class="o">/</span> <span class="n">continent_contouring_point_spacing_degrees</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="c1"># The number of longitudes (including -180 and 180).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_longitudes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">contouring_point_spacing_degrees</span> <span class="o">=</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="c1"># A point grid to calculate contour polygons representing the boundary of reconstructed static polygons that overlap each other.</span>
        <span class="c1">#</span>
        <span class="c1"># NOTE: We must generate points on the dateline (ie, at both longitude -180 and 180) since the</span>
        <span class="c1">#       contouring alorithm depends on this. We also generate points at the North and South poles</span>
        <span class="c1">#       for the same reason.</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">90.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span><span class="p">)</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">180.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_longitudes</span><span class="p">)</span>

        <span class="c1"># Create a multipoint grid of points ordered by longitude first then latitude.</span>
        <span class="n">contouring_longitude_array</span><span class="p">,</span> <span class="n">contouring_latitude_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="n">contouring_latitude_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                <span class="n">contouring_longitude_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Improve efficiency by re-using spatial tree of contouring points over time (when finding points in polygons and finding points near polygons).</span>
        <span class="c1">#</span>
        <span class="c1"># First calculate the subdivision depth to avoid doing too many point-in-polygon tests (for example) for each spatial tree node.</span>
        <span class="c1"># The lat/lon width of a root quad tree node in the spatial tree is 90 degrees which is &#39;n/2&#39; points wide (where &#39;n&#39; is &#39;self.contouring_grid_num_latitudes&#39;).</span>
        <span class="c1"># So a leaf node at subdivision depth &#39;D&#39; is &#39;(n/2) / 2^D&#39; = &#39;n / 2^(D+1)&#39;. The number of points is the square of that &#39;N = &#39;(n / 2^(D+1)) ^ 2&#39;.</span>
        <span class="c1"># Rearranging that gives the subdivision depth &#39;D&#39; in terms of the number of points we&#39;d like in a deepest (leaf) node N:</span>
        <span class="c1">#   D = log2(n / sqrt(N)) - 1</span>
        <span class="n">max_num_points_per_spatial_tree_node</span> <span class="o">=</span> <span class="mi">64</span>  <span class="c1"># N</span>
        <span class="n">points_spatial_tree_subdivision_depth</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span>
                <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max_num_points_per_spatial_tree_node</span><span class="p">),</span>
                <span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">-</span> <span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># D</span>
        <span class="c1"># We won&#39;t exceed 6 subdivision levels because it starts to use a lot of memory.</span>
        <span class="c1"># And 6 is still higher than the default of 4 in PointsSpatialTree.</span>
        <span class="n">points_spatial_tree_subdivision_depth</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="mi">6</span><span class="p">,</span> <span class="n">points_spatial_tree_subdivision_depth</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points_spatial_tree</span> <span class="o">=</span> <span class="n">points_spatial_tree</span><span class="o">.</span><span class="n">PointsSpatialTree</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">,</span> <span class="n">points_spatial_tree_subdivision_depth</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ContinentContouring.get_fragmentation">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring.get_fragmentation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_fragmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the continental fragmentation index (global perimeter-to-area ratio) at the specified time.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the contoured continents representing the boundary(s) of the reconstructed continent polygons that overlap each other.</span>
        <span class="n">contoured_continents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_contoured_continents</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>

        <span class="n">total_perimeter</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">total_area</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Update total perimeter and area.</span>
        <span class="k">for</span> <span class="n">contoured_continent</span> <span class="ow">in</span> <span class="n">contoured_continents</span><span class="p">:</span>
            <span class="n">total_perimeter</span> <span class="o">+=</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">get_perimeter</span><span class="p">()</span>
            <span class="n">total_area</span> <span class="o">+=</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>

        <span class="c1"># Avoid divide-by-zero.</span>
        <span class="k">if</span> <span class="n">total_area</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="c1"># print(&#39; global perimeter/area:&#39;, total_perimeter / total_area / pygplates.Earth.equatorial_radius_in_kms, &#39;km-1&#39;); sys.stdout.flush()</span>

        <span class="c1"># print(&#39;age:&#39;, age, &#39;frag_index (1/km):&#39;, total_perimeter / total_area / 6371.0); sys.stdout.flush()</span>
        <span class="k">return</span> <span class="n">total_perimeter</span> <span class="o">/</span> <span class="n">total_area</span></div>


<div class="viewcode-block" id="ContinentContouring.get_continent_mask">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring.get_continent_mask">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_continent_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct the continents (specified in constructor) and then find the latitude/longitude grid points that are inside them.</span>

<span class="sd">        The grid spacing of these grid points was specified in the constructor.</span>

<span class="sd">        Returns a 2D boolean numpy array of shape (num_latitudes, num_longitudes).</span>
<span class="sd">        Note that when writing to a NetCDF grid file you can convert to floating-point (with &quot;continent_mask.astype(&#39;float&#39;)&quot;).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">contoured_continents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_contoured_continents</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_continent_mask</span><span class="p">(</span><span class="n">contoured_continents</span><span class="p">)</span></div>


<div class="viewcode-block" id="ContinentContouring.get_contoured_continents">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring.get_contoured_continents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_contoured_continents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct the continents (specified in constructor) and then find their boundaries as contoured continents.</span>

<span class="sd">        Returns a list of &#39;ContouredContinent&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">reconstructed_continent_polygons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reconstructed_continent_polygons</span><span class="p">(</span>
            <span class="n">age</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_contoured_continents</span><span class="p">(</span>
            <span class="n">reconstructed_continent_polygons</span><span class="p">,</span> <span class="n">age</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ContinentContouring.get_continent_mask_and_contoured_continents">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring.get_continent_mask_and_contoured_continents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_continent_mask_and_contoured_continents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct the continents (specified in constructor) and then find both their boundaries as contoured continents and</span>
<span class="sd">        the latitude/longitude grid points that are inside them.</span>

<span class="sd">        Returns a 2-tuple of (a 2D boolean numpy array of shape (num_latitudes, num_longitudes), a list of &#39;ContouredContinent&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">contoured_continents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_contoured_continents</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>

        <span class="n">continent_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_continent_mask</span><span class="p">(</span><span class="n">contoured_continents</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">continent_mask</span><span class="p">,</span> <span class="n">contoured_continents</span></div>


<div class="viewcode-block" id="ContinentContouring.get_reconstructed_continent_polygons">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring.get_reconstructed_continent_polygons">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_reconstructed_continent_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct the continents (specified in constructor).</span>

<span class="sd">        Note that these are just the original continent polygons (but reconstructed).</span>
<span class="sd">        They are NOT contoured, so they can still overlap/abutt each other.</span>

<span class="sd">        Returns a list of 2-tuple (&#39;pygplates.PolygonOnSphere&#39;, &#39;pygplates.ReconstructedFeatureGeometry&#39;) where</span>
<span class="sd">        the polygon is obtained from the reconstructed feature geometry.</span>
<span class="sd">        The reconstructed feature geometry can be used to query the associated &#39;pygplates.Feature&#39; and its properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Reconstruct static continental polygons.</span>
        <span class="n">reconstructed_feature_geometries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_features</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
            <span class="n">reconstructed_feature_geometries</span><span class="p">,</span>
            <span class="n">age</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Return a list of 2-tuple (&#39;pygplates.PolygonOnSphere&#39;, &#39;pygplates.ReconstructedFeatureGeometry&#39;).</span>
        <span class="c1">#</span>
        <span class="c1"># We should have polygons (not polylines) but turn into a polygon if happens to be a polyline</span>
        <span class="c1"># (but that actually only works if the polyline is a closed loop and not just part of a polygon&#39;s boundary).</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span>
                    <span class="n">reconstructed_feature_geometry</span><span class="o">.</span><span class="n">get_reconstructed_geometry</span><span class="p">()</span>
                <span class="p">),</span>
                <span class="n">reconstructed_feature_geometry</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">reconstructed_feature_geometry</span> <span class="ow">in</span> <span class="n">reconstructed_feature_geometries</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="ContinentContouring.calculate_continent_mask">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring.calculate_continent_mask">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_continent_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contoured_continents</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the latitude/longitude grid points that are inside the specified contoured continents.</span>

<span class="sd">        The grid spacing of these grid points was specified in the constructor.</span>

<span class="sd">        Returns a 2D boolean numpy array of shape (num_latitudes, num_longitudes).</span>
<span class="sd">        Note that when writing to a NetCDF grid file you can convert to floating-point (with &quot;continent_mask.astype(&#39;float&#39;)&quot;).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_grid_points_inside_contoured_continents</span><span class="p">(</span><span class="n">contoured_continents</span><span class="p">)</span></div>


<div class="viewcode-block" id="ContinentContouring.calculate_contoured_continents">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring.calculate_contoured_continents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_contoured_continents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">continent_polygons</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the boundaries of the specified (potentially overlapping/abutting) continent polygons as contoured continents.</span>

<span class="sd">        Note that each continent polygon should be a 2-tuple (&#39;pygplates.PolygonOnSphere&#39;, &#39;pygplates.ReconstructedFeatureGeometry&#39;).</span>

<span class="sd">        Note that small contoured continent islands with area less than the area threshold will NOT get returned.</span>

<span class="sd">        The &#39;age&#39; is only used to look up the time-dependent thresholds (passed into constructor).</span>
<span class="sd">        If threshold does not vary with time then &#39;age&#39; does not need to be specified (defaults to present day).</span>

<span class="sd">        Returns a list of &#39;ContouredContinent&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># time1 = time.time()</span>

        <span class="n">continent_separation_distance_threshold_radians</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_separation_distance_threshold_radians_function</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">continent_polygon_buffer_and_gap_distance_radians_function</span><span class="p">:</span>

            <span class="c1"># Convert 2-tuple of continent polygons to a 3-tuple where 2nd element is each continent polygon&#39;s buffer distance.</span>
            <span class="n">continent_polygons</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">polygon</span><span class="p">,</span>
                    <span class="c1"># Buffer distance for the current continent polygon...</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">continent_polygon_buffer_and_gap_distance_radians_function</span><span class="p">(</span>
                        <span class="n">age</span><span class="p">,</span> <span class="n">continent_feature_polygon</span>
                    <span class="p">),</span>
                    <span class="n">continent_feature_polygon</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">continent_feature_polygon</span> <span class="ow">in</span> <span class="n">continent_polygons</span>
            <span class="p">]</span>

            <span class="c1"># Find groups of continent polygons where each polygon in a group is within the specified distance of at least one other polygon in the group.</span>
            <span class="n">continent_polygon_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_continent_polygon_groups</span><span class="p">(</span>
                <span class="n">continent_polygons</span><span class="p">,</span> <span class="n">continent_separation_distance_threshold_radians</span>
            <span class="p">)</span>

            <span class="n">contoured_continents</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Create the contoured continents, excluding those with area below the area threshold (if specified).</span>
            <span class="k">for</span> <span class="n">continent_polygons_in_group</span> <span class="ow">in</span> <span class="n">continent_polygon_groups</span><span class="p">:</span>

                <span class="c1"># Find the grid points inside or near the current continent&#39;s polygons.</span>
                <span class="c1">#</span>
                <span class="c1"># Note: Each continental polygon may have a different buffer/gap distance (affecting which points are near each polygon).</span>
                <span class="n">grid_points_inside_continent</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_find_grid_points_inside_or_near_continent_polygons</span><span class="p">(</span>
                        <span class="n">continent_polygons_in_group</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Skip the current continent if its polygons (with buffer expansion) are too small such that they miss all the grid points.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">grid_points_inside_continent</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Contour the grid points that are inside the current continent&#39;s polygons.</span>
                <span class="n">contoured_continent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_contoured_continent</span><span class="p">(</span>
                    <span class="n">grid_points_inside_continent</span>
                <span class="p">)</span>

                <span class="c1"># If the area threshold is non-zero then exclude the current contoured continents if its area is below the threshold.</span>
                <span class="n">continent_contouring_area_threshold_steradians</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_area_threshold_steradians_function</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">continent_contouring_area_threshold_steradians</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>
                    <span class="o">&lt;</span> <span class="n">continent_contouring_area_threshold_steradians</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">contoured_continents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contoured_continent</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># not self.continent_polygon_buffer_and_gap_distance_radians_function ...</span>

            <span class="c1"># Convert 2-tuple of continent polygons to a 3-tuple where 2nd element is the polygon buffer distance of zero.</span>
            <span class="n">continent_polygons</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">continent_feature_polygon</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">continent_feature_polygon</span> <span class="ow">in</span> <span class="n">continent_polygons</span>
            <span class="p">]</span>

            <span class="c1"># Find groups of continent polygons where each polygon in a group is within the specified distance of at least one other polygon in the group.</span>
            <span class="n">continent_polygon_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_continent_polygon_groups</span><span class="p">(</span>
                <span class="n">continent_polygons</span><span class="p">,</span> <span class="n">continent_separation_distance_threshold_radians</span>
            <span class="p">)</span>

            <span class="n">continents</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Create the initial contoured continents, only excluding those with area below the area threshold (if specified).</span>
            <span class="k">for</span> <span class="n">continent_polygons_in_group</span> <span class="ow">in</span> <span class="n">continent_polygon_groups</span><span class="p">:</span>
                <span class="c1"># Find the grid points inside the current continent&#39;s polygons.</span>
                <span class="c1">#</span>
                <span class="c1"># Note: Each continental polygon has a zero buffer/gap distance</span>
                <span class="c1">#       (and so we don&#39;t need to consider points *near* each polygon).</span>
                <span class="n">grid_points_inside_continent</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_find_grid_points_inside_continent_polygons</span><span class="p">(</span>
                        <span class="n">continent_polygons_in_group</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Skip the current continent if its polygons are too small such that they miss all the grid points.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">grid_points_inside_continent</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Contour the grid points that are inside the current continent&#39;s polygons.</span>
                <span class="n">contoured_continent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_contoured_continent</span><span class="p">(</span>
                    <span class="n">grid_points_inside_continent</span>
                <span class="p">)</span>

                <span class="c1"># If the area threshold is non-zero then exclude the current contoured continents if its area is below the threshold.</span>
                <span class="n">continent_contouring_area_threshold_steradians</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_area_threshold_steradians_function</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">continent_contouring_area_threshold_steradians</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>
                    <span class="o">&lt;</span> <span class="n">continent_contouring_area_threshold_steradians</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_buffer_and_gap_distance_radians_function</span><span class="p">:</span>
                    <span class="c1"># The buffer distance for the current contoured continent.</span>
                    <span class="c1">#</span>
                    <span class="c1"># Note: Each continent polygon is actually an n-tuple with the third element being a pygplates.ReconstructedFeatureGeometry.</span>
                    <span class="c1">#       Passing &#39;pygplates.ReconstructedFeatureGeometry&#39;s to the buffer/gap distance function helps it decide the appropriate</span>
                    <span class="c1">#       buffer/gap for the contoured continent (that contours the associated polygons). For example, the function can look</span>
                    <span class="c1">#       at the plate IDs of the polygons (via their pygplates.Feature obtained from &#39;continent_feature_polygon.get_feature()&#39;).</span>
                    <span class="n">continent_feature_polygons</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">continent_polygon</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">continent_polygon</span> <span class="ow">in</span> <span class="n">continent_polygons_in_group</span>
                    <span class="p">]</span>
                    <span class="n">contouring_buffer_and_gap_distance_radians</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">continent_contouring_buffer_and_gap_distance_radians_function</span><span class="p">(</span>
                        <span class="n">age</span><span class="p">,</span> <span class="n">contoured_continent</span><span class="p">,</span> <span class="n">continent_feature_polygons</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">contouring_buffer_and_gap_distance_radians</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Add the current continent.</span>
                <span class="n">continents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_Continent</span><span class="p">(</span>
                        <span class="n">contoured_continent</span><span class="p">,</span>
                        <span class="n">continent_polygons_in_group</span><span class="p">,</span>
                        <span class="n">grid_points_inside_continent</span><span class="p">,</span>
                        <span class="n">contouring_buffer_and_gap_distance_radians</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># time2 = time.time()</span>
            <span class="c1"># print(&#39; contour continents({}): {:.2f}&#39;.format(len(continents), time2 - time1))</span>

            <span class="c1"># If any continent has a non-zero buffer/gap distance expansion then this could cause it to join with nearby continents forming a single merged continent.</span>
            <span class="n">merged_continents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_merged_continents</span><span class="p">(</span>
                <span class="n">continents</span><span class="p">,</span> <span class="n">continent_separation_distance_threshold_radians</span>
            <span class="p">)</span>

            <span class="n">contoured_continents</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Contour each merged continent.</span>
            <span class="k">for</span> <span class="n">merged_continent</span> <span class="ow">in</span> <span class="n">merged_continents</span><span class="p">:</span>
                <span class="c1"># If any continents in the current merged continent have non-zero buffer/gap distances then we&#39;ll need to expand</span>
                <span class="c1"># those continents and re-contour the entire list of (merged) continents.</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="n">continent</span><span class="o">.</span><span class="n">contouring_buffer_and_gap_distance_radians</span>
                    <span class="k">for</span> <span class="n">continent</span> <span class="ow">in</span> <span class="n">merged_continent</span><span class="o">.</span><span class="n">continents</span>
                <span class="p">):</span>

                    <span class="c1"># The grids points inside the merged continent include the grid points inside all its (merged) continents.</span>
                    <span class="n">grid_points_inside_merged_continent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">),</span> <span class="kc">False</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_longitudes</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">continent</span> <span class="ow">in</span> <span class="n">merged_continent</span><span class="o">.</span><span class="n">continents</span><span class="p">:</span>
                        <span class="n">grid_points_inside_merged_continent</span><span class="p">[</span>
                            <span class="n">continent</span><span class="o">.</span><span class="n">grid_points_inside_continent</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># Find the grid points near the current merged continent&#39;s polygons.</span>
                    <span class="c1">#</span>
                    <span class="c1"># Note: Each continent (in the merged continent) may have a different buffer/gap distance.</span>
                    <span class="n">grid_points_near_merged_continent</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_find_grid_points_near_merged_continent</span><span class="p">(</span><span class="n">merged_continent</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="c1"># Add these nearby grid points to those inside the merged continent.</span>
                    <span class="n">grid_points_inside_merged_continent</span><span class="p">[</span>
                        <span class="n">grid_points_near_merged_continent</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># Contour the grid points that are inside the merged continent&#39;s polygons.</span>
                    <span class="n">contoured_continent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_contoured_continent</span><span class="p">(</span>
                        <span class="n">grid_points_inside_merged_continent</span>
                    <span class="p">)</span>

                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_continent</span><span class="o">.</span><span class="n">continents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># There&#39;s only one continent and it has no buffer/gap distance, so its contour will also be the merged continent&#39;s contour.</span>
                    <span class="n">contoured_continent</span> <span class="o">=</span> <span class="n">merged_continent</span><span class="o">.</span><span class="n">continents</span><span class="p">[</span>
                        <span class="mi">0</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">contoured_continent</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                        <span class="s2">&quot;Shouldn&#39;t have multiple merged continents all with zero buffer/gap distances&quot;</span>
                    <span class="p">)</span>

                <span class="n">contoured_continents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contoured_continent</span><span class="p">)</span>

            <span class="c1"># time3 = time.time()</span>
            <span class="c1"># print(&#39; contour merged continents({}): {:.2f}&#39;.format(len(merged_continents), time3 - time2))</span>

        <span class="c1"># Remove any ocean areas (regions which exclude continental crust) that are below the exclusion area threshold.</span>
        <span class="n">continent_exclusion_area_threshold_steradians</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_exclusion_area_threshold_steradians_function</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">continent_exclusion_area_threshold_steradians</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_ocean_areas_below_exclusion_threshold</span><span class="p">(</span>
                <span class="n">contoured_continents</span><span class="p">,</span> <span class="n">continent_exclusion_area_threshold_steradians</span>
            <span class="p">)</span>

        <span class="c1"># time_end = time.time()</span>
        <span class="c1"># print(&#39;calculate_contoured_continents({}): {:.2f}&#39;.format(len(contoured_continents), time_end - time1))</span>

        <span class="k">return</span> <span class="n">contoured_continents</span></div>


<div class="viewcode-block" id="ContinentContouring._Continent">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._Continent">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">_Continent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private inner class containing information about a continent (before continents are merged due to non-zero buffer/gap distances).&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">contoured_continent</span><span class="p">,</span>
            <span class="n">continent_polygons</span><span class="p">,</span>
            <span class="n">grid_points_inside_continent</span><span class="p">,</span>
            <span class="n">contouring_buffer_and_gap_distance_radians</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contoured_continent</span> <span class="o">=</span> <span class="n">contoured_continent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_polygons</span> <span class="o">=</span> <span class="n">continent_polygons</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_points_inside_continent</span> <span class="o">=</span> <span class="n">grid_points_inside_continent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contouring_buffer_and_gap_distance_radians</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">contouring_buffer_and_gap_distance_radians</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="ContinentContouring._MergedContinent">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._MergedContinent">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">_MergedContinent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private inner class containing information about a merged continent (referencing several continents merged due to non-zero buffer/gap distances).&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">continents</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continents</span> <span class="o">=</span> <span class="n">continents</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contoured_continent</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># to be set later (after constructor)</span></div>


<div class="viewcode-block" id="ContinentContouring._find_merged_continents">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._find_merged_continents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_merged_continents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">continents</span><span class="p">,</span> <span class="n">continent_separation_distance_threshold_radians</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge any continents that are within the continent separation distance of each other after expansion by their buffer/gap distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># time1 = time.time()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_are_continents_near_each_other</span><span class="p">(</span><span class="n">continent1_index</span><span class="p">,</span> <span class="n">continent2_index</span><span class="p">):</span>
            <span class="n">continent1</span> <span class="o">=</span> <span class="n">continents</span><span class="p">[</span><span class="n">continent1_index</span><span class="p">]</span>
            <span class="n">continent2</span> <span class="o">=</span> <span class="n">continents</span><span class="p">[</span><span class="n">continent2_index</span><span class="p">]</span>
            <span class="c1"># If both continents have no buffer/gap expansion then we already know they are farther apart</span>
            <span class="c1"># than the continent separation distance (otherwise they wouldn&#39;t be separate continents).</span>
            <span class="c1"># Hence they are not near each other.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">continent1</span><span class="o">.</span><span class="n">contouring_buffer_and_gap_distance_radians</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">continent2</span><span class="o">.</span><span class="n">contouring_buffer_and_gap_distance_radians</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># The distance threshold is the continent separation distance plus the sum of the buffer/gap distance of both continents.</span>
            <span class="c1"># And we clamp to a maximum of PI.</span>
            <span class="n">distance_threshold_radians</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                <span class="n">continent_separation_distance_threshold_radians</span>
                <span class="o">+</span> <span class="n">continent1</span><span class="o">.</span><span class="n">contouring_buffer_and_gap_distance_radians</span>
                <span class="o">+</span> <span class="n">continent2</span><span class="o">.</span><span class="n">contouring_buffer_and_gap_distance_radians</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Test all pairs of polygons between each continent.</span>
            <span class="c1">#</span>
            <span class="c1"># Note: Each continent polygon is actually a tuple where the first element is a pygplates.PolygonOnSphere.</span>
            <span class="c1">#       The second element of tuple is the buffer distance of each continent polygon.</span>
            <span class="c1">#       But since we&#39;re in this function then that should be zero</span>
            <span class="c1">#       (ie, we&#39;re only using buffer distances for *contoured* continents, not individual polygons).</span>
            <span class="k">for</span> <span class="n">polygon1</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="ow">in</span> <span class="n">continent1</span><span class="o">.</span><span class="n">continent_polygons</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">polygon2</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="ow">in</span> <span class="n">continent2</span><span class="o">.</span><span class="n">continent_polygons</span><span class="p">:</span>
                    <span class="c1"># See if the two continent polygons are near each other (within the distance threshold).</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span>
                            <span class="n">polygon1</span><span class="p">,</span>
                            <span class="n">polygon2</span><span class="p">,</span>
                            <span class="n">distance_threshold_radians</span><span class="p">,</span>
                            <span class="n">geometry1_is_solid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">geometry2_is_solid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Each continent will have a list of other continents that are near it.</span>
        <span class="n">nearby_continent_indices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">continents</span><span class="p">))</span>
        <span class="p">]</span>  <span class="c1"># initially a list of empty lists</span>
        <span class="c1"># Find the nearby continents.</span>
        <span class="k">for</span> <span class="n">continent1_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">continents</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">continent2_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">continent1_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">continents</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">_are_continents_near_each_other</span><span class="p">(</span><span class="n">continent1_index</span><span class="p">,</span> <span class="n">continent2_index</span><span class="p">):</span>
                    <span class="c1"># Add links in both directions.</span>
                    <span class="n">nearby_continent_indices</span><span class="p">[</span><span class="n">continent1_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">continent2_index</span><span class="p">)</span>
                    <span class="n">nearby_continent_indices</span><span class="p">[</span><span class="n">continent2_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">continent1_index</span><span class="p">)</span>

        <span class="c1"># Whether a continent has been added to a group yet.</span>
        <span class="n">have_added_continent_to_a_group</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">continents</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_add_nearby_continents_to_group</span><span class="p">(</span><span class="n">continent_index_group</span><span class="p">,</span> <span class="n">continent_index</span><span class="p">):</span>
            <span class="c1"># Iterate over the continents near &#39;continent_index&#39;.</span>
            <span class="k">for</span> <span class="n">nearby_continent_index</span> <span class="ow">in</span> <span class="n">nearby_continent_indices</span><span class="p">[</span><span class="n">continent_index</span><span class="p">]:</span>
                <span class="c1"># Only add nearby continent to the group if it hasn&#39;t already been added to a group.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">have_added_continent_to_a_group</span><span class="p">[</span><span class="n">nearby_continent_index</span><span class="p">]:</span>
                    <span class="c1"># Add the nearby continent and mark it as having been added.</span>
                    <span class="n">continent_index_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nearby_continent_index</span><span class="p">)</span>
                    <span class="n">have_added_continent_to_a_group</span><span class="p">[</span><span class="n">nearby_continent_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># Recursively add continents near the current nearby continent.</span>
                    <span class="n">_add_nearby_continents_to_group</span><span class="p">(</span>
                        <span class="n">continent_index_group</span><span class="p">,</span> <span class="n">nearby_continent_index</span>
                    <span class="p">)</span>

        <span class="n">merged_continents</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Create the merged continents.</span>
        <span class="k">for</span> <span class="n">continent_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">continents</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">have_added_continent_to_a_group</span><span class="p">[</span><span class="n">continent_index</span><span class="p">]:</span>
                <span class="c1"># Add the current continent and mark it as having been added.</span>
                <span class="n">continent_index_group</span> <span class="o">=</span> <span class="p">[</span><span class="n">continent_index</span><span class="p">]</span>
                <span class="n">have_added_continent_to_a_group</span><span class="p">[</span><span class="n">continent_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Recursively add any nearby continents to the same group (if they haven&#39;t already been added to a group).</span>
                <span class="n">_add_nearby_continents_to_group</span><span class="p">(</span><span class="n">continent_index_group</span><span class="p">,</span> <span class="n">continent_index</span><span class="p">)</span>
                <span class="c1"># Create a merged continent from the group of nearby continents.</span>
                <span class="n">merged_continents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MergedContinent</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">continents</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">continent_index_group</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">merged_continent</span><span class="o">.</span><span class="n">continents</span><span class="p">)</span> <span class="k">for</span> <span class="n">merged_continent</span> <span class="ow">in</span> <span class="n">merged_continents</span>
        <span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">continents</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Sum of continents in merged continents is incorrect&quot;</span><span class="p">)</span>

        <span class="c1"># time2 = time.time()</span>
        <span class="c1"># print(&#39; _find_merged_continents({}): {:.2f}&#39;.format(len(merged_continents), time2 - time1))</span>

        <span class="k">return</span> <span class="n">merged_continents</span></div>


<div class="viewcode-block" id="ContinentContouring._remove_ocean_areas_below_exclusion_threshold">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._remove_ocean_areas_below_exclusion_threshold">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_remove_ocean_areas_below_exclusion_threshold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">contoured_continents</span><span class="p">,</span> <span class="n">continent_exclusion_area_threshold_steradians</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove any ocean polygon rings in contoured continents that are below the exclusion area threshold.</span>

<span class="sd">        And remove any continent landmasses inside those removed ocean polygon rings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Return early if there are no contoured continents.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">contoured_continents</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># time1 = time.time()</span>

        <span class="c1">#</span>
        <span class="c1"># Find those ocean polygon rings (ie, which exclude continental crust) that are below the exclusion area threshold.</span>
        <span class="c1"># These rings will now include (rather than exclude) continental crust.</span>
        <span class="c1">#</span>
        <span class="c1"># So we&#39;ll first remove the offending interior rings from their containing polygon (in the case of continent polygons) or</span>
        <span class="c1"># remove the polygon altogether (in the case of ocean polygons).</span>
        <span class="c1">#</span>
        <span class="c1"># Then we&#39;ll find all continent polygons that are inside these removed ocean polygon rings and remove them altogether</span>
        <span class="c1"># (since they are inside an ocean that no longer exists and hence they are no longer a separate continent).</span>
        <span class="c1">#</span>
        <span class="c1"># Doing all this will remove those ocean holes below the threshold, effectively turning them into continental crust.</span>
        <span class="c1">#</span>

        <span class="c1"># First find all ocean polygon rings below threshold and remove them.</span>
        <span class="n">removed_ocean_ring_polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">contoured_continent</span> <span class="ow">in</span> <span class="n">contoured_continents</span><span class="p">:</span>
            <span class="c1"># For each polygon that *includes* continental crust we&#39;ll look at its *interior* rings (which exclude continental crust).</span>
            <span class="k">for</span> <span class="n">polygon_index</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_polygons_including_continent</span>
            <span class="p">):</span>
                <span class="n">interior_rings_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">interior_ring_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                    <span class="n">polygon</span><span class="o">.</span><span class="n">get_number_of_interior_rings</span><span class="p">()</span>
                <span class="p">):</span>
                    <span class="n">interior_ring_points</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_interior_ring_points</span><span class="p">(</span>
                        <span class="n">interior_ring_index</span>
                    <span class="p">)</span>
                    <span class="n">interior_ring_polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span>
                        <span class="n">interior_ring_points</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">interior_ring_polygon</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>
                        <span class="o">&lt;</span> <span class="n">continent_exclusion_area_threshold_steradians</span>
                    <span class="p">):</span>
                        <span class="n">removed_ocean_ring_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interior_ring_polygon</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">interior_rings_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interior_ring_points</span><span class="p">)</span>

                <span class="c1"># If some interior rings have area below the exclusion threshold then remove them by</span>
                <span class="c1"># creating a new polygon without them (need to do this because polygons are immutable).</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">interior_rings_to_keep</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_number_of_interior_rings</span><span class="p">():</span>
                    <span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span>
                        <span class="n">polygon</span><span class="o">.</span><span class="n">get_exterior_ring_points</span><span class="p">(),</span> <span class="n">interior_rings_to_keep</span>
                    <span class="p">)</span>
                    <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_polygons_including_continent</span><span class="p">[</span><span class="n">polygon_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">polygon</span>
                    <span class="p">)</span>

            <span class="c1"># For each polygon that *excludes* continental crust we&#39;ll look at its *exterior* ring (which excludes continental crust).</span>
            <span class="n">polygon_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">polygon_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span>
            <span class="p">):</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span><span class="p">[</span>
                    <span class="n">polygon_index</span>
                <span class="p">]</span>
                <span class="n">exterior_ring_polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span>
                    <span class="n">polygon</span><span class="o">.</span><span class="n">get_exterior_ring_points</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">exterior_ring_polygon</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>
                    <span class="o">&lt;</span> <span class="n">continent_exclusion_area_threshold_steradians</span>
                <span class="p">):</span>
                    <span class="n">removed_ocean_ring_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exterior_ring_polygon</span><span class="p">)</span>
                    <span class="c1"># Remove the polygon.</span>
                    <span class="c1"># Note: Polygons that *exclude* continental crust have no interior rings.</span>
                    <span class="k">del</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span><span class="p">[</span><span class="n">polygon_index</span><span class="p">]</span>
                    <span class="k">continue</span>
                <span class="n">polygon_index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_is_polygon_inside_removed_ocean_ring_polygon</span><span class="p">(</span>
            <span class="n">polygon</span><span class="p">,</span> <span class="n">removed_ocean_ring_polygon</span>
        <span class="p">):</span>
            <span class="c1"># Find a vertex of the polygon that is not right *on* the outline of the removed ocean ring polygon</span>
            <span class="c1"># (it&#39;s possible the two polygons are abutting each other, ie, sharing part of their boundary outline).</span>
            <span class="c1"># If it&#39;s *on* the outline then we can&#39;t do a point-in-polygon test to determine whether polygon is inside or outside.</span>
            <span class="k">for</span> <span class="n">point_on_polygon</span> <span class="ow">in</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_exterior_ring_points</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span>
                        <span class="n">point_on_polygon</span><span class="p">,</span> <span class="n">removed_ocean_ring_polygon</span><span class="p">,</span> <span class="mf">1e-5</span>
                    <span class="p">)</span>
                    <span class="ow">is</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="c1"># Found a polygon vertex that is away from the outline of the removed ocean ring polygon.</span>
                    <span class="c1"># So, if the vertex is inside the removed ocean ring polygon then the entire polygon must also be inside it.</span>
                    <span class="k">return</span> <span class="n">removed_ocean_ring_polygon</span><span class="o">.</span><span class="n">is_point_in_polygon</span><span class="p">(</span>
                        <span class="n">point_on_polygon</span>
                    <span class="p">)</span>

            <span class="c1"># All points on the polygon&#39;s exterior ring are *on* the outline of the removed ocean ring polygon.</span>
            <span class="c1"># This is extremely unlikely, but if it happens then consider the polygon to be inside.</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Next find all continent polygons that are inside the removed ocean polygon rings and remove them altogether.</span>
        <span class="n">contoured_continent_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">contoured_continent_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">contoured_continents</span><span class="p">):</span>
            <span class="n">contoured_continent</span> <span class="o">=</span> <span class="n">contoured_continents</span><span class="p">[</span><span class="n">contoured_continent_index</span><span class="p">]</span>

            <span class="n">polygon_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">polygon_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_polygons_including_continent</span>
            <span class="p">):</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_polygons_including_continent</span><span class="p">[</span>
                    <span class="n">polygon_index</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">removed_ocean_ring_polygon</span> <span class="ow">in</span> <span class="n">removed_ocean_ring_polygons</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_is_polygon_inside_removed_ocean_ring_polygon</span><span class="p">(</span>
                        <span class="n">polygon</span><span class="p">,</span> <span class="n">removed_ocean_ring_polygon</span>
                    <span class="p">):</span>
                        <span class="c1"># Remove the current polygon contour from the contoured continent.</span>
                        <span class="k">del</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_polygons_including_continent</span><span class="p">[</span>
                            <span class="n">polygon_index</span>
                        <span class="p">]</span>
                        <span class="n">polygon_index</span> <span class="o">-=</span> <span class="p">(</span>
                            <span class="mi">1</span>  <span class="c1"># undo the subsequent increment to next polygon</span>
                        <span class="p">)</span>
                        <span class="k">break</span>  <span class="c1"># skip to the next polygon</span>
                <span class="n">polygon_index</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># If the current contoured continent has no polygons then remove the contoured continent.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_polygons_including_continent</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_polygons_excluding_continent</span>
            <span class="p">):</span>
                <span class="k">del</span> <span class="n">contoured_continents</span><span class="p">[</span><span class="n">contoured_continent_index</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="n">contoured_continent_index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># If we are left with no contoured continents (after starting with at least one) then add a</span>
        <span class="c1"># single empty contoured continent (which implies a single landmass covering the entire globe).</span>
        <span class="c1">#</span>
        <span class="c1"># This can happen there was a very large landmass that only had polygons that *excluded* continental crust,</span>
        <span class="c1"># and all those *excluding* polygons were removed, leaving a landmass that covered the entire globe.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">contoured_continents</span><span class="p">:</span>
            <span class="n">contoured_continents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ContouredContinent</span><span class="p">())</span></div>


        <span class="c1"># time2 = time.time()</span>
        <span class="c1"># print(&#39; _remove_ocean_areas_below_exclusion_threshold({}): {:.2f}&#39;.format(len(removed_ocean_ring_polygons), time2 - time1))</span>

<div class="viewcode-block" id="ContinentContouring._find_continent_polygon_groups">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._find_continent_polygon_groups">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_continent_polygon_groups</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">continent_polygons</span><span class="p">,</span> <span class="n">continent_separation_distance_threshold_radians</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find groups of polygons where each polygon in a group (when expanded by its individual polygon buffer distance) is within the</span>
<span class="sd">        specified separation distance of at least one other polygon in the group (also expanded by its individual polygon buffer distance).</span>

<span class="sd">        Note that each continent polygon should be an n-tuple where the first element is a pygplates.PolygonOnSphere and</span>
<span class="sd">        the second is its buffer/gap distance (in radians).</span>
<span class="sd">        Subsequent tuple elements (beyond the two) are optional, and the full tuple will be passed intact to the output groups.</span>

<span class="sd">        This is useful when creating an individual continent for each group.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># time1 = time.time()</span>

        <span class="n">continent_polygon_groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">continent_polygon</span> <span class="ow">in</span> <span class="n">continent_polygons</span><span class="p">:</span>
            <span class="n">polygon</span><span class="p">,</span> <span class="n">polygon_buffer_distance_radians</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">continent_polygon</span>

            <span class="c1"># See if the current continent polygon is near any polygon in any group.</span>
            <span class="n">continent_polygon_group_index</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># index of first group found (if any)</span>

            <span class="c1"># Iterate over the polygon groups.</span>
            <span class="n">group_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">group_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">continent_polygon_groups</span><span class="p">):</span>
                <span class="c1"># Iterate over polygons in the current group.</span>
                <span class="k">for</span> <span class="p">(</span>
                    <span class="n">polygon_in_group</span><span class="p">,</span>
                    <span class="n">polygon_in_group_buffer_distance_radians</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">_</span><span class="p">,</span>
                <span class="p">)</span> <span class="ow">in</span> <span class="n">continent_polygon_groups</span><span class="p">[</span><span class="n">group_index</span><span class="p">]:</span>

                    <span class="c1"># The distance threshold is the continent separation distance plus the sum of each polygon&#39;s buffer distance, clamped to a maximum of PI.</span>
                    <span class="n">distance_threshold_radians</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                        <span class="n">continent_separation_distance_threshold_radians</span>
                        <span class="o">+</span> <span class="n">polygon_buffer_distance_radians</span>
                        <span class="o">+</span> <span class="n">polygon_in_group_buffer_distance_radians</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="c1"># See if the current continent polygon is near the current polygon in the current group.</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span>
                            <span class="n">polygon</span><span class="p">,</span>
                            <span class="n">polygon_in_group</span><span class="p">,</span>
                            <span class="n">distance_threshold_radians</span><span class="p">,</span>
                            <span class="n">geometry1_is_solid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">geometry2_is_solid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="p">):</span>

                        <span class="c1"># If the current continent polygon hasn&#39;t been added to a group yet then add it now.</span>
                        <span class="k">if</span> <span class="n">continent_polygon_group_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">continent_polygon_group_index</span> <span class="o">=</span> <span class="n">group_index</span>
                            <span class="n">continent_polygon_groups</span><span class="p">[</span>
                                <span class="n">continent_polygon_group_index</span>
                            <span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">continent_polygon</span><span class="p">)</span>
                        <span class="c1"># Otherwise it is near another group, so merge that group into the current continent polygon&#39;s group.</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Merge the current group into group that the current continent polygon belongs to.</span>
                            <span class="n">continent_polygon_groups</span><span class="p">[</span>
                                <span class="n">continent_polygon_group_index</span>
                            <span class="p">]</span> <span class="o">+=</span> <span class="n">continent_polygon_groups</span><span class="p">[</span><span class="n">group_index</span><span class="p">]</span>
                            <span class="c1"># And then delete the current group.</span>
                            <span class="k">del</span> <span class="n">continent_polygon_groups</span><span class="p">[</span><span class="n">group_index</span><span class="p">]</span>
                            <span class="n">group_index</span> <span class="o">-=</span> <span class="p">(</span>
                                <span class="mi">1</span>  <span class="c1"># undo the subsequent increment to next group</span>
                            <span class="p">)</span>

                        <span class="c1"># Finished visiting polygons in the current group, so skip to the next group.</span>
                        <span class="k">break</span>

                <span class="c1"># Next group.</span>
                <span class="n">group_index</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># If the current continent polygon is not near any group then add it to a new group.</span>
            <span class="k">if</span> <span class="n">continent_polygon_group_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">continent_polygon_groups</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">continent_polygon</span><span class="p">])</span>

        <span class="c1"># time2 = time.time()</span>
        <span class="c1"># print(&#39; _find_continent_polygon_groups({}): {:.2f}&#39;.format(len(continent_polygon_groups), time2 - time1))</span>

        <span class="k">return</span> <span class="n">continent_polygon_groups</span></div>


<div class="viewcode-block" id="ContinentContouring._find_grid_points_inside_continent_polygons">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._find_grid_points_inside_continent_polygons">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_grid_points_inside_continent_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">continent_polygons</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the latitude/longitude grid points that are inside (one or more of) the specified polygons.</span>

<span class="sd">        Note that each continent polygon should be an n-tuple where the first element is a pygplates.PolygonOnSphere.</span>
<span class="sd">        Subsequent tuple elements (beyond the first) are optional and ignored.</span>

<span class="sd">        The grid spacing of these grid points was specified in the constructor.</span>

<span class="sd">        Returns a 2D boolean numpy array of shape (num_latitudes, num_longitudes).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># time1 = time.time()</span>

        <span class="c1"># Find the polygon (if any) containing each grid point.</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">continent_polygon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">continent_polygon</span> <span class="ow">in</span> <span class="n">continent_polygons</span><span class="p">]</span>
        <span class="n">polygons_containing_points</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">points_in_polygons</span><span class="o">.</span><span class="n">find_polygons_using_points_spatial_tree</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points_spatial_tree</span><span class="p">,</span> <span class="n">polygons</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># time2 = time.time()</span>

        <span class="c1"># Determine which grid points are inside the polygons.</span>
        <span class="n">points_inside_polygons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">contouring_point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">)):</span>
            <span class="c1"># If the current point is inside any polygon then mark it as such.</span>
            <span class="k">if</span> <span class="n">polygons_containing_points</span><span class="p">[</span><span class="n">contouring_point_index</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">points_inside_polygons</span><span class="p">[</span><span class="n">contouring_point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># time3 = time.time()</span>
        <span class="c1"># print(&#39;  _find_grid_points_inside_continent_polygons({}, {}): {:.2f} {:.2f}&#39;.format(len(self.contouring_points), len(polygons), time2 - time1, time3 - time2))</span>

        <span class="c1"># Reshape 1D array as 2D array indexed by (latitude, longitude) - same order as the points.</span>
        <span class="k">return</span> <span class="n">points_inside_polygons</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_longitudes</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ContinentContouring._find_grid_points_inside_or_near_continent_polygons">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._find_grid_points_inside_or_near_continent_polygons">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_grid_points_inside_or_near_continent_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">continent_polygons</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the latitude/longitude grid points that are inside or near the specified continental polygons.</span>

<span class="sd">        Note that each continental polygon can have a different buffer/grap distance</span>
<span class="sd">        (affecting which points are near each polygon).</span>

<span class="sd">        Note that each continent polygon should be an n-tuple where the first element is a pygplates.PolygonOnSphere and</span>
<span class="sd">        the second is its buffer/gap distance (in radians).</span>
<span class="sd">        Subsequent tuple elements (beyond the two) are optional and ignored.</span>

<span class="sd">        The grid spacing of these grid points was specified in the constructor.</span>

<span class="sd">        Returns a 2D boolean numpy array of shape (num_latitudes, num_longitudes).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">points_inside_or_near_polygons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># time1 = time.time()</span>

        <span class="c1"># Find the polygon (if any) containing each grid point.</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">continent_polygon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">continent_polygon</span> <span class="ow">in</span> <span class="n">continent_polygons</span><span class="p">]</span>
        <span class="n">polygons_containing_points</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">points_in_polygons</span><span class="o">.</span><span class="n">find_polygons_using_points_spatial_tree</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points_spatial_tree</span><span class="p">,</span> <span class="n">polygons</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Determine which grid points are inside the polygons.</span>
        <span class="k">for</span> <span class="n">contouring_point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">)):</span>
            <span class="c1"># If the current point is inside any polygon then mark it as such.</span>
            <span class="k">if</span> <span class="n">polygons_containing_points</span><span class="p">[</span><span class="n">contouring_point_index</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">points_inside_or_near_polygons</span><span class="p">[</span><span class="n">contouring_point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># time2 = time.time()</span>

        <span class="c1"># Group together polygons with the same polygon buffer distance.</span>
        <span class="n">polygon_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">polygon_buffer_distance_radians</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="ow">in</span> <span class="n">continent_polygons</span><span class="p">:</span>
            <span class="c1"># We can ignore polygons with a zero buffer distance (they don&#39;t get expanded).</span>
            <span class="k">if</span> <span class="n">polygon_buffer_distance_radians</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">polygon_buffer_distance_radians</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">polygon_groups</span><span class="p">:</span>
                    <span class="n">polygon_groups</span><span class="p">[</span><span class="n">polygon_buffer_distance_radians</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">polygon_groups</span><span class="p">[</span><span class="n">polygon_buffer_distance_radians</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

        <span class="c1"># Find nearest points to each group of polygons</span>
        <span class="c1"># (with all polygons in a group having the same polygon buffer distance).</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">polygon_buffer_distance_radians</span><span class="p">,</span>
            <span class="n">polygons_in_group</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="n">polygon_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># The distance threshold is the polygon buffer distance clamped to a maximum of PI.</span>
            <span class="n">distance_threshold_radians</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">polygon_buffer_distance_radians</span><span class="p">)</span>

            <span class="c1"># Find the polygons in the current group (if any) near each point.</span>
            <span class="n">points_near_polygons_in_group</span> <span class="o">=</span> <span class="n">proximity_query</span><span class="o">.</span><span class="n">find_closest_geometries_to_points_using_points_spatial_tree</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points_spatial_tree</span><span class="p">,</span>
                <span class="n">polygons_in_group</span><span class="p">,</span>
                <span class="n">distance_threshold_radians</span><span class="o">=</span><span class="n">distance_threshold_radians</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">contouring_point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">points_near_polygons_in_group</span><span class="p">[</span><span class="n">contouring_point_index</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">points_inside_or_near_polygons</span><span class="p">[</span><span class="n">contouring_point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># time3 = time.time()</span>
        <span class="c1"># print(&#39;  _find_grid_points_inside_or_near_continent_polygons({}, {}): {:.2f} {:.2f}&#39;.format(</span>
        <span class="c1">#    len(self.contouring_points), len(continent_polygons), time2 - time1, time3 - time2))</span>

        <span class="c1"># Reshape 1D array as 2D array indexed by (latitude, longitude) - same order as the points.</span>
        <span class="k">return</span> <span class="n">points_inside_or_near_polygons</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_longitudes</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ContinentContouring._find_grid_points_inside_contoured_continents">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._find_grid_points_inside_contoured_continents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_grid_points_inside_contoured_continents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contoured_continents</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the latitude/longitude grid points that are inside (one or more of) the specified contoured continents.</span>

<span class="sd">        The grid spacing of these grid points was specified in the constructor.</span>

<span class="sd">        Returns a 2D boolean numpy array of shape (num_latitudes, num_longitudes).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># time1 = time.time()</span>

        <span class="c1"># Test all grid points against each contoured continent.</span>
        <span class="c1">#</span>
        <span class="c1"># Note that the original point-in-polygon boolean grid mask (calculated from the input continent polygons before contouring)</span>
        <span class="c1"># may not match the result of point-in-contoured-continent tests (done here) since any contoured continents with area below</span>
        <span class="c1"># the area threshold would have been removed. So we do our own point-in-contoured-continent tests here.</span>
        <span class="n">points_inside_any_contoured_continent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">),</span> <span class="kc">False</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">contoured_continent</span> <span class="ow">in</span> <span class="n">contoured_continents</span><span class="p">:</span>
            <span class="n">points_inside_contoured_continent</span> <span class="o">=</span> <span class="n">contoured_continent</span><span class="o">.</span><span class="n">are_points_inside</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points_spatial_tree</span>
            <span class="p">)</span>

            <span class="c1"># Combine the results of current contoured continent with previous contoured continents.</span>
            <span class="c1">#</span>
            <span class="c1"># Note that there is typically only a handful of contoured continents in general, so this should not be a bottleneck.</span>
            <span class="n">points_inside_any_contoured_continent</span><span class="p">[</span><span class="n">points_inside_contoured_continent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">True</span>
            <span class="p">)</span>

        <span class="c1"># time2 = time.time()</span>
        <span class="c1"># print(&#39;  _find_grid_points_inside_contoured_continents({}): {:.2f}&#39;.format(len(contoured_continents), time2 - time1))</span>

        <span class="c1"># Reshape 1D array as 2D array indexed by (latitude, longitude) - same order as the points.</span>
        <span class="k">return</span> <span class="n">points_inside_any_contoured_continent</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_longitudes</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ContinentContouring._find_grid_points_near_merged_continent">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._find_grid_points_near_merged_continent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_grid_points_near_merged_continent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">merged_continent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the latitude/longitude grid points that are near the polygons of the continents in the specified merged continent.</span>

<span class="sd">        The grid spacing of these grid points was specified in the constructor.</span>

<span class="sd">        Returns a 2D boolean numpy array of shape (num_latitudes, num_longitudes).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># time1 = time.time()</span>

        <span class="c1"># Determine which grid points are near the polygons of the continents in the merged continent.</span>
        <span class="n">points_near_merged_continent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">continent</span> <span class="ow">in</span> <span class="n">merged_continent</span><span class="o">.</span><span class="n">continents</span><span class="p">:</span>

            <span class="c1"># The distance threshold is the continent buffer/gap distance clamped to a maximum of PI.</span>
            <span class="n">distance_threshold_radians</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">continent</span><span class="o">.</span><span class="n">contouring_buffer_and_gap_distance_radians</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">distance_threshold_radians</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># Each continent polygon is actually a tuple where the first element is a pygplates.PolygonOnSphere.</span>
                <span class="c1">#</span>
                <span class="c1"># Note: The second element of tuple is the buffer distance of each continent polygon.</span>
                <span class="c1">#       But since we&#39;re in this function then that should be zero</span>
                <span class="c1">#       (ie, we&#39;re only using buffer distances for *contoured* continents, not individual polygons).</span>
                <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">continent_polygon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">continent_polygon</span> <span class="ow">in</span> <span class="n">continent</span><span class="o">.</span><span class="n">continent_polygons</span>
                <span class="p">]</span>

                <span class="c1"># Find the polygons (if any) near each point.</span>
                <span class="n">points_near_continent</span> <span class="o">=</span> <span class="n">proximity_query</span><span class="o">.</span><span class="n">find_closest_geometries_to_points_using_points_spatial_tree</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points_spatial_tree</span><span class="p">,</span>
                    <span class="n">polygons</span><span class="p">,</span>
                    <span class="n">distance_threshold_radians</span><span class="o">=</span><span class="n">distance_threshold_radians</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">contouring_point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">points_near_continent</span><span class="p">[</span><span class="n">contouring_point_index</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">points_near_merged_continent</span><span class="p">[</span><span class="n">contouring_point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># time2 = time.time()</span>
        <span class="c1"># print(&#39;  _find_grid_points_near_merged_continent({}): {:.2f}&#39;.format(len(merged_continent.continents), time2 - time1))</span>

        <span class="c1"># Reshape 1D array as 2D array indexed by (latitude, longitude) - same order as the points.</span>
        <span class="k">return</span> <span class="n">points_near_merged_continent</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_longitudes</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ContinentContouring._create_contoured_continent">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._create_contoured_continent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_contoured_continent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points_inside_continent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create landmasses and their boundaries from the specified mask of grid points.</span>

<span class="sd">        Returns a single &#39;ContouredContinent&#39; containing one or more landmasses and their contoured boundaries,</span>
<span class="sd">        or None if none of the grid points are inside continent.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># time1 = time.time()</span>

        <span class="n">num_latitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span>
        <span class="n">num_longitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_longitudes</span>

        <span class="n">num_latitude_intervals</span> <span class="o">=</span> <span class="n">num_latitudes</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">num_longitude_intervals</span> <span class="o">=</span> <span class="n">num_longitudes</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1">#</span>
        <span class="c1"># Use the Marching Squares algorithm.</span>
        <span class="c1">#</span>
        <span class="c1"># This is a 2D version (surface of the globe) of the 3D Marching Cubes algorithm.</span>
        <span class="c1"># However the main difference between this and using skimage.measure.find_contours(),</span>
        <span class="c1"># that we used previously and that also uses the Marching Squares algorithm, is we wrap across the</span>
        <span class="c1"># dateline and handle the poles. In this way we avoid contour polygons clamped to the dateline.</span>
        <span class="c1">#</span>
        <span class="c1"># The way we handle wrapping around the dateline is to have grid points on the dateline (ie, at both longitude -180 and 180).</span>
        <span class="c1"># This way lat/lon points on the left side of uniform lat/lon grid of points actually map to the same points on the globe</span>
        <span class="c1"># as the lat/lon points on the right side of the uniform lat/lon grid of points, and so they will generated the same</span>
        <span class="c1"># point-in-continent-polygon and point-near-continent-polygon results. This ensures the Marching Squares algorithm (below)</span>
        <span class="c1"># will produce continuous contour segments across the dateline (as we move from a square on one side of the dateline to the</span>
        <span class="c1"># adjacent square on the other side).</span>
        <span class="c1">#</span>
        <span class="c1"># We also handle the poles correctly by having the bottom row of lat/lon points map to the South pole and the top row</span>
        <span class="c1"># map to the North pole. Because all points in a (top or bottom) row map to the same point (pole) on the globe they will</span>
        <span class="c1"># generate the same point-in-continent-polygon and point-near-continent-polygon results. And because the entire row is either</span>
        <span class="c1"># inside or outside a contour the Marching Squares algorithm (below) cannot generate contour segments that penetrate the row.</span>
        <span class="c1"># This essentially avoids the problem at the poles.</span>
        <span class="c1">#</span>

        <span class="c1">#</span>
        <span class="c1"># First find those latitude/longitude squares (each square has 4 points from uniform lat/lon grid of points)</span>
        <span class="c1"># that have some of its 4 points inside continent and some outside. These are squares that will contain an edge (segment)</span>
        <span class="c1"># of a contour polygon. According to the Marching Squares algorithm there are 16 cases. Two of these have all 4 points</span>
        <span class="c1"># either inside or outside (and hence have no segments). Twelve cases have a single segment.</span>
        <span class="c1"># And two cases have two segments (because two diagonals points are inside and the other two diagonal points are outside).</span>
        <span class="c1"># Here we can choose to either join two separated contour islands or keep them separated.</span>
        <span class="c1"># We choose to join them because it makes the algorithm easier - if they were separated then a single square would contain</span>
        <span class="c1"># two contours belonging to two separate continents and we&#39;d have to be careful that we visited only the contour belonging</span>
        <span class="c1"># to the continent we are currently filling. When we join them then the two contours belong to the same continent.</span>
        <span class="c1">#</span>
        <span class="c1"># Each segment starts at the middle of one side of the square and ends at the middle of another side.</span>
        <span class="c1"># Each side of the square is given an identifier...</span>
        <span class="c1">#</span>
        <span class="c1">#    ---2---</span>
        <span class="c1">#   |       |</span>
        <span class="c1">#   1       3</span>
        <span class="c1">#   |       |</span>
        <span class="c1">#    ---0---</span>
        <span class="c1">#</span>
        <span class="c1"># ...and each segment records a start and end identifier as a 2-tuple.</span>
        <span class="c1">#</span>

        <span class="c1"># Records the segments contained by all squares.</span>
        <span class="n">marching_squares</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">num_latitude_intervals</span> <span class="o">*</span> <span class="n">num_longitude_intervals</span>
        <span class="p">)</span>  <span class="c1"># squares contain no segments by default</span>
        <span class="c1"># Records the lat/lon index of only those squares containing one (or two) segments.</span>
        <span class="n">marching_squares_containing_segments</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Mark those points *inside* any landmass as requiring a visit.</span>
        <span class="c1"># We also need to remove them once they&#39;ve been visited.</span>
        <span class="c1">#</span>
        <span class="c1"># Optimisation: The scattered code below (referencing this variable) is optimised for speed since it is a hotspot in the contouring algorithm.</span>
        <span class="c1">#               It&#39;s a replacement for the following simpler (but slower) code:</span>
        <span class="c1">#</span>
        <span class="c1">#               for latitude_index in range(num_latitudes):</span>
        <span class="c1">#                   for longitude_index in range(num_longitudes):</span>
        <span class="c1">#                       if points_inside_continent[latitude_index, longitude_index]:</span>
        <span class="c1">#                           points_inside_all_landmasses_to_visit.add((latitude_index, longitude_index))</span>
        <span class="n">points_inside_all_landmasses_to_visit</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">bottom_squares_inside_continent</span> <span class="o">=</span> <span class="n">points_inside_continent</span><span class="p">[</span>
            <span class="mi">0</span><span class="p">,</span> <span class="p">:</span>
        <span class="p">]</span>  <span class="c1"># whether first row of latitude points are inside continent</span>
        <span class="k">for</span> <span class="n">latitude_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_latitude_intervals</span><span class="p">):</span>
            <span class="n">top_squares_inside_continent</span> <span class="o">=</span> <span class="n">points_inside_continent</span><span class="p">[</span>
                <span class="n">latitude_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span>
            <span class="p">]</span>  <span class="c1"># whether next row of latitude points are inside continent</span>

            <span class="c1"># See if points on the left of the first square (at the current latitude) are inside continent.</span>
            <span class="n">bottom_left_square_inside_continent</span> <span class="o">=</span> <span class="n">bottom_squares_inside_continent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">top_left_square_inside_continent</span> <span class="o">=</span> <span class="n">top_squares_inside_continent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">longitude_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_longitude_intervals</span><span class="p">):</span>

                <span class="c1"># See if points on the right of the current square are inside continent.</span>
                <span class="c1">#</span>
                <span class="c1"># Note: These will become the left points in the next loop iteration.</span>
                <span class="n">bottom_right_square_inside_continent</span> <span class="o">=</span> <span class="n">bottom_squares_inside_continent</span><span class="p">[</span>
                    <span class="n">longitude_index</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">]</span>
                <span class="n">top_right_square_inside_continent</span> <span class="o">=</span> <span class="n">top_squares_inside_continent</span><span class="p">[</span>
                    <span class="n">longitude_index</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">]</span>

                <span class="c1"># Mark the point in the bottom-left of square (and that is *inside* any landmass) as requiring a visit.</span>
                <span class="k">if</span> <span class="n">bottom_left_square_inside_continent</span><span class="p">:</span>
                    <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">latitude_index</span><span class="p">,</span> <span class="n">longitude_index</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="c1"># Handle the 16 cases of segments in a square.</span>
                <span class="c1">#</span>
                <span class="c1"># Store 2 segments (most of the time only 1 is needed).</span>
                <span class="c1"># Each segment stores a segment start and end identifier.</span>
                <span class="k">if</span> <span class="n">bottom_left_square_inside_continent</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bottom_right_square_inside_continent</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">top_left_square_inside_continent</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">top_right_square_inside_continent</span><span class="p">:</span>
                                <span class="c1"># Current square doesn&#39;t contain a segment, so skip to the next square.</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="kc">None</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="kc">None</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">top_right_square_inside_continent</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="kc">None</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">top_left_square_inside_continent</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">top_right_square_inside_continent</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="kc">None</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="kc">None</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">top_right_square_inside_continent</span><span class="p">:</span>
                                <span class="c1"># Choose 2 segments that *do* join two islands.</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bottom_right_square_inside_continent</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">top_left_square_inside_continent</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">top_right_square_inside_continent</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="kc">None</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Choose 2 segments that *do* join two islands.</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">top_right_square_inside_continent</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="kc">None</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">top_left_square_inside_continent</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">top_right_square_inside_continent</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="kc">None</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="kc">None</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">top_right_square_inside_continent</span><span class="p">:</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="kc">None</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Current square doesn&#39;t contain a segment, so skip to the next square.</span>
                                <span class="n">segments_in_square</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># If the current square contains a segment then record that.</span>
                <span class="k">if</span> <span class="n">segments_in_square</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">marching_squares</span><span class="p">[</span>
                        <span class="n">latitude_index</span> <span class="o">*</span> <span class="n">num_longitude_intervals</span> <span class="o">+</span> <span class="n">longitude_index</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">segments_in_square</span>
                    <span class="n">marching_squares_containing_segments</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">latitude_index</span><span class="p">,</span> <span class="n">longitude_index</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="c1"># The next square is to the right, so the right side of current square becomes left side of next square.</span>
                <span class="c1">#</span>
                <span class="c1"># This is an optimisation since this loop is a hotspot in the contouring algorithm.</span>
                <span class="c1"># It halves the number of point-inside-contour lookups we need to do.</span>
                <span class="n">bottom_left_square_inside_continent</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">bottom_right_square_inside_continent</span>
                <span class="p">)</span>
                <span class="n">top_left_square_inside_continent</span> <span class="o">=</span> <span class="n">top_right_square_inside_continent</span>

            <span class="c1"># Mark the point in the last longitude column (and that is *inside* any landmass) as requiring a visit.</span>
            <span class="k">if</span> <span class="n">bottom_right_square_inside_continent</span><span class="p">:</span>
                <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">latitude_index</span><span class="p">,</span> <span class="n">num_longitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># In the next loop iteration the bottom row of latitude points (inside continent) will be the current top row.</span>
            <span class="n">bottom_squares_inside_continent</span> <span class="o">=</span> <span class="n">top_squares_inside_continent</span>

        <span class="c1"># Mark points in the last latitude row (and that are *inside* any landmass) as requiring a visit.</span>
        <span class="k">for</span> <span class="n">longitude_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_longitudes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">top_squares_inside_continent</span><span class="p">[</span><span class="n">longitude_index</span><span class="p">]:</span>
                <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">num_latitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">longitude_index</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># time2 = time.time()</span>

        <span class="c1"># Return early if none of the grid points are inside continent.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">points_inside_all_landmasses_to_visit</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1">#</span>
        <span class="c1"># Generate the sole contoured continent by adding one or more landmasses to it.</span>
        <span class="c1">#</span>
        <span class="c1"># Each landmass is found by picking an arbitrary point inside any contours and expanding around it until we&#39;ve filled</span>
        <span class="c1"># the entire landmass. As we expand we detect when we reach a contour that has not yet been generated and generate it</span>
        <span class="c1"># for the current landmass. This expanding fill can detect more than one contour per landmass.</span>
        <span class="c1">#</span>
        <span class="c1"># This is repeated to find all landmasses (at which time we will have no more points left to visit inside contours).</span>
        <span class="c1">#</span>
        <span class="n">contoured_continent</span> <span class="o">=</span> <span class="n">ContouredContinent</span><span class="p">()</span>
        <span class="c1"># Keep visting points *inside* any landmass until there are no points left to visit.</span>
        <span class="k">while</span> <span class="n">points_inside_all_landmasses_to_visit</span><span class="p">:</span>
            <span class="c1"># Contours of the current landmass.</span>
            <span class="n">landmass_contours</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Keep a queue of points inside the current landmass that we will search for contours.</span>
            <span class="n">points_inside_landmass</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

            <span class="c1"># Get any available point inside any landmass.</span>
            <span class="n">lat_lon_indices_of_first_point_inside_landmass</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">point_index_of_first_point_inside_landmass</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">lat_lon_indices_of_first_point_inside_landmass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_longitudes</span>
                <span class="o">+</span> <span class="n">lat_lon_indices_of_first_point_inside_landmass</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">first_point_inside_landmass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_points</span><span class="p">[</span>
                <span class="n">point_index_of_first_point_inside_landmass</span>
            <span class="p">]</span>
            <span class="c1"># This will be the first point inside the current landmass.</span>
            <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">lat_lon_indices_of_first_point_inside_landmass</span>
            <span class="p">)</span>

            <span class="c1"># Find the remaining points inside the current landmass by recursively searching</span>
            <span class="c1"># nearbouring points until we reach a contour boundary of the current landmass.</span>
            <span class="k">while</span> <span class="n">points_inside_landmass</span><span class="p">:</span>
                <span class="c1"># Pop the current point to visit.</span>
                <span class="n">latitude_index</span><span class="p">,</span> <span class="n">longitude_index</span> <span class="o">=</span> <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

                <span class="c1"># Search the four squares, adjacent to the current point, for a contour.</span>
                <span class="c1">#</span>
                <span class="c1"># Note that, for an adjacent square containing a contour, we might already have generated</span>
                <span class="c1"># the contour in which case all segments of that contour will have been removed from</span>
                <span class="c1"># &#39;marching_squares_containing_segments&#39; and hence we will be essentially searching for the</span>
                <span class="c1"># next contour (if any) of the current landmass (eg, an interior hole contour).</span>
                <span class="c1"># And note that all contours in the four adjacent squares belong to the current landmass because</span>
                <span class="c1"># we join continent islands (as opposed to separating them) as described above.</span>
                <span class="c1">#</span>
                <span class="c1">#  +--+--+</span>
                <span class="c1">#  |  |  |</span>
                <span class="c1">#  +--o--+</span>
                <span class="c1">#  |  |  |</span>
                <span class="c1">#  +--+--+</span>
                <span class="c1">#</span>

                <span class="k">if</span> <span class="n">latitude_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">neighbour_square_location</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">latitude_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">longitude_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_square_location</span>
                            <span class="ow">in</span> <span class="n">marching_squares_containing_segments</span>
                        <span class="p">):</span>
                            <span class="n">landmass_contours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_extract_contour</span><span class="p">(</span>
                                    <span class="n">neighbour_square_location</span><span class="p">,</span>
                                    <span class="n">marching_squares</span><span class="p">,</span>
                                    <span class="n">marching_squares_containing_segments</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>

                    <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&lt;</span> <span class="n">num_longitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">neighbour_square_location</span> <span class="o">=</span> <span class="n">latitude_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">longitude_index</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_square_location</span>
                            <span class="ow">in</span> <span class="n">marching_squares_containing_segments</span>
                        <span class="p">):</span>
                            <span class="n">landmass_contours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_extract_contour</span><span class="p">(</span>
                                    <span class="n">neighbour_square_location</span><span class="p">,</span>
                                    <span class="n">marching_squares</span><span class="p">,</span>
                                    <span class="n">marching_squares_containing_segments</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>

                <span class="k">if</span> <span class="n">latitude_index</span> <span class="o">&lt;</span> <span class="n">num_latitude_intervals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">neighbour_square_location</span> <span class="o">=</span> <span class="n">latitude_index</span><span class="p">,</span> <span class="n">longitude_index</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_square_location</span>
                            <span class="ow">in</span> <span class="n">marching_squares_containing_segments</span>
                        <span class="p">):</span>
                            <span class="n">landmass_contours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_extract_contour</span><span class="p">(</span>
                                    <span class="n">neighbour_square_location</span><span class="p">,</span>
                                    <span class="n">marching_squares</span><span class="p">,</span>
                                    <span class="n">marching_squares_containing_segments</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>

                    <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&lt;</span> <span class="n">num_longitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">neighbour_square_location</span> <span class="o">=</span> <span class="n">latitude_index</span><span class="p">,</span> <span class="n">longitude_index</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_square_location</span>
                            <span class="ow">in</span> <span class="n">marching_squares_containing_segments</span>
                        <span class="p">):</span>
                            <span class="n">landmass_contours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_extract_contour</span><span class="p">(</span>
                                    <span class="n">neighbour_square_location</span><span class="p">,</span>
                                    <span class="n">marching_squares</span><span class="p">,</span>
                                    <span class="n">marching_squares_containing_segments</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Propagate outwards from current point to progressively fill the inside of the current landmass.</span>
                <span class="c1">#</span>
                <span class="c1"># This requires visiting up to 8 neighbour points (the &#39;+&#39; in diagram below).</span>
                <span class="c1"># Only visit those points that are inside (the contour) and that have not yet been visited.</span>
                <span class="c1">#</span>
                <span class="c1">#  +--+--+</span>
                <span class="c1">#  |  |  |</span>
                <span class="c1">#  +--o--+</span>
                <span class="c1">#  |  |  |</span>
                <span class="c1">#  +--+--+</span>
                <span class="c1">#</span>
                <span class="c1"># Note that we need to wrap around the dateline (longitude) because we need to visit (and remove)</span>
                <span class="c1"># ALL points that are inside the *current* landmass (before we move onto the next landmass).</span>
                <span class="c1"># However we don&#39;t need to traverse beyond the poles (latitude) in the same way.</span>
                <span class="c1">#</span>

                <span class="k">if</span> <span class="n">latitude_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="n">latitude_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">longitude_index</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">neighbour_point_location</span>
                        <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                    <span class="p">):</span>
                        <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                        <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                        <span class="p">)</span>

                    <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">latitude_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">longitude_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                            <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                        <span class="p">):</span>
                            <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                            <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                <span class="n">neighbour_point_location</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Wrap around the dateline.</span>
                        <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">latitude_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">num_longitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                            <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                        <span class="p">):</span>
                            <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                            <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                <span class="n">neighbour_point_location</span>
                            <span class="p">)</span>

                    <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&lt;</span> <span class="n">num_longitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">latitude_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">longitude_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                            <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                        <span class="p">):</span>
                            <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                            <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                <span class="n">neighbour_point_location</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Wrap around the dateline.</span>
                        <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="n">latitude_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                            <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                        <span class="p">):</span>
                            <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                            <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                <span class="n">neighbour_point_location</span>
                            <span class="p">)</span>

                <span class="k">if</span> <span class="n">latitude_index</span> <span class="o">&lt;</span> <span class="n">num_latitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="n">latitude_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">longitude_index</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">neighbour_point_location</span>
                        <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                    <span class="p">):</span>
                        <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                        <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                        <span class="p">)</span>

                    <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">latitude_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">longitude_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                            <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                        <span class="p">):</span>
                            <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                            <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                <span class="n">neighbour_point_location</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Wrap around the dateline.</span>
                        <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">latitude_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">num_longitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                            <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                        <span class="p">):</span>
                            <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                            <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                <span class="n">neighbour_point_location</span>
                            <span class="p">)</span>

                    <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&lt;</span> <span class="n">num_longitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">latitude_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">longitude_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                            <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                        <span class="p">):</span>
                            <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                            <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                <span class="n">neighbour_point_location</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Wrap around the dateline.</span>
                        <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="n">latitude_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                            <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                        <span class="p">):</span>
                            <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                            <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                <span class="n">neighbour_point_location</span>
                            <span class="p">)</span>

                <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="n">latitude_index</span><span class="p">,</span> <span class="n">longitude_index</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">neighbour_point_location</span>
                        <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                    <span class="p">):</span>
                        <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                        <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Wrap around the dateline.</span>
                    <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="n">latitude_index</span><span class="p">,</span> <span class="n">num_longitudes</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">neighbour_point_location</span>
                        <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                    <span class="p">):</span>
                        <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                        <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                        <span class="p">)</span>

                <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&lt;</span> <span class="n">num_longitudes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="n">latitude_index</span><span class="p">,</span> <span class="n">longitude_index</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">neighbour_point_location</span>
                        <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                    <span class="p">):</span>
                        <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                        <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Wrap around the dateline.</span>
                    <span class="n">neighbour_point_location</span> <span class="o">=</span> <span class="n">latitude_index</span><span class="p">,</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">neighbour_point_location</span>
                        <span class="ow">in</span> <span class="n">points_inside_all_landmasses_to_visit</span>
                    <span class="p">):</span>
                        <span class="n">points_inside_landmass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_point_location</span><span class="p">)</span>
                        <span class="n">points_inside_all_landmasses_to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                            <span class="n">neighbour_point_location</span>
                        <span class="p">)</span>

            <span class="c1"># The current landmass should have encountered one or more contours since</span>
            <span class="c1"># it was filled until it reached a boundary (contour) between continent and ocean.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">landmass_contours</span><span class="p">:</span>
                <span class="c1"># However it is potentially possible for the landmass to cover the entire globe (ie, no contours).</span>
                <span class="c1"># In this case there must be only one landmass, which means all points must have been visited.</span>
                <span class="k">if</span> <span class="n">points_inside_all_landmasses_to_visit</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                        <span class="s2">&quot;A single landmass covering entire globe must be the only landmass&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># Add the current landmass (bounded by contours) to the ContouredContinent.</span>
            <span class="c1"># This uses an arbitrary point inside the landmass to determine which contours are its exterior rings and which are its interior rings.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_landmass_to_contoured_continent</span><span class="p">(</span>
                <span class="n">contoured_continent</span><span class="p">,</span> <span class="n">landmass_contours</span><span class="p">,</span> <span class="n">first_point_inside_landmass</span>
            <span class="p">)</span>

        <span class="c1"># time3 = time.time()</span>
        <span class="c1"># print(&#39;  _create_contoured_continent: {:.2f} {:.2f}&#39;.format(time2 - time1, time3 - time2))</span>

        <span class="k">return</span> <span class="n">contoured_continent</span></div>


<div class="viewcode-block" id="ContinentContouring._add_landmass_to_contoured_continent">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._add_landmass_to_contoured_continent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_landmass_to_contoured_continent</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">contoured_continent</span><span class="p">,</span>
        <span class="n">landmass_contours</span><span class="p">,</span>
        <span class="n">any_point_inside_contoured_continent</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a landmass (bounded by the specified contours) to a ContouredContinent.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For each contour create a ring (a polygon with only an exterior ring).</span>
        <span class="n">contour_rings</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span> <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">landmass_contours</span>
        <span class="p">]</span>

        <span class="c1"># Arrange the contour rings into those that *include* and those that *exclude* continent.</span>
        <span class="c1">#</span>
        <span class="c1"># Note that we can get multiple ocean polygons if there is no contour ring that includes continent.</span>
        <span class="c1"># In this case the continent covers the entire globe except for a few oceanic holes.</span>
        <span class="c1"># However you can&#39;t have a single polygon with only interior holes (and no exterior ring).</span>
        <span class="c1"># So intead we allow for multiple ocean polygons to represent these holes (and treat this as a special case).</span>
        <span class="n">contour_rings_including_continent</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">contour_rings_excluding_continent</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">contour_ring</span> <span class="ow">in</span> <span class="n">contour_rings</span><span class="p">:</span>
            <span class="c1"># A point inside the continent might actually be outside the current contour ring.</span>
            <span class="n">contour_ring_interior_contains_continent</span> <span class="o">=</span> <span class="n">contour_ring</span><span class="o">.</span><span class="n">is_point_in_polygon</span><span class="p">(</span>
                <span class="n">any_point_inside_contoured_continent</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">contour_ring_interior_contains_continent</span><span class="p">:</span>
                <span class="n">contour_rings_including_continent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contour_ring</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">contour_rings_excluding_continent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contour_ring</span><span class="p">)</span>

        <span class="c1"># We should have either:</span>
        <span class="c1">#</span>
        <span class="c1"># 1) a single contour ring *including* continent and *zero or more* contour rings *excluding* continent, or</span>
        <span class="c1"># 2) no contour ring *including* continent and *one or more* contour rings *excluding* continent.</span>
        <span class="c1">#</span>
        <span class="c1"># For the case (1) we have a *single* polygon with zero or more interior rings. And it *includes* continent.</span>
        <span class="c1"># For the case (2) we have a *multiple* polygons, each with no interior rings. And they *exclude* continent with</span>
        <span class="c1"># the rest of the globe *including* continent.</span>
        <span class="c1">#</span>
        <span class="c1"># There&#39;s actually a third special case when there&#39;s no oceanic crust, just a single landmass covering the entire globe.</span>
        <span class="c1"># In that case there are no contours (and no continent or ocean polygons).</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_rings_including_continent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># One continent polygon.</span>
            <span class="n">continent_exterior_ring</span> <span class="o">=</span> <span class="n">contour_rings_including_continent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ocean_interior_rings</span> <span class="o">=</span> <span class="n">contour_rings_excluding_continent</span>
            <span class="n">continent_polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span>
                <span class="n">continent_exterior_ring</span><span class="p">,</span> <span class="n">ocean_interior_rings</span>
            <span class="p">)</span>
            <span class="c1"># Add the continent polygon.</span>
            <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_add_continent</span><span class="p">(</span><span class="n">continent_polygon</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">contour_rings_including_continent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Zero or more ocean polygons (each with no interior rings).</span>
            <span class="c1"># Note: We only have *zero* ocean polygons for the special case of a single landmass covering the entire globe.</span>
            <span class="k">for</span> <span class="n">ocean_exterior_ring</span> <span class="ow">in</span> <span class="n">contour_rings_excluding_continent</span><span class="p">:</span>
                <span class="n">ocean_polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">ocean_exterior_ring</span><span class="p">)</span>
                <span class="c1"># Add an ocean polygon.</span>
                <span class="n">contoured_continent</span><span class="o">.</span><span class="n">_add_ocean</span><span class="p">(</span><span class="n">ocean_polygon</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># len(contour_rings_including_continent) &gt;= 2</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="s2">&quot;A single landmass cannot have multiple polygons that include continent&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="ContinentContouring._extract_contour">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.continent_contours.ContinentContouring._extract_contour">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_contour</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">first_segment_lat_lon_indices</span><span class="p">,</span>
        <span class="n">marching_squares</span><span class="p">,</span>
        <span class="n">marching_squares_containing_segments</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Follow the segment in marching square at specified lat/lon index around contour back to that first segment.</span>

<span class="sd">        Note that a marching square can have two segments, in which case that square represents a thin connecting region between</span>
<span class="sd">        two larger islands of the contour (but still all just one contour). That square will get traversed twice (once in one direction</span>
<span class="sd">        through one segment and once in another the opposite direction through the second segment of that square).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">contour_points</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">interval_spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_point_spacing_degrees</span>
        <span class="n">num_latitude_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_latitudes</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">num_longitude_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contouring_grid_num_longitudes</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1">#</span>
        <span class="c1"># When a contour is first encountered (during the caller&#39;s expanding fill) a contour ring is generated by starting at the first square</span>
        <span class="c1"># found that contains one (or two) segments, which represents the start of that contour. We then pick one of that square&#39;s segments</span>
        <span class="c1"># (in most cases it&#39;ll only have one segment) and generate the first contour point at that segment&#39;s start. Note that it doesn&#39;t matter</span>
        <span class="c1"># which segment we pick (if there&#39;s two segments) because the contour ring will traverse back to the second segment (since both segments</span>
        <span class="c1"># are part of the same contour because their containing square represents a thin connecting region between two larger islands of the ring).</span>
        <span class="c1"># We then find the adjacent square to the segment&#39;s end (since a segment ends in the middle of a side of the square we can find the adjacent square).</span>
        <span class="c1"># We then find the segment in the adjacent square that starts (or ends) at the that point (the previous segment end). The adjacent</span>
        <span class="c1"># square may contain two segments in which case we need to find the correct segment (that continues the previous segment).</span>
        <span class="c1"># We generate the next contour point at the segment start and continue this process following the contour through segments of squares</span>
        <span class="c1"># until we return to the first segment (thus closing the contour loop).</span>
        <span class="c1">#</span>

        <span class="c1">#</span>
        <span class="c1"># Starting at the first segment, follow the segments in a loop until they return to the first segment (thus forming a contour ring).</span>
        <span class="c1">#</span>
        <span class="n">latitude_index</span><span class="p">,</span> <span class="n">longitude_index</span> <span class="o">=</span> <span class="n">first_segment_lat_lon_indices</span>
        <span class="n">prev_segment_end</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

            <span class="c1"># Get a segment from the current square.</span>
            <span class="n">segment1</span><span class="p">,</span> <span class="n">segment2</span> <span class="o">=</span> <span class="n">marching_squares</span><span class="p">[</span>
                <span class="n">latitude_index</span> <span class="o">*</span> <span class="n">num_longitude_intervals</span> <span class="o">+</span> <span class="n">longitude_index</span>
            <span class="p">]</span>
            <span class="c1"># If a square has only one segment then it will be in &#39;segment1&#39; (not &#39;segment2&#39;).</span>
            <span class="k">if</span> <span class="n">segment1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Shouldn&#39;t be able to reach a square that doesn&#39;t have any segments (or previously had segments but now has none).</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Square has no segments&quot;</span><span class="p">)</span>

            <span class="c1"># Find a segment in the current square such that the segment start matches the</span>
            <span class="c1"># end of the previous segment (in the previous square).</span>
            <span class="n">segment_start</span><span class="p">,</span> <span class="n">segment_end</span> <span class="o">=</span> <span class="n">segment1</span>
            <span class="k">if</span> <span class="n">prev_segment_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># first segment of current contour...</span>
                <span class="c1"># Mark the start of the contour so that later we know when we&#39;ve completed the contour.</span>
                <span class="n">first_segment_start</span> <span class="o">=</span> <span class="n">segment_start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Continue from the side of the previous square that contains the end point of the previous segment to the side of</span>
                <span class="c1"># the current square that should contain the start point of the current segment (that continues previous segment).</span>
                <span class="c1">#</span>
                <span class="c1"># The right side of previous square continues to left side of current square.</span>
                <span class="c1"># The left side of previous square continues to right side of current square.</span>
                <span class="c1"># The top side of previous square continues to bottom side of current square.</span>
                <span class="c1"># The bottom side of previous square continues to top side of current square.</span>
                <span class="c1">#</span>
                <span class="c1"># The adjacency relation means 2-&gt;0, 0-&gt;2, 3-&gt;1 and 1-&gt;3...</span>
                <span class="c1">#</span>
                <span class="c1">#    ---2---</span>
                <span class="c1">#   |       |</span>
                <span class="c1">#   1       3</span>
                <span class="c1">#   |       |</span>
                <span class="c1">#    ---0---</span>
                <span class="c1">#</span>
                <span class="c1"># ...which is satisfied by 2^2-&gt;0, 0^2-&gt;2, 3^2-&gt;1 and 1^2-&gt;3 (where &#39;^&#39; is exclusive-or).</span>
                <span class="c1">#</span>
                <span class="n">curr_segment_start</span> <span class="o">=</span> <span class="n">prev_segment_end</span> <span class="o">^</span> <span class="mb">0b10</span>

                <span class="c1">#</span>
                <span class="c1"># Find the right segment (if there&#39;s two segments) and reverse the segment if necessary</span>
                <span class="c1"># so that previous segment end matches current segment start.</span>
                <span class="c1">#</span>
                <span class="k">if</span> <span class="n">curr_segment_start</span> <span class="o">==</span> <span class="n">segment_start</span><span class="p">:</span>
                    <span class="c1"># We&#39;re traversing segment in the correct direction.</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">curr_segment_start</span> <span class="o">==</span> <span class="n">segment_end</span><span class="p">:</span>
                    <span class="c1"># Reverse segment direction (swap segment start and end points).</span>
                    <span class="n">segment_start</span><span class="p">,</span> <span class="n">segment_end</span> <span class="o">=</span> <span class="n">segment_end</span><span class="p">,</span> <span class="n">segment_start</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">segment2</span><span class="p">:</span>
                        <span class="c1"># Segment 1 didn&#39;t match so swap it with segment 2 (so it can be used later).</span>
                        <span class="n">segment1</span><span class="p">,</span> <span class="n">segment2</span> <span class="o">=</span> <span class="n">segment2</span><span class="p">,</span> <span class="n">segment1</span>

                        <span class="n">segment_start</span><span class="p">,</span> <span class="n">segment_end</span> <span class="o">=</span> <span class="n">segment1</span>
                        <span class="k">if</span> <span class="n">curr_segment_start</span> <span class="o">==</span> <span class="n">segment_start</span><span class="p">:</span>
                            <span class="c1"># We&#39;re traversing segment in the correct direction.</span>
                            <span class="k">pass</span>
                        <span class="k">elif</span> <span class="n">curr_segment_start</span> <span class="o">==</span> <span class="n">segment_end</span><span class="p">:</span>
                            <span class="c1"># Reverse segment direction (swap segment start and end points).</span>
                            <span class="n">segment_start</span><span class="p">,</span> <span class="n">segment_end</span> <span class="o">=</span> <span class="n">segment_end</span><span class="p">,</span> <span class="n">segment_start</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Unable to find connecting segment&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Unable to find connecting segment&quot;</span><span class="p">)</span>

            <span class="c1"># The start position of &#39;segment&#39;.</span>
            <span class="c1"># It will be at the midpoint of a side of the square.</span>
            <span class="k">if</span> <span class="n">segment_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">segment_start_latitude</span> <span class="o">=</span> <span class="o">-</span><span class="mf">90.0</span> <span class="o">+</span> <span class="n">latitude_index</span> <span class="o">*</span> <span class="n">interval_spacing</span>
                <span class="n">segment_start_longitude</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="mf">180.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">longitude_index</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval_spacing</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">segment_start</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">segment_start_latitude</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="mf">90.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">latitude_index</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval_spacing</span>
                <span class="p">)</span>
                <span class="n">segment_start_longitude</span> <span class="o">=</span> <span class="o">-</span><span class="mf">180.0</span> <span class="o">+</span> <span class="n">longitude_index</span> <span class="o">*</span> <span class="n">interval_spacing</span>
            <span class="k">elif</span> <span class="n">segment_start</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">segment_start_latitude</span> <span class="o">=</span> <span class="o">-</span><span class="mf">90.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">latitude_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval_spacing</span>
                <span class="n">segment_start_longitude</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="mf">180.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">longitude_index</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval_spacing</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># segment_start == 3</span>
                <span class="n">segment_start_latitude</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="mf">90.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">latitude_index</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval_spacing</span>
                <span class="p">)</span>
                <span class="n">segment_start_longitude</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="mf">180.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">longitude_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval_spacing</span>
                <span class="p">)</span>

            <span class="c1"># Generate a contour point at the start of the current segment.</span>
            <span class="n">contour_point</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span>
                <span class="n">segment_start_latitude</span><span class="p">,</span> <span class="n">segment_start_longitude</span>
            <span class="p">)</span>
            <span class="n">contour_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contour_point</span><span class="p">)</span>

            <span class="c1"># We&#39;ve just used &#39;segment1&#39;, so discard it by moving &#39;segment2&#39; into its position to be used later.</span>
            <span class="c1"># And if &#39;segment2&#39; is None then there are no more segments in current square so discard the entire square.</span>
            <span class="n">marching_squares</span><span class="p">[</span>
                <span class="n">latitude_index</span> <span class="o">*</span> <span class="n">num_longitude_intervals</span> <span class="o">+</span> <span class="n">longitude_index</span>
            <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">segment2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># There are no segments left in the current square, so we&#39;re finished with it.</span>
                <span class="c1"># Note: This will raise KeyError if not present in &#39;set&#39;.</span>
                <span class="n">marching_squares_containing_segments</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">latitude_index</span><span class="p">,</span> <span class="n">longitude_index</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># We&#39;re moving onto the next segment in the next square.</span>
            <span class="n">prev_segment_end</span> <span class="o">=</span> <span class="n">segment_end</span>

            <span class="c1"># Move to the next square connected by the end of the current segment.</span>
            <span class="c1">#</span>
            <span class="c1">#    ---2---</span>
            <span class="c1">#   |       |</span>
            <span class="c1">#   1       3</span>
            <span class="c1">#   |       |</span>
            <span class="c1">#    ---0---</span>
            <span class="c1">#</span>
            <span class="c1"># As noted above, at each pole there is an entire row of lat/lon grid points that are all either inside or outside a contour.</span>
            <span class="c1"># This means the Marching Squares algorithm cannot generate contour segments that penetrate the row. So we should not be able</span>
            <span class="c1"># to move beyond the poles.</span>
            <span class="c1">#</span>
            <span class="c1"># Also as noted above, the both the leftmost and rightmost columns of the lat/lon grid of points will be on the dateline</span>
            <span class="c1"># (ie, at both longitude -180 and 180). This means the Marching Squares algorithm will produce continuous contour segments across</span>
            <span class="c1"># the dateline (as we move from a square on one side of the dateline to the adjacent square on the other side).</span>
            <span class="k">if</span> <span class="n">prev_segment_end</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">latitude_index</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">latitude_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Segment entered South Pole&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">prev_segment_end</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">longitude_index</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Wrap around the dateline.</span>
                    <span class="n">longitude_index</span> <span class="o">+=</span> <span class="n">num_longitude_intervals</span>
            <span class="k">elif</span> <span class="n">prev_segment_end</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">latitude_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">latitude_index</span> <span class="o">==</span> <span class="n">num_latitude_intervals</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Segment entered North Pole&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># prev_segment_end == 3</span>
                <span class="n">longitude_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">longitude_index</span> <span class="o">==</span> <span class="n">num_longitude_intervals</span><span class="p">:</span>
                    <span class="c1"># Wrap around the dateline.</span>
                    <span class="n">longitude_index</span> <span class="o">-=</span> <span class="n">num_longitude_intervals</span>

            <span class="c1"># See if we&#39;re returned to the first square (containing the first segment).</span>
            <span class="k">if</span> <span class="n">first_segment_lat_lon_indices</span> <span class="o">==</span> <span class="p">(</span><span class="n">latitude_index</span><span class="p">,</span> <span class="n">longitude_index</span><span class="p">):</span>
                <span class="c1"># And make sure the end of the previous segment matches the start of the first segment.</span>
                <span class="c1"># See comment above about adjacency relation for explanatation of exclusive-or.</span>
                <span class="k">if</span> <span class="n">first_segment_start</span> <span class="o">==</span> <span class="p">(</span><span class="n">prev_segment_end</span> <span class="o">^</span> <span class="mb">0b10</span><span class="p">):</span>
                    <span class="c1"># Break out of current contour loop (we&#39;ve completed the contour).</span>
                    <span class="k">break</span>

        <span class="c1"># Return the ring of contour points.</span>
        <span class="k">return</span> <span class="n">contour_points</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, The University of Sydney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>