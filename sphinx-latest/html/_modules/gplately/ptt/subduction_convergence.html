

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gplately.ptt.subduction_convergence &mdash; gplately 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            gplately
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basic_usages.html">Minimal working example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../use_cases.html">Common Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Trouble-shooting and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_line_interface.html">Command Line Interface (CLI)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">Main Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../secondaries.html">Other Classes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gplately</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gplately.ptt.subduction_convergence</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gplately.ptt.subduction_convergence</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">#    Copyright (C) 2016 The University of Sydney, Australia</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1">#    the terms of the GNU General Public License, version 2, as published by</span>
<span class="c1">#    the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c1">#    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c1">#    for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License along</span>
<span class="c1">#    with this program; if not, write to Free Software Foundation, Inc.,</span>
<span class="c1">#    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Find the convergence rate of trenches (subduction zones).</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">argparse</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pygplates</span>

<span class="c1"># The default threshold sampling distance along trenches (subduction zones).</span>
<span class="n">DEFAULT_THRESHOLD_SAMPLING_DISTANCE_DEGREES</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">DEFAULT_THRESHOLD_SAMPLING_DISTANCE_KMS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">DEFAULT_THRESHOLD_SAMPLING_DISTANCE_DEGREES</span><span class="p">)</span>
    <span class="o">*</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">equatorial_radius_in_kms</span>
<span class="p">)</span>

<span class="n">DEFAULT_TIME_RANGE_YOUNG_TIME</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">DEFAULT_TIME_RANGE_OLD_TIME</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">DEFAULT_TIME_INCREMENT</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">DEFAULT_VELOCITY_DELTA_TIME</span> <span class="o">=</span> <span class="mi">1</span>


<span class="c1"># Determine the subducting plate of the subduction shared sub-segment.</span>
<span class="c1">#</span>
<span class="c1"># Note: There is now a similar method in PyGPlates version 30 called pygplates.ResolvedTopologicalSharedSubSegment.get_subducting_plate().</span>
<span class="k">def</span><span class="w"> </span><span class="nf">find_subducting_plate</span><span class="p">(</span>
    <span class="n">subduction_shared_sub_segment</span><span class="p">,</span>
    <span class="n">include_slab_topologies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine the subducting plate of the subduction shared sub-segment.&quot;&quot;&quot;</span>
    <span class="c1"># Get the subduction polarity of the subducting line.</span>
    <span class="n">subduction_polarity</span> <span class="o">=</span> <span class="n">subduction_shared_sub_segment</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_enumeration</span><span class="p">(</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">PropertyName</span><span class="o">.</span><span class="n">gpml_subduction_polarity</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">subduction_polarity</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">subduction_polarity</span> <span class="o">==</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">subducting_plate</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Iterate over the resolved topologies sharing the subduction sub-segment.</span>
    <span class="c1"># We are looking for exactly one subducting plate, or one boundary and</span>
    <span class="c1"># one network.</span>
    <span class="c1">#</span>
    <span class="c1"># There can be zero, one or more overriding plates but that does not affect us (since only looking for subducting plate).</span>
    <span class="c1"># This actually makes things more robust because it&#39;s possible the topologies were built in such a way that a subduction line</span>
    <span class="c1"># is inadvertently duplicated such that the subducting plate uses one of the subduction lines as its boundary and the overriding plate</span>
    <span class="c1"># uses the other. In this case the subducting line attached to the subducting plate will not also be attached to the overriding plate</span>
    <span class="c1"># and hence there will be zero overriding plates here.</span>
    <span class="c1"># Another example is having two overriding plates (or at least there will be two topologies on the overriding side of the subduction line).</span>
    <span class="c1">#</span>
    <span class="c1"># So all these overriding cases do not affect us, which means we will actually get a more accurate total subduction zone length in this script</span>
    <span class="c1"># because we are not forced to ignore these overriding cases (normally we would be forced to find *one* overriding plate if we were looking for</span>
    <span class="c1"># both the subducting and overriding plates). And also we&#39;re not counting duplicate subduction lines because we only count one of the duplicate</span>
    <span class="c1"># subduction lines (the one attached to the subducting plate). However we will still have a problem if too many subducting plates are found.</span>
    <span class="n">sharing_resolved_topologies</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">subduction_shared_sub_segment</span><span class="o">.</span><span class="n">get_sharing_resolved_topologies</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">geometry_reversal_flags</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">subduction_shared_sub_segment</span><span class="o">.</span><span class="n">get_sharing_resolved_topology_geometry_reversal_flags</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">key</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Boundaries first, then networks - boundaries will be replaced by networks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ResolvedTopologicalBoundary</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ResolvedTopologicalNetwork</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">2</span>

    <span class="n">zipped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sharing_resolved_topologies</span><span class="p">,</span> <span class="n">geometry_reversal_flags</span><span class="p">))</span>
    <span class="n">zipped</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
    <span class="n">sharing_resolved_topologies</span><span class="p">,</span> <span class="n">geometry_reversal_flags</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zipped</span><span class="p">)</span>

    <span class="n">n_subducting_plates</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">subducting_topology_types</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span>
        <span class="n">sharing_resolved_topology</span><span class="p">,</span>
        <span class="n">geometry_reversal_flag</span><span class="p">,</span>
    <span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sharing_resolved_topologies</span><span class="p">,</span> <span class="n">geometry_reversal_flags</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">include_slab_topologies</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">sharing_resolved_topology</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span>
            <span class="o">.</span><span class="n">get_feature_type</span><span class="p">()</span>
            <span class="o">.</span><span class="n">to_qualified_string</span><span class="p">()</span>
            <span class="o">==</span> <span class="s2">&quot;gpml:TopologicalSlabBoundary&quot;</span>
        <span class="p">):</span>
            <span class="c1"># Ignore slab topologies (e.g. flat slabs)</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">sharing_resolved_topology</span><span class="o">.</span><span class="n">get_resolved_boundary</span><span class="p">()</span><span class="o">.</span><span class="n">get_orientation</span><span class="p">()</span>
            <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="o">.</span><span class="n">Orientation</span><span class="o">.</span><span class="n">clockwise</span>
        <span class="p">):</span>
            <span class="c1"># The current topology sharing the subducting line has clockwise orientation (when viewed from above the Earth).</span>
            <span class="c1"># If the overriding plate (subduction polarity) is to the &#39;left&#39; of the subducting line (when following its vertices in order)</span>
            <span class="c1"># and the subducting line is not reversed when contributing to the topology then that topology is the subducting plate.</span>
            <span class="c1"># A similar test applies to the &#39;right&#39; but with the subducting line reversed in the topology.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">subduction_polarity</span> <span class="o">==</span> <span class="s2">&quot;Left&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">geometry_reversal_flag</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">subduction_polarity</span> <span class="o">==</span> <span class="s2">&quot;Right&quot;</span> <span class="ow">and</span> <span class="n">geometry_reversal_flag</span>
            <span class="p">):</span>
                <span class="n">n_subducting_plates</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">subducting_topology_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sharing_resolved_topology</span><span class="p">))</span>
                <span class="c1"># Make sure this topology actually has a plate ID</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">sharing_resolved_topology</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                    <span class="ow">is</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">subducting_plate</span> <span class="o">=</span> <span class="n">sharing_resolved_topology</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The current topology sharing the subducting line has counter-clockwise orientation (when viewed from above the Earth).</span>
            <span class="c1"># If the overriding plate (subduction polarity) is to the &#39;left&#39; of the subducting line (when following its vertices in order)</span>
            <span class="c1"># and the subducting line is reversed when contributing to the topology then that topology is the subducting plate.</span>
            <span class="c1"># A similar test applies to the &#39;right&#39; but with the subducting line not reversed in the topology.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">subduction_polarity</span> <span class="o">==</span> <span class="s2">&quot;Left&quot;</span> <span class="ow">and</span> <span class="n">geometry_reversal_flag</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">subduction_polarity</span> <span class="o">==</span> <span class="s2">&quot;Right&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">geometry_reversal_flag</span>
            <span class="p">):</span>
                <span class="n">n_subducting_plates</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">subducting_topology_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sharing_resolved_topology</span><span class="p">))</span>
                <span class="c1"># Make sure this topology actually has a plate ID</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">sharing_resolved_topology</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                    <span class="ow">is</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">subducting_plate</span> <span class="o">=</span> <span class="n">sharing_resolved_topology</span>

    <span class="k">if</span> <span class="n">subducting_plate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n_subducting_plates</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Unable to find subducting plate, so return None.</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subducting_topology_types</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">subducting_topology_types</span><span class="p">)):</span>
        <span class="c1"># More than one rigid plate or more than one deforming network</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">subducting_plate</span><span class="p">,</span> <span class="n">subduction_polarity</span><span class="p">)</span>


<div class="viewcode-block" id="subduction_convergence">
<a class="viewcode-back" href="../../../generated/gplately.subduction_convergence.html#gplately.subduction_convergence">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">subduction_convergence</span><span class="p">(</span>
    <span class="n">rotation_features_or_model</span><span class="p">,</span>
    <span class="n">topology_features</span><span class="p">,</span>
    <span class="n">threshold_sampling_distance_radians</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">velocity_delta_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">include_slab_topologies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">include_network_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the convergence and absolute velocities sampled along trenches (subduction zones) at a particular geological time.</span>

<span class="sd">    Each sampled point along trench returns the following information:</span>

<span class="sd">    - 0 longitude of sample point</span>
<span class="sd">    - 1 latitude of sample point</span>
<span class="sd">    - 2 subducting convergence (relative to trench) velocity magnitude (in cm/yr)</span>
<span class="sd">    - 3 subducting convergence velocity obliquity angle (angle between trench normal vector and convergence velocity vector)</span>
<span class="sd">    - 4 trench absolute (relative to anchor plate) velocity magnitude (in cm/yr)</span>
<span class="sd">    - 5 trench absolute velocity obliquity angle (angle between trench normal vector and trench absolute velocity vector)</span>
<span class="sd">    - 6 length of arc segment (in degrees) that current point is on</span>
<span class="sd">    - 7 trench normal azimuth angle (clockwise starting at North, ie, 0 to 360 degrees) at current point</span>
<span class="sd">    - 8 subducting plate ID</span>
<span class="sd">    - 9 trench plate ID</span>

<span class="sd">    The optional ``output_*`` parameters can be used to append extra data to the above output for each sampled trench point.</span>
<span class="sd">    The order of any extra data is the same order in which the parameters are listed below.</span>

<span class="sd">    The obliquity angles are in the range (-180, 180). The range (0, 180) goes clockwise (when viewed from above the Earth) from the</span>
<span class="sd">    trench normal direction to the velocity vector. The range (0, -180) goes counter-clockwise.</span>
<span class="sd">    You can change the range (-180, 180) to the range (0, 360) by adding 360 to negative angles.</span>
<span class="sd">    The trench normal is perpendicular to the trench and pointing toward the overriding plate.</span>

<span class="sd">    Note that the convergence velocity magnitude is negative if the plates are diverging (if convergence obliquity angle</span>
<span class="sd">    is greater than 90 or less than -90). And note that the absolute velocity magnitude is negative if the trench (subduction zone)</span>
<span class="sd">    is moving towards the overriding plate (if absolute obliquity angle is less than 90 and greater than -90) - note that this</span>
<span class="sd">    ignores the kinematics of the subducting plate. Similiarly for the subducting plate absolute velocity magnitude</span>
<span class="sd">    (if keyword argument ``output_subducting_absolute_velocity`` is ``True``).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rotation_features_or_model : `pygplates.RotationModel`_, or any combination of str, `pygplates.FeatureCollection`_, `pygplates.Feature`_</span>
<span class="sd">        The rotation model can be specified as a `pygplates.RotationModel`_. Or it can be specified as a rotation feature collection,</span>
<span class="sd">        or rotation filename, or rotation feature, or sequence of rotation features, or a sequence (eg, list or tuple) of any combination</span>
<span class="sd">        of those four types.</span>
<span class="sd">    topology_features: any combination of str, `pygplates.FeatureCollection`_, `pygplates.Feature`_</span>
<span class="sd">        The topological boundary and network features and the topological section features they reference (regular and topological lines).</span>
<span class="sd">        Can be specified as a feature collection, or filename, or feature, or sequence of features, or a sequence (eg, list or tuple)</span>
<span class="sd">        of any combination of those four types.</span>
<span class="sd">    threshold_sampling_distance_radians: float</span>
<span class="sd">        Threshold sampling distance along trench (in radians).</span>
<span class="sd">    time: float</span>
<span class="sd">        The reconstruction time at which to query subduction convergence.</span>
<span class="sd">    velocity_delta_time: float, optional</span>
<span class="sd">        The delta time interval used for velocity calculations. Defaults to 1My.</span>
<span class="sd">    anchor_plate_id: int, optional</span>
<span class="sd">        Anchor plate ID for reconstruction.</span>
<span class="sd">        If not specified then uses the default anchor plate of ``rotation_model`` if it&#39;s a `pygplates.RotationModel`_ (otherwise uses zero).</span>
<span class="sd">    include_slab_topologies : bool, default False</span>
<span class="sd">        Include slab topologies (``gpml:TopologicalSlabBoundary``) in analysis.</span>
<span class="sd">    include_network_boundaries : bool, default False</span>
<span class="sd">        Whether to calculate subduction convergence along network boundaries that are not also plate boundaries (defaults to False).</span>
<span class="sd">        If a deforming network shares a boundary with a plate then it&#39;ll get included regardless of this option.</span>
<span class="sd">    output_distance_to_nearest_edge_of_trench : bool, default=False</span>
<span class="sd">        Append the distance (in degrees) along the trench line to the nearest trench edge to each returned sample point.</span>
<span class="sd">        A trench edge is the farthermost location on the current trench feature that contributes to a plate boundary.</span>
<span class="sd">    output_distance_to_start_edge_of_trench : bool, default=False</span>
<span class="sd">        Append the distance (in degrees) along the trench line from the start edge of the trench to each returned sample point.</span>
<span class="sd">        The start of the trench is along the clockwise direction around the overriding plate.</span>
<span class="sd">    output_convergence_velocity_components : bool, default=False</span>
<span class="sd">        Append the convergence velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">        Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">        Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">    output_trench_absolute_velocity_components : bool, default=False</span>
<span class="sd">        Append the trench absolute velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">        Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">        Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">    output_subducting_absolute_velocity : bool, default=False</span>
<span class="sd">        Append the subducting plate absolute velocity magnitude (in cm/yr) and obliquity angle (in degrees) to each returned sample point.</span>
<span class="sd">    output_subducting_absolute_velocity_components : bool, default=False</span>
<span class="sd">        Append the subducting plate absolute velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">        Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">        Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">    output_trench_normal : bool, default=False</span>
<span class="sd">        Append the x, y and z components of the trench normal unit-length 3D vectors.</span>
<span class="sd">        These vectors are normal to the trench in the direction of subduction (towards overriding plate).</span>
<span class="sd">        These are global 3D vectors which differ from trench normal azimuth angles (ie, angles relative to North).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of tuples</span>
<span class="sd">        The results for all points sampled along trench.</span>
<span class="sd">        The size of the returned list is equal to the number of sampled points.</span>
<span class="sd">        Each tuple in the list corresponds to a point and has the following tuple items:</span>

<span class="sd">        * longitude of sample point</span>
<span class="sd">        * latitude of sample point</span>
<span class="sd">        * subducting convergence (relative to trench) velocity magnitude (in cm/yr)</span>
<span class="sd">        * subducting convergence velocity obliquity angle (angle between trench normal vector and convergence velocity vector)</span>
<span class="sd">        * trench absolute (relative to anchor plate) velocity magnitude (in cm/yr)</span>
<span class="sd">        * trench absolute velocity obliquity angle (angle between trench normal vector and trench absolute velocity vector)</span>
<span class="sd">        * length of arc segment (in degrees) that current point is on</span>
<span class="sd">        * trench normal azimuth angle (clockwise starting at North, ie, 0 to 360 degrees) at current point</span>
<span class="sd">        * subducting plate ID</span>
<span class="sd">        * trench plate ID</span>

<span class="sd">        The optional ``output_*`` parameters can be used to append extra data to the tuple of each sampled trench point.</span>
<span class="sd">        The order of any extra data is the same order in which the parameters are listed in this function.</span>


<span class="sd">    .. note::</span>

<span class="sd">        Each point in the output is the midpoint of a great circle arc between two adjacent points in the trench polyline.</span>
<span class="sd">        The trench normal vector used in the obliquity calculations is perpendicular to the great circle arc of each point (arc midpoint)</span>
<span class="sd">        and pointing towards the overriding plate (rather than away from it).</span>

<span class="sd">        Each trench is sampled at approximately uniform intervals along its length (specified via a threshold sampling distance).</span>
<span class="sd">        The sampling along the entire length of a trench is not exactly uniform. Each segment along a trench is sampled</span>
<span class="sd">        such that the samples have a uniform spacing that is less than or equal to the threshold sampling distance. However each segment</span>
<span class="sd">        in a trench might have a slightly different spacing distance (since segment lengths are not integer multiples of the threshold sampling distance).</span>

<span class="sd">        The trench normal (at each arc segment mid-point) always points **towards** the overriding plate.</span>


<span class="sd">    .. _pygplates.RotationModel: https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel</span>
<span class="sd">    .. _pygplates.Feature: https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature</span>
<span class="sd">    .. _pygplates.FeatureCollection: https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection</span>
<span class="sd">    .. _pygplates.FeatureType: https://www.gplates.org/docs/pygplates/generated/pygplates.featuretype</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="c1"># Turn rotation data into a RotationModel (if not already).</span>
    <span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">rotation_features_or_model</span><span class="p">)</span>

    <span class="c1"># Turn topology data into a list of features (if not already).</span>
    <span class="n">topology_features</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeaturesFunctionArgument</span><span class="p">(</span>
        <span class="n">topology_features</span>
    <span class="p">)</span><span class="o">.</span><span class="n">get_features</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_slab_topologies</span><span class="p">:</span>
        <span class="c1"># Ignore slab topologies (usually flat slabs)</span>
        <span class="n">topology_features</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">topology_features</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">get_feature_type</span><span class="p">()</span><span class="o">.</span><span class="n">to_qualified_string</span><span class="p">()</span>
            <span class="o">!=</span> <span class="s2">&quot;gpml:TopologicalSlabBoundary&quot;</span>
        <span class="p">]</span>

    <span class="c1"># If requested, exclude resolved topological *networks*.</span>
    <span class="c1"># Caller may only want subduction zones along *plate* boundaries.</span>
    <span class="n">resolve_topology_types</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ResolveTopologyType</span><span class="o">.</span><span class="n">boundary</span>
    <span class="k">if</span> <span class="n">include_network_boundaries</span><span class="p">:</span>
        <span class="n">resolve_topology_types</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">resolve_topology_types</span> <span class="o">|</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ResolveTopologyType</span><span class="o">.</span><span class="n">network</span>
        <span class="p">)</span>

    <span class="c1"># Resolve our topological plate polygons (and deforming networks) to the current &#39;time&#39;.</span>
    <span class="c1"># We generate both the resolved topology boundaries and the boundary sections between them.</span>
    <span class="n">resolved_topologies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">shared_boundary_sections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pygplates</span><span class="o">.</span><span class="n">resolve_topologies</span><span class="p">(</span>
        <span class="n">topology_features</span><span class="p">,</span>
        <span class="n">rotation_model</span><span class="p">,</span>
        <span class="n">resolved_topologies</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">shared_boundary_sections</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="p">,</span>
        <span class="n">resolve_topology_types</span><span class="o">=</span><span class="n">resolve_topology_types</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># List of tesselated subduction zone (trench) shared subsegment points and associated convergence parameters</span>
    <span class="c1"># for the current &#39;time&#39;.</span>
    <span class="n">output_data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate over the shared boundary sections of all resolved topologies.</span>
    <span class="k">for</span> <span class="n">shared_boundary_section</span> <span class="ow">in</span> <span class="n">shared_boundary_sections</span><span class="p">:</span>
        <span class="c1"># Skip sections that are not subduction zones (trenches).</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">shared_boundary_section</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_feature_type</span><span class="p">()</span>
            <span class="o">!=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">gpml_subduction_zone</span>
        <span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># The trench length is the sum of the lengths of the shared sub-segments.</span>
        <span class="c1"># The shared sub-segments represent portions of the trench with different subducting plates.</span>
        <span class="c1"># We need the trench length to determine whether a point along the trench is closer to the start or end of trench.</span>
        <span class="n">trench_length_radians</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">fsum</span><span class="p">(</span>
            <span class="n">shared_sub_segment</span><span class="o">.</span><span class="n">get_resolved_geometry</span><span class="p">()</span><span class="o">.</span><span class="n">get_arc_length</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">shared_sub_segment</span> <span class="ow">in</span> <span class="n">shared_boundary_section</span><span class="o">.</span><span class="n">get_shared_sub_segments</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># The distance-along-trench will accumulate as we traverse the shared sub-segments.</span>
        <span class="n">distance_along_trench_radians</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Iterate over the shared sub-segments of the current subducting line.</span>
        <span class="c1"># These are the parts of the subducting line that actually contribute to topological boundaries.</span>
        <span class="k">for</span> <span class="n">shared_sub_segment</span> <span class="ow">in</span> <span class="n">shared_boundary_section</span><span class="o">.</span><span class="n">get_shared_sub_segments</span><span class="p">():</span>
            <span class="c1"># Find the subducting plate of the shared sub-segment.</span>
            <span class="c1">#</span>
            <span class="c1"># Note that prior to pyGPlates 0.22 we also looked for the overriding plate since it couldn&#39;t extract the individual trench plate IDs</span>
            <span class="c1"># from a &quot;resolved topological line&quot; trench (now we use the trench plate IDs since our minimum requirement is above version 0.28).</span>
            <span class="c1"># Not having to find the overriding plate means we actually get a more accurate total subduction zone length in this script.</span>
            <span class="c1"># This is because we are not forced to ignore trench sections where there&#39;s not exactly one overriding plate</span>
            <span class="c1"># (and optionally a deforming network overlapping it). And also we&#39;re not counting duplicate subduction lines</span>
            <span class="c1"># (where one duplicate is attached only to the overriding plate and the other attached only to the subducting plate)</span>
            <span class="c1"># because we only count the subduction line attached to the subducting plate.</span>
            <span class="n">subducting_plate_and_polarity</span> <span class="o">=</span> <span class="n">find_subducting_plate</span><span class="p">(</span>
                <span class="n">shared_sub_segment</span><span class="p">,</span>
                <span class="n">include_slab_topologies</span><span class="o">=</span><span class="n">include_slab_topologies</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">subducting_plate_and_polarity</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;Unable to find the subducting plate of the subducting sub-segment &quot;</span><span class="si">{0}</span><span class="s1">&quot; at </span><span class="si">{1}</span><span class="s1">Ma.</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s2">&quot;    Either the subduction polarity is not properly set or there&quot;</span>
                    <span class="s2">&quot; are too many subducting plates sharing the sub-segment.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;    Ignoring current sub-segment.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">shared_sub_segment</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span> <span class="n">time</span>
                    <span class="p">),</span>
                    <span class="ne">RuntimeWarning</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">subducting_plate</span><span class="p">,</span> <span class="n">subduction_polarity</span> <span class="o">=</span> <span class="n">subducting_plate_and_polarity</span>
            <span class="n">subducting_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">subducting_plate</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="c1"># We need to reverse the trench normal direction if overriding plate is to</span>
            <span class="c1"># the right of the subducting line since great circle arc normal is always to the left.</span>
            <span class="k">if</span> <span class="n">subduction_polarity</span> <span class="o">==</span> <span class="s2">&quot;Left&quot;</span><span class="p">:</span>
                <span class="n">trench_normal_reversal</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">trench_normal_reversal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># The plate ID of the trench line (as opposed to the subducting plate).</span>
            <span class="c1">#</span>
            <span class="c1"># Update: The plate IDs of the trench line and overriding plate can differ</span>
            <span class="c1"># even in a non-deforming model due to smaller plates, not modelled by topologies, moving</span>
            <span class="c1"># differently than the larger topological plate being modelled - and the trench line</span>
            <span class="c1"># having plate IDs of the smaller plates near them. For that reason we use the plate ID</span>
            <span class="c1"># of the trench line whenever we can.</span>
            <span class="c1">#</span>
            <span class="c1"># If the current shared sub-segment is part of a topological line then we obtain</span>
            <span class="c1"># its sub-sub-segments. This is because trench lines that are topological lines might</span>
            <span class="c1"># actually be deforming (or intended to be deforming) and hence their</span>
            <span class="c1"># plate ID is not meaningful or at least we can&#39;t be sure whether it will be zero or the</span>
            <span class="c1"># overriding plate (or something else). In this case we look at the plate IDs of the</span>
            <span class="c1"># sub-sub-segments.</span>
            <span class="n">sub_segments_of_topological_line_sub_segment</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">shared_sub_segment</span><span class="o">.</span><span class="n">get_sub_segments</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">sub_segments_of_topological_line_sub_segment</span><span class="p">:</span>
                <span class="c1"># Iterate over the sub-sub-segments associated with the topological line shared sub-segment.</span>
                <span class="k">for</span> <span class="n">sub_sub_segment</span> <span class="ow">in</span> <span class="n">sub_segments_of_topological_line_sub_segment</span><span class="p">:</span>
                    <span class="n">trench_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">sub_sub_segment</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                    <span class="p">)</span>

                    <span class="n">sub_sub_segment_geometry</span> <span class="o">=</span> <span class="n">sub_sub_segment</span><span class="o">.</span><span class="n">get_resolved_geometry</span><span class="p">()</span>
                    <span class="c1"># If sub-sub-segment was reversed when it contributed to the topological line shared sub-segment then</span>
                    <span class="c1"># we need to use that reversed geometry so that it has the same order of points as the topological line.</span>
                    <span class="k">if</span> <span class="n">sub_sub_segment</span><span class="o">.</span><span class="n">was_geometry_reversed_in_topology</span><span class="p">():</span>
                        <span class="c1"># Create a new sub-sub-segment polyline with points in reverse order.</span>
                        <span class="n">sub_sub_segment_geometry</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span>
                            <span class="n">sub_sub_segment_geometry</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="p">)</span>

                    <span class="n">_sub_segment_subduction_convergence</span><span class="p">(</span>
                        <span class="n">output_data</span><span class="p">,</span>
                        <span class="n">time</span><span class="p">,</span>
                        <span class="n">sub_sub_segment_geometry</span><span class="p">,</span>
                        <span class="n">trench_plate_id</span><span class="p">,</span>
                        <span class="n">subducting_plate_id</span><span class="p">,</span>
                        <span class="n">trench_normal_reversal</span><span class="p">,</span>
                        <span class="n">trench_length_radians</span><span class="p">,</span>
                        <span class="n">distance_along_trench_radians</span><span class="p">,</span>
                        <span class="n">threshold_sampling_distance_radians</span><span class="p">,</span>
                        <span class="n">velocity_delta_time</span><span class="p">,</span>
                        <span class="n">rotation_model</span><span class="p">,</span>
                        <span class="n">anchor_plate_id</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="c1"># Accumulate distance-along-trench.</span>
                    <span class="n">distance_along_trench_radians</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">sub_sub_segment_geometry</span><span class="o">.</span><span class="n">get_arc_length</span><span class="p">()</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># It&#39;s not a topological line...</span>
                <span class="n">trench_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">shared_sub_segment</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">sub_segment_geometry</span> <span class="o">=</span> <span class="n">shared_sub_segment</span><span class="o">.</span><span class="n">get_resolved_geometry</span><span class="p">()</span>
                <span class="n">_sub_segment_subduction_convergence</span><span class="p">(</span>
                    <span class="n">output_data</span><span class="p">,</span>
                    <span class="n">time</span><span class="p">,</span>
                    <span class="n">sub_segment_geometry</span><span class="p">,</span>
                    <span class="n">trench_plate_id</span><span class="p">,</span>
                    <span class="n">subducting_plate_id</span><span class="p">,</span>
                    <span class="n">trench_normal_reversal</span><span class="p">,</span>
                    <span class="n">trench_length_radians</span><span class="p">,</span>
                    <span class="n">distance_along_trench_radians</span><span class="p">,</span>
                    <span class="n">threshold_sampling_distance_radians</span><span class="p">,</span>
                    <span class="n">velocity_delta_time</span><span class="p">,</span>
                    <span class="n">rotation_model</span><span class="p">,</span>
                    <span class="n">anchor_plate_id</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Accumulate distance-along-trench by length of sub-segment geometry.</span>
                <span class="n">distance_along_trench_radians</span> <span class="o">+=</span> <span class="n">sub_segment_geometry</span><span class="o">.</span><span class="n">get_arc_length</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">output_data</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_sub_segment_subduction_convergence</span><span class="p">(</span>
    <span class="n">output_data</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">sub_segment_geometry</span><span class="p">,</span>
    <span class="n">trench_plate_id</span><span class="p">,</span>
    <span class="n">subducting_plate_id</span><span class="p">,</span>
    <span class="n">trench_normal_reversal</span><span class="p">,</span>
    <span class="n">trench_length_radians</span><span class="p">,</span>
    <span class="n">distance_along_trench_radians</span><span class="p">,</span>
    <span class="n">threshold_sampling_distance_radians</span><span class="p">,</span>
    <span class="n">velocity_delta_time</span><span class="p">,</span>
    <span class="n">rotation_model</span><span class="p">,</span>
    <span class="n">anchor_plate_id</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1">#</span>
    <span class="c1"># Process keyword arguments.</span>
    <span class="c1">#</span>
    <span class="n">output_distance_to_nearest_edge_of_trench</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_distance_to_nearest_edge_of_trench&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_distance_to_start_edge_of_trench</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_distance_to_start_edge_of_trench&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_convergence_velocity_components</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_convergence_velocity_components&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_trench_absolute_velocity_components</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_trench_absolute_velocity_components&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_subducting_absolute_velocity</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_subducting_absolute_velocity&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_subducting_absolute_velocity_components</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_subducting_absolute_velocity_components&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_trench_normal</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_trench_normal&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Get the rotation of the subducting plate relative to the trench line</span>
    <span class="c1"># from &#39;time + velocity_delta_time&#39; to &#39;time&#39;.</span>
    <span class="n">convergence_relative_stage_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">subducting_plate_id</span><span class="p">,</span>
        <span class="n">time</span> <span class="o">+</span> <span class="n">velocity_delta_time</span><span class="p">,</span>
        <span class="n">trench_plate_id</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># In the following:</span>
    <span class="c1">#   * T is for Trench (subduction zone line)</span>
    <span class="c1">#   * S is subducting plate</span>
    <span class="c1">#   * A is anchor plate</span>
    <span class="c1">#</span>
    <span class="c1"># The trenches have been reconstructed using the rotation &quot;R(0-&gt;t,A-&gt;T)&quot;:</span>
    <span class="c1">#</span>
    <span class="c1">#   reconstructed_geometry = R(0-&gt;t,A-&gt;T) * present_day_geometry</span>
    <span class="c1">#</span>
    <span class="c1"># We can write &quot;R(0-&gt;t,A-&gt;T)&quot; in terms of the convergence stage rotation &quot;R(t+dt-&gt;t,T-&gt;S)&quot; as:</span>
    <span class="c1">#</span>
    <span class="c1">#   R(0-&gt;t,A-&gt;T)  = R(0-&gt;t,A-&gt;S) * R(0-&gt;t,S-&gt;T)</span>
    <span class="c1">#                 = R(0-&gt;t,A-&gt;S) * inverse[R(0-&gt;t,T-&gt;S)]</span>
    <span class="c1">#                 = R(0-&gt;t,A-&gt;S) * inverse[R(t+dt-&gt;t,T-&gt;S) * R(0-&gt;t+dt,T-&gt;S)]</span>
    <span class="c1">#                 = R(0-&gt;t,A-&gt;S) * inverse[stage_rotation * R(0-&gt;t+dt,T-&gt;S)]</span>
    <span class="c1">#                 = R(0-&gt;t,A-&gt;S) * inverse[R(0-&gt;t+dt,T-&gt;S)] * inverse[stage_rotation]</span>
    <span class="c1">#                 = R(0-&gt;t,A-&gt;S) * R(0-&gt;t+dt,S-&gt;T) * inverse[stage_rotation]</span>
    <span class="c1">#</span>
    <span class="c1"># So to get the *reconstructed* subduction line geometry into the stage rotation reference frame</span>
    <span class="c1"># we need to rotate it by &quot;inverse[R(0-&gt;t,A-&gt;S) * R(0-&gt;t+dt,S-&gt;T)]&quot;:</span>
    <span class="c1">#</span>
    <span class="c1">#   reconstructed_geometry = R(0-&gt;t,A-&gt;T) * present_day_geometry</span>
    <span class="c1">#                          = R(0-&gt;t,A-&gt;S) * R(0-&gt;t+dt,S-&gt;T) * inverse[stage_rotation] * present_day_geometry</span>
    <span class="c1">#   inverse[R(0-&gt;t,A-&gt;S) * R(0-&gt;t+dt,S-&gt;T)] * reconstructed_geometry = inverse[stage_rotation] * present_day_geometry</span>
    <span class="c1">#</span>
    <span class="c1"># Once we&#39;ve done that we can calculate the velocities of those geometry points</span>
    <span class="c1"># using the stage rotation. Then the velocities need to be rotated back from the</span>
    <span class="c1"># stage rotation reference frame using the rotation &quot;R(0-&gt;t,A-&gt;S) * R(0-&gt;t+dt,S-&gt;T)&quot;.</span>
    <span class="c1">#</span>
    <span class="n">from_convergence_stage_frame</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
        <span class="n">time</span><span class="p">,</span> <span class="n">subducting_plate_id</span><span class="p">,</span> <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span>
    <span class="p">)</span> <span class="o">*</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
        <span class="n">time</span> <span class="o">+</span> <span class="n">velocity_delta_time</span><span class="p">,</span>
        <span class="n">trench_plate_id</span><span class="p">,</span>
        <span class="n">fixed_plate_id</span><span class="o">=</span><span class="n">subducting_plate_id</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">to_convergence_stage_frame</span> <span class="o">=</span> <span class="n">from_convergence_stage_frame</span><span class="o">.</span><span class="n">get_inverse</span><span class="p">()</span>

    <span class="c1"># Get the rotation of the trench relative to the anchor plate</span>
    <span class="c1"># from &#39;time + velocity_delta_time&#39; to &#39;time&#39;.</span>
    <span class="c1">#</span>
    <span class="c1"># Note: We don&#39;t need to convert to and from the stage rotation reference frame</span>
    <span class="c1"># like the above convergence because...</span>
    <span class="c1">#</span>
    <span class="c1">#   R(0-&gt;t,A-&gt;T)  = R(t+dt-&gt;t,A-&gt;T) * R(0-&gt;t+dt,A-&gt;T)</span>
    <span class="c1">#</span>
    <span class="c1">#   reconstructed_geometry = R(0-&gt;t,A-&gt;T) * present_day_geometry</span>
    <span class="c1">#                          = R(t+dt-&gt;t,A-&gt;T) * R(0-&gt;t+dt,A-&gt;T) * present_day_geometry</span>
    <span class="c1">#</span>
    <span class="c1"># ...where *reconstructed* subduction line geometry is already in the frame of the stage rotation &quot;R(t+dt-&gt;t,A-&gt;T)&quot;.</span>
    <span class="n">trench_equivalent_stage_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">trench_plate_id</span><span class="p">,</span>
        <span class="n">time</span> <span class="o">+</span> <span class="n">velocity_delta_time</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">output_subducting_absolute_velocity</span>
        <span class="ow">or</span> <span class="n">output_subducting_absolute_velocity_components</span>
    <span class="p">):</span>
        <span class="c1"># Get the rotation of the subducting plate relative to the anchor plate</span>
        <span class="c1"># from &#39;time + velocity_delta_time&#39; to &#39;time&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: We don&#39;t need to convert to and from the stage rotation reference frame</span>
        <span class="c1"># like the above convergence because...</span>
        <span class="c1">#</span>
        <span class="c1">#   R(0-&gt;t,A-&gt;T)  = R(0-&gt;t,A-&gt;S) * R(0-&gt;t,S-&gt;T)</span>
        <span class="c1">#                 = R(t+dt-&gt;t,A-&gt;S) * R(0-&gt;t+dt,A-&gt;S) * R(0-&gt;t,S-&gt;T)</span>
        <span class="c1">#</span>
        <span class="c1">#   reconstructed_geometry = R(0-&gt;t,A-&gt;T) * present_day_geometry</span>
        <span class="c1">#                          = R(t+dt-&gt;t,A-&gt;S) * R(0-&gt;t+dt,A-&gt;S) * R(0-&gt;t,S-&gt;T) * present_day_geometry</span>
        <span class="c1">#</span>
        <span class="c1"># ...where *reconstructed* subduction line geometry is already in the frame of the stage rotation &quot;R(t+dt-&gt;t,A-&gt;S)&quot;.</span>
        <span class="n">subducting_equivalent_stage_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">subducting_plate_id</span><span class="p">,</span>
            <span class="n">time</span> <span class="o">+</span> <span class="n">velocity_delta_time</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Ensure the shared sub-segment is tessellated to within the threshold sampling distance.</span>
    <span class="n">tessellated_shared_sub_segment_polyline</span> <span class="o">=</span> <span class="n">sub_segment_geometry</span><span class="o">.</span><span class="n">to_tessellated</span><span class="p">(</span>
        <span class="n">threshold_sampling_distance_radians</span>
    <span class="p">)</span>

    <span class="c1"># Iterate over the great circle arcs of the tessellated polyline to get the</span>
    <span class="c1"># arc midpoints, lengths and trench normals.</span>
    <span class="c1"># There is an arc between each adjacent pair of points in the polyline.</span>
    <span class="n">arc_midpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">arc_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">trench_normals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">tessellated_shared_sub_segment_polyline</span><span class="o">.</span><span class="n">get_segments</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arc</span><span class="o">.</span><span class="n">is_zero_length</span><span class="p">():</span>
            <span class="n">arc_midpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">get_arc_point</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
            <span class="n">arc_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">get_arc_length</span><span class="p">())</span>
            <span class="c1"># The normal to the trench in the direction of subduction (towards overriding plate).</span>
            <span class="n">trench_normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">trench_normal_reversal</span> <span class="o">*</span> <span class="n">arc</span><span class="o">.</span><span class="n">get_great_circle_normal</span><span class="p">()</span>
            <span class="p">)</span>

    <span class="c1"># Shouldn&#39;t happen, but just in case the shared sub-segment polyline coincides with a point.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arc_midpoints</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># The trench normals relative to North (azimuth).</span>
    <span class="c1"># Convert global 3D normal vectors to local (magnitude, azimuth, inclination) tuples (one tuple per point).</span>
    <span class="n">trench_local_normals</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">LocalCartesian</span><span class="o">.</span><span class="n">convert_from_geocentric_to_magnitude_azimuth_inclination</span><span class="p">(</span>
        <span class="n">arc_midpoints</span><span class="p">,</span> <span class="n">trench_normals</span>
    <span class="p">)</span>

    <span class="c1"># Calculate the convergence velocities at the arc midpoints.</span>
    <span class="c1">#</span>
    <span class="c1"># Note; We need to convert the reconstructed geometry points into the convergence stage rotation</span>
    <span class="c1"># reference frame to calculate velocities and then convert the velocities using the</span>
    <span class="c1"># reverse transform as mentioned above.</span>
    <span class="n">arc_midpoints_in_convergence_stage_frame</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">to_convergence_stage_frame</span> <span class="o">*</span> <span class="n">arc_midpoint</span> <span class="k">for</span> <span class="n">arc_midpoint</span> <span class="ow">in</span> <span class="n">arc_midpoints</span>
    <span class="p">]</span>
    <span class="n">convergence_velocity_vectors_in_convergence_stage_frame</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">calculate_velocities</span><span class="p">(</span>
            <span class="n">arc_midpoints_in_convergence_stage_frame</span><span class="p">,</span>
            <span class="n">convergence_relative_stage_rotation</span><span class="p">,</span>
            <span class="n">velocity_delta_time</span><span class="p">,</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">cms_per_yr</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">convergence_velocity_vectors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">from_convergence_stage_frame</span> <span class="o">*</span> <span class="n">velocity</span>
        <span class="k">for</span> <span class="n">velocity</span> <span class="ow">in</span> <span class="n">convergence_velocity_vectors_in_convergence_stage_frame</span>
    <span class="p">]</span>

    <span class="c1"># Calculate the trench absolute velocities at the arc midpoints.</span>
    <span class="n">trench_absolute_velocity_vectors</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">calculate_velocities</span><span class="p">(</span>
        <span class="n">arc_midpoints</span><span class="p">,</span>
        <span class="n">trench_equivalent_stage_rotation</span><span class="p">,</span>
        <span class="n">velocity_delta_time</span><span class="p">,</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">cms_per_yr</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">output_subducting_absolute_velocity</span>
        <span class="ow">or</span> <span class="n">output_subducting_absolute_velocity_components</span>
    <span class="p">):</span>
        <span class="c1"># Calculate the subducting absolute velocities at the arc midpoints.</span>
        <span class="n">subducting_absolute_velocity_vectors</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">calculate_velocities</span><span class="p">(</span>
            <span class="n">arc_midpoints</span><span class="p">,</span>
            <span class="n">subducting_equivalent_stage_rotation</span><span class="p">,</span>
            <span class="n">velocity_delta_time</span><span class="p">,</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">cms_per_yr</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">arc_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arc_midpoints</span><span class="p">)):</span>
        <span class="n">arc_midpoint</span> <span class="o">=</span> <span class="n">arc_midpoints</span><span class="p">[</span><span class="n">arc_index</span><span class="p">]</span>
        <span class="n">arc_length</span> <span class="o">=</span> <span class="n">arc_lengths</span><span class="p">[</span><span class="n">arc_index</span><span class="p">]</span>
        <span class="n">trench_normal</span> <span class="o">=</span> <span class="n">trench_normals</span><span class="p">[</span><span class="n">arc_index</span><span class="p">]</span>
        <span class="n">trench_normal_azimuth</span> <span class="o">=</span> <span class="n">trench_local_normals</span><span class="p">[</span><span class="n">arc_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">arc_midpoint</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>

        <span class="c1"># The direction towards which we rotate from the trench normal in a clockwise fashion.</span>
        <span class="n">clockwise_direction</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span>
            <span class="n">trench_normal</span><span class="p">,</span> <span class="n">arc_midpoint</span><span class="o">.</span><span class="n">to_xyz</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Calculate the convergence rate parameters.</span>
        <span class="n">convergence_velocity_vector</span> <span class="o">=</span> <span class="n">convergence_velocity_vectors</span><span class="p">[</span><span class="n">arc_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">convergence_velocity_vector</span><span class="o">.</span><span class="n">is_zero_magnitude</span><span class="p">():</span>
            <span class="n">convergence_velocity_magnitude</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">convergence_obliquity_degrees</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">convergence_velocity_magnitude</span> <span class="o">=</span> <span class="n">convergence_velocity_vector</span><span class="o">.</span><span class="n">get_magnitude</span><span class="p">()</span>
            <span class="n">convergence_obliquity_degrees</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">angle_between</span><span class="p">(</span>
                    <span class="n">convergence_velocity_vector</span><span class="p">,</span> <span class="n">trench_normal</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Anti-clockwise direction has range (0, -180) instead of (0, 180).</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">convergence_velocity_vector</span><span class="p">,</span> <span class="n">clockwise_direction</span><span class="p">)</span>
                <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="n">convergence_obliquity_degrees</span> <span class="o">=</span> <span class="o">-</span><span class="n">convergence_obliquity_degrees</span>

            <span class="c1"># See if plates are diverging (moving away from each other).</span>
            <span class="c1"># If plates are diverging (moving away from each other) then make the</span>
            <span class="c1"># velocity magnitude negative to indicate this. This could be inferred from</span>
            <span class="c1"># the obliquity but it seems this is the standard way to output convergence rate.</span>
            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">convergence_obliquity_degrees</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">convergence_velocity_magnitude</span> <span class="o">=</span> <span class="o">-</span><span class="n">convergence_velocity_magnitude</span>

        <span class="c1"># Calculate the trench absolute velocity magnitude and obliquity.</span>
        <span class="n">trench_absolute_velocity_vector</span> <span class="o">=</span> <span class="n">trench_absolute_velocity_vectors</span><span class="p">[</span><span class="n">arc_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">trench_absolute_velocity_vector</span><span class="o">.</span><span class="n">is_zero_magnitude</span><span class="p">():</span>
            <span class="n">trench_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">trench_absolute_obliquity_degrees</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trench_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">trench_absolute_velocity_vector</span><span class="o">.</span><span class="n">get_magnitude</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">trench_absolute_obliquity_degrees</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">angle_between</span><span class="p">(</span>
                    <span class="n">trench_absolute_velocity_vector</span><span class="p">,</span> <span class="n">trench_normal</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Anti-clockwise direction has range (0, -180) instead of (0, 180).</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">trench_absolute_velocity_vector</span><span class="p">,</span> <span class="n">clockwise_direction</span>
                <span class="p">)</span>
                <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="n">trench_absolute_obliquity_degrees</span> <span class="o">=</span> <span class="o">-</span><span class="n">trench_absolute_obliquity_degrees</span>

            <span class="c1"># See if the trench absolute motion is heading in the direction of the</span>
            <span class="c1"># overriding plate. If it is then make the velocity magnitude negative to</span>
            <span class="c1"># indicate this. This could be inferred from the obliquity but it seems this</span>
            <span class="c1"># is the standard way to output trench velocity magnitude.</span>
            <span class="c1">#</span>
            <span class="c1"># Note that we are not calculating the motion of the trench</span>
            <span class="c1"># relative to the overriding plate - they are usually attached to each other</span>
            <span class="c1"># and hence wouldn&#39;t move relative to each other.</span>
            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">trench_absolute_obliquity_degrees</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">trench_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="o">-</span><span class="n">trench_absolute_velocity_magnitude</span>

        <span class="c1"># Start with the standard tuple, and add extra data later (if requested).</span>
        <span class="c1">#</span>
        <span class="c1"># The data will be output in GMT format (ie, lon first, then lat, etc).</span>
        <span class="n">output_tuple</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">lon</span><span class="p">,</span>
            <span class="n">lat</span><span class="p">,</span>
            <span class="n">convergence_velocity_magnitude</span><span class="p">,</span>
            <span class="n">convergence_obliquity_degrees</span><span class="p">,</span>
            <span class="n">trench_absolute_velocity_magnitude</span><span class="p">,</span>
            <span class="n">trench_absolute_obliquity_degrees</span><span class="p">,</span>
            <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">arc_length</span><span class="p">),</span>
            <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">trench_normal_azimuth</span><span class="p">),</span>
            <span class="n">subducting_plate_id</span><span class="p">,</span>
            <span class="n">trench_plate_id</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">output_distance_to_nearest_edge_of_trench</span>
            <span class="ow">or</span> <span class="n">output_distance_to_start_edge_of_trench</span>
        <span class="p">):</span>
            <span class="c1"># Increase by distance from previous segment mid-point to current segment mid-point.</span>
            <span class="c1"># Which is half previous segment length and half current segment length.</span>
            <span class="k">if</span> <span class="n">arc_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">prev_arc_length</span> <span class="o">=</span> <span class="n">arc_lengths</span><span class="p">[</span><span class="n">arc_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">distance_along_trench_radians</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">prev_arc_length</span>
            <span class="n">distance_along_trench_radians</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">arc_length</span>

            <span class="c1"># Distance to nearest edge of the trench.</span>
            <span class="k">if</span> <span class="n">output_distance_to_nearest_edge_of_trench</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">distance_along_trench_radians</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">trench_length_radians</span><span class="p">:</span>
                    <span class="n">distance_to_nearest_edge_of_trench_radians</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">distance_along_trench_radians</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">distance_to_nearest_edge_of_trench_radians</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">trench_length_radians</span> <span class="o">-</span> <span class="n">distance_along_trench_radians</span>
                    <span class="p">)</span>

                <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">distance_to_nearest_edge_of_trench_radians</span><span class="p">),</span>
                <span class="p">)</span>

            <span class="c1"># Distance to start edge of the trench.</span>
            <span class="k">if</span> <span class="n">output_distance_to_start_edge_of_trench</span><span class="p">:</span>
                <span class="c1"># We want the distance to be along the clockwise direction around the overriding plate.</span>
                <span class="k">if</span> <span class="n">trench_normal_reversal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># The overriding plate is on the right of the trench.</span>
                    <span class="c1"># So the clockwise direction starts at the beginning of the trench.</span>
                    <span class="n">distance_to_start_edge_of_trench_radians</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">distance_along_trench_radians</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># The overriding plate is on the left of the trench.</span>
                    <span class="c1"># So the clockwise direction starts at the end of the trench.</span>
                    <span class="n">distance_to_start_edge_of_trench_radians</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">trench_length_radians</span> <span class="o">-</span> <span class="n">distance_along_trench_radians</span>
                    <span class="p">)</span>

                <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">distance_to_start_edge_of_trench_radians</span><span class="p">),</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">output_convergence_velocity_components</span><span class="p">:</span>
            <span class="c1"># The orthogonal and parallel components are just magnitude multiplied by cosine and sine.</span>
            <span class="n">convergence_velocity_orthogonal</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">convergence_obliquity_degrees</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">convergence_velocity_magnitude</span><span class="p">)</span>
            <span class="n">convergence_velocity_parallel</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">convergence_obliquity_degrees</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">convergence_velocity_magnitude</span><span class="p">)</span>
            <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">convergence_velocity_orthogonal</span><span class="p">,</span>
                <span class="n">convergence_velocity_parallel</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">output_trench_absolute_velocity_components</span><span class="p">:</span>
            <span class="c1"># The orthogonal and parallel components are just magnitude multiplied by cosine and sine.</span>
            <span class="n">trench_absolute_velocity_orthogonal</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">trench_absolute_obliquity_degrees</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">trench_absolute_velocity_magnitude</span><span class="p">)</span>
            <span class="n">trench_absolute_velocity_parallel</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">trench_absolute_obliquity_degrees</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">trench_absolute_velocity_magnitude</span><span class="p">)</span>
            <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">trench_absolute_velocity_orthogonal</span><span class="p">,</span>
                <span class="n">trench_absolute_velocity_parallel</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">output_subducting_absolute_velocity</span>
            <span class="ow">or</span> <span class="n">output_subducting_absolute_velocity_components</span>
        <span class="p">):</span>
            <span class="c1"># Calculate the subducting absolute velocity magnitude and obliquity.</span>
            <span class="n">subducting_absolute_velocity_vector</span> <span class="o">=</span> <span class="n">subducting_absolute_velocity_vectors</span><span class="p">[</span>
                <span class="n">arc_index</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">subducting_absolute_velocity_vector</span><span class="o">.</span><span class="n">is_zero_magnitude</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">output_subducting_absolute_velocity</span><span class="p">:</span>
                    <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">output_subducting_absolute_velocity_components</span><span class="p">:</span>
                    <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subducting_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subducting_absolute_velocity_vector</span><span class="o">.</span><span class="n">get_magnitude</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">subducting_absolute_obliquity_degrees</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span>
                    <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">angle_between</span><span class="p">(</span>
                        <span class="n">subducting_absolute_velocity_vector</span><span class="p">,</span> <span class="n">trench_normal</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># Anti-clockwise direction has range (0, -180) instead of (0, 180).</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">subducting_absolute_velocity_vector</span><span class="p">,</span> <span class="n">clockwise_direction</span>
                    <span class="p">)</span>
                    <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="n">subducting_absolute_obliquity_degrees</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="n">subducting_absolute_obliquity_degrees</span>
                    <span class="p">)</span>

                <span class="c1"># See if the subducting absolute motion is heading in the direction of the overriding plate.</span>
                <span class="c1"># If it is then make the velocity magnitude negative to indicate this.</span>
                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">subducting_absolute_obliquity_degrees</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                    <span class="n">subducting_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="n">subducting_absolute_velocity_magnitude</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">output_subducting_absolute_velocity</span><span class="p">:</span>
                    <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">subducting_absolute_velocity_magnitude</span><span class="p">,</span>
                        <span class="n">subducting_absolute_obliquity_degrees</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">output_subducting_absolute_velocity_components</span><span class="p">:</span>
                    <span class="c1"># The orthogonal and parallel components are just magnitude multiplied by cosine and sine.</span>
                    <span class="n">subducting_absolute_velocity_orthogonal</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span>
                        <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">subducting_absolute_obliquity_degrees</span><span class="p">)</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">subducting_absolute_velocity_magnitude</span><span class="p">)</span>
                    <span class="n">subducting_absolute_velocity_parallel</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span>
                        <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">subducting_absolute_obliquity_degrees</span><span class="p">)</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">subducting_absolute_velocity_magnitude</span><span class="p">)</span>
                    <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">subducting_absolute_velocity_orthogonal</span><span class="p">,</span>
                        <span class="n">subducting_absolute_velocity_parallel</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">output_trench_normal</span><span class="p">:</span>
            <span class="n">output_tuple</span> <span class="o">+=</span> <span class="n">trench_normal</span><span class="o">.</span><span class="n">to_xyz</span><span class="p">()</span>

        <span class="n">output_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_tuple</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">write_output_file</span><span class="p">(</span><span class="n">output_filename</span><span class="p">,</span> <span class="n">output_data</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">output_line</span> <span class="ow">in</span> <span class="n">output_data</span><span class="p">:</span>
            <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">output_line</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">create_coverage_feature_from_convergence_data</span><span class="p">(</span>
    <span class="n">subduction_convergence_data</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a feature with a coverage geometry containing the calculated convergence and absolute velocity data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    subduction_convergence_data : list of tuples</span>
<span class="sd">        The subduction convergence data calculated by :func:`subduction_convergence`.</span>
<span class="sd">        Each tuple in the list contains the calculated data for a single sample point on a trench line.</span>
<span class="sd">    time: float</span>
<span class="sd">        The reconstruction time associated with the subduction convergence data.</span>
<span class="sd">    output_distance_to_nearest_edge_of_trench : bool, default=False</span>
<span class="sd">        Append the distance (in degrees) along the trench line to the nearest trench edge to each returned sample point.</span>
<span class="sd">        A trench edge is the farthermost location on the current trench feature that contributes to a plate boundary.</span>
<span class="sd">    output_distance_to_start_edge_of_trench : bool, default=False</span>
<span class="sd">        Append the distance (in degrees) along the trench line from the start edge of the trench to each returned sample point.</span>
<span class="sd">        The start of the trench is along the clockwise direction around the overriding plate.</span>
<span class="sd">    output_convergence_velocity_components : bool, default=False</span>
<span class="sd">        Append the convergence velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">        Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">        Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">    output_trench_absolute_velocity_components : bool, default=False</span>
<span class="sd">        Append the trench absolute velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">        Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">        Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">    output_subducting_absolute_velocity : bool, default=False</span>
<span class="sd">        Append the subducting plate absolute velocity magnitude (in cm/yr) and obliquity angle (in degrees) to each returned sample point.</span>
<span class="sd">    output_subducting_absolute_velocity_components : bool, default=False</span>
<span class="sd">        Append the subducting plate absolute velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">        Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">        Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">    output_trench_normal : bool, default=False</span>
<span class="sd">        Append the x, y and z components of the trench normal unit-length 3D vectors.</span>
<span class="sd">        These vectors are normal to the trench in the direction of subduction (towards overriding plate).</span>
<span class="sd">        These are global 3D vectors which differ from trench normal azimuth angles (ie, angles relative to North).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pygplates.Feature</span>
<span class="sd">        The feature with a coverage geometry containing the calculated convergence and absolute velocity data.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The optional &#39;output_*&#39; parameters are the same as that of the `subduction_convergence` function , which is used to append extra data</span>
<span class="sd">    to the output of each sample point. Here it is used to interpret the same output data and create scalar coverages.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Process keyword arguments.</span>
    <span class="c1">#</span>
    <span class="n">output_distance_to_nearest_edge_of_trench</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_distance_to_nearest_edge_of_trench&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_distance_to_start_edge_of_trench</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_distance_to_start_edge_of_trench&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_convergence_velocity_components</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_convergence_velocity_components&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_trench_absolute_velocity_components</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_trench_absolute_velocity_components&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_subducting_absolute_velocity</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_subducting_absolute_velocity&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_subducting_absolute_velocity_components</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_subducting_absolute_velocity_components&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_trench_normal</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_trench_normal&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Convert the list of tuples (one tuple per sample point) into a tuple of lists (one list per data parameter).</span>
    <span class="n">parameter_lists</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">subduction_convergence_data</span><span class="p">))</span>

    <span class="c1"># Put all convergence data for the current reconstruction time into a single feature.</span>
    <span class="n">coverage_feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="p">()</span>

    <span class="c1"># Make it only appear at &#39;time&#39;.</span>
    <span class="n">coverage_feature</span><span class="o">.</span><span class="n">set_valid_time</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">time</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># Extract the non-optional parameters.</span>
    <span class="n">all_lon</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">all_lat</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">all_convergence_velocity_magnitude</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">all_convergence_obliquity_degrees</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">all_trench_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">all_trench_absolute_obliquity_degrees</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">all_subducting_length_degrees</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">all_trench_normal_azimuth_degrees</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="n">all_subducting_plate_id</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">all_trench_plate_id</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>

    <span class="c1"># Add each data parameter as a separate scalar coverage.</span>
    <span class="n">coverage_geometry</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">all_lat</span><span class="p">,</span> <span class="n">all_lon</span><span class="p">))</span>
    <span class="n">coverage_scalars</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span>
            <span class="s2">&quot;ConvergenceVelocityMagnitude&quot;</span>
        <span class="p">):</span> <span class="n">all_convergence_velocity_magnitude</span><span class="p">,</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span>
            <span class="s2">&quot;ConvergenceObliquityDegrees&quot;</span>
        <span class="p">):</span> <span class="n">all_convergence_obliquity_degrees</span><span class="p">,</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span>
            <span class="s2">&quot;TrenchAbsoluteVelocityMagnitude&quot;</span>
        <span class="p">):</span> <span class="n">all_trench_absolute_velocity_magnitude</span><span class="p">,</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span>
            <span class="s2">&quot;TrenchAbsoluteObliquityDegrees&quot;</span>
        <span class="p">):</span> <span class="n">all_trench_absolute_obliquity_degrees</span><span class="p">,</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span>
            <span class="s2">&quot;SubductingLengthDegrees&quot;</span>
        <span class="p">):</span> <span class="n">all_subducting_length_degrees</span><span class="p">,</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span>
            <span class="s2">&quot;TrenchNormalAzimuthDegrees&quot;</span>
        <span class="p">):</span> <span class="n">all_trench_normal_azimuth_degrees</span><span class="p">,</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;SubductingPlateId&quot;</span><span class="p">):</span> <span class="n">all_subducting_plate_id</span><span class="p">,</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;TrenchPlateId&quot;</span><span class="p">):</span> <span class="n">all_trench_plate_id</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Extract the optional parameters.</span>
    <span class="n">optional_parameter_index</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">if</span> <span class="n">output_distance_to_nearest_edge_of_trench</span><span class="p">:</span>
        <span class="n">all_distance_to_nearest_edge_of_trench_degrees</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span>
            <span class="n">optional_parameter_index</span>
        <span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;DistanceToNearestEdgeOfTrenchDegrees&quot;</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">all_distance_to_nearest_edge_of_trench_degrees</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">output_distance_to_start_edge_of_trench</span><span class="p">:</span>
        <span class="n">all_distance_to_start_edge_of_trench_degrees</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span>
            <span class="n">optional_parameter_index</span>
        <span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;DistanceToStartEdgeOfTrenchDegrees&quot;</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">all_distance_to_start_edge_of_trench_degrees</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">output_convergence_velocity_components</span><span class="p">:</span>
        <span class="n">all_convergence_velocity_orthogonal</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="n">optional_parameter_index</span><span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;ConvergenceVelocityOrthogonal&quot;</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">all_convergence_velocity_orthogonal</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">all_convergence_velocity_parallel</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="n">optional_parameter_index</span><span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;ConvergenceVelocityParallel&quot;</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">all_convergence_velocity_parallel</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">output_trench_absolute_velocity_components</span><span class="p">:</span>
        <span class="n">all_trench_absolute_velocity_orthogonal</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span>
            <span class="n">optional_parameter_index</span>
        <span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;TrenchAbsoluteVelocityOrthogonal&quot;</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">all_trench_absolute_velocity_orthogonal</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">all_trench_absolute_velocity_parallel</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span>
            <span class="n">optional_parameter_index</span>
        <span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;TrenchAbsoluteVelocityParallel&quot;</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">all_trench_absolute_velocity_parallel</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">output_subducting_absolute_velocity</span><span class="p">:</span>
        <span class="n">all_subducting_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span>
            <span class="n">optional_parameter_index</span>
        <span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;SubductingAbsoluteVelocityMagnitude&quot;</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">all_subducting_absolute_velocity_magnitude</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">all_subducting_absolute_obliquity_degrees</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span>
            <span class="n">optional_parameter_index</span>
        <span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;SubductingAbsoluteObliquityDegrees&quot;</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">all_subducting_absolute_obliquity_degrees</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">output_subducting_absolute_velocity_components</span><span class="p">:</span>
        <span class="n">all_subducting_absolute_velocity_orthogonal</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span>
            <span class="n">optional_parameter_index</span>
        <span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;SubductingAbsoluteVelocityOrthogonal&quot;</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">all_subducting_absolute_velocity_orthogonal</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">all_subducting_absolute_velocity_parallel</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span>
            <span class="n">optional_parameter_index</span>
        <span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;SubductingAbsoluteVelocityParallel&quot;</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">all_subducting_absolute_velocity_parallel</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">output_trench_normal</span><span class="p">:</span>
        <span class="n">all_trench_normal_x</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="n">optional_parameter_index</span><span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;TrenchNormalX&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">all_trench_normal_x</span>
        <span class="p">)</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">all_trench_normal_y</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="n">optional_parameter_index</span><span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;TrenchNormalY&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">all_trench_normal_y</span>
        <span class="p">)</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">all_trench_normal_z</span> <span class="o">=</span> <span class="n">parameter_lists</span><span class="p">[</span><span class="n">optional_parameter_index</span><span class="p">]</span>
        <span class="n">coverage_scalars</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s2">&quot;TrenchNormalZ&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">all_trench_normal_z</span>
        <span class="p">)</span>
        <span class="n">optional_parameter_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">coverage_feature</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">((</span><span class="n">coverage_geometry</span><span class="p">,</span> <span class="n">coverage_scalars</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">coverage_feature</span>


<span class="k">def</span><span class="w"> </span><span class="nf">subduction_convergence_over_time</span><span class="p">(</span>
    <span class="n">output_filename_prefix</span><span class="p">,</span>
    <span class="n">output_filename_extension</span><span class="p">,</span>
    <span class="n">rotation_filenames</span><span class="p">,</span>
    <span class="n">topology_filenames</span><span class="p">,</span>
    <span class="n">threshold_sampling_distance_radians</span><span class="p">,</span>
    <span class="n">time_young</span><span class="p">,</span>
    <span class="n">time_old</span><span class="p">,</span>
    <span class="n">time_increment</span><span class="p">,</span>
    <span class="n">velocity_delta_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">output_gpml_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">include_slab_topologies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;calculate subduction convergence over time&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_increment</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;The time increment &quot;</span><span class="si">{0}</span><span class="s1">&quot; is not positive and non-zero.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">time_increment</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">time_young</span> <span class="o">&gt;</span> <span class="n">time_old</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The young time </span><span class="si">{0}</span><span class="s2"> is older (larger) than the old time </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">time_young</span><span class="p">,</span> <span class="n">time_old</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">rotation_filenames</span><span class="p">)</span>

    <span class="c1"># Read/parse the topological features once so we&#39;re not doing at each time iteration.</span>
    <span class="n">topology_features</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">topology_filename</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">topology_filename</span> <span class="ow">in</span> <span class="n">topology_filenames</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">output_gpml_filename</span><span class="p">:</span>
        <span class="n">coverage_features</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate over the time rage.</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">time_young</span>
    <span class="k">while</span> <span class="n">time</span> <span class="o">&lt;=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeoTimeInstant</span><span class="p">(</span><span class="n">time_old</span><span class="p">):</span>
        <span class="c1"># print(&#39;Time {0}&#39;.format(time))</span>

        <span class="c1"># Returns a list of tesselated trench points and associated convergence parameters</span>
        <span class="c1"># to write to the output file for the current &#39;time&#39;.</span>
        <span class="n">output_data</span> <span class="o">=</span> <span class="n">subduction_convergence</span><span class="p">(</span>
            <span class="n">rotation_model</span><span class="p">,</span>
            <span class="n">topology_features</span><span class="p">,</span>
            <span class="n">threshold_sampling_distance_radians</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">velocity_delta_time</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="p">,</span>
            <span class="n">include_slab_topologies</span><span class="o">=</span><span class="n">include_slab_topologies</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">output_data</span><span class="p">:</span>
            <span class="n">output_filename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">_</span><span class="si">{1:0.2f}</span><span class="s2">.</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">output_filename_prefix</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">output_filename_extension</span>
            <span class="p">)</span>
            <span class="n">write_output_file</span><span class="p">(</span><span class="n">output_filename</span><span class="p">,</span> <span class="n">output_data</span><span class="p">)</span>

            <span class="c1"># Also keep track of convergence data if we need to write out a GPML file.</span>
            <span class="k">if</span> <span class="n">output_gpml_filename</span><span class="p">:</span>
                <span class="n">coverage_feature</span> <span class="o">=</span> <span class="n">create_coverage_feature_from_convergence_data</span><span class="p">(</span>
                    <span class="n">output_data</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
                <span class="n">coverage_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coverage_feature</span><span class="p">)</span>

        <span class="c1"># Increment the time further into the past.</span>
        <span class="n">time</span> <span class="o">+=</span> <span class="n">time_increment</span>

    <span class="k">if</span> <span class="n">output_gpml_filename</span><span class="p">:</span>
        <span class="c1"># Write out all coverage features to a single GPML file.</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">coverage_features</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output_gpml_filename</span><span class="p">)</span>

    <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># Success</span>


<span class="c1"># Convert mm/yr to cm/yr.</span>
<span class="n">_MM_YR_TO_CM_YR</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1"># Earth mean radius in kms.</span>
<span class="n">_EARTH_RADIUS_KMS</span> <span class="o">=</span> <span class="mf">6371.009</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convert_old_convergence_output</span><span class="p">(</span><span class="n">old_convergence_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts the output of the old &quot;convergence.py&quot; script to the current output format of the `subduction_convergence` function.</span>

<span class="sd">    This function&#39;s purpose is to help transition workflows that use &quot;convergence.py&quot; to use this script instead.</span>
<span class="sd">    At the time this function was implemented, both scripts have essentially the same output with just minor format differences (as seen below).</span>
<span class="sd">    However in the future this script will generate additional outputs (such as deformation strain rates) that the old script will not.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    old_convergence_data : list of tuples</span>
<span class="sd">        The subduction convergence data output from the old &quot;convergence.py&quot; script.</span>
<span class="sd">        Each tuple in the list contains the data for a single sample point on a trench line.</span>
<span class="sd">    output_distance_to_nearest_edge_of_trench : bool, default=False</span>
<span class="sd">        Append the distance (in degrees) along the trench line to the nearest trench edge to each returned sample point.</span>
<span class="sd">        A trench edge is the farthermost location on the current trench feature that contributes to a plate boundary.</span>
<span class="sd">    output_distance_to_start_edge_of_trench : bool, default=False</span>
<span class="sd">        Append the distance (in degrees) along the trench line from the start edge of the trench to each returned sample point.</span>
<span class="sd">        The start of the trench is along the clockwise direction around the overriding plate.</span>
<span class="sd">    output_convergence_velocity_components : bool, default=False</span>
<span class="sd">        Append the convergence velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">        Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">        Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">    output_trench_absolute_velocity_components : bool, default=False</span>
<span class="sd">        Append the trench absolute velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">        Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">        Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">    output_subducting_absolute_velocity : bool, default=False</span>
<span class="sd">        Append the subducting plate absolute velocity magnitude (in cm/yr) and obliquity angle (in degrees) to each returned sample point.</span>
<span class="sd">    output_subducting_absolute_velocity_components : bool, default=False</span>
<span class="sd">        Append the subducting plate absolute velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">        Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">        Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">    output_trench_normal : bool, default=False</span>
<span class="sd">        Append the x, y and z components of the trench normal unit-length 3D vectors.</span>
<span class="sd">        These vectors are normal to the trench in the direction of subduction (towards overriding plate).</span>
<span class="sd">        These are global 3D vectors which differ from trench normal azimuth angles (ie, angles relative to North).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of tuples</span>
<span class="sd">        The converted results for all input points from the old &quot;convergence.py&quot; script.</span>
<span class="sd">        The size of the returned list is equal to the number of input points.</span>
<span class="sd">        Each tuple in the list corresponds to a point and has the following tuple items:</span>

<span class="sd">        * longitude of sample point</span>
<span class="sd">        * latitude of sample point</span>
<span class="sd">        * subducting convergence (relative to trench) velocity magnitude (in cm/yr)</span>
<span class="sd">        * subducting convergence velocity obliquity angle (angle between trench normal vector and convergence velocity vector)</span>
<span class="sd">        * trench absolute (relative to anchor plate) velocity magnitude (in cm/yr)</span>
<span class="sd">        * trench absolute velocity obliquity angle (angle between trench normal vector and trench absolute velocity vector)</span>
<span class="sd">        * length of arc segment (in degrees) that current point is on</span>
<span class="sd">        * trench normal azimuth angle (clockwise starting at North, ie, 0 to 360 degrees) at current point</span>
<span class="sd">        * subducting plate ID</span>
<span class="sd">        * trench plate ID</span>

<span class="sd">        The optional &#39;output_*&#39; parameters can be used to append extra data to the tuple of each sampled trench point.</span>
<span class="sd">        The order of any extra data is the same order in which the parameters are listed in this function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The optional &#39;output_*&#39; parameters are the same as that of the `subduction_convergence` function , which is used to append extra data</span>
<span class="sd">    to the output of each sample point.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Process keyword arguments.</span>
    <span class="c1">#</span>
    <span class="n">output_distance_to_nearest_edge_of_trench</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_distance_to_nearest_edge_of_trench&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_distance_to_start_edge_of_trench</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_distance_to_start_edge_of_trench&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_convergence_velocity_components</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_convergence_velocity_components&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_trench_absolute_velocity_components</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_trench_absolute_velocity_components&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_subducting_absolute_velocity</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_subducting_absolute_velocity&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_subducting_absolute_velocity_components</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;output_subducting_absolute_velocity_components&quot;</span><span class="p">,</span> <span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">output_trench_normal</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_trench_normal&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="n">new_convergence_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">old_convergence_data_sample</span> <span class="ow">in</span> <span class="n">old_convergence_data</span><span class="p">:</span>
        <span class="p">(</span>
            <span class="c1"># Longitude of mid-point of segment (degrees).</span>
            <span class="n">old_longitude</span><span class="p">,</span>
            <span class="c1"># Latitude of mid-point of segment (degrees).</span>
            <span class="n">old_latitude</span><span class="p">,</span>
            <span class="c1"># Convergence velocity magnitude (mm/yr).</span>
            <span class="n">old_convRate</span><span class="p">,</span>
            <span class="c1"># Length of segment containing the sample mid-point (km).</span>
            <span class="n">old_segmentLength</span><span class="p">,</span>
            <span class="c1"># Subducting plate velocity orthogonal to the trench in direction of overriding plate (mm/yr).</span>
            <span class="n">old_orthAbs</span><span class="p">,</span>
            <span class="c1"># Overriding plate velocity orthogonal to the trench in direction of overriding plate (mm/yr).</span>
            <span class="n">old_orthOP</span><span class="p">,</span>
            <span class="c1"># Trench velocity orthogonal to the trench in direction of overriding plate (mm/yr).</span>
            <span class="n">old_orthTrench</span><span class="p">,</span>
            <span class="c1"># Convergence obliquity (degrees) varies from 0 to 90 degrees (regardless of diverging/converging).</span>
            <span class="n">old_subObliquity</span><span class="p">,</span>
            <span class="c1"># Subduction line polarity (degrees).</span>
            <span class="c1"># Angle from North (-180 to 180 degrees) along subduction line</span>
            <span class="c1"># in order of its points (ie, first to last).</span>
            <span class="c1"># Note that the subduction line&#39;s points are reversed (if necessary)</span>
            <span class="c1"># so that the overriding plate is always on its right.</span>
            <span class="n">old_subPolarity</span><span class="p">,</span>
            <span class="c1"># Distance (km) to start of subduction line, where start is the first point along</span>
            <span class="c1"># subduction line where subducting/overriding plate IDs are same as current location.</span>
            <span class="c1"># Note that the subduction line&#39;s points are reversed (if necessary)</span>
            <span class="c1"># so that the overriding plate is always on its right.</span>
            <span class="n">old_distEdge</span><span class="p">,</span>
            <span class="c1"># Convergence velocity orthogonal to the trench in direction of overriding plate (mm/yr).</span>
            <span class="n">old_convPerp</span><span class="p">,</span>
            <span class="c1"># Convergence velocity parallel to the trench (mm/yr) along subduction line</span>
            <span class="c1"># in order of its points (ie, first to last).</span>
            <span class="c1"># Note that the subduction line&#39;s points are reversed (if necessary)</span>
            <span class="c1"># so that the overriding plate is always on its right.</span>
            <span class="n">old_convPar</span><span class="p">,</span>
            <span class="c1"># Subducting plate velocity parallel to the trench (mm/yr) along subduction line</span>
            <span class="c1"># in order of its points (ie, first to last).</span>
            <span class="c1"># Note that the subduction line&#39;s points are reversed (if necessary)</span>
            <span class="c1"># so that the overriding plate is always on its right.</span>
            <span class="n">old_parAbs</span><span class="p">,</span>
            <span class="c1"># Overriding plate velocity parallel to the trench (mm/yr) along subduction line</span>
            <span class="c1"># in order of its points (ie, first to last).</span>
            <span class="c1"># Note that the subduction line&#39;s points are reversed (if necessary)</span>
            <span class="c1"># so that the overriding plate is always on its right.</span>
            <span class="n">old_parOP</span><span class="p">,</span>
            <span class="c1"># Trench velocity parallel to the trench (mm/yr) along subduction line</span>
            <span class="c1"># in order of its points (ie, first to last).</span>
            <span class="c1"># Note that the subduction line&#39;s points are reversed (if necessary)</span>
            <span class="c1"># so that the overriding plate is always on its right.</span>
            <span class="n">old_parTrench</span><span class="p">,</span>
            <span class="c1"># Distance (km) to edge of subduction line, where edge is nearest location along</span>
            <span class="c1"># subduction line where subducting/overriding plate IDs differ from current location.</span>
            <span class="n">old_distEdgeTotal</span><span class="p">,</span>
            <span class="c1"># Subducting plate ID.</span>
            <span class="n">old_SPid</span><span class="p">,</span>
            <span class="c1"># Trench plate ID.</span>
            <span class="n">old_TRENCHid</span><span class="p">,</span>
            <span class="c1"># Overriding plate ID.</span>
            <span class="n">old_OPid</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">old_convergence_data_sample</span>

        <span class="n">new_longitude</span> <span class="o">=</span> <span class="n">old_longitude</span>
        <span class="n">new_latitude</span> <span class="o">=</span> <span class="n">old_latitude</span>

        <span class="c1"># Convergence velocity magnitude.</span>
        <span class="n">new_convergence_velocity_magnitude</span> <span class="o">=</span> <span class="n">_MM_YR_TO_CM_YR</span> <span class="o">*</span> <span class="n">old_convRate</span>
        <span class="c1"># The convergence velocity magnitude is negative if the plates are diverging.</span>
        <span class="k">if</span> <span class="n">old_convPerp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_convergence_velocity_magnitude</span> <span class="o">=</span> <span class="o">-</span><span class="n">new_convergence_velocity_magnitude</span>

        <span class="c1">#</span>
        <span class="c1"># The vertical line is subduction line in old convergence (normal is always to the right).</span>
        <span class="c1"># The new obliquity goes clockwise (0 to 180) and counter-clockwise (0 to -180) from the normal</span>
        <span class="c1"># (which points in the direction of the overriding plate).</span>
        <span class="c1"># This is atan2(-y, x) where x is component of convergence velocity in the normal direction, and</span>
        <span class="c1"># y is component of convergence along old subduction line.</span>
        <span class="c1">#</span>
        <span class="c1">#                 --&gt; normal</span>
        <span class="c1">#                ^\    positive</span>
        <span class="c1">#                | \  obliquity</span>
        <span class="c1">#                |  \</span>
        <span class="c1">#</span>
        <span class="c1">#             &lt;-- normal</span>
        <span class="c1">#    negative   /^</span>
        <span class="c1">#   obliquity  / |</span>
        <span class="c1">#             /  |</span>
        <span class="c1">#</span>
        <span class="n">new_convergence_obliquity_degrees</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">old_convPar</span><span class="p">,</span> <span class="n">old_convPerp</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Trench absolute velocity magnitude obtained parallel and orthogonal components.</span>
        <span class="n">new_trench_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="n">_MM_YR_TO_CM_YR</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">old_parTrench</span> <span class="o">*</span> <span class="n">old_parTrench</span> <span class="o">+</span> <span class="n">old_orthTrench</span> <span class="o">*</span> <span class="n">old_orthTrench</span>
        <span class="p">)</span>
        <span class="c1"># The trench absolute velocity magnitude is negative if trench is moving toward the overriding plate.</span>
        <span class="k">if</span> <span class="n">old_orthTrench</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_trench_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="p">(</span>
                <span class="o">-</span><span class="n">new_trench_absolute_velocity_magnitude</span>
            <span class="p">)</span>

        <span class="c1"># Same reasoning as for convergence obliquity above.</span>
        <span class="n">new_trench_absolute_obliquity_degrees</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">old_parTrench</span><span class="p">,</span> <span class="n">old_orthTrench</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Convert distance in kms to degrees.</span>
        <span class="n">new_arc_length_degrees</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">old_segmentLength</span> <span class="o">/</span> <span class="n">_EARTH_RADIUS_KMS</span><span class="p">)</span>

        <span class="c1"># The old subduction polarity points along the subduction line, and since the overriding plate</span>
        <span class="c1"># (and hence normal) is always to the right, we simply add 90 degrees to point along normal.</span>
        <span class="n">new_subducting_arc_normal_azimuth_degrees</span> <span class="o">=</span> <span class="n">old_subPolarity</span> <span class="o">+</span> <span class="mf">90.0</span>
        <span class="c1"># Ensure range is [0,360].</span>
        <span class="n">new_subducting_arc_normal_azimuth_degrees</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">new_subducting_arc_normal_azimuth_degrees</span> <span class="o">+</span> <span class="mf">360.0</span>
        <span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span>

        <span class="n">new_subducting_plate_id</span> <span class="o">=</span> <span class="n">old_SPid</span>
        <span class="n">new_subduction_zone_plate_id</span> <span class="o">=</span> <span class="n">old_TRENCHid</span>

        <span class="n">new_convergence_data_sample</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">new_longitude</span><span class="p">,</span>
            <span class="n">new_latitude</span><span class="p">,</span>
            <span class="n">new_convergence_velocity_magnitude</span><span class="p">,</span>
            <span class="n">new_convergence_obliquity_degrees</span><span class="p">,</span>
            <span class="n">new_trench_absolute_velocity_magnitude</span><span class="p">,</span>
            <span class="n">new_trench_absolute_obliquity_degrees</span><span class="p">,</span>
            <span class="n">new_arc_length_degrees</span><span class="p">,</span>
            <span class="n">new_subducting_arc_normal_azimuth_degrees</span><span class="p">,</span>
            <span class="n">new_subducting_plate_id</span><span class="p">,</span>
            <span class="n">new_subduction_zone_plate_id</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">output_distance_to_nearest_edge_of_trench</span><span class="p">:</span>
            <span class="c1"># Convert distance in kms to degrees.</span>
            <span class="n">new_distance_to_nearest_edge_of_trench_degrees</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span>
                <span class="n">old_distEdgeTotal</span> <span class="o">/</span> <span class="n">_EARTH_RADIUS_KMS</span>
            <span class="p">)</span>

            <span class="n">new_convergence_data_sample</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">new_distance_to_nearest_edge_of_trench_degrees</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">output_distance_to_start_edge_of_trench</span><span class="p">:</span>
            <span class="c1"># Convert distance in kms to degrees.</span>
            <span class="n">new_distance_to_start_edge_of_trench_degrees</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span>
                <span class="n">old_distEdge</span> <span class="o">/</span> <span class="n">_EARTH_RADIUS_KMS</span>
            <span class="p">)</span>

            <span class="n">new_convergence_data_sample</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">new_distance_to_start_edge_of_trench_degrees</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">output_convergence_velocity_components</span><span class="p">:</span>
            <span class="n">new_convergence_velocity_orthogonal</span> <span class="o">=</span> <span class="n">_MM_YR_TO_CM_YR</span> <span class="o">*</span> <span class="n">old_convPerp</span>
            <span class="n">new_convergence_velocity_parallel</span> <span class="o">=</span> <span class="n">_MM_YR_TO_CM_YR</span> <span class="o">*</span> <span class="o">-</span><span class="n">old_convPar</span>

            <span class="c1"># Should give same values as the following...</span>
            <span class="c1">#</span>
            <span class="c1"># # The orthogonal and parallel components are just magnitude multiplied by cosine and sine.</span>
            <span class="c1"># new_convergence_velocity_orthogonal = (</span>
            <span class="c1">#     math.cos(math.radians(new_convergence_obliquity_degrees)) * math.fabs(new_convergence_velocity_magnitude))</span>
            <span class="c1"># new_convergence_velocity_parallel = (</span>
            <span class="c1">#     math.sin(math.radians(new_convergence_obliquity_degrees)) * math.fabs(new_convergence_velocity_magnitude))</span>

            <span class="n">new_convergence_data_sample</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">new_convergence_velocity_orthogonal</span><span class="p">,</span>
                <span class="n">new_convergence_velocity_parallel</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">output_trench_absolute_velocity_components</span><span class="p">:</span>
            <span class="n">new_trench_absolute_velocity_orthogonal</span> <span class="o">=</span> <span class="n">_MM_YR_TO_CM_YR</span> <span class="o">*</span> <span class="n">old_orthTrench</span>
            <span class="n">new_trench_absolute_velocity_parallel</span> <span class="o">=</span> <span class="n">_MM_YR_TO_CM_YR</span> <span class="o">*</span> <span class="o">-</span><span class="n">old_parTrench</span>

            <span class="c1"># Should give same values as the following...</span>
            <span class="c1">#</span>
            <span class="c1"># # The orthogonal and parallel components are just magnitude multiplied by cosine and sine.</span>
            <span class="c1"># new_trench_absolute_velocity_orthogonal = (</span>
            <span class="c1">#     math.cos(math.radians(new_trench_absolute_obliquity_degrees)) * math.fabs(new_trench_absolute_velocity_magnitude))</span>
            <span class="c1"># new_trench_absolute_velocity_parallel = (</span>
            <span class="c1">#     math.sin(math.radians(new_trench_absolute_obliquity_degrees)) * math.fabs(new_trench_absolute_velocity_magnitude))</span>

            <span class="n">new_convergence_data_sample</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">new_trench_absolute_velocity_orthogonal</span><span class="p">,</span>
                <span class="n">new_trench_absolute_velocity_parallel</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">output_subducting_absolute_velocity</span>
            <span class="ow">or</span> <span class="n">output_subducting_absolute_velocity_components</span>
        <span class="p">):</span>
            <span class="c1"># Subducting absolute velocity magnitude obtained parallel and orthogonal components.</span>
            <span class="n">new_subducting_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="n">_MM_YR_TO_CM_YR</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">old_parAbs</span> <span class="o">*</span> <span class="n">old_parAbs</span> <span class="o">+</span> <span class="n">old_orthAbs</span> <span class="o">*</span> <span class="n">old_orthAbs</span>
            <span class="p">)</span>
            <span class="c1"># The subducting absolute velocity magnitude is negative if subducting plate is moving toward the overriding plate.</span>
            <span class="k">if</span> <span class="n">old_orthAbs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_subducting_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="n">new_subducting_absolute_velocity_magnitude</span>
                <span class="p">)</span>

            <span class="c1"># Same reasoning as for convergence obliquity above.</span>
            <span class="n">new_subducting_absolute_obliquity_degrees</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">old_parAbs</span><span class="p">,</span> <span class="n">old_orthAbs</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">output_subducting_absolute_velocity</span><span class="p">:</span>
                <span class="n">new_convergence_data_sample</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">new_subducting_absolute_velocity_magnitude</span><span class="p">,</span>
                    <span class="n">new_subducting_absolute_obliquity_degrees</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">output_subducting_absolute_velocity_components</span><span class="p">:</span>
                <span class="n">new_subducting_absolute_velocity_orthogonal</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_MM_YR_TO_CM_YR</span> <span class="o">*</span> <span class="n">old_orthAbs</span>
                <span class="p">)</span>
                <span class="n">new_subducting_absolute_velocity_parallel</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_MM_YR_TO_CM_YR</span> <span class="o">*</span> <span class="o">-</span><span class="n">old_parAbs</span>
                <span class="p">)</span>

                <span class="c1"># Should give same values as the following...</span>
                <span class="c1">#</span>
                <span class="c1"># # The orthogonal and parallel components are just magnitude multiplied by cosine and sine.</span>
                <span class="c1"># new_subducting_absolute_velocity_orthogonal = (</span>
                <span class="c1">#     math.cos(math.radians(new_subducting_absolute_obliquity_degrees)) * math.fabs(new_subducting_absolute_velocity_magnitude))</span>
                <span class="c1"># new_subducting_absolute_velocity_parallel = (</span>
                <span class="c1">#     math.sin(math.radians(new_subducting_absolute_obliquity_degrees)) * math.fabs(new_subducting_absolute_velocity_magnitude))</span>

                <span class="n">new_convergence_data_sample</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">new_subducting_absolute_velocity_orthogonal</span><span class="p">,</span>
                    <span class="n">new_subducting_absolute_velocity_parallel</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">output_trench_normal</span><span class="p">:</span>
            <span class="c1"># Convert trench normal from local (magnitude, azimuth, inclination) to a global 3D vector.</span>
            <span class="n">local_cartesian</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">LocalCartesian</span><span class="p">((</span><span class="n">new_latitude</span><span class="p">,</span> <span class="n">new_longitude</span><span class="p">))</span>
            <span class="n">trench_normal</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">local_cartesian</span><span class="o">.</span><span class="n">from_magnitude_azimuth_inclination_to_geocentric</span><span class="p">(</span>
                    <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">new_subducting_arc_normal_azimuth_degrees</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">new_convergence_data_sample</span> <span class="o">+=</span> <span class="n">trench_normal</span><span class="o">.</span><span class="n">to_xyz</span><span class="p">()</span>

        <span class="n">new_convergence_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_convergence_data_sample</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_convergence_data</span>


<span class="c1"># List of optional output parameters available to append to the output of each sample point.</span>
<span class="c1">#</span>
<span class="c1"># NOTE: This should be in the same order as output parameters are actually added.</span>
<span class="n">_OUTPUT_PARAMETER_NAME_LIST</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;output_distance_to_nearest_edge_of_trench&quot;</span><span class="p">,</span>
    <span class="s2">&quot;output_distance_to_start_edge_of_trench&quot;</span><span class="p">,</span>
    <span class="s2">&quot;output_convergence_velocity_components&quot;</span><span class="p">,</span>
    <span class="s2">&quot;output_trench_absolute_velocity_components&quot;</span><span class="p">,</span>
    <span class="s2">&quot;output_subducting_absolute_velocity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;output_subducting_absolute_velocity_components&quot;</span><span class="p">,</span>
    <span class="s2">&quot;output_trench_normal&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="c1">########################</span>
<span class="c1"># Command-line parsing #</span>
<span class="c1">########################</span>


<span class="k">def</span><span class="w"> </span><span class="nf">warning_format</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># return &#39;{0}:{1}: {1}:{1}\n&#39;.format(filename, lineno, category.__name__, message)</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">category</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>


<span class="c1"># Print the warnings without the filename and line number.</span>
<span class="c1"># Users are not going to want to see that.</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">formatwarning</span> <span class="o">=</span> <span class="n">warning_format</span>

<span class="n">__description__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Find the convergence rates along trenches (subduction zones) over time.</span>

<span class="s2">For each time (over a range of times) an output xy file is generated containing the resolved trenches</span>
<span class="s2">(with point locations as the first two columns x and y) and the following convergence rate parameters in subsequent columns:</span>

<span class="s2">    - subducting convergence (relative to trench) velocity magnitude (in cm/yr)</span>
<span class="s2">    - subducting convergence velocity obliquity angle (angle between trench normal vector and convergence velocity vector)</span>
<span class="s2">    - trench absolute (relative to anchor plate) velocity magnitude (in cm/yr)</span>
<span class="s2">    - trench absolute velocity obliquity angle (angle between trench normal vector and trench absolute velocity vector)</span>
<span class="s2">    - length of arc segment (in degrees) that current point is on</span>
<span class="s2">    - trench normal azimuth angle (clockwise starting at North, ie, 0 to 360 degrees) at current point</span>
<span class="s2">    - subducting plate ID</span>
<span class="s2">    - trench plate ID</span>
<span class="s2">    </span>
<span class="s2">    - extra data can be appended by specifying optional extra output parameters using the &#39;-x&#39; command-line option.</span>
<span class="s2">    </span>
<span class="s2">    The order of any extra data is the same order in which the parameters are listed below.</span>
<span class="s2">    But note that all parameters are optional, you only need to specify the ones you want.</span>
<span class="s2">    </span>
<span class="s2">    +------------------------------------------------+-----------------------------------------------------------------------------------+</span>
<span class="s2">    | Name                                           | Description                                                                       |</span>
<span class="s2">    +------------------------------------------------+-----------------------------------------------------------------------------------+</span>
<span class="s2">    | output_distance_to_nearest_edge_of_trench      | Append the distance (in degrees) along the trench line to the nearest             |</span>
<span class="s2">    |                                                | trench edge to each returned sample point. A trench edge is the farthermost       |</span>
<span class="s2">    |                                                | location on the current trench feature that contributes to a plate boundary.      |</span>
<span class="s2">    +------------------------------------------------+-----------------------------------------------------------------------------------+</span>
<span class="s2">    | output_distance_to_start_edge_of_trench        | Append the distance (in degrees) along the trench line from the start edge of     |</span>
<span class="s2">    |                                                | the trench to each returned sample point. The start of the trench is along the    |</span>
<span class="s2">    |                                                | clockwise direction around the overriding plate.                                  |</span>
<span class="s2">    +------------------------------------------------+-----------------------------------------------------------------------------------+</span>
<span class="s2">    | output_convergence_velocity_components         | Append the convergence velocity orthogonal and parallel                           |</span>
<span class="s2">    |                                                | components (in cm/yr) to each returned sample point.                              |</span>
<span class="s2">    |                                                | Orthogonal is normal to trench (in direction of overriding plate when positive).  |</span>
<span class="s2">    |                                                | Parallel is along trench (90 degrees clockwise from trench normal when positive). |</span>
<span class="s2">    +------------------------------------------------+-----------------------------------------------------------------------------------+</span>
<span class="s2">    | output_trench_absolute_velocity_components     | Append the trench absolute velocity orthogonal and parallel                       |</span>
<span class="s2">    |                                                | components (in cm/yr) to each returned sample point.                              |</span>
<span class="s2">    |                                                | Orthogonal is normal to trench (in direction of overriding plate when positive).  |</span>
<span class="s2">    |                                                | Parallel is along trench (90 degrees clockwise from trench normal when positive). |</span>
<span class="s2">    +------------------------------------------------+-----------------------------------------------------------------------------------+</span>
<span class="s2">    | output_subducting_absolute_velocity            | Append the subducting plate absolute velocity magnitude (in cm/yr) and            |</span>
<span class="s2">    |                                                | obliquity angle (in degrees) to each returned sample point.                       |</span>
<span class="s2">    +------------------------------------------------+-----------------------------------------------------------------------------------+</span>
<span class="s2">    | output_subducting_absolute_velocity_components | Append the subducting plate absolute velocity orthogonal and parallel             |</span>
<span class="s2">    |                                                | components (in cm/yr) to each returned sample point.                              |</span>
<span class="s2">    |                                                | Orthogonal is normal to trench (in direction of overriding plate when positive).  |</span>
<span class="s2">    |                                                | Parallel is along trench (90 degrees clockwise from trench normal when positive). |</span>
<span class="s2">    +------------------------------------------------+-----------------------------------------------------------------------------------+</span>
<span class="s2">    | output_trench_normal                           | Append the x, y and z components of the trench normal unit-length 3D vectors.     |</span>
<span class="s2">    |                                                | These vectors are normal to the trench in the direction of subduction             |</span>
<span class="s2">    |                                                | (towards overriding plate). These are global 3D vectors which differ from         |</span>
<span class="s2">    |                                                | trench normal azimuth angles (ie, angles relative to North).                      |</span>
<span class="s2">    +------------------------------------------------+-----------------------------------------------------------------------------------+</span>

<span class="s2">The obliquity angles are in the range (-180 180). The range (0, 180) goes clockwise (when viewed from above the Earth) from the</span>
<span class="s2">trench normal direction to the velocity vector. The range (0, -180) goes counter-clockwise.</span>
<span class="s2">You can change the range (-180, 180) to the range (0, 360) by adding 360 to negative angles.</span>

<span class="s2">Note that the convergence velocity magnitude is negative if the plates are diverging (if convergence obliquity angle</span>
<span class="s2">is greater than 90 or less than -90). And note that the absolute velocity magnitude is negative if the trench</span>
<span class="s2">is moving towards the overriding plate (if absolute obliquity angle is less than 90 or greater than -90) - note that this</span>
<span class="s2">ignores the kinematics of the subducting plate. Similiarly for the subducting plate absolute velocity magnitude</span>
<span class="s2">(if extra output parameter &#39;output_subducting_absolute_velocity&#39; is specified).</span>

<span class="s2">Each point in the output is the midpoint of a great circle arc between two adjacent points in the trench polyline.</span>
<span class="s2">The trench normal vector used in the obliquity calculations is perpendicular to the great circle arc of each point (arc midpoint)</span>
<span class="s2">and pointing towards the overriding plate (rather than away from it).</span>

<span class="s2">Each trench is sampled at approximately uniform intervals along its length (specified via a threshold sampling distance).</span>
<span class="s2">The sampling along the entire length of a trench is not exactly uniform. Each segment along a trench is sampled</span>
<span class="s2">such that the samples have a uniform spacing that is less than or equal to the threshold sampling distance. However each segment</span>
<span class="s2">in a trench might have a slightly different spacing distance (since segment lengths are not integer multiples of</span>
<span class="s2">the threshold sampling distance).</span>

<span class="s2">The trench normal (at each arc segment mid-point) always points *towards* the overriding plate.</span>

<span class="s2">NOTE: Separate the positional and optional arguments with &#39;--&#39; (workaround for bug in argparse module).</span>
<span class="s2">For example...</span>

<span class="si">%(prog)s</span><span class="s2"> -r rotations.rot -m topologies.gpml -t 0 200 -i 1 -v 1 -d 0.5 -e xy -- convergence</span>
<span class="s2">    &quot;&quot;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">add_arguments</span><span class="p">(</span><span class="n">parser</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;add command line argument parser&quot;&quot;&quot;</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">formatter_class</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">RawDescriptionHelpFormatter</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">__description__</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">main</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-r&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--rotation_filenames&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;rotation_filename&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;One or more rotation files.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-m&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--topology_filenames&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;topology_filename&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;One or more topology files to generate resolved subducting lines.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-a&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--anchor&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;anchor_plate_id&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Anchor plate id used for reconstructing. Defaults to zero.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Can specify only one of &#39;-i&#39;, &#39;-l&#39; or &#39;-t&#39;.</span>
    <span class="n">threshold_sampling_distance_group</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_mutually_exclusive_group</span><span class="p">()</span>
    <span class="n">threshold_sampling_distance_group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-d&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--threshold_sampling_distance_degrees&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Threshold sampling distance along trenches (in degrees). &quot;</span>
        <span class="s2">&quot;Defaults to </span><span class="si">{0}</span><span class="s2"> degrees.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEFAULT_THRESHOLD_SAMPLING_DISTANCE_DEGREES</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">threshold_sampling_distance_group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-k&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--threshold_sampling_distance_kms&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Threshold sampling distance along trenches (in Kms). &quot;</span>
        <span class="s2">&quot;Defaults to </span><span class="si">{0:.2f}</span><span class="s2"> Kms (which is equivalent to </span><span class="si">{1}</span><span class="s2"> degrees).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">DEFAULT_THRESHOLD_SAMPLING_DISTANCE_KMS</span><span class="p">,</span>
            <span class="n">DEFAULT_THRESHOLD_SAMPLING_DISTANCE_DEGREES</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-t&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--time_range&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;young_time&quot;</span><span class="p">,</span> <span class="s2">&quot;old_time&quot;</span><span class="p">),</span>
        <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="n">DEFAULT_TIME_RANGE_YOUNG_TIME</span><span class="p">,</span> <span class="n">DEFAULT_TIME_RANGE_OLD_TIME</span><span class="p">],</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The time range (in Ma) from young time to old time. &quot;</span>
        <span class="s2">&quot;Defaults to </span><span class="si">{0}</span><span class="s2"> -&gt; </span><span class="si">{1}</span><span class="s2"> Ma.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">DEFAULT_TIME_RANGE_YOUNG_TIME</span><span class="p">,</span> <span class="n">DEFAULT_TIME_RANGE_OLD_TIME</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_positive_number</span><span class="p">(</span><span class="n">value_string</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_string</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentTypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a number&quot;</span> <span class="o">%</span> <span class="n">value_string</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentTypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2"> is not a positive number&quot;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-i&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--time_increment&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="n">parse_positive_number</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">DEFAULT_TIME_INCREMENT</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The time increment in My. Defaults to </span><span class="si">{0}</span><span class="s2"> My.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">DEFAULT_TIME_INCREMENT</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-v&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--velocity_delta_time&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="n">parse_positive_number</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">DEFAULT_VELOCITY_DELTA_TIME</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The delta time interval used to calculate velocities in My. &quot;</span>
        <span class="s2">&quot;Defaults to </span><span class="si">{0}</span><span class="s2"> My.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEFAULT_VELOCITY_DELTA_TIME</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-x&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--extra_output_parameters&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;output_parameter&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Optional extra output parameters to be appended to the usual (non-optional) &quot;</span>
        <span class="s2">&quot;output parameters for each sample point. &quot;</span>
        <span class="s2">&quot;Choices include </span><span class="si">{0}</span><span class="s2">. &quot;</span>
        <span class="s2">&quot;The order in which they are output is in the same order as those choices.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_OUTPUT_PARAMETER_NAME_LIST</span><span class="p">)</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-g&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--output_gpml_filename&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Optional GPML output filename to contain the subduction convergence data for all specified times. &quot;</span>
        <span class="s2">&quot;This can then be loaded into GPlates to display the data as scalar coverages.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;output_filename_prefix&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The output filename prefix. An output file is created for each geological time in the sequence where &quot;</span>
        <span class="s2">&quot;the filename suffix contains the time and the filename extension.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-e&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--output_filename_extension&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The output xy filename extension. Defaults to &quot;xy&quot;.&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-w&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--ignore_topology_warnings&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;If specified then topology warnings are ignored (not output). &quot;</span>
        <span class="s2">&quot;These are the warnings about not finding the overriding and subducting plates.&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># Topology warnings correspond to calls to &quot;warnings.warn(... , RuntimeWarning)&quot;.</span>
    <span class="c1"># Ignore them if requested.</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">ignore_topology_warnings</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">args</span><span class="o">.</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentTypeError</span><span class="p">(</span>
            <span class="s2">&quot;First (young) value in time range is greater than second (old) value&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Determine threshold sampling distance.</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">threshold_sampling_distance_degrees</span><span class="p">:</span>
        <span class="n">threshold_sampling_distance_radians</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span>
            <span class="n">args</span><span class="o">.</span><span class="n">threshold_sampling_distance_degrees</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">threshold_sampling_distance_kms</span><span class="p">:</span>
        <span class="n">threshold_sampling_distance_radians</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">args</span><span class="o">.</span><span class="n">threshold_sampling_distance_kms</span>
            <span class="o">/</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">equatorial_radius_in_kms</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># default...</span>
        <span class="n">threshold_sampling_distance_radians</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span>
            <span class="n">DEFAULT_THRESHOLD_SAMPLING_DISTANCE_DEGREES</span>
        <span class="p">)</span>

    <span class="c1"># Specify any optional output parameters to append for each sample point.</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extra_output_parameters</span>
    <span class="p">):</span>  <span class="c1"># Default argument is None (not an empty list), so check first before iterating.</span>
        <span class="k">for</span> <span class="n">extra_output_parameter</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">extra_output_parameters</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extra_output_parameter</span> <span class="ow">in</span> <span class="n">_OUTPUT_PARAMETER_NAME_LIST</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">extra_output_parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> is not a valid output parameter&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extra_output_parameter</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="n">return_code</span> <span class="o">=</span> <span class="n">subduction_convergence_over_time</span><span class="p">(</span>
        <span class="n">args</span><span class="o">.</span><span class="n">output_filename_prefix</span><span class="p">,</span>
        <span class="n">args</span><span class="o">.</span><span class="n">output_filename_extension</span><span class="p">,</span>
        <span class="n">args</span><span class="o">.</span><span class="n">rotation_filenames</span><span class="p">,</span>
        <span class="n">args</span><span class="o">.</span><span class="n">topology_filenames</span><span class="p">,</span>
        <span class="n">threshold_sampling_distance_radians</span><span class="p">,</span>
        <span class="n">args</span><span class="o">.</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">args</span><span class="o">.</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">args</span><span class="o">.</span><span class="n">time_increment</span><span class="p">,</span>
        <span class="n">args</span><span class="o">.</span><span class="n">velocity_delta_time</span><span class="p">,</span>
        <span class="n">args</span><span class="o">.</span><span class="n">anchor_plate_id</span><span class="p">,</span>
        <span class="n">args</span><span class="o">.</span><span class="n">output_gpml_filename</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_code</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># The command-line parser.</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="n">__description__</span><span class="p">,</span>
        <span class="n">formatter_class</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">RawDescriptionHelpFormatter</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># add arguments</span>
    <span class="n">add_arguments</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>

    <span class="c1"># Parse command-line options.</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="c1"># call main function</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">main</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;ERROR: </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="n">exc</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span>
        <span class="p">)</span>
        <span class="c1"># Uncomment this to print traceback to location of raised exception.</span>
        <span class="c1"># import traceback</span>
        <span class="c1"># traceback.print_exc()</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, The University of Sydney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>