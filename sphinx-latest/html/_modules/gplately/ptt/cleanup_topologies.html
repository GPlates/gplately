

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gplately.ptt.cleanup_topologies &mdash; gplately 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            gplately
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basic_usages.html">Minimal working example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../use_cases.html">Common Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Trouble-shooting and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_line_interface.html">Command Line Interface (CLI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../primer.html">Primer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">GPlately API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gplately</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gplately.ptt.cleanup_topologies</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gplately.ptt.cleanup_topologies</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">#    Copyright (C) 2019 The University of Sydney, Australia</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1">#    the terms of the GNU General Public License, version 2, as published by</span>
<span class="c1">#    the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c1">#    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c1">#    for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License along</span>
<span class="c1">#    with this program; if not, write to Free Software Foundation, Inc.,</span>
<span class="c1">#    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Clean up topologies</span>

<span class="sd">including:   </span>
<span class="sd">- Removing any regular features not referenced by topologies.                                </span>
<span class="sd">- Restricting the time periods of referenced features to match the referencing topologies.   </span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">argparse</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pygplates</span>

<span class="c1">#</span>
<span class="c1"># Python 2 and 3 compatibility.</span>
<span class="c1">#</span>
<span class="c1"># Iterating over a dict.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="nb">dict</span><span class="o">.</span><span class="n">iteritems</span>
<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="c1"># Python 3</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">itervalues</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">iteritems</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">listvalues</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">listitems</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Python 2</span>
<div class="viewcode-block" id="itervalues">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies.itervalues">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">itervalues</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()</span></div>


<div class="viewcode-block" id="iteritems">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies.iteritems">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iteritems</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span></div>


<div class="viewcode-block" id="listvalues">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies.listvalues">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">listvalues</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()</span></div>


<div class="viewcode-block" id="listitems">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies.listitems">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">listitems</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span></div>



<div class="viewcode-block" id="remove_features_not_referenced_by_topologies">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies.remove_features_not_referenced_by_topologies">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">remove_features_not_referenced_by_topologies</span><span class="p">(</span>
    <span class="n">feature_collections</span><span class="p">,</span>
    <span class="n">restrict_referenced_feature_time_periods</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">removed_features_collections</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># Docstring in numpydoc format...</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove any regular features not referenced by topological features.</span>

<span class="sd">    The results are returned as a list of pygplates.FeatureCollection (one per input feature collection).</span>

<span class="sd">    The input feature collections should contain the topological and regular features that make up the topological model.</span>
<span class="sd">    Ensure you at least specify all topological features in the topological model, otherwise regular features</span>
<span class="sd">    referenced by the missing topologies will get removed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feature_collections : sequence of (str, or sequence of pygplates.Feature, or pygplates.FeatureCollection, or pygplates.Feature)</span>
<span class="sd">        A sequence of feature collections containing both the topological features and the regular features they reference.</span>
<span class="sd">        Each collection in the sequence can be a filename, or a sequence (eg, list of tuple) or features, or</span>
<span class="sd">        a feature collection, or even a single feature.</span>
<span class="sd">    restrict_referenced_feature_time_periods: bool</span>
<span class="sd">        Whether to restrict the time periods of features referenced by topologies such that they are</span>
<span class="sd">        limited by the time periods of the referencing topologies.</span>
<span class="sd">    removed_features_collections: list</span>
<span class="sd">        If an empty list is provided then it will be filled with one feature collection for each input feature collection.</span>
<span class="sd">        And each of these will contain any removed features.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of pygplates.FeatureCollection</span>
<span class="sd">        The (potentially) modified feature collections.</span>
<span class="sd">        Returned list is same length as ``feature_collections``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert each feature collection into a list of features so we can more easily remove features</span>
    <span class="c1"># and insert features at arbitrary locations within each feature collection</span>
    <span class="c1"># (for example removing an unreferenced regular feature).</span>
    <span class="n">feature_collections</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">feature_collection</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">feature_collection</span> <span class="ow">in</span> <span class="n">feature_collections</span>
    <span class="p">]</span>

    <span class="c1"># Set of feature IDs of all topological polygons and networks.</span>
    <span class="c1"># Note that we only keep topological lines if they are referenced by a topological polygon or network.</span>
    <span class="n">feature_ids_of_topological_polygons_and_networks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="c1"># Set of feature IDs referenced by all topological polygons and networks.</span>
    <span class="n">feature_ids_referenced_by_topological_polygons_and_networks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="c1"># Set of feature IDs referenced by topological lines that are referenced by topological polygons and networks.</span>
    <span class="n">feature_ids_referenced_by_topological_lines_referenced_by_topological_polygons_and_networks</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">set</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># The features referenced by topological polygons and networks.</span>
    <span class="n">topological_polygon_and_network_references</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># The features referenced by topological lines.</span>
    <span class="n">topological_line_references</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># All features mapped by feature ID.</span>
    <span class="n">all_features</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Find all topological features and their references to regular features.</span>
    <span class="n">topological_reference_visitor</span> <span class="o">=</span> <span class="n">_TopologicalReferenceVisitor</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">feature_collection</span> <span class="ow">in</span> <span class="n">feature_collections</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">feature_collection</span><span class="p">:</span>
            <span class="n">feature_id</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">get_feature_id</span><span class="p">()</span>

            <span class="c1"># Enable any feature to be looked up using its feature ID.</span>
            <span class="n">all_features</span><span class="p">[</span><span class="n">feature_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature</span>

            <span class="c1"># See if the current feature has a topological geometry and (if so) find the features it references.</span>
            <span class="p">(</span>
                <span class="n">topology_type</span><span class="p">,</span>
                <span class="n">topological_references</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">topological_reference_visitor</span><span class="o">.</span><span class="n">visit_feature</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>

            <span class="c1"># For topological lines, we&#39;ll just keep track of their references for later since we don&#39;t yet know</span>
            <span class="c1"># which topological lines (if any) will in turn be referenced by topological polygons and  networks.</span>
            <span class="k">if</span> <span class="n">topology_type</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalLine</span><span class="p">:</span>
                <span class="n">topological_line_references</span><span class="p">[</span><span class="n">feature_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">feature</span><span class="p">,</span>
                    <span class="n">topological_references</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># For topological polygons and networks, we know they get included straight away.</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">topology_type</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalPolygon</span>
                <span class="ow">or</span> <span class="n">topology_type</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalNetwork</span>
            <span class="p">):</span>
                <span class="n">topological_polygon_and_network_references</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">topological_references</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># Add the current topological polygon or network.</span>
                <span class="n">feature_ids_of_topological_polygons_and_networks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">feature_id</span><span class="p">)</span>
            <span class="c1"># else it&#39;s not a topological feature, so ignore it.</span>

    <span class="c1"># Referenced time periods of referenced feature (non-topological and topological lines).</span>
    <span class="n">time_periods_of_referenced_non_topological_features</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">time_periods_of_referenced_topological_line_features</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Set of feature IDs of topological lines that are referenced by topological polygons and networks.</span>
    <span class="n">feature_ids_of_topological_lines_referenced_by_topological_polygons_and_networks</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">set</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Start with begin time as -inf (so that it can only get larger with max() function) and</span>
    <span class="c1"># end time as +inf (so that it can only get smaller with min() function).</span>
    <span class="n">uninitialised_time_period</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>  <span class="c1"># begin_time, end_time</span>

    <span class="c1"># Find features directly referenced by topological polygons and networks.</span>
    <span class="k">for</span> <span class="p">(</span>
        <span class="n">topological_polygon_and_network_feature</span><span class="p">,</span>
        <span class="n">topological_polygon_and_network_reference</span><span class="p">,</span>
    <span class="p">)</span> <span class="ow">in</span> <span class="n">topological_polygon_and_network_references</span><span class="p">:</span>
        <span class="p">(</span>
            <span class="n">topological_polygon_and_network_begin_time</span><span class="p">,</span>
            <span class="n">topological_polygon_and_network_end_time</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">topological_polygon_and_network_feature</span><span class="o">.</span><span class="n">get_valid_time</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">reference_begin_time</span><span class="p">,</span>
            <span class="n">reference_end_time</span><span class="p">,</span>
        <span class="p">),</span> <span class="n">feature_ids_referenced_in_time_period</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">topological_polygon_and_network_reference</span>
        <span class="p">):</span>
            <span class="c1"># Restrict the current referenced time period to that of the topological polygon (or network) valid time period.</span>
            <span class="k">if</span> <span class="n">reference_begin_time</span> <span class="o">&gt;</span> <span class="n">topological_polygon_and_network_begin_time</span><span class="p">:</span>
                <span class="n">reference_begin_time</span> <span class="o">=</span> <span class="n">topological_polygon_and_network_begin_time</span>
            <span class="k">if</span> <span class="n">reference_end_time</span> <span class="o">&lt;</span> <span class="n">topological_polygon_and_network_end_time</span><span class="p">:</span>
                <span class="n">reference_end_time</span> <span class="o">=</span> <span class="n">topological_polygon_and_network_end_time</span>

            <span class="c1"># If the referenced time period and the topological polygon/network valid time overlap.</span>
            <span class="k">if</span> <span class="n">reference_begin_time</span> <span class="o">&gt;=</span> <span class="n">reference_end_time</span><span class="p">:</span>
                <span class="c1"># Add the features referenced by the current topological polygon or network.</span>
                <span class="n">feature_ids_referenced_by_topological_polygons_and_networks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">feature_ids_referenced_in_time_period</span>
                <span class="p">)</span>

                <span class="c1"># Iterate over referenced feature IDs for the currently reference time period.</span>
                <span class="k">for</span> <span class="n">referenced_feature_id</span> <span class="ow">in</span> <span class="n">feature_ids_referenced_in_time_period</span><span class="p">:</span>
                    <span class="c1"># Point to time periods of either topological line features or non-topological features.</span>
                    <span class="k">if</span> <span class="n">referenced_feature_id</span> <span class="ow">in</span> <span class="n">topological_line_references</span><span class="p">:</span>
                        <span class="n">time_periods_of_referenced_features</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">time_periods_of_referenced_topological_line_features</span>
                        <span class="p">)</span>
                        <span class="n">feature_ids_of_topological_lines_referenced_by_topological_polygons_and_networks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                            <span class="n">referenced_feature_id</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">time_periods_of_referenced_features</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">time_periods_of_referenced_non_topological_features</span>
                        <span class="p">)</span>

                    <span class="c1"># The current referenced feature needs to include the time period referenced by the topological polygon (or network).</span>
                    <span class="p">(</span>
                        <span class="n">referenced_feature_max_begin_time</span><span class="p">,</span>
                        <span class="n">referenced_feature_min_end_time</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="n">time_periods_of_referenced_features</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">referenced_feature_id</span><span class="p">,</span> <span class="n">uninitialised_time_period</span>
                    <span class="p">)</span>
                    <span class="n">time_periods_of_referenced_features</span><span class="p">[</span><span class="n">referenced_feature_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="nb">max</span><span class="p">(</span><span class="n">referenced_feature_max_begin_time</span><span class="p">,</span> <span class="n">reference_begin_time</span><span class="p">),</span>
                        <span class="nb">min</span><span class="p">(</span><span class="n">referenced_feature_min_end_time</span><span class="p">,</span> <span class="n">reference_end_time</span><span class="p">),</span>
                    <span class="p">)</span>

    <span class="k">if</span> <span class="n">restrict_referenced_feature_time_periods</span><span class="p">:</span>
        <span class="c1"># Restrict the valid time periods of all referenced *topological line* features such that they are limited by the time periods of the referencing topologies.</span>
        <span class="k">for</span> <span class="n">referenced_feature_id</span><span class="p">,</span> <span class="p">(</span>
            <span class="n">referenced_feature_max_begin_time</span><span class="p">,</span>
            <span class="n">referenced_feature_min_end_time</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">time_periods_of_referenced_topological_line_features</span><span class="p">):</span>
            <span class="n">referenced_feature</span> <span class="o">=</span> <span class="n">all_features</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">referenced_feature_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">referenced_feature</span><span class="p">:</span>  <span class="c1"># Referenced feature might not actually exist.</span>
                <span class="n">begin_time</span><span class="p">,</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">referenced_feature</span><span class="o">.</span><span class="n">get_valid_time</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">begin_time</span> <span class="o">&gt;</span> <span class="n">referenced_feature_max_begin_time</span><span class="p">:</span>
                    <span class="n">begin_time</span> <span class="o">=</span> <span class="n">referenced_feature_max_begin_time</span>
                <span class="k">if</span> <span class="n">end_time</span> <span class="o">&lt;</span> <span class="n">referenced_feature_min_end_time</span><span class="p">:</span>
                    <span class="n">end_time</span> <span class="o">=</span> <span class="n">referenced_feature_min_end_time</span>

                <span class="c1"># If the referenced time period and the topological line feature valid time overlap.</span>
                <span class="k">if</span> <span class="n">begin_time</span> <span class="o">&gt;=</span> <span class="n">end_time</span><span class="p">:</span>
                    <span class="n">referenced_feature</span><span class="o">.</span><span class="n">set_valid_time</span><span class="p">(</span><span class="n">begin_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>

    <span class="c1"># Iterate over topological lines referenced by topological polygons and networks.</span>
    <span class="k">for</span> <span class="p">(</span>
        <span class="n">referenced_topological_line_feature_id</span>
    <span class="p">)</span> <span class="ow">in</span> <span class="p">(</span>
        <span class="n">feature_ids_of_topological_lines_referenced_by_topological_polygons_and_networks</span>
    <span class="p">):</span>
        <span class="p">(</span>
            <span class="n">topological_line_feature</span><span class="p">,</span>
            <span class="n">topological_line_reference</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">topological_line_references</span><span class="p">[</span><span class="n">referenced_topological_line_feature_id</span><span class="p">]</span>
        <span class="p">(</span>
            <span class="n">topological_line_begin_time</span><span class="p">,</span>
            <span class="n">topological_line_end_time</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">topological_line_feature</span><span class="o">.</span><span class="n">get_valid_time</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">reference_begin_time</span><span class="p">,</span>
            <span class="n">reference_end_time</span><span class="p">,</span>
        <span class="p">),</span> <span class="n">feature_ids_referenced_in_time_period</span> <span class="ow">in</span> <span class="n">topological_line_reference</span><span class="p">:</span>
            <span class="c1"># Restrict the current referenced time period to that of the topological line valid time period.</span>
            <span class="k">if</span> <span class="n">reference_begin_time</span> <span class="o">&gt;</span> <span class="n">topological_line_begin_time</span><span class="p">:</span>
                <span class="n">reference_begin_time</span> <span class="o">=</span> <span class="n">topological_line_begin_time</span>
            <span class="k">if</span> <span class="n">reference_end_time</span> <span class="o">&lt;</span> <span class="n">topological_line_end_time</span><span class="p">:</span>
                <span class="n">reference_end_time</span> <span class="o">=</span> <span class="n">topological_line_end_time</span>

            <span class="c1"># If the referenced time period and the topological line valid time overlap.</span>
            <span class="k">if</span> <span class="n">reference_begin_time</span> <span class="o">&gt;=</span> <span class="n">reference_end_time</span><span class="p">:</span>
                <span class="c1"># Add the features referenced by the current topological line (which is referenced by a topological polygon or network).</span>
                <span class="n">feature_ids_referenced_by_topological_lines_referenced_by_topological_polygons_and_networks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">feature_ids_referenced_in_time_period</span>
                <span class="p">)</span>

                <span class="c1"># Iterate over referenced feature IDs for the currently referenced time period.</span>
                <span class="k">for</span> <span class="n">referenced_feature_id</span> <span class="ow">in</span> <span class="n">feature_ids_referenced_in_time_period</span><span class="p">:</span>
                    <span class="c1"># The current referenced feature needs to include the time period referenced by the topological line.</span>
                    <span class="p">(</span>
                        <span class="n">referenced_feature_max_begin_time</span><span class="p">,</span>
                        <span class="n">referenced_feature_min_end_time</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="n">time_periods_of_referenced_non_topological_features</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">referenced_feature_id</span><span class="p">,</span> <span class="n">uninitialised_time_period</span>
                    <span class="p">)</span>
                    <span class="n">time_periods_of_referenced_non_topological_features</span><span class="p">[</span>
                        <span class="n">referenced_feature_id</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="nb">max</span><span class="p">(</span><span class="n">referenced_feature_max_begin_time</span><span class="p">,</span> <span class="n">reference_begin_time</span><span class="p">),</span>
                        <span class="nb">min</span><span class="p">(</span><span class="n">referenced_feature_min_end_time</span><span class="p">,</span> <span class="n">reference_end_time</span><span class="p">),</span>
                    <span class="p">)</span>

    <span class="k">if</span> <span class="n">restrict_referenced_feature_time_periods</span><span class="p">:</span>
        <span class="c1"># Restrict the valid time periods of all referenced *non-topological* features such that they are limited by the time periods of the referencing topologies.</span>
        <span class="k">for</span> <span class="n">referenced_feature_id</span><span class="p">,</span> <span class="p">(</span>
            <span class="n">referenced_feature_max_begin_time</span><span class="p">,</span>
            <span class="n">referenced_feature_min_end_time</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">time_periods_of_referenced_non_topological_features</span><span class="p">):</span>
            <span class="n">referenced_feature</span> <span class="o">=</span> <span class="n">all_features</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">referenced_feature_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">referenced_feature</span><span class="p">:</span>  <span class="c1"># Referenced feature might not actually exist.</span>
                <span class="n">begin_time</span><span class="p">,</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">referenced_feature</span><span class="o">.</span><span class="n">get_valid_time</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">begin_time</span> <span class="o">&gt;</span> <span class="n">referenced_feature_max_begin_time</span><span class="p">:</span>
                    <span class="n">begin_time</span> <span class="o">=</span> <span class="n">referenced_feature_max_begin_time</span>
                <span class="k">if</span> <span class="n">end_time</span> <span class="o">&lt;</span> <span class="n">referenced_feature_min_end_time</span><span class="p">:</span>
                    <span class="n">end_time</span> <span class="o">=</span> <span class="n">referenced_feature_min_end_time</span>

                <span class="c1"># If the referenced time period and the non-topological feature valid time overlap.</span>
                <span class="k">if</span> <span class="n">begin_time</span> <span class="o">&gt;=</span> <span class="n">end_time</span><span class="p">:</span>
                    <span class="n">referenced_feature</span><span class="o">.</span><span class="n">set_valid_time</span><span class="p">(</span><span class="n">begin_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>

    <span class="c1"># Only keep features that are topological polygons and networks, and any features referenced directly</span>
    <span class="c1"># or indirectly by them. For example, a topological polygon might reference a topological line which</span>
    <span class="c1"># in turn references regular features. In this case the topological line and the features it references</span>
    <span class="c1"># must all be kept.</span>
    <span class="n">feature_ids_to_keep</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">feature_ids_of_topological_polygons_and_networks</span>
        <span class="o">|</span> <span class="n">feature_ids_referenced_by_topological_polygons_and_networks</span>
        <span class="o">|</span> <span class="n">feature_ids_referenced_by_topological_lines_referenced_by_topological_polygons_and_networks</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">feature_collection</span> <span class="ow">in</span> <span class="n">feature_collections</span><span class="p">:</span>
        <span class="c1"># Create an extra feature collection (containing removed features) for each feature collection.</span>
        <span class="k">if</span> <span class="n">removed_features_collections</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">removed_features_collection</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">()</span>
            <span class="n">removed_features_collections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">removed_features_collection</span><span class="p">)</span>

        <span class="n">feature_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">feature_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_collection</span><span class="p">):</span>
            <span class="n">feature</span> <span class="o">=</span> <span class="n">feature_collection</span><span class="p">[</span><span class="n">feature_index</span><span class="p">]</span>
            <span class="n">feature_id</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">get_feature_id</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">feature_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">feature_ids_to_keep</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">feature_collection</span><span class="p">[</span><span class="n">feature_index</span><span class="p">]</span>
                <span class="n">feature_index</span> <span class="o">-=</span> <span class="mi">1</span>

                <span class="c1"># Keep track of the removed feature if requested.</span>
                <span class="k">if</span> <span class="n">removed_features_collections</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">removed_features_collection</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>

            <span class="n">feature_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Return our (potentially) modified feature collections as a list of pygplates.FeatureCollection.</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">feature_collection</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">feature_collection</span> <span class="ow">in</span> <span class="n">feature_collections</span>
    <span class="p">]</span></div>



<span class="c1"># Private helper class (has &#39;_&#39; prefix) to find topology-related GpmlPropertyDelegate&#39;s.</span>
<div class="viewcode-block" id="_TopologicalReferenceVisitor">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies._TopologicalReferenceVisitor">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">_TopologicalReferenceVisitor</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PropertyValueVisitor</span><span class="p">):</span>
    <span class="n">ALL_TIME</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span>  <span class="c1"># begin_time, end_time</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_TopologicalReferenceVisitor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="_TopologicalReferenceVisitor.visit_feature">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies._TopologicalReferenceVisitor.visit_feature">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visit_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topology_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_time_period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ALL_TIME</span>

        <span class="c1"># Visit all properties in the feature to find a topological line, polygon or network.</span>
        <span class="k">for</span> <span class="nb">property</span> <span class="ow">in</span> <span class="n">feature</span><span class="p">:</span>
            <span class="c1"># Get the top-level property value (containing all times) not just a specific time.</span>
            <span class="n">property_value</span> <span class="o">=</span> <span class="nb">property</span><span class="o">.</span><span class="n">get_time_dependent_value</span><span class="p">()</span>
            <span class="c1"># Visit the property value.</span>
            <span class="n">property_value</span><span class="o">.</span><span class="n">accept_visitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># If we visited a topological line, polygon or network then we&#39;re finished with the current feature.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology_type</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span></div>


<div class="viewcode-block" id="_TopologicalReferenceVisitor.visit_gpml_constant_value">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies._TopologicalReferenceVisitor.visit_gpml_constant_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visit_gpml_constant_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpml_constant_value</span><span class="p">):</span>
        <span class="c1"># Visit the GpmlConstantValue&#39;s nested property value.</span>
        <span class="n">gpml_constant_value</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">accept_visitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="_TopologicalReferenceVisitor.visit_gpml_piecewise_aggregation">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies._TopologicalReferenceVisitor.visit_gpml_piecewise_aggregation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visit_gpml_piecewise_aggregation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpml_piecewise_aggregation</span><span class="p">):</span>
        <span class="c1"># Only need to visit if contains a topological line, polygon or network.</span>
        <span class="n">value_type</span> <span class="o">=</span> <span class="n">gpml_piecewise_aggregation</span><span class="o">.</span><span class="n">get_value_type</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">value_type</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalLine</span>
            <span class="ow">or</span> <span class="n">value_type</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalPolygon</span>
            <span class="ow">or</span> <span class="n">value_type</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalNetwork</span>
        <span class="p">):</span>
            <span class="c1"># NOTE: If there&#39;s only *one* time window then we ignore its time period.</span>
            <span class="c1">#</span>
            <span class="c1"># We do this for the same reason that GPlates does this (this comment from the GPlates source code)...</span>
            <span class="c1">#</span>
            <span class="c1"># This is because GPML files created with old versions of GPlates set the time period,</span>
            <span class="c1"># of the sole time window, to match that of the &#39;feature&#39;s time period (in the topology</span>
            <span class="c1"># build/edit tools) - newer versions set it to *all* time (distant past/future) - in fact</span>
            <span class="c1"># newer versions just use a GpmlConstantValue instead of GpmlPiecewiseAggregation because</span>
            <span class="c1"># the topology tools cannot yet create time-dependent topology (section) lists.</span>
            <span class="c1"># With old versions if the user expanded the &#39;feature&#39;s time period *after* building/editing</span>
            <span class="c1"># the topology then the *un-adjusted* time window time period will be incorrect and hence</span>
            <span class="c1"># we need to ignore it here.</span>
            <span class="c1"># Those old versions were around 4 years ago (prior to GPlates 1.3) - so we really shouldn&#39;t</span>
            <span class="c1"># be seeing any old topologies.</span>
            <span class="c1"># Actually I can see there are some currently in the sample data for GPlates 2.0.</span>
            <span class="c1"># So as a compromise we&#39;ll ignore the reconstruction time if there&#39;s only one time window</span>
            <span class="c1"># (a single time window shouldn&#39;t really have any time constraints on it anyway)</span>
            <span class="c1"># and respect the reconstruction time if there&#39;s more than one time window</span>
            <span class="c1"># (since multiple time windows need non-overlapping time constraints).</span>
            <span class="c1"># This is especially true now that pyGPlates will soon be able to generate time-dependent</span>
            <span class="c1"># topologies (where the reconstruction time will need to be respected otherwise multiple</span>
            <span class="c1"># networks from different time periods will get created instead of just one of them).</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gpml_piecewise_aggregation</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Assume the sole time window covers *all* time (the default).</span>
                <span class="n">gpml_piecewise_aggregation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">accept_visitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Visit the property value in each time window.</span>
                <span class="k">for</span> <span class="n">gpml_time_window</span> <span class="ow">in</span> <span class="n">gpml_piecewise_aggregation</span><span class="p">:</span>
                    <span class="c1"># Restrict the time period while we&#39;re visiting the time window.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_time_period</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">gpml_time_window</span><span class="o">.</span><span class="n">get_begin_time</span><span class="p">(),</span>
                        <span class="n">gpml_time_window</span><span class="o">.</span><span class="n">get_end_time</span><span class="p">(),</span>
                    <span class="p">)</span>
                    <span class="n">gpml_time_window</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">accept_visitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_time_period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ALL_TIME</span></div>


<div class="viewcode-block" id="_TopologicalReferenceVisitor.visit_gpml_topological_line">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies._TopologicalReferenceVisitor.visit_gpml_topological_line">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visit_gpml_topological_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpml_topological_line</span><span class="p">):</span>
        <span class="n">referenced_feature_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Topological line sections are topological sections (which contain a property delegate).</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">gpml_topological_line</span><span class="o">.</span><span class="n">get_sections</span><span class="p">():</span>
            <span class="n">referenced_feature_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">get_property_delegate</span><span class="p">()</span><span class="o">.</span><span class="n">get_feature_id</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">topology_type</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalLine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">current_time_period</span><span class="p">,</span> <span class="n">referenced_feature_ids</span><span class="p">))</span></div>


<div class="viewcode-block" id="_TopologicalReferenceVisitor.visit_gpml_topological_polygon">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies._TopologicalReferenceVisitor.visit_gpml_topological_polygon">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visit_gpml_topological_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpml_topological_polygon</span><span class="p">):</span>
        <span class="n">referenced_feature_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Topological polygon exterior sections are topological sections (which contain a property delegate).</span>
        <span class="k">for</span> <span class="n">exterior_section</span> <span class="ow">in</span> <span class="n">gpml_topological_polygon</span><span class="o">.</span><span class="n">get_exterior_sections</span><span class="p">():</span>
            <span class="n">referenced_feature_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="n">exterior_section</span><span class="o">.</span><span class="n">get_property_delegate</span><span class="p">()</span><span class="o">.</span><span class="n">get_feature_id</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">topology_type</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalPolygon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">current_time_period</span><span class="p">,</span> <span class="n">referenced_feature_ids</span><span class="p">))</span></div>


<div class="viewcode-block" id="_TopologicalReferenceVisitor.visit_gpml_topological_network">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies._TopologicalReferenceVisitor.visit_gpml_topological_network">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visit_gpml_topological_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpml_topological_network</span><span class="p">):</span>
        <span class="n">referenced_feature_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Topological network boundary sections are topological sections (which contain a property delegate).</span>
        <span class="k">for</span> <span class="n">boundary_section</span> <span class="ow">in</span> <span class="n">gpml_topological_network</span><span class="o">.</span><span class="n">get_boundary_sections</span><span class="p">():</span>
            <span class="n">referenced_feature_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="n">boundary_section</span><span class="o">.</span><span class="n">get_property_delegate</span><span class="p">()</span><span class="o">.</span><span class="n">get_feature_id</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="c1"># Topological network interiors are already property delegates.</span>
        <span class="k">for</span> <span class="n">interior</span> <span class="ow">in</span> <span class="n">gpml_topological_network</span><span class="o">.</span><span class="n">get_interiors</span><span class="p">():</span>
            <span class="n">referenced_feature_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">interior</span><span class="o">.</span><span class="n">get_feature_id</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">topology_type</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalNetwork</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">current_time_period</span><span class="p">,</span> <span class="n">referenced_feature_ids</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="add_arguments">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies.add_arguments">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">add_arguments</span><span class="p">(</span><span class="n">parser</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;add command line argument parser&quot;&quot;&quot;</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">formatter_class</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">RawDescriptionHelpFormatter</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">__description__</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">main</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-o&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--output_filename_prefix&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;output_filename_prefix&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Optional output filename prefix. If one is provided then an output file &quot;</span>
        <span class="s2">&quot;is created for each input file by prefixing the input filenames. &quot;</span>
        <span class="s2">&quot;If no filename prefix is provided then the input files are overwritten.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-d&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--removed_features_filename_prefix&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;removed_features_filename_prefix&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Option to save removed features in new files with specified filename prefix. &quot;</span>
        <span class="s2">&quot;If specified then a file is created for each input file (that has features removed) &quot;</span>
        <span class="s2">&quot;by prefixing the input filenames. If no filename prefix is provided then the &quot;</span>
        <span class="s2">&quot;removed features are not saved.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-p&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--restricted_referenced_time_periods&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;If specified then restrict the time periods of features referenced by topologies such that they are &quot;</span>
        <span class="s2">&quot;limited by the time periods of the referencing topologies (default is no restriction).&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;input_filenames&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;input_filename&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;One or more files containing topological features and features referenced by them.&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>



<span class="n">__description__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Remove any regular features not referenced by topological features.</span><span class="se">\</span>
<span class="s2">    </span>
<span class="s2">    The input files should contain the topological and regular features that make up the topological model.</span>
<span class="s2">    Ensure you at least specify all topological features in the topological model, otherwise regular features</span>
<span class="s2">    referenced by the missing topologies will get removed.</span>
<span class="s2">    </span>
<span class="s2">    The results are written back to the input files unless an output filename prefix is provided.</span>

<span class="s2">    NOTE: Separate the positional and optional arguments with &#39;--&#39; (workaround for bug in argparse module).</span>
<span class="s2">    For example...</span>

<span class="s2">    </span><span class="si">%(prog)s</span><span class="s2"> -o cleanup_topologies_ -- topologies.gpml</span>
<span class="s2">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="main">
<a class="viewcode-back" href="../../../gplately.ptt.html#gplately.ptt.cleanup_topologies.main">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># Read the input feature collections.</span>
    <span class="n">input_feature_collections</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">input_filename</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">input_filename</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">input_filenames</span>
    <span class="p">]</span>

    <span class="c1"># If we&#39;re saving the removed features then provide a list for those feature collections.</span>
    <span class="n">removed_features_collections</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">removed_features_filename_prefix</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># Remove features not referenced by topologies.</span>
    <span class="n">output_feature_collections</span> <span class="o">=</span> <span class="n">remove_features_not_referenced_by_topologies</span><span class="p">(</span>
        <span class="n">input_feature_collections</span><span class="p">,</span>
        <span class="n">args</span><span class="o">.</span><span class="n">restricted_referenced_time_periods</span><span class="p">,</span>
        <span class="n">removed_features_collections</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Write the modified feature collections to disk.</span>
    <span class="k">for</span> <span class="n">feature_collection_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_feature_collections</span><span class="p">)):</span>
        <span class="c1"># Each output filename is the input filename with an optional prefix prepended.</span>
        <span class="n">input_filename</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">input_filenames</span><span class="p">[</span><span class="n">feature_collection_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">output_filename_prefix</span><span class="p">:</span>
            <span class="nb">dir</span><span class="p">,</span> <span class="n">file_basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">input_filename</span><span class="p">)</span>
            <span class="n">output_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="nb">dir</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output_filename_prefix</span><span class="p">,</span> <span class="n">file_basename</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_filename</span> <span class="o">=</span> <span class="n">input_filename</span>
        <span class="n">output_feature_collections</span><span class="p">[</span><span class="n">feature_collection_index</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output_filename</span><span class="p">)</span>

        <span class="c1"># Write the removed features to disk.</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">removed_features_filename_prefix</span><span class="p">:</span>
            <span class="nb">dir</span><span class="p">,</span> <span class="n">file_basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">input_filename</span><span class="p">)</span>
            <span class="n">removed_features_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="nb">dir</span><span class="p">,</span>
                <span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">removed_features_filename_prefix</span><span class="p">,</span> <span class="n">file_basename</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">removed_features_collections</span><span class="p">[</span><span class="n">feature_collection_index</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">removed_features_filename</span>
            <span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="c1"># The command-line parser.</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="n">__description__</span><span class="p">,</span>
        <span class="n">formatter_class</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">RawDescriptionHelpFormatter</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># add arguments</span>
    <span class="n">add_arguments</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>

    <span class="c1"># Parse command-line options.</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="c1"># call main function</span>
    <span class="n">main</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, The University of Sydney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>