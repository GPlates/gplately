

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gplately.ptt.utils.points_in_polygons &mdash; gplately 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            gplately
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../basic_usages.html">Minimal working example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../use_cases.html">Common Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq.html">Trouble-shooting and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../command_line_interface.html">Command Line Interface (CLI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../primer.html">Primer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">gplately</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">gplately</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gplately.ptt.utils.points_in_polygons</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gplately.ptt.utils.points_in_polygons</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">#    Copyright (C) 2017-2020 The University of Sydney, Australia</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1">#    the terms of the GNU General Public License, version 2, as published by</span>
<span class="c1">#    the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c1">#    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c1">#    for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License along</span>
<span class="c1">#    with this program; if not, write to Free Software Foundation, Inc.,</span>
<span class="c1">#    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="c1">#</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Efficient point-in-polygon testing when there are many relatively uniformly spaced points to be tested against polygons. </span>

<span class="sd">For example, to find the plate ID of the polygon containing each point in a sequence of points:</span>

<span class="sd">```pyton</span>
<span class="sd">import points_in_polygons</span>

<span class="sd"># A list of &#39;pygplates.PointOnSphere&#39; points.</span>
<span class="sd">points = [...]</span>

<span class="sd"># Some polygon features (eg, coastlines).</span>
<span class="sd">polygon_feature_collection = pygplates.FeatureCollection(&#39;polygons.gpml&#39;)</span>

<span class="sd"># Extract the polygons from the features.</span>
<span class="sd">polygons = []</span>
<span class="sd">polygon_features = []</span>
<span class="sd">for polygon_feature in polygon_feature_collection:</span>
<span class="sd">    polygons.append(polygon_feature.get_geometry())</span>
<span class="sd">    polygon_features.append(polygon_feature)</span>

<span class="sd">#</span>
<span class="sd"># Assuming the polygons are *non-overlapping*, find the single polygon (feature) containing each point.</span>
<span class="sd">#</span>
<span class="sd">polygon_features_containing_points = points_in_polygons.find_polygons(points, polygons, polygon_features)</span>

<span class="sd"># Assign a plate ID to each point (or 0 if point outside all polygons).</span>
<span class="sd">plate_ids = []</span>
<span class="sd">for polygon_feature in polygon_features_containing_points:</span>
<span class="sd">    if polygon_feature is not None:</span>
<span class="sd">        plate_id = polygon_feature.get_reconstruction_plate_id()</span>
<span class="sd">    else:</span>
<span class="sd">        plate_id = 0</span>

<span class="sd">    plate_ids.append(plate_id)</span>

<span class="sd">#</span>
<span class="sd"># Assuming the polygons are *overlapping*, find all polygons (features) containing each point.</span>
<span class="sd">#</span>
<span class="sd">polygon_features_containing_points = points_in_polygons.find_polygons(points, polygons, polygon_features, all_polygons=True)</span>

<span class="sd"># Assign multiple points to each plate ID.</span>
<span class="sd">plate_id_to_points_mapping = {} # Each plate ID has a list of points.</span>
<span class="sd">for point_index, polygon_feature_list in enumerate(polygon_features_containing_points):</span>
<span class="sd">    if polygon_feature_list:</span>
<span class="sd">        for polygon_feature in polygon_feature_list</span>
<span class="sd">            plate_id = polygon_feature.get_reconstruction_plate_id()</span>
<span class="sd">            points_with_plate_id = plate_id_to_points_mapping.setdefault(plate_id, [])</span>
<span class="sd">            points_with_plate_id.append(points[point_index])</span>
<span class="sd">```</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pygplates</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">points_spatial_tree</span>

<span class="c1"># the following line would ensure more correct python2-3 compatibility,</span>
<span class="c1"># but requires a non-standard module</span>
<span class="c1"># from builtins import range</span>


<div class="viewcode-block" id="find_polygons">
<a class="viewcode-back" href="../../../../gplately.ptt.utils.html#gplately.ptt.utils.points_in_polygons.find_polygons">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_polygons</span><span class="p">(</span>
    <span class="n">points</span><span class="p">,</span>
    <span class="n">polygons</span><span class="p">,</span>
    <span class="n">polygon_proxies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">all_polygons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">subdivision_depth</span><span class="o">=</span><span class="n">points_spatial_tree</span><span class="o">.</span><span class="n">DEFAULT_SUBDIVISION_DEPTH</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Efficient point-in-polygon testing when there are many relatively uniformly spaced points to be tested against polygons.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points: a sequence of &#39;pygplates.PointOnSphere&#39;</span>
<span class="sd">        a sequence of points</span>

<span class="sd">    polygons: a sequence of &#39;pygplates.PolygonOnSphere&#39;</span>
<span class="sd">        a sequence of polygons</span>

<span class="sd">    polygon_proxies : Optional sequence of objects associated with &#39;polygons&#39;</span>
<span class="sd">        If not specified then the proxies default to the polygons themselves.</span>
<span class="sd">        These can be any object (such as the &#39;pygplates.Feature&#39; that the polygon came from).</span>

<span class="sd">    all_polygons: bool</span>
<span class="sd">        Whether to find all polygons containing each point or just the first one encountered.</span>
<span class="sd">        Set to True if polygons overlap each other, otherwise set to False (for non-overlapping polygons).</span>
<span class="sd">        Defaults to False (non-overlapping polygons).</span>

<span class="sd">    subdivision_depth: number</span>
<span class="sd">        The depth of the lat/lon quad tree used to speed up point-in-polygon queries.</span>
<span class="sd">        The lat/lon width of a leaf quad tree node is (90 / (2^subdivision_depth)) degrees.</span>
<span class="sd">        Generally the denser the &#39;points&#39; the larger the depth should be.</span>
<span class="sd">        Setting this value too high causes unnecessary time to be spent generating a deep quad tree.</span>
<span class="sd">        Setting this value too low reduces the culling efficiency of the quad tree.</span>
<span class="sd">        However a value of 4 seems to work quite well for a uniform lat/lon spacing of &#39;points&#39; of 1 degree and below</span>
<span class="sd">        without the cost of generating a deep quad tree.</span>
<span class="sd">        So most of the time the subdivision depth can be left at its default value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A list of polygon proxies associated with &#39;points&#39;</span>
<span class="sd">        The length of the returned list matches the length of &#39;points&#39;.</span>
<span class="sd">        For each point in &#39;points&#39;, if the point is contained by a polygon then that polygon&#39;s proxy</span>
<span class="sd">        is stored (otherwise None is stored) at the same index (as the point) in the returned list.</span>
<span class="sd">        If &#39;all_polygons&#39; is False then each item in returned list is a single polygon proxy (or a single None).</span>
<span class="sd">        If &#39;all_polygons&#39; is True then each item in returned list is a *list* of polygon proxies (or a single None).</span>

<span class="sd">    Raises ValueError if the lengths of &#39;polygons&#39; and &#39;polygon_proxies&#39; (if specified) do not match.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">spatial_tree_of_points</span> <span class="o">=</span> <span class="n">points_spatial_tree</span><span class="o">.</span><span class="n">PointsSpatialTree</span><span class="p">(</span>
        <span class="n">points</span><span class="p">,</span> <span class="n">subdivision_depth</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">find_polygons_using_points_spatial_tree</span><span class="p">(</span>
        <span class="n">points</span><span class="p">,</span> <span class="n">spatial_tree_of_points</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">polygon_proxies</span><span class="p">,</span> <span class="n">all_polygons</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="find_polygons_using_points_spatial_tree">
<a class="viewcode-back" href="../../../../gplately.ptt.utils.html#gplately.ptt.utils.points_in_polygons.find_polygons_using_points_spatial_tree">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_polygons_using_points_spatial_tree</span><span class="p">(</span>
    <span class="n">points</span><span class="p">,</span> <span class="n">spatial_tree_of_points</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">polygon_proxies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">all_polygons</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Same as &#39;find_polygons()&#39; except &#39;spatial_tree_of_points&#39; is a &#39;points_spatial_tree.PointsSpatialTree&#39; of &#39;points&#39;.</span>

<span class="sd">    This is useful when re-using a single &#39;points_spatial_tree.PointsSpatialTree&#39;.</span>
<span class="sd">    For example, when using it both for point-in-polygon queries and minimum distance queries.</span>

<span class="sd">    Note that &#39;spatial_tree_of_points&#39; should have been built from &#39;points&#39; since it contains</span>
<span class="sd">    indices into the &#39;points&#39; sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Use the polygons as proxies if no proxies have been specified.</span>
    <span class="k">if</span> <span class="n">polygon_proxies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">polygon_proxies</span> <span class="o">=</span> <span class="n">polygons</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygons</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon_proxies</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of polygons must match number of proxies.&quot;</span><span class="p">)</span>

    <span class="c1"># Sort the polygons from largest to smallest area.</span>
    <span class="c1"># This makes searching for points/geometries more efficient.</span>
    <span class="c1">#</span>
    <span class="c1"># &#39;polygons_and_proxies&#39; is a list of 2-tuples (polygon, polygon_proxy).</span>
    <span class="n">polygons_and_proxies</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="p">((</span><span class="n">polygons</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">polygon_proxies</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polygons</span><span class="p">))),</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">polygon_and_proxy</span><span class="p">:</span> <span class="n">polygon_and_proxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_area</span><span class="p">(),</span>
        <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># By default all points are outside all polygons.</span>
    <span class="c1"># If any are found to be inside then we&#39;ll set the relevant polygon proxy.</span>
    <span class="n">polygon_proxies_containing_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="c1"># Use a quad tree for efficiency - enables us to cull large groups of points that are either</span>
    <span class="c1"># outside all polygons or inside a polygon (avoids point-in-polygon tests for these points).</span>
    <span class="k">for</span> <span class="n">root_node</span> <span class="ow">in</span> <span class="n">spatial_tree_of_points</span><span class="o">.</span><span class="n">get_root_nodes</span><span class="p">():</span>
        <span class="n">_visit_spatial_tree_node</span><span class="p">(</span>
            <span class="n">root_node</span><span class="p">,</span>
            <span class="n">points</span><span class="p">,</span>
            <span class="n">polygons_and_proxies</span><span class="p">,</span>
            <span class="n">polygon_proxies_containing_points</span><span class="p">,</span>
            <span class="n">all_polygons</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">polygon_proxies_containing_points</span></div>



<span class="c1">##################</span>
<span class="c1"># Implementation #</span>
<span class="c1">##################</span>


<div class="viewcode-block" id="_visit_spatial_tree_node">
<a class="viewcode-back" href="../../../../gplately.ptt.utils.html#gplately.ptt.utils.points_in_polygons._visit_spatial_tree_node">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_visit_spatial_tree_node</span><span class="p">(</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">points</span><span class="p">,</span>
    <span class="n">parent_overlapping_polygons_and_proxies</span><span class="p">,</span>
    <span class="n">polygon_proxies_containing_points</span><span class="p">,</span>
    <span class="n">all_polygons</span><span class="p">,</span>
<span class="p">):</span>

    <span class="c1"># See if the current quad tree node&#39;s bounding polygon overlaps any polygons.</span>
    <span class="n">overlapping_polygons_and_proxies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">polygon_proxy</span> <span class="ow">in</span> <span class="n">parent_overlapping_polygons_and_proxies</span><span class="p">:</span>

        <span class="c1"># See if quad tree node and current polygon overlap.</span>
        <span class="n">polygon_node_overlap_distance</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">get_bounding_polygon</span><span class="p">(),</span>
            <span class="n">polygon</span><span class="p">,</span>
            <span class="mf">1e-4</span><span class="p">,</span>  <span class="c1"># Anything smaller than this is considered zero distance (intersection).</span>
            <span class="n">geometry1_is_solid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">geometry2_is_solid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Note: PyGPlates version 0.15 fixed an issue in GeometryOnSphere.distance() where very small distances (approx &lt;= 1e-6)</span>
        <span class="c1"># should have been set to zero (to indicate an intersection) but were not. So we&#39;ll assume pyGPlates version 0.14 or less</span>
        <span class="c1"># test for small distances instead of zero (this also works for version 0.15 and above). Our small distance is the threshold</span>
        <span class="c1"># distance above. It&#39;s possible both polygons don&#39;t really overlap but are just very close, but that&#39;s OK since</span>
        <span class="c1"># we&#39;re being conservative in that we&#39;re looking for possibilities of points being in polygons.</span>
        <span class="k">if</span> <span class="n">polygon_node_overlap_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># See if quad tree node is contained completely inside polygon.</span>
            <span class="c1"># We test this by ensuring the outlines of both polygons are not too close (ie, don&#39;t touch), and if they don&#39;t</span>
            <span class="c1"># touch then later testing if any point on the node bounding polygon outline is inside the current polygon</span>
            <span class="c1"># (and none of the current polygon&#39;s interior holes are inside the node bounding polygon).</span>
            <span class="n">node_to_polygon_distance</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">get_bounding_polygon</span><span class="p">(),</span> <span class="n">polygon</span><span class="p">,</span> <span class="mf">1e-4</span>
            <span class="p">)</span>  <span class="c1"># Anything smaller than this is considered zero distance (intersection).</span>

            <span class="c1"># See if the node bounding polygon is entirely inside the solid interior region of the current polygon.</span>
            <span class="n">is_quad_tree_completely_inside_polygon</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">node_to_polygon_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Test if any point on the node bounding polygon outline (we use first point) is inside the current polygon.</span>
                <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_point_in_polygon</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">get_bounding_polygon</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">is_quad_tree_completely_inside_polygon</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># If the current polygon contains interior rings/holes then it&#39;s possible that the outline of the node bounding polygon</span>
                    <span class="c1"># lies entirely inside the current polygon *but* surrounds one of its interior rings/holes.</span>
                    <span class="c1"># And this means we cannot fill the node (like we could if the current polygon did not contain any holes).</span>
                    <span class="c1"># So we also detect if any interior holes of the current polygon are inside the node bounding polygon.</span>
                    <span class="k">for</span> <span class="n">interior_ring_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                        <span class="n">polygon</span><span class="o">.</span><span class="n">get_number_of_interior_rings</span><span class="p">()</span>
                    <span class="p">):</span>
                        <span class="c1"># Arbitrarily choose the first point on each interior ring.</span>
                        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">get_bounding_polygon</span><span class="p">()</span><span class="o">.</span><span class="n">is_point_in_polygon</span><span class="p">(</span>
                            <span class="n">polygon</span><span class="o">.</span><span class="n">get_interior_ring_points</span><span class="p">(</span><span class="n">interior_ring_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="p">):</span>
                            <span class="n">is_quad_tree_completely_inside_polygon</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>

            <span class="k">if</span> <span class="n">is_quad_tree_completely_inside_polygon</span><span class="p">:</span>

                <span class="c1"># Recursively fill the entire quad sub-tree as inside current polygon.</span>
                <span class="n">_fill_spatial_tree_node_inside_polygon</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span> <span class="n">polygon_proxy</span><span class="p">,</span> <span class="n">polygon_proxies_containing_points</span><span class="p">,</span> <span class="n">all_polygons</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">all_polygons</span><span class="p">:</span>
                    <span class="c1"># Only storing first polygon proxy encountered, so skip remaining polygons.</span>
                    <span class="k">return</span>

                <span class="c1"># Note: No need to add polygon to &#39;overlapping_polygons_and_proxies&#39; since we&#39;ve already taken care of it.</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">overlapping_polygons_and_proxies</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">polygon</span><span class="p">,</span> <span class="n">polygon_proxy</span><span class="p">))</span>

    <span class="c1"># If quad tree node is outside all polygons then nothing left to do since all points are marked as outside by default.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">overlapping_polygons_and_proxies</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># Visit child nodes (if internal node) or test each point (if leaf node).</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_internal_node</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">child_node</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_nodes</span><span class="p">():</span>
            <span class="n">_visit_spatial_tree_node</span><span class="p">(</span>
                <span class="n">child_node</span><span class="p">,</span>
                <span class="n">points</span><span class="p">,</span>
                <span class="n">overlapping_polygons_and_proxies</span><span class="p">,</span>
                <span class="n">polygon_proxies_containing_points</span><span class="p">,</span>
                <span class="n">all_polygons</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_point_indices</span><span class="p">():</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">polygon_proxy</span> <span class="ow">in</span> <span class="n">overlapping_polygons_and_proxies</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_point_in_polygon</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
                    <span class="c1"># Point is inside a polygon.</span>
                    <span class="k">if</span> <span class="n">all_polygons</span><span class="p">:</span>
                        <span class="c1"># Each point has a *list* of polygon proxies (or None).</span>
                        <span class="c1"># Create list if first polygon proxy encountered for current point.</span>
                        <span class="k">if</span> <span class="n">polygon_proxies_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">polygon_proxies_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">polygon_proxies_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">polygon_proxy</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Each point has a *single* polygon proxy (or None).</span>
                        <span class="n">polygon_proxies_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon_proxy</span>
                        <span class="c1"># No need to visit remaining polygons for the current point.</span>
                        <span class="k">break</span></div>



<div class="viewcode-block" id="_fill_spatial_tree_node_inside_polygon">
<a class="viewcode-back" href="../../../../gplately.ptt.utils.html#gplately.ptt.utils.points_in_polygons._fill_spatial_tree_node_inside_polygon">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_fill_spatial_tree_node_inside_polygon</span><span class="p">(</span>
    <span class="n">node</span><span class="p">,</span> <span class="n">polygon_proxy</span><span class="p">,</span> <span class="n">polygon_proxies_containing_points</span><span class="p">,</span> <span class="n">all_polygons</span>
<span class="p">):</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_internal_node</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">child_node</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_nodes</span><span class="p">():</span>
            <span class="n">_fill_spatial_tree_node_inside_polygon</span><span class="p">(</span>
                <span class="n">child_node</span><span class="p">,</span>
                <span class="n">polygon_proxy</span><span class="p">,</span>
                <span class="n">polygon_proxies_containing_points</span><span class="p">,</span>
                <span class="n">all_polygons</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_point_indices</span><span class="p">():</span>
            <span class="c1"># Point is inside a polygon.</span>
            <span class="k">if</span> <span class="n">all_polygons</span><span class="p">:</span>
                <span class="c1"># Each point has a *list* of polygon proxies (or None).</span>
                <span class="c1"># Create list if first polygon proxy encountered for current point.</span>
                <span class="k">if</span> <span class="n">polygon_proxies_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">polygon_proxies_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">polygon_proxies_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon_proxy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Each point has a *single* polygon proxy (or None).</span>
                <span class="n">polygon_proxies_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon_proxy</span></div>



<span class="c1"># if __name__ == &#39;__main__&#39;:</span>
<span class="c1">#</span>
<span class="c1">#    #</span>
<span class="c1">#    # Some testing/example code.</span>
<span class="c1">#    #</span>
<span class="c1">#</span>
<span class="c1">#    import time</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    print(&#39;Loading coastline polygons and rotation model...&#39;)</span>
<span class="c1">#    coastline_features = pygplates.FeatureCollection(&#39;../../../sample_data/2.0/SampleData/FeatureCollections/Coastlines/Matthews_etal_GPC_2016_Coastlines.gpmlz&#39;)</span>
<span class="c1">#    rotation_model = pygplates.RotationModel(&#39;../../../sample_data/2.0/SampleData/FeatureCollections/Rotations/Matthews_etal_GPC_2016_410-0Ma_GK07.rot&#39;)</span>
<span class="c1">#</span>
<span class="c1">#    print(&#39;Reconstructing coastline polygons...&#39;)</span>
<span class="c1">#    reconstruction_time = 200</span>
<span class="c1">#    coastline_reconstructed_feature_geometries = []</span>
<span class="c1">#    pygplates.reconstruct(coastline_features, rotation_model, coastline_reconstructed_feature_geometries, reconstruction_time)</span>
<span class="c1">#</span>
<span class="c1">#    polygons = []</span>
<span class="c1">#    polygon_features = []</span>
<span class="c1">#    for reconstructed_feature_geometry in coastline_reconstructed_feature_geometries:</span>
<span class="c1">#        polygons.append(reconstructed_feature_geometry.get_reconstructed_geometry())</span>
<span class="c1">#        polygon_features.append(reconstructed_feature_geometry.get_feature())</span>
<span class="c1">#</span>
<span class="c1">#    # Create uniform lat/lon distribution of points.</span>
<span class="c1">#    print(&#39;Creating lat/lon grid of points...&#39;)</span>
<span class="c1">#    num_latitudes = 180</span>
<span class="c1">#    num_longitudes = 360</span>
<span class="c1">#    lat_grid_spacing_degrees = 180.0 / num_latitudes</span>
<span class="c1">#    lon_grid_spacing_degrees = 360.0 / num_longitudes</span>
<span class="c1">#</span>
<span class="c1">#    points = []</span>
<span class="c1">#    for lat_index in xrange(num_latitudes):</span>
<span class="c1">#        # The 0.5 puts the point in the centre of the grid pixel.</span>
<span class="c1">#        # This also avoids sampling right on the poles.</span>
<span class="c1">#        lat = -90 + (lat_index + 0.5) * lat_grid_spacing_degrees</span>
<span class="c1">#</span>
<span class="c1">#        for lon_index in xrange(num_longitudes):</span>
<span class="c1">#            # The 0.5 puts the point in the centre of the grid pixel.</span>
<span class="c1">#            # This also avoids sampling right on the dateline where there might be</span>
<span class="c1">#            # age grid or static polygon artifacts.</span>
<span class="c1">#            lon = -180 + (lon_index + 0.5) * lon_grid_spacing_degrees</span>
<span class="c1">#</span>
<span class="c1">#            point = pygplates.PointOnSphere(lat, lon)</span>
<span class="c1">#            points.append(point)</span>
<span class="c1">#</span>
<span class="c1">#    print(&#39;Finding polygons containing points...&#39;)</span>
<span class="c1">#    time_begin = time.clock()</span>
<span class="c1">#</span>
<span class="c1">#    if True:</span>
<span class="c1">#        #</span>
<span class="c1">#        # The fast way (about 3 seconds).</span>
<span class="c1">#        #</span>
<span class="c1">#        polygon_features_containing_points = find_polygons(points, polygons, polygon_features, all_polygons=True)</span>
<span class="c1">#    else:</span>
<span class="c1">#        #</span>
<span class="c1">#        # The slow way (about 200 seconds).</span>
<span class="c1">#        #</span>
<span class="c1">#        # Similar to &#39;find_polygons()&#39; except without using a quad tree.</span>
<span class="c1">#        #</span>
<span class="c1">#        polygons_and_features = sorted(</span>
<span class="c1">#                ((polygons[index], polygon_features[index]) for index in xrange(len(polygons))),</span>
<span class="c1">#                key=lambda polygon_and_feature: polygon_and_feature[0].get_area(),</span>
<span class="c1">#                reverse=True)</span>
<span class="c1">#        polygon_features_containing_points = [None] * len(points)</span>
<span class="c1">#        for point_index, point in enumerate(points):</span>
<span class="c1">#            for polygon, polygon_feature in polygons_and_features:</span>
<span class="c1">#                if polygon.is_point_in_polygon(point):</span>
<span class="c1">#                    if polygon_features_containing_points[point_index] is None:</span>
<span class="c1">#                        polygon_features_containing_points[point_index] = []</span>
<span class="c1">#                    polygon_features_containing_points[point_index].append(polygon_feature)</span>
<span class="c1">#</span>
<span class="c1">#    time_end = time.clock()</span>
<span class="c1">#    print(&#39;  {0} seconds&#39;.format(time_end - time_begin))</span>
<span class="c1">#</span>
<span class="c1">#    print(&#39;Associate each point with zero or more polygon plate IDs...&#39;)</span>
<span class="c1">#</span>
<span class="c1">#    # Group points inside each polygon so can create one multi-point per polygon.</span>
<span class="c1">#    polygon_feature_to_points_mapping = {}</span>
<span class="c1">#    for point_index, polygon_feature_list in enumerate(polygon_features_containing_points):</span>
<span class="c1">#        if polygon_feature_list:</span>
<span class="c1">#            for polygon_feature in polygon_feature_list:</span>
<span class="c1">#                points_in_polygon = polygon_feature_to_points_mapping.setdefault(polygon_feature, [])</span>
<span class="c1">#                points_in_polygon.append(points[point_index])</span>
<span class="c1">#</span>
<span class="c1">#    # Create multi-point features.</span>
<span class="c1">#    multi_point_features = []</span>
<span class="c1">#    for polygon_feature, points_in_polygon in polygon_feature_to_points_mapping.iteritems():</span>
<span class="c1">#        multi_point_feature = pygplates.Feature()</span>
<span class="c1">#        multi_point_feature.set_geometry(</span>
<span class="c1">#                pygplates.MultiPointOnSphere(points_in_polygon))</span>
<span class="c1">#</span>
<span class="c1">#        begin_time, end_time = polygon_feature.get_valid_time()</span>
<span class="c1">#        multi_point_feature.set_valid_time(begin_time, end_time)</span>
<span class="c1">#</span>
<span class="c1">#        multi_point_feature.set_reconstruction_plate_id(</span>
<span class="c1">#                polygon_feature.get_reconstruction_plate_id())</span>
<span class="c1">#</span>
<span class="c1">#        multi_point_features.append(multi_point_feature)</span>
<span class="c1">#</span>
<span class="c1">#    print(&#39;Writing points feature collection...&#39;)</span>
<span class="c1">#    pygplates.FeatureCollection(multi_point_features).write(&#39;multi_point_features.gpml&#39;)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, The University of Sydney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>