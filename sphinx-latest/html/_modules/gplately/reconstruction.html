

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gplately.reconstruction &mdash; gplately 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            gplately
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basic_usages.html">Minimal working example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../use_cases.html">Common Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Trouble-shooting and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../command_line_interface.html">Command Line Interface (CLI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primer.html">Primer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Main Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../secondaries.html">Other Classes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">gplately</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gplately.reconstruction</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gplately.reconstruction</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">#    Copyright (C) 2024 The University of Sydney, Australia</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1">#    the terms of the GNU General Public License, version 2, as published by</span>
<span class="c1">#    the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c1">#    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c1">#    for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License along</span>
<span class="c1">#    with this program; if not, write to Free Software Foundation, Inc.,</span>
<span class="c1">#    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This sub-module contains tools that wrap up pyGPlates and Plate Tectonic Tools functionalities for reconstructing features,</span>
<span class="sd">working with point data, and calculating plate velocities at specific geological times.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># pyright: reportMissingTypeStubs=true</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pygplates</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">tools</span> <span class="k">as</span> <span class="n">_tools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.gpml</span><span class="w"> </span><span class="kn">import</span> <span class="n">_load_FeatureCollection</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.ptt</span><span class="w"> </span><span class="kn">import</span> <span class="n">separate_ridge_transform_segments</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;gplately&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="PlateReconstruction">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PlateReconstruction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruct topology features to specific geological times given a :py:attr:`~rotation_model`,</span>
<span class="sd">    a set of :py:attr:`~topology_features` and a set of :py:attr:`~static_polygons`.</span>
<span class="sd">    Topological plate velocity data at specific geological times can also be</span>
<span class="sd">    calculated from these reconstructed features.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlateReconstruction.__init__">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rotation_model</span><span class="p">,</span>
        <span class="n">topology_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">static_polygons</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">plate_model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Nemo&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rotation_model : str/`os.PathLike`, or instance of `pygplates.FeatureCollection`_, or `pygplates.Feature`_, or sequence of `pygplates.Feature`_, or instance of `pygplates.RotationModel`_</span>
<span class="sd">            A rotation model to query equivalent and/or relative topological plate rotations</span>
<span class="sd">            from a time in the past relative to another time in the past or to present day. Can be</span>
<span class="sd">            provided as a rotation filename, or rotation feature collection, or rotation feature, or</span>
<span class="sd">            sequence of rotation features, or a sequence (eg, a list or tuple) of any combination of</span>
<span class="sd">            those four types.</span>
<span class="sd">        topology_features : str/`os.PathLike`, or a sequence (eg, `list` or `tuple`) of instances of `pygplates.Feature`_, or a single instance of `pygplates.Feature`_, or an instance of `pygplates.FeatureCollection`_, default None</span>
<span class="sd">            Reconstructable topological features like trenches, ridges and transforms. Can be provided</span>
<span class="sd">            as an optional topology-feature filename, or sequence of features, or a single feature.</span>
<span class="sd">        static_polygons : str/`os.PathLike`, or instance of `pygplates.Feature`_, or sequence of `pygplates.Feature`_, or an instance of `pygplates.FeatureCollection`_, default None</span>
<span class="sd">            Present-day polygons whose shapes do not change through geological time. They are</span>
<span class="sd">            used to cookie-cut dynamic polygons into identifiable topological plates (assigned</span>
<span class="sd">            an ID) according to their present-day locations. Can be provided as a static polygon feature</span>
<span class="sd">            collection, or optional filename, or a single feature, or a sequence of</span>
<span class="sd">            features.</span>
<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Default anchor plate ID for reconstruction.</span>
<span class="sd">            If not specified then uses the default anchor plate of :py:attr:`~rotation_model`.</span>
<span class="sd">        plate_model_name : str, optional</span>
<span class="sd">            Only if the plate model has a name and users would like the :py:class:`gplately.PlateReconstruction` object tracks the name</span>


<span class="sd">        .. _pygplates.RotationModel: https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel</span>
<span class="sd">        .. _pygplates.Feature: https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature</span>
<span class="sd">        .. _pygplates.FeatureCollection: https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#: (`pygplates.RotationModel &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel&gt;`__) - query equivalent and/or relative topological plate rotations</span>
        <span class="c1">#: from a time in the past relative to another time in the past or to present day.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Add a warning if the rotation_model is empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rotation_model</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No rotation features were passed to the constructor of PlateReconstruction. The reconstruction will not work. Check your rotation file(s).&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rotation_model</span><span class="p">,</span> <span class="s2">&quot;reconstruction_identifier&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">reconstruction_identifier</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">anchor_plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotation_model</span><span class="p">,</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
                <span class="c1"># Use the default anchor plate of &#39;rotation_model&#39;.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">rotation_model</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Using rotation features/files, so default anchor plate is 0.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">rotation_model</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># User has explicitly specified an anchor plate ID, so let&#39;s check it.</span>
            <span class="n">anchor_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_anchor_plate_id</span><span class="p">(</span><span class="n">anchor_plate_id</span><span class="p">)</span>
            <span class="c1"># This works when &#39;rotation_model&#39; is a RotationModel or rotation features/files.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="n">rotation_model</span><span class="p">,</span> <span class="n">default_anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span>
            <span class="p">)</span>

        <span class="c1">#: (`pygplates.FeatureCollection &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection&gt;`__, default None) -</span>
        <span class="c1">#: Topological features like trenches, ridges and transforms.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span> <span class="o">=</span> <span class="n">_load_FeatureCollection</span><span class="p">(</span><span class="n">topology_features</span><span class="p">)</span>

        <span class="c1">#: (`pygplates.FeatureCollection &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection&gt;`__, default None) -</span>
        <span class="c1">#: Present-day polygons whose shapes do not change through geological time when reconstructed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">static_polygons</span> <span class="o">=</span> <span class="n">_load_FeatureCollection</span><span class="p">(</span><span class="n">static_polygons</span><span class="p">)</span>

        <span class="c1">#: (str, optional) -</span>
        <span class="c1">#: optional plate model name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plate_model_name</span> <span class="o">=</span> <span class="n">plate_model_name</span>

        <span class="c1"># Keep a snapshot of the resolved topologies at its last requested snapshot time (and anchor plate).</span>
        <span class="c1"># Also keep a snapshot of the reconstructed static polygons at its the last requested snapshot time (and anchor plate)</span>
        <span class="c1"># which, by the way, could be a different snapshot time and anchor plate than the topological snapshot.</span>
        <span class="c1">#</span>
        <span class="c1"># This avoids having to do unnessary work if the same snapshot time (and anchor plate) is requested again.</span>
        <span class="c1"># But if the requested time (or anchor plate) changes then we&#39;ll create a new snapshot.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: Both pygplates.TopologicalSnapshot and pygplates.ReconstructSnapshot can be pickled.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_topological_snapshot</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons_snapshot</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Remove the unpicklable entries.</span>
        <span class="c1">#</span>
        <span class="c1"># This includes pygplates reconstructed feature geometries and resolved topological geometries.</span>
        <span class="c1"># Note: PyGPlates features and features collections (and rotation models) can be pickled though.</span>
        <span class="c1">#</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1"># Restore the unpicklable entries.</span>
        <span class="c1">#</span>
        <span class="c1"># This includes pygplates reconstructed feature geometries and resolved topological geometries.</span>
        <span class="c1"># Note: PyGPlates features and features collections (and rotation models) can be pickled though.</span>
        <span class="c1">#</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">anchor_plate_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;default anchor plate ID for reconstruction. Must be an integer &gt;= 0.&quot;&quot;&quot;</span>
        <span class="c1"># The default anchor plate comes from the RotationModel.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="o">.</span><span class="n">get_default_anchor_plate_id</span><span class="p">()</span>

    <span class="nd">@anchor_plate_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">anchor_plate_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anchor_plate</span><span class="p">):</span>
        <span class="c1"># Note: Caller cannot specify None when setting the anchor plate.</span>
        <span class="n">anchor_plate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_anchor_plate_id</span><span class="p">(</span><span class="n">anchor_plate</span><span class="p">)</span>
        <span class="c1"># Only need to update if the anchor plate changed.</span>
        <span class="k">if</span> <span class="n">anchor_plate</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span><span class="p">:</span>
            <span class="c1"># Update the RotationModel (which is where the anchor plate is stored).</span>
            <span class="c1"># This keeps the same rotation model but just changes the anchor plate.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span> <span class="n">default_anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate</span>
            <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_check_anchor_plate_id</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid anchor plate ID: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">id</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_topology_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Topology features have not been set in this PlateReconstruction.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If not including topological slab boundaries then remove them.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_topological_slab_boundaries</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">feature</span>
                <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span>
                <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">get_feature_type</span><span class="p">()</span>
                <span class="o">!=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">gpml_topological_slab_boundary</span>  <span class="c1"># type: ignore</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span>

<div class="viewcode-block" id="PlateReconstruction.topological_snapshot">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.topological_snapshot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">topological_snapshot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a snapshot of resolved topologies at the specified reconstruction time.</span>

<span class="sd">        This returns a `pygplates.TopologicalSnapshot &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.TopologicalSnapshot&gt;`__</span>
<span class="sd">        from which you can extract resolved topologies, calculate velocities at point locations, calculate plate boundary statistics, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : float, int or pygplates.GeoTimeInstant</span>
<span class="sd">            The geological time at which to create the topological snapshot.</span>
<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            The anchored plate id to use when resolving topologies.</span>
<span class="sd">            If not specified then uses the current anchor plate (:py:attr:`gplately.PlateReconstruction.anchor_plate_id` attribute).</span>
<span class="sd">        include_topological_slab_boundaries : bool, default=True</span>
<span class="sd">            Include topological boundary features of type ``gpml:TopologicalSlabBoundary``.</span>
<span class="sd">            By default all features passed into constructor ``__init__()`` are included in the snapshot.</span>
<span class="sd">            However setting this to False is useful when you&#39;re only interested in **plate** boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topological_snapshot : pygplates.TopologicalSnapshot</span>
<span class="sd">            The `topological snapshot &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.TopologicalSnapshot&gt;`__</span>
<span class="sd">            at the specified ``time`` (and anchor plate).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If topology features have not been set in this :py:class:`gplately.PlateReconstruction` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">anchor_plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">anchor_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span>

        <span class="c1"># Only need to create a new snapshot if we don&#39;t have one, or if any of the following have changed since the last snapshot:</span>
        <span class="c1"># - the reconstruction time,</span>
        <span class="c1"># - the anchor plate,</span>
        <span class="c1"># - whether to include topological slab boundaries or not.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_topological_snapshot</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="c1"># last snapshot time...</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topological_snapshot</span><span class="o">.</span><span class="n">get_reconstruction_time</span><span class="p">()</span>
            <span class="c1"># use pygplates.GeoTimeInstant to get a numerical tolerance in floating-point time comparison...</span>
            <span class="o">!=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeoTimeInstant</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># last snapshot anchor plate...</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topological_snapshot</span><span class="o">.</span><span class="n">get_rotation_model</span><span class="p">()</span><span class="o">.</span><span class="n">get_default_anchor_plate_id</span><span class="p">()</span>
            <span class="o">!=</span> <span class="n">anchor_plate_id</span>
            <span class="c1"># whether last snapshot included topological slab boundaries...</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topological_snapshot_includes_topological_slab_boundaries</span>
            <span class="o">!=</span> <span class="n">include_topological_slab_boundaries</span>
        <span class="p">):</span>
            <span class="c1"># Create snapshot for current parameters.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_topological_snapshot</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">TopologicalSnapshot</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_topology_features</span><span class="p">(</span>
                    <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="n">include_topological_slab_boundaries</span>
                <span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Parameters used for the last snapshot.</span>
            <span class="c1">#</span>
            <span class="c1"># The snapshot time and anchor plate are stored in the snapshot itself (so not added here).</span>
            <span class="c1">#</span>
            <span class="c1"># Note: These don&#39;t need to be initialised in &#39;__init__()&#39; as long as it sets &quot;self._topological_snapshot = None&quot;.</span>
            <span class="c1">#</span>
            <span class="c1"># Note: If we add more parameters then perhaps create a single nested private (leading &#39;_&#39;) class for them.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_topological_snapshot_includes_topological_slab_boundaries</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">include_topological_slab_boundaries</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topological_snapshot</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_check_static_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Check we have static polygons.</span>
        <span class="c1">#</span>
        <span class="c1"># Currently all available models have them, but it&#39;s possible for a user to create a PlateReconstruction without them.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_polygons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Static polygons have not been set in this PlateReconstruction.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_polygons</span>

<div class="viewcode-block" id="PlateReconstruction.static_polygons_snapshot">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.static_polygons_snapshot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">static_polygons_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a reconstructed snapshot of the static polygons at the specified reconstruction time.</span>

<span class="sd">        This returns a `pygplates.ReconstructSnapshot &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.ReconstructSnapshot&gt;`__</span>
<span class="sd">        from which you can extract reconstructed static polygons, find reconstructed polygons containing points and calculate velocities at point locations, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : float, int or pygplates.GeoTimeInstant</span>
<span class="sd">            The geological time at which to create the reconstructed static polygons snapshot.</span>
<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            The anchored plate id to use when reconstructing the static polygons.</span>
<span class="sd">            If not specified then uses the current anchor plate (:py:attr:`anchor_plate_id` attribute).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        static_polygons_snapshot : pygplates.ReconstructSnapshot</span>
<span class="sd">            The reconstructed static polygons `snapshot &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.ReconstructSnapshot&gt;`__</span>
<span class="sd">            at the specified &quot;time&quot; (and anchor plate).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If static polygons have not been set in this :py:class:`gplately.PlateReconstruction` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">anchor_plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">anchor_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span>

        <span class="c1"># Only need to create a new snapshot if we don&#39;t have one, or if any of the following have changed since the last snapshot:</span>
        <span class="c1"># - the reconstruction time,</span>
        <span class="c1"># - the anchor plate.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons_snapshot</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="c1"># last snapshot time...</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons_snapshot</span><span class="o">.</span><span class="n">get_reconstruction_time</span><span class="p">()</span>
            <span class="c1"># use pygplates.GeoTimeInstant to get a numerical tolerance in floating-point time comparison...</span>
            <span class="o">!=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeoTimeInstant</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># last snapshot anchor plate...</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons_snapshot</span><span class="o">.</span><span class="n">get_rotation_model</span><span class="p">()</span><span class="o">.</span><span class="n">get_default_anchor_plate_id</span><span class="p">()</span>
            <span class="o">!=</span> <span class="n">anchor_plate_id</span>
        <span class="p">):</span>
            <span class="c1"># Create snapshot for current parameters.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons_snapshot</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ReconstructSnapshot</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_static_polygons</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons_snapshot</span></div>


<div class="viewcode-block" id="PlateReconstruction.divergent_convergent_plate_boundaries">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.divergent_convergent_plate_boundaries">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">divergent_convergent_plate_boundaries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">uniform_point_spacing_radians</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="n">divergence_velocity_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">convergence_velocity_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">first_uniform_point_spacing_radians</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">velocity_delta_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">velocity_delta_time_type</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityDeltaTimeType</span><span class="o">.</span><span class="n">t_plus_delta_t_to_t</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">velocity_units</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">cms_per_yr</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">earth_radius_in_kms</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">include_network_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">boundary_section_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Samples points uniformly along plate boundaries and calculates statistics at diverging/converging locations at a particular geological time.</span>

<span class="sd">        Resolves topologies at &quot;&quot;time&quot;&quot;, uniformly samples all plate boundaries into points and returns two lists of</span>
<span class="sd">        `pygplates.PlateBoundaryStatistic &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.PlateBoundaryStatistic&gt;`__.</span>
<span class="sd">        The first list represents sample points where the plates are diverging, and the second where plates are converging.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : float</span>
<span class="sd">            The reconstruction time (Ma) at which to query divergent/convergent plate boundaries.</span>
<span class="sd">        uniform_point_spacing_radians : float, default=0.001</span>
<span class="sd">            The spacing between uniform points along plate boundaries (in radians).</span>
<span class="sd">        divergence_velocity_threshold : float, default=0.0</span>
<span class="sd">            Orthogonal (ie, in the direction of boundary normal) velocity threshold for &quot;diverging&quot; sample points.</span>
<span class="sd">            Points with an orthogonal &quot;diverging&quot; velocity above this value will be returned in &quot;diverging_data&quot;.</span>
<span class="sd">            The default is 0.0 which removes all converging sample points (leaving only diverging points).</span>
<span class="sd">            This value can be negative which means a small amount of convergence is allowed for the diverging points.</span>
<span class="sd">            The units should match the units of &quot;velocity_units&quot; (eg, if that&#39;s cm/yr then this threshold should also be in cm/yr).</span>
<span class="sd">        convergence_velocity_threshold : float, default=0.0</span>
<span class="sd">            Orthogonal (ie, in the direction of boundary normal) velocity threshold for &quot;converging&quot; sample points.</span>
<span class="sd">            Points with an orthogonal &quot;converging&quot; velocity above this value will be returned in &quot;converging_data&quot;.</span>
<span class="sd">            The default is 0.0 which removes all diverging sample points (leaving only converging points).</span>
<span class="sd">            This value can be negative which means a small amount of divergence is allowed for the converging points.</span>
<span class="sd">            The units should match the units of &quot;velocity_units&quot; (eg, if that&#39;s cm/yr then this threshold should also be in cm/yr).</span>
<span class="sd">        first_uniform_point_spacing_radians : float, optional</span>
<span class="sd">            Spacing of first uniform point in each resolved topological section (in radians) - see</span>
<span class="sd">            `pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics() &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.topologicalsnapshot#pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics&gt;`__</span>
<span class="sd">            for more details. Defaults to half of &quot;uniform_point_spacing_radians&quot;.</span>
<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Anchor plate ID. Defaults to the current anchor plate ID (:py:attr:`anchor_plate_id` attribute).</span>
<span class="sd">        velocity_delta_time : float, default=1.0</span>
<span class="sd">            The time delta used to calculate velocities (defaults to 1 Myr).</span>
<span class="sd">        velocity_delta_time_type : pygplates.VelocityDeltaTimeType, default=pygplates.VelocityDeltaTimeType.t_plus_delta_t_to_t</span>
<span class="sd">            How the two velocity times are calculated relative to &quot;time&quot; (defaults to &quot;[time + velocity_delta_time, time]&quot;).</span>
<span class="sd">        velocity_units : pygplates.VelocityUnits, default=pygplates.VelocityUnits.cms_per_yr</span>
<span class="sd">            Whether to return velocities in centimetres per year or kilometres per million years (defaults to centimetres per year).</span>
<span class="sd">        earth_radius_in_kms : float, default=pygplates.Earth.mean_radius_in_kms</span>
<span class="sd">            Radius of the Earth in kilometres.</span>
<span class="sd">            This is only used to calculate velocities (strain rates always use &quot;pygplates.Earth.equatorial_radius_in_kms&quot;).</span>
<span class="sd">        include_network_boundaries : bool, default=False</span>
<span class="sd">            Whether to sample along network boundaries that are not also plate boundaries (defaults to False).</span>
<span class="sd">            If a deforming network shares a boundary with a plate then it&#39;ll get included regardless of this option.</span>
<span class="sd">        include_topological_slab_boundaries : bool, default=False</span>
<span class="sd">            Whether to sample along slab boundaries (features of type gpml:TopologicalSlabBoundary).</span>
<span class="sd">            By default they are not sampled since they are not plate boundaries.</span>
<span class="sd">        boundary_section_filter</span>
<span class="sd">            Same as the &quot;boundary_section_filter&quot; argument in</span>
<span class="sd">            `pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics() &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.topologicalsnapshot#pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics&gt;`__.</span>
<span class="sd">            Defaults to None (meaning all plate boundaries are included by default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        diverging_data : list of pygplates.PlateBoundaryStatistic</span>
<span class="sd">            The results for all uniformly sampled points along plate boundaries that are &quot;diverging&quot; relative to &quot;divergence_threshold&quot;.</span>
<span class="sd">            The size of the returned list is equal to the number of sampled points that are &quot;diverging&quot;.</span>
<span class="sd">            Each `pygplates.PlateBoundaryStatistic &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.PlateBoundaryStatistic&gt;`__ is guaranteed to have a valid (ie, not None)</span>
<span class="sd">            `convergence velocity &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.PlateBoundaryStatistic.html#pygplates.PlateBoundaryStatistic.convergence_velocity&gt;`__.</span>
<span class="sd">        converging_data : list of pygplates.PlateBoundaryStatistic</span>
<span class="sd">            The results for all uniformly sampled points along plate boundaries that are &quot;converging&quot; relative to &quot;convergence_threshold&quot;.</span>
<span class="sd">            The size of the returned list is equal to the number of sampled points that are &quot;converging&quot;.</span>
<span class="sd">            Each `pygplates.PlateBoundaryStatistic &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.PlateBoundaryStatistic&gt;`__ is guaranteed to have a valid (ie, not None)</span>
<span class="sd">            `convergence velocity &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.PlateBoundaryStatistic.html#pygplates.PlateBoundaryStatistic.convergence_velocity&gt;`__.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If topology features have not been set in this :py:class:`gplately.PlateReconstruction` object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To sample diverging/converging points along plate boundaries at 50Ma:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            diverging_data, converging_data = (</span>
<span class="sd">                plate_reconstruction.divergent_convergent_plate_boundaries(50)</span>
<span class="sd">            )</span>

<span class="sd">        To do the same, but restrict converging data to points where orthogonal converging velocities are greater than 0.2 cm/yr</span>
<span class="sd">        (with diverging data remaining unchanged with the default 0.0 threshold):</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            diverging_data, converging_data = (</span>
<span class="sd">                plate_reconstruction.divergent_convergent_plate_boundaries(</span>
<span class="sd">                    50, convergence_velocity_threshold=0.2</span>
<span class="sd">                )</span>
<span class="sd">            )</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you want to access all sampled points regardless of their convergence/divergence you can call `topological_snapshot()` and then use it to directly call</span>
<span class="sd">        `pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics() &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.topologicalsnapshot#pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics&gt;`__.</span>
<span class="sd">        Then you can do your own analysis on the returned data:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            plate_boundary_statistics = plate_reconstruction.topological_snapshot(</span>
<span class="sd">                time, include_topological_slab_boundaries=False</span>
<span class="sd">            ).calculate_plate_boundary_statistics(uniform_point_spacing_radians=0.001)</span>

<span class="sd">            for stat in plate_boundary_statistics:</span>
<span class="sd">                if np.isnan(stat.convergence_velocity_orthogonal):</span>
<span class="sd">                    continue  # missing left or right plate</span>
<span class="sd">                latitude, longitude = stat.boundary_point.to_lat_lon()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Generate statistics at uniformly spaced points along plate boundaries.</span>
        <span class="n">plate_boundary_statistics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_snapshot</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39;</span>
            <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="n">include_topological_slab_boundaries</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">calculate_plate_boundary_statistics</span><span class="p">(</span>
            <span class="n">uniform_point_spacing_radians</span><span class="p">,</span>
            <span class="n">first_uniform_point_spacing_radians</span><span class="o">=</span><span class="n">first_uniform_point_spacing_radians</span><span class="p">,</span>
            <span class="n">velocity_delta_time</span><span class="o">=</span><span class="n">velocity_delta_time</span><span class="p">,</span>
            <span class="n">velocity_delta_time_type</span><span class="o">=</span><span class="n">velocity_delta_time_type</span><span class="p">,</span>
            <span class="n">velocity_units</span><span class="o">=</span><span class="n">velocity_units</span><span class="p">,</span>
            <span class="n">earth_radius_in_kms</span><span class="o">=</span><span class="n">earth_radius_in_kms</span><span class="p">,</span>
            <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
            <span class="n">boundary_section_filter</span><span class="o">=</span><span class="n">boundary_section_filter</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">diverging_point_stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">converging_point_stats</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">plate_boundary_statistics</span><span class="p">:</span>

            <span class="c1"># Convergence velocity.</span>
            <span class="c1">#</span>
            <span class="c1"># Note: We use the &#39;orthogonal&#39; component of velocity vector.</span>
            <span class="n">convergence_velocity_orthogonal</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity_orthogonal</span>
            <span class="c1"># Skip current point if missing left or right plate (cannot calculate convergence).</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">convergence_velocity_orthogonal</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Add to diverging points if within the specified divergence velocity threshold.</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">convergence_velocity_orthogonal</span> <span class="o">&gt;=</span> <span class="n">divergence_velocity_threshold</span><span class="p">:</span>
                <span class="n">diverging_point_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span>

            <span class="c1"># Add to converging points if within the specified convergence velocity threshold.</span>
            <span class="k">if</span> <span class="n">convergence_velocity_orthogonal</span> <span class="o">&gt;=</span> <span class="n">convergence_velocity_threshold</span><span class="p">:</span>
                <span class="n">converging_point_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">diverging_point_stats</span><span class="p">,</span> <span class="n">converging_point_stats</span></div>


<div class="viewcode-block" id="PlateReconstruction.crustal_production_destruction_rate">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.crustal_production_destruction_rate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">crustal_production_destruction_rate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">uniform_point_spacing_radians</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="n">divergence_velocity_threshold_in_cms_per_yr</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">convergence_velocity_threshold_in_cms_per_yr</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">first_uniform_point_spacing_radians</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">velocity_delta_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">velocity_delta_time_type</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityDeltaTimeType</span><span class="o">.</span><span class="n">t_plus_delta_t_to_t</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">include_network_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">boundary_section_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the total crustal production and destruction rates (in km\\ :sup:`2`/yr) of divergent and convergent plate boundaries at the specified geological time (Ma).</span>

<span class="sd">        Resolves topologies at `time` and uniformly samples all plate boundaries into divergent and convergent boundary points.</span>

<span class="sd">        Total crustal production (and destruction) rate is then calculated by accumulating divergent (and convergent) orthogonal velocities multiplied by their local boundary lengths.</span>
<span class="sd">        Velocities and lengths are scaled using the geocentric radius (at each divergent and convergent sampled point).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : float</span>
<span class="sd">            The reconstruction time (Ma) at which to query divergent/convergent plate boundaries.</span>
<span class="sd">        uniform_point_spacing_radians : float, default=0.001</span>
<span class="sd">            The spacing between uniform points along plate boundaries (in radians).</span>
<span class="sd">        divergence_velocity_threshold_in_cms_per_yr : float, default=0.0</span>
<span class="sd">            Orthogonal (ie, in the direction of boundary normal) velocity threshold for *diverging* sample points.</span>
<span class="sd">            Points with an orthogonal *diverging* velocity above this value will accumulate crustal *production*.</span>
<span class="sd">            The default is `0.0` which removes all converging sample points (leaving only diverging points).</span>
<span class="sd">            This value can be negative which means a small amount of convergence is allowed for the diverging points.</span>
<span class="sd">            The units should be in cm/yr.</span>
<span class="sd">        convergence_velocity_threshold_in_cms_per_yr : float, default=0.0</span>
<span class="sd">            Orthogonal (ie, in the direction of boundary normal) velocity threshold for *converging* sample points.</span>
<span class="sd">            Points with an orthogonal *converging* velocity above this value will accumulate crustal *destruction*.</span>
<span class="sd">            The default is `0.0` which removes all diverging sample points (leaving only converging points).</span>
<span class="sd">            This value can be negative which means a small amount of divergence is allowed for the converging points.</span>
<span class="sd">            The units should be in cm/yr.</span>
<span class="sd">        first_uniform_point_spacing_radians : float, optional</span>
<span class="sd">            Spacing of first uniform point in each resolved topological section (in radians) - see</span>
<span class="sd">            `divergent_convergent_plate_boundaries()` for more details. Defaults to half of `uniform_point_spacing_radians`.</span>
<span class="sd">        velocity_delta_time : float, default=1.0</span>
<span class="sd">            The time delta used to calculate velocities (defaults to 1 Myr).</span>
<span class="sd">        velocity_delta_time_type : pygplates.VelocityDeltaTimeType.t_plus_delta_t_to_t, pygplates.VelocityDeltaTimeType.t_to_t_minus_delta_t, pygplates.VelocityDeltaTimeType.t_plus_minus_half_delta_t, default=pygplates.VelocityDeltaTimeType.t_plus_delta_t_to_t</span>
<span class="sd">            How the two velocity times are calculated relative to `time` (defaults to ``[time + velocity_delta_time, time]``).</span>
<span class="sd">        include_network_boundaries : bool, default=False</span>
<span class="sd">            Whether to sample along network boundaries that are not also plate boundaries (defaults to False).</span>
<span class="sd">            If a deforming network shares a boundary with a plate then it&#39;ll get included regardless of this option.</span>
<span class="sd">        include_topological_slab_boundaries : bool, default=False</span>
<span class="sd">            Whether to sample along slab boundaries (features of type `gpml:TopologicalSlabBoundary`).</span>
<span class="sd">            By default they are *not* sampled since they are *not* plate boundaries.</span>
<span class="sd">        boundary_section_filter</span>
<span class="sd">            Same as the ``boundary_section_filter`` argument in `divergent_convergent_plate_boundaries()`.</span>
<span class="sd">            Defaults to ``None`` (meaning all plate boundaries are included by default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_crustal_production_rate_in_km_2_per_yr : float</span>
<span class="sd">            The total rate of crustal *production* at divergent plate boundaries (in km\\ :sup:`2`/yr) at the specified `time`.</span>
<span class="sd">        total_crustal_destruction_rate_in_km_2_per_yr : float</span>
<span class="sd">            The total rate of crustal *destruction* at convergent plate boundaries (in km\\ :sup:`2`/yr) at the specified `time`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If topology features have not been set in this :py:class:`gplately.PlateReconstruction` object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To calculate total crustal production/destruction along plate boundaries at 50Ma:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            (</span>
<span class="sd">                total_crustal_production_rate_in_km_2_per_yr,</span>
<span class="sd">                total_crustal_destruction_rate_in_km_2_per_yr,</span>
<span class="sd">            ) = plate_reconstruction.crustal_production_destruction_rate(50)</span>

<span class="sd">        To do the same, but restrict convergence to points where orthogonal converging velocities are greater than 0.2 cm/yr</span>
<span class="sd">        (with divergence remaining unchanged with the default 0.0 threshold):</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            (</span>
<span class="sd">                total_crustal_production_rate_in_km_2_per_yr,</span>
<span class="sd">                total_crustal_destruction_rate_in_km_2_per_yr,</span>
<span class="sd">            ) = plate_reconstruction.crustal_production_destruction_rate(</span>
<span class="sd">                50, convergence_velocity_threshold_in_cms_per_yr=0.2</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Generate statistics at uniformly spaced points along plate boundaries.</span>
        <span class="n">diverging_data</span><span class="p">,</span> <span class="n">converging_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">divergent_convergent_plate_boundaries</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">uniform_point_spacing_radians</span><span class="o">=</span><span class="n">uniform_point_spacing_radians</span><span class="p">,</span>
            <span class="n">divergence_velocity_threshold</span><span class="o">=</span><span class="n">divergence_velocity_threshold_in_cms_per_yr</span><span class="p">,</span>
            <span class="n">convergence_velocity_threshold</span><span class="o">=</span><span class="n">convergence_velocity_threshold_in_cms_per_yr</span><span class="p">,</span>
            <span class="n">first_uniform_point_spacing_radians</span><span class="o">=</span><span class="n">first_uniform_point_spacing_radians</span><span class="p">,</span>
            <span class="n">velocity_delta_time</span><span class="o">=</span><span class="n">velocity_delta_time</span><span class="p">,</span>
            <span class="n">velocity_delta_time_type</span><span class="o">=</span><span class="n">velocity_delta_time_type</span><span class="p">,</span>
            <span class="n">velocity_units</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">cms_per_yr</span><span class="p">,</span>
            <span class="n">earth_radius_in_kms</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span><span class="p">,</span>
            <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
            <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="n">include_topological_slab_boundaries</span><span class="p">,</span>
            <span class="n">boundary_section_filter</span><span class="o">=</span><span class="n">boundary_section_filter</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Total crustal production rate at divergent plate boundaries.</span>
        <span class="n">total_crustal_production_rate</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">diverging_data</span><span class="p">:</span>
            <span class="c1"># Get actual Earth radius at current latitude.</span>
            <span class="n">boundary_lat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_point</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>
            <span class="n">earth_radius_kms</span> <span class="o">=</span> <span class="n">_tools</span><span class="o">.</span><span class="n">geocentric_radius</span><span class="p">(</span><span class="n">boundary_lat</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e3</span>

            <span class="c1"># Convergence velocity was calculated using pygplates.Earth.mean_radius_in_kms,</span>
            <span class="c1"># so adjust for actual Earth radius &#39;earth_radius_kms&#39; at current latitude.</span>
            <span class="n">convergence_velocity_orthogonal</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity_orthogonal</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">earth_radius_kms</span> <span class="o">/</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span>
            <span class="p">)</span>

            <span class="c1"># Calculate crustal production rate at current location (in km^2/yr).</span>
            <span class="c1">#</span>
            <span class="c1"># Note: Orthogonal convergence velocity is guaranteed to be non-NaN.</span>
            <span class="n">crustal_production_rate</span> <span class="o">=</span> <span class="p">(</span>
                <span class="o">-</span><span class="n">convergence_velocity_orthogonal</span>  <span class="c1"># negate for divergence</span>
                <span class="o">*</span> <span class="mf">1e-5</span>  <span class="c1"># convert cm/yr to km/yr</span>
                <span class="o">*</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_length</span>  <span class="c1"># radians</span>
                <span class="o">*</span> <span class="n">earth_radius_kms</span>  <span class="c1"># km</span>
            <span class="p">)</span>

            <span class="n">total_crustal_production_rate</span> <span class="o">+=</span> <span class="n">crustal_production_rate</span>

        <span class="c1"># Total crustal destruction rate at convergent plate boundaries.</span>
        <span class="n">total_crustal_destruction_rate</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">converging_data</span><span class="p">:</span>
            <span class="c1"># Get actual Earth radius at current latitude.</span>
            <span class="n">boundary_lat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_point</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>
            <span class="n">earth_radius_kms</span> <span class="o">=</span> <span class="n">_tools</span><span class="o">.</span><span class="n">geocentric_radius</span><span class="p">(</span><span class="n">boundary_lat</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e3</span>

            <span class="c1"># Convergence velocity was calculated using pygplates.Earth.mean_radius_in_kms,</span>
            <span class="c1"># so adjust for actual Earth radius &#39;earth_radius_kms&#39; at current latitude.</span>
            <span class="n">convergence_velocity_orthogonal</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity_orthogonal</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">earth_radius_kms</span> <span class="o">/</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span>
            <span class="p">)</span>

            <span class="c1"># Calculate crustal destruction rate at current location (in km^2/yr).</span>
            <span class="c1">#</span>
            <span class="c1"># Note: Orthogonal convergence velocity is guaranteed to be non-NaN.</span>
            <span class="n">crustal_destruction_rate</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">convergence_velocity_orthogonal</span>
                <span class="o">*</span> <span class="mf">1e-5</span>  <span class="c1"># convert cm/yr to km/yr</span>
                <span class="o">*</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_length</span>  <span class="c1"># radians</span>
                <span class="o">*</span> <span class="n">earth_radius_kms</span>  <span class="c1"># km</span>
            <span class="p">)</span>

            <span class="n">total_crustal_destruction_rate</span> <span class="o">+=</span> <span class="n">crustal_destruction_rate</span>

        <span class="k">return</span> <span class="n">total_crustal_production_rate</span><span class="p">,</span> <span class="n">total_crustal_destruction_rate</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_subduction_convergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">uniform_point_spacing_radians</span><span class="p">,</span>
        <span class="n">velocity_delta_time</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="p">,</span>
        <span class="n">include_network_boundaries</span><span class="p">,</span>
        <span class="n">convergence_threshold_in_cm_per_yr</span><span class="p">,</span>
        <span class="n">output_distance_to_nearest_edge_of_trench</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_distance_to_start_edge_of_trench</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_convergence_velocity_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_trench_absolute_velocity_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_subducting_absolute_velocity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_subducting_absolute_velocity_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_trench_normal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1">#</span>
        <span class="c1"># This is essentially a replacement for &#39;ptt.subduction_convergence.subduction_convergence()&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># Instead of calculating convergence along subduction zones using subducting and overriding plate IDs,</span>
        <span class="c1"># it uses pyGPlates 1.0 functionality that calculates statistics along plate boundaries</span>
        <span class="c1"># (such as plate velocities, from which convergence velocity can be obtained).</span>
        <span class="c1">#</span>
        <span class="c1"># Note that this function has an advantage over &#39;ptt.subduction_convergence.subduction_convergence()&#39;:</span>
        <span class="c1">#   It does not reject subducting boundaries that have more than one (or even zero) subducting plates (or subducting networks),</span>
        <span class="c1">#   which can happen if the topological model was built incorrectly (eg, mislabelled plate boundaries).</span>
        <span class="c1">#   As long as there&#39;s at least one plate (or network) on the subducting side then it can find it</span>
        <span class="c1">#   (even if the plate is not directly attached to the subduction zone, ie, doesn&#39;t specify it as part of its boundary).</span>
        <span class="c1"># However, like &#39;ptt.subduction_convergence.subduction_convergence()&#39;, it only samples plate boundaries that have a</span>
        <span class="c1"># subduction polarity (eg, subduction zones) since we still need to know which plates are subducting and overriding,</span>
        <span class="c1"># and hence cannot calculate convergence over all plate boundaries.</span>

        <span class="c1"># Restrict plate boundaries to those that have a subduction polarity.</span>
        <span class="c1"># This is just an optimisation to avoid unnecessarily sampling all plate boundaries.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_boundary_section_filter_function</span><span class="p">(</span><span class="n">resolved_topological_section</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">resolved_topological_section</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_enumeration</span><span class="p">(</span>
                    <span class="n">pygplates</span><span class="o">.</span><span class="n">PropertyName</span><span class="o">.</span><span class="n">gpml_subduction_polarity</span>
                <span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">)</span>

        <span class="c1"># Generate statistics at uniformly spaced points along plate boundaries.</span>
        <span class="n">plate_boundary_statistics_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_snapshot</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
            <span class="c1"># Ignore topological slab boundaries since they are not *plate* boundaries</span>
            <span class="c1"># (a slab edge could have a subduction polarity, and would otherwise get included)...</span>
            <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">calculate_plate_boundary_statistics</span><span class="p">(</span>
            <span class="n">uniform_point_spacing_radians</span><span class="p">,</span>
            <span class="n">first_uniform_point_spacing_radians</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">velocity_delta_time</span><span class="o">=</span><span class="n">velocity_delta_time</span><span class="p">,</span>
            <span class="n">velocity_units</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">cms_per_yr</span><span class="p">,</span>
            <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
            <span class="n">boundary_section_filter</span><span class="o">=</span><span class="n">_boundary_section_filter_function</span><span class="p">,</span>
            <span class="n">return_shared_sub_segment_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">subduction_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate over the shared boundary sub-segments (each one will have a list of uniform points).</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">shared_sub_segment</span><span class="p">,</span>
            <span class="n">shared_sub_segment_stats</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="n">plate_boundary_statistics_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Find the subduction plate of the current shared boundary sub-segment.</span>
            <span class="n">subducting_plate_and_polarity</span> <span class="o">=</span> <span class="n">shared_sub_segment</span><span class="o">.</span><span class="n">get_subducting_plate</span><span class="p">(</span>
                <span class="n">return_subduction_polarity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">enforce_single_plate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Skip current shared boundary sub-segment if it doesn&#39;t have a valid subduction polarity.</span>
            <span class="c1">#</span>
            <span class="c1"># Note: There might not even be a subducting plate directly attached, but that&#39;s fine because</span>
            <span class="c1">#       we&#39;re only interested in the subduction polarity. Later we&#39;ll get the subducting plate</span>
            <span class="c1">#       from the plate boundary statistics instead (since that&#39;s more reliable).</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">subducting_plate_and_polarity</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">subduction_polarity</span> <span class="o">=</span> <span class="n">subducting_plate_and_polarity</span>

            <span class="k">if</span> <span class="n">subduction_polarity</span> <span class="o">==</span> <span class="s2">&quot;Left&quot;</span><span class="p">:</span>
                <span class="n">overriding_plate_is_on_left</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">overriding_plate_is_on_left</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Iterate over the uniform points of the current shared boundary sub-segment.</span>
            <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">shared_sub_segment_stats</span><span class="p">:</span>
                <span class="c1"># Find subducting plate velocity (opposite to overriding plate).</span>
                <span class="k">if</span> <span class="n">overriding_plate_is_on_left</span><span class="p">:</span>
                    <span class="n">subducting_plate_velocity</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">right_plate_velocity</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subducting_plate_velocity</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">left_plate_velocity</span>
                <span class="c1"># Reject point if there&#39;s no subducting plate (or network).</span>
                <span class="k">if</span> <span class="n">subducting_plate_velocity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># The convergence velocity is actually that of the subducting plate relative to the trench line.</span>
                <span class="c1"># It&#39;s not the right plate relative to the left (or vice versa).</span>
                <span class="n">convergence_velocity</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subducting_plate_velocity</span> <span class="o">-</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_velocity</span>
                <span class="p">)</span>

                <span class="c1"># Get the trench normal (and azimuth).</span>
                <span class="n">trench_normal</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_normal</span>
                <span class="n">trench_normal_azimuth</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_normal_azimuth</span>
                <span class="c1"># If the trench normal (in direction of overriding plate) is opposite the boundary line normal</span>
                <span class="c1"># (which is to the left) then flip it.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">overriding_plate_is_on_left</span><span class="p">:</span>
                    <span class="n">trench_normal</span> <span class="o">=</span> <span class="o">-</span><span class="n">trench_normal</span>
                    <span class="n">trench_normal_azimuth</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                    <span class="c1"># Keep in the range [0, 2*pi].</span>
                    <span class="k">if</span> <span class="n">trench_normal_azimuth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">trench_normal_azimuth</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

                <span class="c1"># If requested, reject point if it&#39;s not converging within specified threshold.</span>
                <span class="k">if</span> <span class="n">convergence_threshold_in_cm_per_yr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Note that we use the &#39;orthogonal&#39; component of velocity vector.</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">convergence_velocity</span><span class="p">,</span> <span class="n">trench_normal</span><span class="p">)</span>
                        <span class="o">&lt;</span> <span class="n">convergence_threshold_in_cm_per_yr</span>
                    <span class="p">):</span>
                        <span class="k">continue</span>

                <span class="c1"># Convergence velocity magnitude and obliquity.</span>
                <span class="k">if</span> <span class="n">convergence_velocity</span><span class="o">.</span><span class="n">is_zero_magnitude</span><span class="p">():</span>
                    <span class="n">convergence_velocity_magnitude</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">convergence_obliquity</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">convergence_velocity_magnitude</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">convergence_velocity</span><span class="o">.</span><span class="n">get_magnitude</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="n">convergence_obliquity</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">angle_between</span><span class="p">(</span>
                        <span class="n">convergence_velocity</span><span class="p">,</span> <span class="n">trench_normal</span>
                    <span class="p">)</span>

                    <span class="c1"># The direction towards which we rotate from the trench normal in a clockwise fashion.</span>
                    <span class="n">clockwise_direction</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span>
                        <span class="n">trench_normal</span><span class="p">,</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_point</span><span class="o">.</span><span class="n">to_xyz</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="c1"># Anti-clockwise direction has range (0, -pi) instead of (0, pi).</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">convergence_velocity</span><span class="p">,</span> <span class="n">clockwise_direction</span>
                        <span class="p">)</span>
                        <span class="o">&lt;</span> <span class="mi">0</span>
                    <span class="p">):</span>
                        <span class="n">convergence_obliquity</span> <span class="o">=</span> <span class="o">-</span><span class="n">convergence_obliquity</span>

                    <span class="c1"># See if plates are diverging (moving away from each other).</span>
                    <span class="c1"># If plates are diverging (moving away from each other) then make the</span>
                    <span class="c1"># velocity magnitude negative to indicate this. This could be inferred from</span>
                    <span class="c1"># the obliquity but it seems this is the standard way to output convergence rate.</span>
                    <span class="c1">#</span>
                    <span class="c1"># Note: This is the same as done in &#39;ptt.subduction_convergence.subduction_convergence()&#39;.</span>
                    <span class="k">if</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">convergence_velocity</span><span class="p">,</span> <span class="n">trench_normal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">convergence_velocity_magnitude</span> <span class="o">=</span> <span class="o">-</span><span class="n">convergence_velocity_magnitude</span>

                <span class="c1"># Trench absolute velocity magnitude and obliquity.</span>
                <span class="n">trench_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_velocity_magnitude</span>
                <span class="n">trench_absolute_velocity_obliquity</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_velocity_obliquity</span>

                <span class="c1"># If the trench normal (in direction of overriding plate) is opposite the boundary line normal (which is to the left)</span>
                <span class="c1"># then we need to flip the obliquity of the trench absolute velocity vector. This is because it&#39;s currently relative</span>
                <span class="c1"># to the boundary line normal but needs to be relative to the trench normal.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">overriding_plate_is_on_left</span><span class="p">:</span>
                    <span class="n">trench_absolute_velocity_obliquity</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                    <span class="c1"># Keep obliquity in the range [-pi, pi].</span>
                    <span class="k">if</span> <span class="n">trench_absolute_velocity_obliquity</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                        <span class="n">trench_absolute_velocity_obliquity</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

                <span class="c1"># See if the trench absolute motion is heading in the direction of the</span>
                <span class="c1"># overriding plate. If it is then make the velocity magnitude negative to</span>
                <span class="c1"># indicate this. This could be inferred from the obliquity but it seems this</span>
                <span class="c1"># is the standard way to output trench velocity magnitude.</span>
                <span class="c1">#</span>
                <span class="c1"># Note that we are not calculating the motion of the trench</span>
                <span class="c1"># relative to the overriding plate - they are usually attached to each other</span>
                <span class="c1"># and hence wouldn&#39;t move relative to each other.</span>
                <span class="c1">#</span>
                <span class="c1"># Note: This is the same as done in &#39;ptt.subduction_convergence.subduction_convergence()&#39;.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trench_absolute_velocity_obliquity</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                    <span class="n">trench_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="n">trench_absolute_velocity_magnitude</span>
                    <span class="p">)</span>

                <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_point</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>

                <span class="c1"># The plate ID along the trench line.</span>
                <span class="c1">#</span>
                <span class="c1"># Note: The plate IDs along the trench line and overriding plate ID can differ even in a non-deforming model</span>
                <span class="c1">#       due to smaller plates, not modelled by topologies, moving differently than the larger topological</span>
                <span class="c1">#       plate being modelled - and the trench line having plate IDs of the smaller plates near them.</span>
                <span class="c1">#       For that reason we use the plate IDs of the trench line (rather than the overriding plate ID).</span>
                <span class="c1">#</span>
                <span class="c1"># Note: Using &#39;pygplates.PlateBoundaryStatistic.boundary_feature&#39; means that if the current shared sub-segment</span>
                <span class="c1">#       is part of a topological line then this will obtain a plate ID from whichever sub-segment, of the current</span>
                <span class="c1">#       shared sub-segment, the current boundary point lies on (rather than obtaining a plate ID from the</span>
                <span class="c1">#       shared sub-segment itself). This is because a trench line that is a topological line might actually be</span>
                <span class="c1">#       deforming (or intended to be deforming) and hence its plate ID is not meaningful, or at least we can&#39;t</span>
                <span class="c1">#       be sure whether it will be zero or the overriding plate (or something else).</span>
                <span class="c1">#</span>
                <span class="n">trench_plate_id</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_feature</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">overriding_plate_is_on_left</span><span class="p">:</span>
                    <span class="n">subducting_plate</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">right_plate</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subducting_plate</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">left_plate</span>

                <span class="c1"># Get the subducting plate ID from resolved topological boundary (or network).</span>
                <span class="k">if</span> <span class="n">subducting_plate</span><span class="o">.</span><span class="n">located_in_resolved_boundary</span><span class="p">():</span>
                    <span class="n">subducting_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">subducting_plate</span><span class="o">.</span><span class="n">located_in_resolved_boundary</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_feature</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subducting_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">subducting_plate</span><span class="o">.</span><span class="n">located_in_resolved_network</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_feature</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                    <span class="p">)</span>

                <span class="n">output_tuple</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">lon</span><span class="p">,</span>
                    <span class="n">lat</span><span class="p">,</span>
                    <span class="n">convergence_velocity_magnitude</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">convergence_obliquity</span><span class="p">),</span>
                    <span class="n">trench_absolute_velocity_magnitude</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">trench_absolute_velocity_obliquity</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">boundary_length</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">trench_normal_azimuth</span><span class="p">),</span>
                    <span class="n">subducting_plate_id</span><span class="p">,</span>
                    <span class="n">trench_plate_id</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">output_distance_to_nearest_edge_of_trench</span><span class="p">:</span>
                    <span class="n">distance_to_nearest_edge_of_trench</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="n">stat</span><span class="o">.</span><span class="n">distance_from_start_of_topological_section</span><span class="p">,</span>
                        <span class="n">stat</span><span class="o">.</span><span class="n">distance_to_end_of_topological_section</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">distance_to_nearest_edge_of_trench</span><span class="p">),)</span>

                <span class="k">if</span> <span class="n">output_distance_to_start_edge_of_trench</span><span class="p">:</span>
                    <span class="c1"># We want the distance to be along the clockwise direction around the overriding plate.</span>
                    <span class="k">if</span> <span class="n">overriding_plate_is_on_left</span><span class="p">:</span>
                        <span class="c1"># The overriding plate is on the left of the trench.</span>
                        <span class="c1"># So the clockwise direction starts at the end of the trench.</span>
                        <span class="n">distance_to_start_edge_of_trench</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">stat</span><span class="o">.</span><span class="n">distance_to_end_of_topological_section</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># The overriding plate is on the right of the trench.</span>
                        <span class="c1"># So the clockwise direction starts at the beginning of the trench.</span>
                        <span class="n">distance_to_start_edge_of_trench</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">stat</span><span class="o">.</span><span class="n">distance_from_start_of_topological_section</span>
                        <span class="p">)</span>
                    <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">distance_to_start_edge_of_trench</span><span class="p">),)</span>

                <span class="k">if</span> <span class="n">output_convergence_velocity_components</span><span class="p">:</span>
                    <span class="c1"># The orthogonal and parallel components are just magnitude multiplied by cosine and sine.</span>
                    <span class="n">convergence_velocity_orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span>
                        <span class="n">convergence_obliquity</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">convergence_velocity_magnitude</span><span class="p">)</span>
                    <span class="n">convergence_velocity_parallel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span>
                        <span class="n">convergence_obliquity</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">convergence_velocity_magnitude</span><span class="p">)</span>
                    <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">convergence_velocity_orthogonal</span><span class="p">,</span>
                        <span class="n">convergence_velocity_parallel</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">output_trench_absolute_velocity_components</span><span class="p">:</span>
                    <span class="c1"># The orthogonal and parallel components are just magnitude multiplied by cosine and sine.</span>
                    <span class="n">trench_absolute_velocity_orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span>
                        <span class="n">trench_absolute_velocity_obliquity</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trench_absolute_velocity_magnitude</span><span class="p">)</span>
                    <span class="n">trench_absolute_velocity_parallel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span>
                        <span class="n">trench_absolute_velocity_obliquity</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trench_absolute_velocity_magnitude</span><span class="p">)</span>
                    <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">trench_absolute_velocity_orthogonal</span><span class="p">,</span>
                        <span class="n">trench_absolute_velocity_parallel</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">output_subducting_absolute_velocity</span>
                    <span class="ow">or</span> <span class="n">output_subducting_absolute_velocity_components</span>
                <span class="p">):</span>
                    <span class="c1"># Subducting absolute velocity magnitude and obliquity.</span>
                    <span class="c1">#</span>
                    <span class="c1"># Note: Subducting plate is opposite the overriding plate.</span>
                    <span class="k">if</span> <span class="n">overriding_plate_is_on_left</span><span class="p">:</span>
                        <span class="n">subducting_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">stat</span><span class="o">.</span><span class="n">right_plate_velocity_magnitude</span>
                        <span class="p">)</span>
                        <span class="n">subducting_absolute_velocity_obliquity</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">stat</span><span class="o">.</span><span class="n">right_plate_velocity_obliquity</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">subducting_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">stat</span><span class="o">.</span><span class="n">left_plate_velocity_magnitude</span>
                        <span class="p">)</span>
                        <span class="n">subducting_absolute_velocity_obliquity</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">stat</span><span class="o">.</span><span class="n">left_plate_velocity_obliquity</span>
                        <span class="p">)</span>
                        <span class="c1"># Flip obliquity since trench normal (towards overidding plate on right)</span>
                        <span class="c1"># is opposite the boundary line normal (towards left).</span>
                        <span class="n">subducting_absolute_velocity_obliquity</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                        <span class="c1"># Keep obliquity in the range [-pi, pi].</span>
                        <span class="k">if</span> <span class="n">subducting_absolute_velocity_obliquity</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                            <span class="n">subducting_absolute_velocity_obliquity</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

                    <span class="c1"># Similar to the trench absolute motion, if subducting absolute motion is heading</span>
                    <span class="c1"># in the direction of the overriding plate then make the velocity magnitude negative.</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">subducting_absolute_velocity_obliquity</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                        <span class="n">subducting_absolute_velocity_magnitude</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="o">-</span><span class="n">subducting_absolute_velocity_magnitude</span>
                        <span class="p">)</span>

                    <span class="k">if</span> <span class="n">output_subducting_absolute_velocity</span><span class="p">:</span>
                        <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="n">subducting_absolute_velocity_magnitude</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">subducting_absolute_velocity_obliquity</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">output_subducting_absolute_velocity_components</span><span class="p">:</span>
                        <span class="c1"># The orthogonal and parallel components are just magnitude multiplied by cosine and sine.</span>
                        <span class="n">subducting_absolute_velocity_orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span>
                            <span class="n">subducting_absolute_velocity_obliquity</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">subducting_absolute_velocity_magnitude</span><span class="p">)</span>
                        <span class="n">subducting_absolute_velocity_parallel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span>
                            <span class="n">subducting_absolute_velocity_obliquity</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">subducting_absolute_velocity_magnitude</span><span class="p">)</span>
                        <span class="n">output_tuple</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="n">subducting_absolute_velocity_orthogonal</span><span class="p">,</span>
                            <span class="n">subducting_absolute_velocity_parallel</span><span class="p">,</span>
                        <span class="p">)</span>

                <span class="k">if</span> <span class="n">output_trench_normal</span><span class="p">:</span>
                    <span class="n">output_tuple</span> <span class="o">+=</span> <span class="n">trench_normal</span><span class="o">.</span><span class="n">to_xyz</span><span class="p">()</span>

                <span class="n">subduction_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_tuple</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">subduction_data</span>

<div class="viewcode-block" id="PlateReconstruction.tessellate_subduction_zones">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.tessellate_subduction_zones">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tessellate_subduction_zones</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">tessellation_threshold_radians</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="n">ignore_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_geodataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">use_ptt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">include_network_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">convergence_threshold_in_cm_per_yr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">velocity_delta_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">output_distance_to_nearest_edge_of_trench</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_distance_to_start_edge_of_trench</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_convergence_velocity_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_trench_absolute_velocity_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_subducting_absolute_velocity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_subducting_absolute_velocity_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_trench_normal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Samples points along subduction zone trenches and obtains subduction data at a particular geological time.</span>

<span class="sd">        Resolves topologies at ``time`` and tessellates all resolved subducting features into points.</span>

<span class="sd">        Returns a 10-column vertically-stacked tuple with the following data per sampled trench point:</span>

<span class="sd">        * Col. 0 - longitude of sampled trench point</span>
<span class="sd">        * Col. 1 - latitude of sampled trench point</span>
<span class="sd">        * Col. 2 - subducting convergence (relative to trench) velocity magnitude (in cm/yr)</span>
<span class="sd">        * Col. 3 - subducting convergence velocity obliquity angle in degrees (angle between trench normal vector and convergence velocity vector)</span>
<span class="sd">        * Col. 4 - trench absolute (relative to anchor plate) velocity magnitude (in cm/yr)</span>
<span class="sd">        * Col. 5 - trench absolute velocity obliquity angle in degrees (angle between trench normal vector and trench absolute velocity vector)</span>
<span class="sd">        * Col. 6 - length of arc segment (in degrees) that current point is on</span>
<span class="sd">        * Col. 7 - trench normal (in subduction direction, ie, towards overriding plate) azimuth angle (clockwise starting at North, ie, 0 to 360 degrees) at current point</span>
<span class="sd">        * Col. 8 - subducting plate ID</span>
<span class="sd">        * Col. 9 - trench plate ID</span>

<span class="sd">        The optional ``output_*`` parameters can be used to append extra data to the output tuple of each sampled trench point.</span>
<span class="sd">        The order of any extra data is the same order in which the parameters are listed below.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : float</span>
<span class="sd">            The reconstruction time (Ma) at which to query subduction convergence.</span>
<span class="sd">        tessellation_threshold_radians : float, default=0.001</span>
<span class="sd">            The threshold sampling distance along the plate boundaries (in radians).</span>
<span class="sd">        ignore_warnings : bool, default=False</span>
<span class="sd">            Choose to ignore warnings from :py:func:`ptt.subduction_convergence.subduction_convergence` (if ``use_ptt`` is ``True``).</span>
<span class="sd">        return_geodataframe : bool, default=False</span>
<span class="sd">            Choose to return data in a geopandas.GeoDataFrame.</span>
<span class="sd">        use_ptt : bool, default=False</span>
<span class="sd">            If set to ``True`` then uses :py:func:`ptt.subduction_convergence.subduction_convergence` to calculate subduction convergence</span>
<span class="sd">            (which uses the subducting stage rotation of the subduction/trench plate IDs calculate subducting velocities).</span>
<span class="sd">            If set to ``False`` then uses plate convergence to calculate subduction convergence</span>
<span class="sd">            (which samples velocities of the two adjacent boundary plates at each sampled point to calculate subducting velocities).</span>
<span class="sd">            Both methods ignore plate boundaries that do not have a subduction polarity (feature property), which essentially means</span>
<span class="sd">            they only sample subduction zones.</span>
<span class="sd">        include_network_boundaries : bool, default=False</span>
<span class="sd">            Whether to calculate subduction convergence along network boundaries that are not also plate boundaries (defaults to False).</span>
<span class="sd">            If a deforming network shares a boundary with a plate then it&#39;ll get included regardless of this option.</span>
<span class="sd">            Since subduction zones occur along *plate* boundaries this would only be an issue if an intra-plate network boundary was incorrectly labelled as subducting.</span>
<span class="sd">        convergence_threshold_in_cm_per_yr : float, optional</span>
<span class="sd">            Only return sample points with an orthogonal (ie, in the subducting geometry&#39;s normal direction) converging velocity above this value (in cm/yr).</span>
<span class="sd">            For example, setting this to `0.0` would remove all diverging sample points (leaving only converging points).</span>
<span class="sd">            This value can be negative which means a small amount of divergence is allowed.</span>
<span class="sd">            If `None` then all (converging and diverging) sample points are returned. This is the default.</span>
<span class="sd">            Note that this parameter can only be specified if ``use_ptt`` is ``False``.</span>
<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Anchor plate ID. Defaults to the current anchor plate ID (:py:attr:`gplately.PlateReconstruction.anchor_plate_id` attribute).</span>
<span class="sd">        velocity_delta_time : float, default=1.0</span>
<span class="sd">            Velocity delta time used in convergence velocity calculations (defaults to 1 Myr).</span>
<span class="sd">        output_distance_to_nearest_edge_of_trench : bool, default=False</span>
<span class="sd">            Append the distance (in degrees) along the trench line to the nearest trench edge to each returned sample point.</span>
<span class="sd">            A trench edge is the farthermost location on the current trench feature that contributes to a plate boundary.</span>
<span class="sd">        output_distance_to_start_edge_of_trench : bool, default=False</span>
<span class="sd">            Append the distance (in degrees) along the trench line from the start edge of the trench to each returned sample point.</span>
<span class="sd">            The start of the trench is along the clockwise direction around the overriding plate.</span>
<span class="sd">        output_convergence_velocity_components : bool, default=False</span>
<span class="sd">            Append the convergence velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">            Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">            Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">        output_trench_absolute_velocity_components : bool, default=False</span>
<span class="sd">            Append the trench absolute velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">            Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">            Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">        output_subducting_absolute_velocity : bool, default=False</span>
<span class="sd">            Append the subducting plate absolute velocity magnitude (in cm/yr) and obliquity angle (in degrees) to each returned sample point.</span>
<span class="sd">        output_subducting_absolute_velocity_components : bool, default=False</span>
<span class="sd">            Append the subducting plate absolute velocity orthogonal and parallel components (in cm/yr) to each returned sample point.</span>
<span class="sd">            Orthogonal is normal to trench (in direction of overriding plate when positive).</span>
<span class="sd">            Parallel is along trench (90 degrees clockwise from trench normal when positive).</span>
<span class="sd">        output_trench_normal : bool, default=False</span>
<span class="sd">            Append the x, y and z components of the trench normal unit-length 3D vectors.</span>
<span class="sd">            These vectors are normal to the trench in the direction of subduction (towards overriding plate).</span>
<span class="sd">            These are global 3D vectors which differ from trench normal azimuth angles (ie, angles relative to North).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subduction_data : a list of vertically-stacked tuples</span>
<span class="sd">            The results for all tessellated points sampled along the trench.</span>
<span class="sd">            The size of the returned list is equal to the number of tessellated points.</span>
<span class="sd">            Each tuple in the list corresponds to a tessellated point and has the following tuple items:</span>

<span class="sd">            * Col. 0 - longitude of sampled trench point</span>
<span class="sd">            * Col. 1 - latitude of sampled trench point</span>
<span class="sd">            * Col. 2 - subducting convergence (relative to trench) velocity magnitude (in cm/yr)</span>
<span class="sd">            * Col. 3 - subducting convergence velocity obliquity angle in degrees (angle between trench normal vector and convergence velocity vector)</span>
<span class="sd">            * Col. 4 - trench absolute (relative to anchor plate) velocity magnitude (in cm/yr)</span>
<span class="sd">            * Col. 5 - trench absolute velocity obliquity angle in degrees (angle between trench normal vector and trench absolute velocity vector)</span>
<span class="sd">            * Col. 6 - length of arc segment (in degrees) that current point is on</span>
<span class="sd">            * Col. 7 - trench normal (in subduction direction, ie, towards overriding plate) azimuth angle (clockwise starting at North, ie, 0 to 360 degrees) at current point</span>
<span class="sd">            * Col. 8 - subducting plate ID</span>
<span class="sd">            * Col. 9 - trench plate ID</span>

<span class="sd">            The optional ``output_*`` parameters can be used to append extra data to the tuple of each sampled trench point.</span>
<span class="sd">            The order of any extra data is the same order in which the parameters are listed in this function.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If topology features have not been set in this :py:class:`gplately.PlateReconstruction` object.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``use_ptt`` is ``True`` and ``convergence_threshold_in_cm_per_yr`` is not ``None``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``use_ptt`` is False then each trench is sampled at **exactly** uniform intervals along its length such that the sampled points</span>
<span class="sd">        have a uniform spacing (along each trench polyline) that is **equal** to ``tessellation_threshold_radians``.</span>
<span class="sd">        If ``use_ptt`` is True then each trench is sampled at *approximately* uniform intervals along its length such that the sampled points</span>
<span class="sd">        have a uniform spacing (along each trench polyline) that is **less than or equal to** ``tessellation_threshold_radians``.</span>

<span class="sd">        The trench normal (at each sampled trench point) always points *towards* the overriding plate.</span>
<span class="sd">        The obliquity angles are in the range (-180, 180). The range (0, 180) goes clockwise (when viewed from above the Earth)</span>
<span class="sd">        from the trench normal direction to the velocity vector. The range (0, -180) goes counter-clockwise.</span>
<span class="sd">        You can change the range (-180, 180) to the range (0, 360) by adding 360 to negative angles.</span>
<span class="sd">        The trench normal is perpendicular to the trench and pointing toward the overriding plate.</span>

<span class="sd">        Note that the convergence velocity magnitude is negative if the plates are diverging (if convergence obliquity angle</span>
<span class="sd">        is greater than 90 or less than -90). And note that the trench absolute velocity magnitude is negative if the trench</span>
<span class="sd">        (subduction zone) is moving towards the overriding plate (if trench absolute obliquity angle is less than 90 and greater</span>
<span class="sd">        than -90) - note that this ignores the kinematics of the subducting plate. Similiarly for the subducting plate absolute</span>
<span class="sd">        velocity magnitude (if keyword argument ``output_subducting_absolute_velocity`` is True).</span>

<span class="sd">        The trench plate ID at each sample point can differ from the overriding plate ID.</span>
<span class="sd">        This is because, even in a non-deforming model, the smaller plates (not modelled by topologies) can move differently</span>
<span class="sd">        than the larger topological plate. So the trench line has the plate IDs of the smaller plates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To sample points along subduction zones at 50Ma:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            subduction_data = plate_reconstruction.tessellate_subduction_zones(50)</span>

<span class="sd">        To sample points along subduction zones at 50Ma, but only where there&#39;s convergence:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            subduction_data = plate_reconstruction.tessellate_subduction_zones(</span>
<span class="sd">                50, convergence_threshold_in_cm_per_yr=0.0</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">use_ptt</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">ptt</span> <span class="k">as</span> <span class="n">_ptt</span>

            <span class="k">if</span> <span class="n">convergence_threshold_in_cm_per_yr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Can only specify &#39;convergence_threshold_in_cm_per_yr&#39; if &#39;use_ptt&#39; is False.&quot;</span>
                <span class="p">)</span>

            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">ignore_warnings</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

                <span class="n">subduction_data</span> <span class="o">=</span> <span class="n">_ptt</span><span class="o">.</span><span class="n">subduction_convergence</span><span class="o">.</span><span class="n">subduction_convergence</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_topology_features</span><span class="p">(</span>
                        <span class="c1"># Ignore topological slab boundaries since they are not *plate* boundaries</span>
                        <span class="c1"># (actually they get ignored by default in &#39;ptt.subduction_convergence&#39; anyway)...</span>
                        <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">),</span>
                    <span class="n">tessellation_threshold_radians</span><span class="p">,</span>
                    <span class="n">time</span><span class="p">,</span>
                    <span class="n">velocity_delta_time</span><span class="o">=</span><span class="n">velocity_delta_time</span><span class="p">,</span>
                    <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
                    <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
                    <span class="n">output_distance_to_nearest_edge_of_trench</span><span class="o">=</span><span class="n">output_distance_to_nearest_edge_of_trench</span><span class="p">,</span>
                    <span class="n">output_distance_to_start_edge_of_trench</span><span class="o">=</span><span class="n">output_distance_to_start_edge_of_trench</span><span class="p">,</span>
                    <span class="n">output_convergence_velocity_components</span><span class="o">=</span><span class="n">output_convergence_velocity_components</span><span class="p">,</span>
                    <span class="n">output_trench_absolute_velocity_components</span><span class="o">=</span><span class="n">output_trench_absolute_velocity_components</span><span class="p">,</span>
                    <span class="n">output_subducting_absolute_velocity</span><span class="o">=</span><span class="n">output_subducting_absolute_velocity</span><span class="p">,</span>
                    <span class="n">output_subducting_absolute_velocity_components</span><span class="o">=</span><span class="n">output_subducting_absolute_velocity_components</span><span class="p">,</span>
                    <span class="n">output_trench_normal</span><span class="o">=</span><span class="n">output_trench_normal</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">subduction_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subduction_convergence</span><span class="p">(</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">uniform_point_spacing_radians</span><span class="o">=</span><span class="n">tessellation_threshold_radians</span><span class="p">,</span>
                <span class="n">velocity_delta_time</span><span class="o">=</span><span class="n">velocity_delta_time</span><span class="p">,</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
                <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
                <span class="n">convergence_threshold_in_cm_per_yr</span><span class="o">=</span><span class="n">convergence_threshold_in_cm_per_yr</span><span class="p">,</span>
                <span class="n">output_distance_to_nearest_edge_of_trench</span><span class="o">=</span><span class="n">output_distance_to_nearest_edge_of_trench</span><span class="p">,</span>
                <span class="n">output_distance_to_start_edge_of_trench</span><span class="o">=</span><span class="n">output_distance_to_start_edge_of_trench</span><span class="p">,</span>
                <span class="n">output_convergence_velocity_components</span><span class="o">=</span><span class="n">output_convergence_velocity_components</span><span class="p">,</span>
                <span class="n">output_trench_absolute_velocity_components</span><span class="o">=</span><span class="n">output_trench_absolute_velocity_components</span><span class="p">,</span>
                <span class="n">output_subducting_absolute_velocity</span><span class="o">=</span><span class="n">output_subducting_absolute_velocity</span><span class="p">,</span>
                <span class="n">output_subducting_absolute_velocity_components</span><span class="o">=</span><span class="n">output_subducting_absolute_velocity_components</span><span class="p">,</span>
                <span class="n">output_trench_normal</span><span class="o">=</span><span class="n">output_trench_normal</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">subduction_data</span><span class="p">:</span>
            <span class="n">subduction_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">subduction_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No subduction data.</span>
            <span class="n">num_columns</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">output_distance_to_nearest_edge_of_trench</span><span class="p">:</span>
                <span class="n">num_columns</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">output_distance_to_start_edge_of_trench</span><span class="p">:</span>
                <span class="n">num_columns</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">output_convergence_velocity_components</span><span class="p">:</span>
                <span class="n">num_columns</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">output_trench_absolute_velocity_components</span><span class="p">:</span>
                <span class="n">num_columns</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">output_subducting_absolute_velocity</span><span class="p">:</span>
                <span class="n">num_columns</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">output_subducting_absolute_velocity_components</span><span class="p">:</span>
                <span class="n">num_columns</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">output_trench_normal</span><span class="p">:</span>
                <span class="n">num_columns</span> <span class="o">+=</span> <span class="mi">3</span>
            <span class="n">subduction_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_columns</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">return_geodataframe</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="kn">import</span> <span class="n">geometry</span>

            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="c1"># Required data.</span>
            <span class="n">gdf_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">points</span><span class="p">,</span>
                <span class="s2">&quot;convergence velocity (cm/yr)&quot;</span><span class="p">:</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;convergence obliquity angle (degrees)&quot;</span><span class="p">:</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span>
                <span class="s2">&quot;trench velocity (cm/yr)&quot;</span><span class="p">:</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">],</span>
                <span class="s2">&quot;trench obliquity angle (degrees)&quot;</span><span class="p">:</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">],</span>
                <span class="s2">&quot;length (degrees)&quot;</span><span class="p">:</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">],</span>
                <span class="s2">&quot;trench normal angle (degrees)&quot;</span><span class="p">:</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">7</span><span class="p">],</span>
                <span class="s2">&quot;subducting plate ID&quot;</span><span class="p">:</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">8</span><span class="p">],</span>
                <span class="s2">&quot;trench plate ID&quot;</span><span class="p">:</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">9</span><span class="p">],</span>
            <span class="p">}</span>

            <span class="c1"># Optional data.</span>
            <span class="c1">#</span>
            <span class="c1"># Note: The order must match the output order.</span>
            <span class="n">optional_gdf_data_index</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">output_distance_to_nearest_edge_of_trench</span><span class="p">:</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;distance to nearest trench edge (degrees)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subduction_data</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="n">optional_gdf_data_index</span>
                <span class="p">]</span>
                <span class="n">optional_gdf_data_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">output_distance_to_start_edge_of_trench</span><span class="p">:</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;distance to start of trench edge (degrees)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">optional_gdf_data_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">output_convergence_velocity_components</span><span class="p">:</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;convergence velocity orthogonal component (cm/yr)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;convergence velocity parallel component (cm/yr)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">optional_gdf_data_index</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">output_trench_absolute_velocity_components</span><span class="p">:</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;trench absolute velocity orthogonal component (cm/yr)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;trench absolute velocity parallel component (cm/yr)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">optional_gdf_data_index</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">output_subducting_absolute_velocity</span><span class="p">:</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;subducting absolute velocity (cm/yr)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subduction_data</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="n">optional_gdf_data_index</span>
                <span class="p">]</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;subducting absolute obliquity angle (degrees)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">optional_gdf_data_index</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">output_subducting_absolute_velocity_components</span><span class="p">:</span>
                <span class="n">gdf_data</span><span class="p">[</span>
                    <span class="s2">&quot;subducting absolute velocity orthogonal component (cm/yr)&quot;</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span><span class="p">]</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;subducting absolute velocity parallel component (cm/yr)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">optional_gdf_data_index</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">output_trench_normal</span><span class="p">:</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;trench normal (unit-length 3D vector) x component&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;trench normal (unit-length 3D vector) y component&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;trench normal (unit-length 3D vector) z component&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">subduction_data</span><span class="p">[:,</span> <span class="n">optional_gdf_data_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">optional_gdf_data_index</span> <span class="o">+=</span> <span class="mi">3</span>

            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">gdf_data</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gdf</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">subduction_data</span></div>


<div class="viewcode-block" id="PlateReconstruction.total_subduction_zone_length">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.total_subduction_zone_length">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_subduction_zone_length</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">use_ptt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">include_network_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">convergence_threshold_in_cm_per_yr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the total length of all subduction zones (km) at the specified geological time (Ma).</span>

<span class="sd">        Resolves topologies at ``time`` and tessellates all resolved subducting features into points (see :py:meth:`tessellate_subduction_zones`).</span>

<span class="sd">        Total length is calculated by sampling points along the resolved subducting features (e.g. subduction zones) and accumulating their lengths</span>
<span class="sd">        (see :py:meth:`tessellate_subduction_zones`). Scales lengths to kilometres using the geocentric radius (at each sampled point).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : int</span>
<span class="sd">            The geological time at which to calculate total subduction zone lengths.</span>
<span class="sd">        use_ptt : bool, default=False</span>
<span class="sd">            If set to ``True`` then uses :py:func:`ptt.subduction_convergence.subduction_convergence` to calculate total subduction zone length.</span>
<span class="sd">            If set to ``False`` then uses plate convergence instead.</span>
<span class="sd">            Plate convergence is the more general approach that works along all plate boundaries (not just subduction zones).</span>
<span class="sd">        ignore_warnings : bool, default=False</span>
<span class="sd">            Choose to ignore warnings from :py:func:`ptt.subduction_convergence.subduction_convergence` (if ``use_ptt`` is ``True``).</span>
<span class="sd">        include_network_boundaries : bool, default=False</span>
<span class="sd">            Whether to count lengths along network boundaries that are not also plate boundaries (defaults to False).</span>
<span class="sd">            If a deforming network shares a boundary with a plate then it&#39;ll get included regardless of this option.</span>
<span class="sd">            Since subduction zones occur along **plate** boundaries this would only be an issue if an intra-plate network boundary was incorrectly labelled as subducting.</span>
<span class="sd">        convergence_threshold_in_cm_per_yr : float, optional</span>
<span class="sd">            Only count lengths associated with sample points that have an orthogonal (ie, in the subducting geometry&#39;s normal direction) converging velocity above this value (in cm/yr).</span>
<span class="sd">            For example, setting this to ``0.0`` would remove all diverging sample points (leaving only converging points).</span>
<span class="sd">            This value can be negative which means a small amount of divergence is allowed.</span>
<span class="sd">            If ``None`` then all (converging and diverging) sample points are counted. This is the default.</span>
<span class="sd">            Note that this parameter can only be specified if ``use_ptt`` is ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_subduction_zone_length_kms : float</span>
<span class="sd">            The total subduction zone length (in km) at the specified ``time``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If topology features have not been set in this :py:class:`gplately.PlateReconstruction` object.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``use_ptt`` is ``True`` and ``convergence_threshold_in_cm_per_yr`` is not ``None``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To calculate the total length of subduction zones at 50Ma:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            total_subduction_zone_length_kms = plate_reconstruction.total_subduction_zone_length(50)</span>

<span class="sd">        To calculate the total length of subduction zones at 50Ma, but only where there&#39;s actual convergence:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            total_subduction_zone_length_kms = plate_reconstruction.total_subduction_zone_length(50,</span>
<span class="sd">                    convergence_threshold_in_cm_per_yr=0.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subduction_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tessellate_subduction_zones</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">ignore_warnings</span><span class="o">=</span><span class="n">ignore_warnings</span><span class="p">,</span>
            <span class="n">use_ptt</span><span class="o">=</span><span class="n">use_ptt</span><span class="p">,</span>
            <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
            <span class="n">convergence_threshold_in_cm_per_yr</span><span class="o">=</span><span class="n">convergence_threshold_in_cm_per_yr</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">trench_arcseg</span> <span class="o">=</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">]</span>
        <span class="n">trench_pt_lat</span> <span class="o">=</span> <span class="n">subduction_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">total_subduction_zone_length_kms</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trench_arcseg</span><span class="p">):</span>
            <span class="n">earth_radius</span> <span class="o">=</span> <span class="n">_tools</span><span class="o">.</span><span class="n">geocentric_radius</span><span class="p">(</span><span class="n">trench_pt_lat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1e3</span>
            <span class="n">total_subduction_zone_length_kms</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="o">*</span> <span class="n">earth_radius</span>

        <span class="k">return</span> <span class="n">total_subduction_zone_length_kms</span></div>


<div class="viewcode-block" id="PlateReconstruction.total_continental_arc_length">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.total_continental_arc_length">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_continental_arc_length</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">continental_grid</span><span class="p">,</span>
        <span class="n">trench_arc_distance</span><span class="p">,</span>
        <span class="n">ignore_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">use_ptt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">include_network_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">convergence_threshold_in_cm_per_yr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the total length of all global continental arcs (km) at the specified geological time (Ma).</span>

<span class="sd">        Resolves topologies at ``time`` and tessellates all resolved subducting features into points (see :py:meth:`tessellate_subduction_zones`).</span>
<span class="sd">        The resolved points then are projected out by the ``trench_arc_distance`` (towards overriding plate) and their new locations are</span>
<span class="sd">        linearly interpolated onto the supplied ``continental_grid``. If the projected trench points lie in the grid, they are considered</span>
<span class="sd">        continental arc points, and their arc segment lengths are appended to the total continental arc length for the specified ``time``.</span>
<span class="sd">        The total length is scaled to kilometres using the geocentric radius (at each sampled point).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : int</span>
<span class="sd">            The geological time at which to calculate total continental arc lengths.</span>
<span class="sd">        continental_grid: gplately.Raster, array_like, or str</span>
<span class="sd">            The continental grid used to identify continental arc points. Must</span>
<span class="sd">            be convertible to :class:`gplately.Raster`. For an array, a global extent is</span>
<span class="sd">            assumed [-180,180,-90,90]. For a filename, the extent is obtained</span>
<span class="sd">            from the file.</span>
<span class="sd">        trench_arc_distance : float</span>
<span class="sd">            The trench-to-arc distance (in kilometres) to project sampled trench points out by in the direction of the overriding plate.</span>
<span class="sd">        ignore_warnings : bool, default=True</span>
<span class="sd">            Choose whether to ignore warning messages from :py:func:`ptt.subduction_convergence.subduction_convergence` (if ``use_ptt`` is ``True``)</span>
<span class="sd">            that alerts the user of subduction sub-segments that are ignored due to unidentified polarities and/or subducting plates.</span>
<span class="sd">        use_ptt : bool, default=False</span>
<span class="sd">            If set to ``True`` then uses :py:func:`ptt.subduction_convergence.subduction_convergence` to sample subducting features and their subduction polarities.</span>
<span class="sd">            If set to ``False`` then uses plate convergence instead.</span>
<span class="sd">            Plate convergence is the more general approach that works along all plate boundaries (not just subduction zones).</span>
<span class="sd">        include_network_boundaries : bool, default=False</span>
<span class="sd">            Whether to sample subducting features along network boundaries that are not also plate boundaries (defaults to False).</span>
<span class="sd">            If a deforming network shares a boundary with a plate then it&#39;ll get included regardless of this option.</span>
<span class="sd">            Since subduction zones occur along *plate* boundaries this would only be an issue if an intra-plate network boundary was incorrectly labelled as subducting.</span>
<span class="sd">        convergence_threshold_in_cm_per_yr : float, optional</span>
<span class="sd">            Only sample points with an orthogonal (ie, in the subducting geometry&#39;s normal direction) converging velocity above this value (in cm/yr).</span>
<span class="sd">            For example, setting this to ``0.0`` would remove all diverging sample points (leaving only converging points).</span>
<span class="sd">            This value can be negative which means a small amount of divergence is allowed.</span>
<span class="sd">            If ``None`` then all (converging and diverging) points are sampled. This is the default.</span>
<span class="sd">            Note that this parameter can only be specified if ``use_ptt`` is ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_continental_arc_length_kms : float</span>
<span class="sd">            The continental arc length (in km) at the specified time.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If topology features have not been set in this :py:class:`gplately.PlateReconstruction` object.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``use_ptt`` is ``True`` and ``convergence_threshold_in_cm_per_yr`` is not ``None``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To calculate the total length of continental arcs at 50Ma:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            total_continental_arc_length_kms = plate_reconstruction.total_continental_arc_length(50)</span>

<span class="sd">        To calculate the total length of subduction zones adjacent to continents at 50Ma, but only where there&#39;s actual convergence:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            total_continental_arc_length_kms = (</span>
<span class="sd">                plate_reconstruction.total_continental_arc_length(</span>
<span class="sd">                    50, convergence_threshold_in_cm_per_yr=0.0</span>
<span class="sd">                )</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">grids</span> <span class="k">as</span> <span class="n">_grids</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">continental_grid</span><span class="p">,</span> <span class="n">_grids</span><span class="o">.</span><span class="n">Raster</span><span class="p">):</span>
            <span class="n">graster</span> <span class="o">=</span> <span class="n">continental_grid</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">continental_grid</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Process the continental grid directory</span>
            <span class="n">graster</span> <span class="o">=</span> <span class="n">_grids</span><span class="o">.</span><span class="n">Raster</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">continental_grid</span><span class="p">,</span>
                <span class="n">realign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Process the masked continental grid</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">continental_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">continental_grid</span><span class="p">)</span>
                <span class="n">graster</span> <span class="o">=</span> <span class="n">_grids</span><span class="o">.</span><span class="n">Raster</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">continental_grid</span><span class="p">,</span>
                    <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span>
                    <span class="n">time</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid type for `continental_grid` (must be Raster,&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; str, or array_like)&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">!=</span> <span class="n">graster</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ignore_warnings</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span>
                <span class="s2">&quot;`continental_grid.time` (</span><span class="si">{}</span><span class="s2">) &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">graster</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;does not match `time` (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Obtain trench data.</span>
        <span class="n">trench_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tessellate_subduction_zones</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">ignore_warnings</span><span class="o">=</span><span class="n">ignore_warnings</span><span class="p">,</span>
            <span class="n">use_ptt</span><span class="o">=</span><span class="n">use_ptt</span><span class="p">,</span>
            <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
            <span class="n">convergence_threshold_in_cm_per_yr</span><span class="o">=</span><span class="n">convergence_threshold_in_cm_per_yr</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Extract trench data</span>
        <span class="n">trench_normal_azimuthal_angle</span> <span class="o">=</span> <span class="n">trench_data</span><span class="p">[:,</span> <span class="mi">7</span><span class="p">]</span>
        <span class="n">trench_arcseg</span> <span class="o">=</span> <span class="n">trench_data</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">]</span>
        <span class="n">trench_pt_lon</span> <span class="o">=</span> <span class="n">trench_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">trench_pt_lat</span> <span class="o">=</span> <span class="n">trench_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Modify the trench-arc distance using the geocentric radius</span>
        <span class="n">arc_distance</span> <span class="o">=</span> <span class="n">trench_arc_distance</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">_tools</span><span class="o">.</span><span class="n">geocentric_radius</span><span class="p">(</span><span class="n">trench_pt_lat</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="p">)</span>

        <span class="c1"># Project trench points out along trench-arc distance, and obtain their new lat-lon coordinates</span>
        <span class="n">dlon</span> <span class="o">=</span> <span class="n">arc_distance</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">trench_normal_azimuthal_angle</span><span class="p">))</span>
        <span class="n">dlat</span> <span class="o">=</span> <span class="n">arc_distance</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">trench_normal_azimuthal_angle</span><span class="p">))</span>
        <span class="n">ilon</span> <span class="o">=</span> <span class="n">trench_pt_lon</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">dlon</span><span class="p">)</span>
        <span class="n">ilat</span> <span class="o">=</span> <span class="n">trench_pt_lat</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">dlat</span><span class="p">)</span>

        <span class="c1"># Linearly interpolate projected points onto continental grids, and collect the indices of points that lie</span>
        <span class="c1"># within the grids.</span>
        <span class="n">sampled_points</span> <span class="o">=</span> <span class="n">graster</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
            <span class="n">ilon</span><span class="p">,</span>
            <span class="n">ilat</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
            <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># the code below will not work if graster.interpolate() returned a tuple</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sampled_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">continental_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sampled_points</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">point_lats</span> <span class="o">=</span> <span class="n">ilat</span><span class="p">[</span><span class="n">continental_indices</span><span class="p">]</span>
        <span class="n">point_radii</span> <span class="o">=</span> <span class="n">_tools</span><span class="o">.</span><span class="n">geocentric_radius</span><span class="p">(</span><span class="n">point_lats</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0e-3</span>  <span class="c1"># km</span>
        <span class="c1"># the code below will not work if trench_arcseg is GeoDataFrame</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trench_arcseg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">segment_arclens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">trench_arcseg</span><span class="p">[</span><span class="n">continental_indices</span><span class="p">])</span>
        <span class="n">segment_lengths</span> <span class="o">=</span> <span class="n">point_radii</span> <span class="o">*</span> <span class="n">segment_arclens</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">segment_lengths</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_ridge_spreading_rates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">uniform_point_spacing_radians</span><span class="p">,</span>
        <span class="n">velocity_delta_time</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="p">,</span>
        <span class="n">spreading_feature_types</span><span class="p">,</span>
        <span class="n">transform_segment_deviation_in_radians</span><span class="p">,</span>
        <span class="n">include_network_boundaries</span><span class="p">,</span>
        <span class="n">divergence_threshold_in_cm_per_yr</span><span class="p">,</span>
        <span class="n">output_obliquity_and_normal_and_left_right_plates</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1">#</span>
        <span class="c1"># This is essentially a replacement for &#39;ptt.ridge_spreading_rate.spreading_rates()&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># Instead of calculating spreading rates along mid-ocean ridges using left/right plate IDs,</span>
        <span class="c1"># it uses pyGPlates 1.0 functionality that calculates statistics along plate boundaries</span>
        <span class="c1"># (such as plate velocities, from which divergence spreading velocity can be obtained).</span>
        <span class="c1">#</span>
        <span class="c1"># Note that this function has an advantage over &#39;ptt.ridge_spreading_rate.spreading_rates()&#39;.</span>
        <span class="c1"># It can work on all plate boundaries, not just those that are spreading (eg, have left/right plate IDs).</span>
        <span class="c1"># This is because it uses plate velocities to calculate divergence (and hence spreading rates).</span>
        <span class="c1">#</span>

        <span class="c1"># Generate statistics at uniformly spaced points along plate boundaries.</span>
        <span class="n">plate_boundary_statistics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_snapshot</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
            <span class="c1"># Ignore topological slab boundaries since they are not *plate* boundaries</span>
            <span class="c1"># (useful when &#39;spreading_feature_types&#39; is None, and hence all plate boundaries are considered)...</span>
            <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">calculate_plate_boundary_statistics</span><span class="p">(</span>
            <span class="n">uniform_point_spacing_radians</span><span class="p">,</span>
            <span class="n">first_uniform_point_spacing_radians</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">velocity_delta_time</span><span class="o">=</span><span class="n">velocity_delta_time</span><span class="p">,</span>
            <span class="n">velocity_units</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">cms_per_yr</span><span class="p">,</span>
            <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
            <span class="n">boundary_section_filter</span><span class="o">=</span><span class="n">spreading_feature_types</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">ridge_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">plate_boundary_statistics</span><span class="p">:</span>
            <span class="c1"># Reject point if there&#39;s not a plate (or network) on both the left and right sides.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">spreading_obliquity</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity_obliquity</span>

            <span class="c1"># If requested, reject point if it&#39;s not diverging within specified threshold.</span>
            <span class="k">if</span> <span class="n">divergence_threshold_in_cm_per_yr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Note that we use the &#39;orthogonal&#39; component of velocity vector.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="o">-</span><span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity_orthogonal</span>
                    <span class="o">&lt;</span> <span class="n">divergence_threshold_in_cm_per_yr</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="n">output_obliquity_and_normal_and_left_right_plates</span>
                <span class="ow">or</span> <span class="n">transform_segment_deviation_in_radians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="c1"># Convert obliquity from the range [-pi, pi] to [0, pi/2].</span>
                <span class="c1"># We&#39;re only interested in the deviation angle from the normal line (positive or negative normal direction).</span>
                <span class="c1"># not interested in clockwise vs anti-clockwise</span>
                <span class="n">spreading_obliquity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity_obliquity</span><span class="p">)</span>
                <span class="c1"># angle relative to negative normal direction</span>
                <span class="k">if</span> <span class="n">spreading_obliquity</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                    <span class="n">spreading_obliquity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">spreading_obliquity</span>

                <span class="c1"># If a transform segment deviation was specified then we need to reject transform segments.</span>
                <span class="k">if</span> <span class="n">transform_segment_deviation_in_radians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Reject if spreading direction is too oblique compared to the plate boundary normal.</span>
                    <span class="c1">#</span>
                    <span class="c1"># Note: If there is zero spreading then we don&#39;t actually have an obliquity.</span>
                    <span class="c1">#       In which case we reject the current point to match the behaviour of</span>
                    <span class="c1">#       &#39;ptt.ridge_spreading_rate.spreading_rates()&#39; which rejects zero spreading stage rotations.</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity</span><span class="o">.</span><span class="n">is_zero_magnitude</span><span class="p">()</span>
                        <span class="ow">or</span> <span class="n">spreading_obliquity</span> <span class="o">&gt;</span> <span class="n">transform_segment_deviation_in_radians</span>
                    <span class="p">):</span>
                        <span class="k">continue</span>

            <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_point</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>
            <span class="n">spreading_velocity</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity_magnitude</span>

            <span class="k">if</span> <span class="n">output_obliquity_and_normal_and_left_right_plates</span><span class="p">:</span>
                <span class="c1"># Get the left plate ID from resolved topological boundary (or network).</span>
                <span class="k">if</span> <span class="n">stat</span><span class="o">.</span><span class="n">left_plate</span><span class="o">.</span><span class="n">located_in_resolved_boundary</span><span class="p">():</span>
                    <span class="n">left_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">stat</span><span class="o">.</span><span class="n">left_plate</span><span class="o">.</span><span class="n">located_in_resolved_boundary</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_feature</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">stat</span><span class="o">.</span><span class="n">left_plate</span><span class="o">.</span><span class="n">located_in_resolved_network</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_feature</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="c1"># Get the right plate ID from resolved topological boundary (or network).</span>
                <span class="k">if</span> <span class="n">stat</span><span class="o">.</span><span class="n">right_plate</span><span class="o">.</span><span class="n">located_in_resolved_boundary</span><span class="p">():</span>
                    <span class="n">right_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">stat</span><span class="o">.</span><span class="n">right_plate</span><span class="o">.</span><span class="n">located_in_resolved_boundary</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_feature</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">right_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">stat</span><span class="o">.</span><span class="n">right_plate</span><span class="o">.</span><span class="n">located_in_resolved_network</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_feature</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                    <span class="p">)</span>

                <span class="n">ridge_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">lon</span><span class="p">,</span>
                        <span class="n">lat</span><span class="p">,</span>
                        <span class="n">spreading_velocity</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">spreading_obliquity</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">boundary_length</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">boundary_normal_azimuth</span><span class="p">),</span>
                        <span class="n">left_plate_id</span><span class="p">,</span>
                        <span class="n">right_plate_id</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ridge_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">lon</span><span class="p">,</span>
                        <span class="n">lat</span><span class="p">,</span>
                        <span class="n">spreading_velocity</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">boundary_length</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">ridge_data</span>

<div class="viewcode-block" id="PlateReconstruction.tessellate_mid_ocean_ridges">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.tessellate_mid_ocean_ridges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tessellate_mid_ocean_ridges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">tessellation_threshold_radians</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="n">ignore_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_geodataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">use_ptt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">spreading_feature_types</span><span class="o">=</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">gpml_mid_ocean_ridge</span><span class="p">],</span>
        <span class="n">transform_segment_deviation_in_radians</span><span class="o">=</span><span class="n">separate_ridge_transform_segments</span><span class="o">.</span><span class="n">DEFAULT_TRANSFORM_SEGMENT_DEVIATION_RADIANS</span><span class="p">,</span>
        <span class="n">include_network_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">divergence_threshold_in_cm_per_yr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">output_obliquity_and_normal_and_left_right_plates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">velocity_delta_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Samples points along resolved spreading features (e.g. mid-ocean ridges) and calculates spreading rates and</span>
<span class="sd">        lengths of ridge segments at a particular geological time.</span>

<span class="sd">        Resolves topologies at time and tessellates all resolved spreading features into points.</span>

<span class="sd">        The transform segments of spreading features are ignored (unless &quot;transform_segment_deviation_in_radians is None).</span>

<span class="sd">        Returns a 4-column vertically stacked tuple with the following data per sampled ridge point</span>
<span class="sd">        (depending on &quot;output_obliquity_and_normal_and_left_right_plates&quot;):</span>

<span class="sd">        If &quot;output_obliquity_and_normal_and_left_right_plates&quot; is False (the default):</span>

<span class="sd">        * Col. 0 - longitude of sampled ridge point</span>
<span class="sd">        * Col. 1 - latitude of sampled ridge point</span>
<span class="sd">        * Col. 2 - spreading velocity magnitude (in cm/yr)</span>
<span class="sd">        * Col. 3 - length of arc segment (in degrees) that current point is on</span>

<span class="sd">        If &quot;output_obliquity_and_normal_and_left_right_plates&quot; is True:</span>

<span class="sd">        * Col. 0 - longitude of sampled ridge point</span>
<span class="sd">        * Col. 1 - latitude of sampled ridge point</span>
<span class="sd">        * Col. 2 - spreading velocity magnitude (in cm/yr)</span>
<span class="sd">        * Col. 3 - spreading obliquity in degrees (deviation from normal line in range 0 to 90 degrees)</span>
<span class="sd">        * Col. 4 - length of arc segment (in degrees) that current point is on</span>
<span class="sd">        * Col. 5 - azimuth of vector normal to the arc segment in degrees (clockwise starting at North, ie, 0 to 360 degrees)</span>
<span class="sd">        * Col. 6 - left plate ID</span>
<span class="sd">        * Col. 7 - right plate ID</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : float</span>
<span class="sd">            The reconstruction time (Ma) at which to query spreading rates.</span>
<span class="sd">        tessellation_threshold_radians : float, default=0.001</span>
<span class="sd">            The threshold sampling distance along the plate boundaries (in radians).</span>
<span class="sd">        ignore_warnings : bool, default=False</span>
<span class="sd">            Choose to ignore warnings from Plate Tectonic Tools&#39; ridge_spreading_rate workflow (if &quot;use_ptt&quot; is True).</span>
<span class="sd">        return_geodataframe : bool, default=False</span>
<span class="sd">            Choose to return data in a geopandas.GeoDataFrame.</span>
<span class="sd">        use_ptt : bool, default=False</span>
<span class="sd">            If set to True then uses Plate Tectonic Tools&#39; ridge_spreading_rate workflow to calculate ridge spreading rates</span>
<span class="sd">            (which uses the spreading stage rotation of the left/right plate IDs calculate spreading velocities).</span>
<span class="sd">            If set to False then uses plate divergence to calculate ridge spreading rates</span>
<span class="sd">            (which samples velocities of the two adjacent boundary plates at each sampled point to calculate spreading velocities).</span>
<span class="sd">            Plate divergence is the more general approach that works along all plate boundaries (not just mid-ocean ridges).</span>
<span class="sd">        spreading_feature_types : &lt;pygplates.FeatureType&gt; or sequence of &lt;pygplates.FeatureType&gt;, default=pygplates.FeatureType.gpml_mid_ocean_ridge</span>
<span class="sd">            Only sample points along plate boundaries of the specified feature types.</span>
<span class="sd">            Default is to only sample mid-ocean ridges.</span>
<span class="sd">            You can explicitly specify None to sample all plate boundaries, but note that if &quot;use_ptt&quot; is True</span>
<span class="sd">            then only plate boundaries that are spreading feature types are sampled</span>
<span class="sd">            (since Plate Tectonic Tools only works on spreading plate boundaries, eg, mid-ocean ridges).</span>
<span class="sd">        transform_segment_deviation_in_radians : float, default=&lt;implementation-defined&gt;</span>
<span class="sd">            How much a spreading direction can deviate from the segment normal before it&#39;s considered a transform segment (in radians).</span>
<span class="sd">            The default value has been empirically determined to give the best results for typical models.</span>
<span class="sd">            If &quot;None&quot; then the full feature geometry is used (ie, it is not split into ridge and transform segments with the transform segments getting ignored).</span>
<span class="sd">        include_network_boundaries : bool, default=False</span>
<span class="sd">            Whether to calculate spreading rate along network boundaries that are not also plate boundaries (defaults to False).</span>
<span class="sd">            If a deforming network shares a boundary with a plate then it&#39;ll get included regardless of this option.</span>
<span class="sd">            Since spreading features occur along *plate* boundaries this would only be an issue if an intra-plate network boundary was incorrectly labelled as spreading.</span>
<span class="sd">        divergence_threshold_in_cm_per_yr : float, optional</span>
<span class="sd">            Only return sample points with an orthogonal (ie, in the spreading geometry&#39;s normal direction) diverging velocity above this value (in cm/yr).</span>
<span class="sd">            For example, setting this to `0.0` would remove all converging sample points (leaving only diverging points).</span>
<span class="sd">            This value can be negative which means a small amount of convergence is allowed.</span>
<span class="sd">            If `None` then all (diverging and converging) sample points are returned.</span>
<span class="sd">            This is the default since &quot;spreading_feature_types&quot; is instead used (by default) to include only plate boundaries that are typically diverging (eg, mid-ocean ridges).</span>
<span class="sd">            However, setting &quot;spreading_feature_types&quot; to None (and &quot;transform_segment_deviation_in_radians&quot; to None) and explicitly specifying this parameter (eg, to 0.0)</span>
<span class="sd">            can be used to find points along all plate boundaries that are diverging.</span>
<span class="sd">            However, this parameter can only be specified if &quot;use_ptt&quot; is False.</span>
<span class="sd">        output_obliquity_and_normal_and_left_right_plates : bool, default=False</span>
<span class="sd">            Whether to also return spreading obliquity, normal azimuth and left/right plates.</span>
<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Anchor plate ID. Defaults to the current anchor plate ID (:py:attr:`anchor_plate_id` attribute)..</span>
<span class="sd">        velocity_delta_time : float, default=1.0</span>
<span class="sd">            Velocity delta time used in spreading velocity calculations (defaults to 1 Myr).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ridge_data : a list of vertically-stacked tuples</span>
<span class="sd">            The results for all tessellated points sampled along the mid-ocean ridges.</span>
<span class="sd">            The size of the returned list is equal to the number of tessellated points.</span>
<span class="sd">            Each tuple in the list corresponds to a tessellated point and has the following tuple items</span>
<span class="sd">            (depending on &quot;output_obliquity_and_normal_and_left_right_plates&quot;):</span>

<span class="sd">            If &quot;output_obliquity_and_normal_and_left_right_plates&quot; is False (the default):</span>

<span class="sd">            * longitude of sampled point</span>
<span class="sd">            * latitude of sampled point</span>
<span class="sd">            * spreading velocity magnitude (in cm/yr)</span>
<span class="sd">            * length of arc segment (in degrees) that sampled point is on</span>

<span class="sd">            If &quot;output_obliquity_and_normal_and_left_right_plates&quot; is True:</span>

<span class="sd">            * longitude of sampled point</span>
<span class="sd">            * latitude of sampled point</span>
<span class="sd">            * spreading velocity magnitude (in cm/yr)</span>
<span class="sd">            * spreading obliquity in degrees (deviation from normal line in range 0 to 90 degrees)</span>
<span class="sd">            * length of arc segment (in degrees) that sampled point is on</span>
<span class="sd">            * azimuth of vector normal to the arc segment in degrees (clockwise starting at North, ie, 0 to 360 degrees)</span>
<span class="sd">            * left plate ID</span>
<span class="sd">            * right plate ID</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If topology features have not been set in this :py:class:`gplately.PlateReconstruction` object.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If &quot;use_ptt&quot; is True and &quot;divergence_threshold_in_cm_per_yr&quot; is not None.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If &quot;use_ptt&quot; is False then each ridge segment is sampled at exactly uniform intervals along its length such that the sampled points</span>
<span class="sd">        have a uniform spacing (along each ridge segment polyline) that is equal to &quot;tessellation_threshold_radians&quot;.</span>
<span class="sd">        If &quot;use_ptt&quot; is True then each ridge segment is sampled at approximately uniform intervals along its length such that the sampled points</span>
<span class="sd">        have a uniform spacing (along each ridge segment polyline) that is less than or equal to &quot;tessellation_threshold_radians&quot;.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To sample points along mid-ocean ridges at 50Ma, but ignoring the transform segments (of the ridges):</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            ridge_data = plate_reconstruction.tessellate_mid_ocean_ridges(50)</span>

<span class="sd">        To do the same, but instead of ignoring transform segments include both ridge and transform segments,</span>
<span class="sd">        but only where orthogonal diverging velocities are greater than 0.2 cm/yr:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            ridge_data = plate_reconstruction.tessellate_mid_ocean_ridges(</span>
<span class="sd">                50,</span>
<span class="sd">                transform_segment_deviation_in_radians=None,</span>
<span class="sd">                divergence_threshold_in_cm_per_yr=0.2,</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">use_ptt</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">ptt</span> <span class="k">as</span> <span class="n">_ptt</span>

            <span class="k">if</span> <span class="n">divergence_threshold_in_cm_per_yr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Can only specify &#39;divergence_threshold_in_cm_per_yr&#39; if &#39;use_ptt&#39; is False.&quot;</span>
                <span class="p">)</span>

            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">ignore_warnings</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

                <span class="n">ridge_data</span> <span class="o">=</span> <span class="n">_ptt</span><span class="o">.</span><span class="n">ridge_spreading_rate</span><span class="o">.</span><span class="n">spreading_rates</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_topology_features</span><span class="p">(</span>
                        <span class="c1"># Ignore topological slab boundaries since they are not *plate* boundaries</span>
                        <span class="c1"># (not really needed since only *spreading* feature types are considered, and</span>
                        <span class="c1"># they typically wouldn&#39;t get used for a slab&#39;s boundary)...</span>
                        <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">),</span>
                    <span class="n">time</span><span class="p">,</span>
                    <span class="n">tessellation_threshold_radians</span><span class="p">,</span>
                    <span class="n">spreading_feature_types</span><span class="o">=</span><span class="n">spreading_feature_types</span><span class="p">,</span>
                    <span class="n">transform_segment_deviation_in_radians</span><span class="o">=</span><span class="n">transform_segment_deviation_in_radians</span><span class="p">,</span>
                    <span class="n">velocity_delta_time</span><span class="o">=</span><span class="n">velocity_delta_time</span><span class="p">,</span>
                    <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
                    <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
                    <span class="n">output_obliquity_and_normal_and_left_right_plates</span><span class="o">=</span><span class="n">output_obliquity_and_normal_and_left_right_plates</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ridge_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ridge_spreading_rates</span><span class="p">(</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">uniform_point_spacing_radians</span><span class="o">=</span><span class="n">tessellation_threshold_radians</span><span class="p">,</span>
                <span class="n">velocity_delta_time</span><span class="o">=</span><span class="n">velocity_delta_time</span><span class="p">,</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
                <span class="n">spreading_feature_types</span><span class="o">=</span><span class="n">spreading_feature_types</span><span class="p">,</span>
                <span class="n">transform_segment_deviation_in_radians</span><span class="o">=</span><span class="n">transform_segment_deviation_in_radians</span><span class="p">,</span>
                <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
                <span class="n">divergence_threshold_in_cm_per_yr</span><span class="o">=</span><span class="n">divergence_threshold_in_cm_per_yr</span><span class="p">,</span>
                <span class="n">output_obliquity_and_normal_and_left_right_plates</span><span class="o">=</span><span class="n">output_obliquity_and_normal_and_left_right_plates</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">ridge_data</span><span class="p">:</span>
            <span class="n">ridge_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">ridge_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No ridge data.</span>
            <span class="k">if</span> <span class="n">output_obliquity_and_normal_and_left_right_plates</span><span class="p">:</span>
                <span class="n">ridge_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ridge_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">return_geodataframe</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="kn">import</span> <span class="n">geometry</span>

            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="n">gdf_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">points</span><span class="p">,</span>
                <span class="s2">&quot;velocity (cm/yr)&quot;</span><span class="p">:</span> <span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">output_obliquity_and_normal_and_left_right_plates</span><span class="p">:</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;obliquity (degrees)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;length (degrees)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;normal azimuth (degrees)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;left plate ID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">]</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;right plate ID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">7</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gdf_data</span><span class="p">[</span><span class="s2">&quot;length (degrees)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">gdf_data</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ridge_data</span></div>


<div class="viewcode-block" id="PlateReconstruction.total_ridge_length">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.total_ridge_length">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_ridge_length</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">use_ptt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">spreading_feature_types</span><span class="o">=</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">gpml_mid_ocean_ridge</span><span class="p">],</span>
        <span class="n">transform_segment_deviation_in_radians</span><span class="o">=</span><span class="n">separate_ridge_transform_segments</span><span class="o">.</span><span class="n">DEFAULT_TRANSFORM_SEGMENT_DEVIATION_RADIANS</span><span class="p">,</span>
        <span class="n">include_network_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">divergence_threshold_in_cm_per_yr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the total length of all resolved spreading features (e.g. mid-ocean ridges) at the specified geological time (Ma).</span>

<span class="sd">        Resolves topologies at ``time`` and tessellates all resolved spreading features into points (see :py:meth:`tessellate_mid_ocean_ridges`).</span>

<span class="sd">        The transform segments of spreading features are ignored (unless ``transform_segment_deviation_in_radians`` is ``None``).</span>

<span class="sd">        Total length is calculated by sampling points along the resolved spreading features (e.g. mid-ocean ridges) and accumulating their lengths</span>
<span class="sd">        (see :py:meth:`tessellate_mid_ocean_ridges`). Scales lengths to kilometres using the geocentric radius (at each sampled point).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : int</span>
<span class="sd">            The geological time at which to calculate total mid-ocean ridge lengths.</span>
<span class="sd">        use_ptt : bool, default=False</span>
<span class="sd">            If set to ``True`` then uses :py:func:`ptt.ridge_spreading_rate.spreading_rates()` to calculate total ridge length</span>
<span class="sd">            (which uses the spreading stage rotation of the left/right plate IDs to calculate spreading directions - see ``transform_segment_deviation_in_radians``).</span>
<span class="sd">            If set to ``False`` then uses plate divergence to calculate total ridge length (which samples velocities of the two adjacent</span>
<span class="sd">            boundary plates at each sampled point to calculate spreading directions - see ``transform_segment_deviation_in_radians``).</span>
<span class="sd">            Plate divergence is the more general approach that works along all plate boundaries (not just mid-ocean ridges).</span>
<span class="sd">        ignore_warnings : bool, default=False</span>
<span class="sd">            Choose to ignore warnings from :py:func:`ptt.ridge_spreading_rate.spreading_rates()` (if ``use_ptt`` is ``True``).</span>
<span class="sd">        spreading_feature_types : &lt;pygplates.FeatureType&gt; or sequence of &lt;pygplates.FeatureType&gt;, default=pygplates.FeatureType.gpml_mid_ocean_ridge</span>
<span class="sd">            Only count lengths along plate boundaries of the specified feature types.</span>
<span class="sd">            Default is to only sample mid-ocean ridges.</span>
<span class="sd">            You can explicitly specify ``None`` to sample all plate boundaries, but note that if ``use_ptt`` is ``True``</span>
<span class="sd">            then only plate boundaries that are spreading feature types are sampled</span>
<span class="sd">            (since Plate Tectonic Tools only works on **spreading** plate boundaries, eg, mid-ocean ridges).</span>
<span class="sd">        transform_segment_deviation_in_radians : float, default=&lt;implementation-defined&gt;</span>
<span class="sd">            How much a spreading direction can deviate from the segment normal before it&#39;s considered a transform segment (in radians).</span>
<span class="sd">            The default value has been empirically determined to give the best results for typical models.</span>
<span class="sd">            If ``None`` then the full feature geometry is used (ie, it is not split into ridge and transform segments with the transform segments getting ignored).</span>
<span class="sd">        include_network_boundaries : bool, default=False</span>
<span class="sd">            Whether to count lengths along network boundaries that are not also plate boundaries (defaults to False).</span>
<span class="sd">            If a deforming network shares a boundary with a plate then it&#39;ll get included regardless of this option.</span>
<span class="sd">            Since spreading features occur along **plate** boundaries this would only be an issue if an intra-plate network boundary was incorrectly labelled as spreading.</span>
<span class="sd">        divergence_threshold_in_cm_per_yr : float, optional</span>
<span class="sd">            Only count lengths associated with sample points that have an orthogonal (ie, in the spreading geometry&#39;s normal direction) diverging velocity above this value (in cm/yr).</span>
<span class="sd">            For example, setting this to ``0.0`` would remove all converging sample points (leaving only diverging points).</span>
<span class="sd">            This value can be negative which means a small amount of convergence is allowed.</span>
<span class="sd">            If ``None`` then all (diverging and converging) sample points are counted.</span>
<span class="sd">            This is the default since ``spreading_feature_types`` is instead used (by default) to include only plate boundaries that are typically diverging (eg, mid-ocean ridges).</span>
<span class="sd">            However, setting ``spreading_feature_types`` to ``None`` (and ``transform_segment_deviation_in_radians`` to ``None``) and explicitly specifying this parameter (eg, to ``0.0``)</span>
<span class="sd">            can be used to count points along all plate boundaries that are diverging.</span>
<span class="sd">            However, this parameter can only be specified if ``use_ptt`` is ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_ridge_length_kms : float</span>
<span class="sd">            The total length of global mid-ocean ridges (in kilometres) at the specified time.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If topology features have not been set in this :py:class:`gplately.PlateReconstruction` object.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``use_ptt`` is ``True`` and ``divergence_threshold_in_cm_per_yr`` is not ``None``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To calculate the total length of mid-ocean ridges at 50Ma, but ignoring the transform segments (of the ridges):</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            total_ridge_length_kms = plate_reconstruction.total_ridge_length(50)</span>

<span class="sd">        To do the same, but instead of ignoring transform segments include both ridge and transform segments,</span>
<span class="sd">        but only where orthogonal diverging velocities are greater than 0.2 cm/yr:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            total_ridge_length_kms = plate_reconstruction.total_ridge_length(50,</span>
<span class="sd">                    transform_segment_deviation_in_radians=None,</span>
<span class="sd">                    divergence_threshold_in_cm_per_yr=0.2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ridge_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tessellate_mid_ocean_ridges</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">ignore_warnings</span><span class="o">=</span><span class="n">ignore_warnings</span><span class="p">,</span>
            <span class="n">use_ptt</span><span class="o">=</span><span class="n">use_ptt</span><span class="p">,</span>
            <span class="n">spreading_feature_types</span><span class="o">=</span><span class="n">spreading_feature_types</span><span class="p">,</span>
            <span class="n">transform_segment_deviation_in_radians</span><span class="o">=</span><span class="n">transform_segment_deviation_in_radians</span><span class="p">,</span>
            <span class="n">include_network_boundaries</span><span class="o">=</span><span class="n">include_network_boundaries</span><span class="p">,</span>
            <span class="n">divergence_threshold_in_cm_per_yr</span><span class="o">=</span><span class="n">divergence_threshold_in_cm_per_yr</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">ridge_arcseg</span> <span class="o">=</span> <span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">ridge_pt_lat</span> <span class="o">=</span> <span class="n">ridge_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">total_ridge_length_kms</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ridge_arcseg</span><span class="p">):</span>
            <span class="n">earth_radius</span> <span class="o">=</span> <span class="n">_tools</span><span class="o">.</span><span class="n">geocentric_radius</span><span class="p">(</span><span class="n">ridge_pt_lat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1e3</span>
            <span class="n">total_ridge_length_kms</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="o">*</span> <span class="n">earth_radius</span>

        <span class="k">return</span> <span class="n">total_ridge_length_kms</span></div>


<div class="viewcode-block" id="PlateReconstruction.reconstruct_snapshot">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.reconstruct_snapshot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstruct_snapshot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reconstructable_features</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">from_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a snapshot of reconstructed regular features (including motion paths and flowlines) at a specific geological time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reconstructable_features : str/os.PathLike, or a sequence (eg, list or tuple) of instances of &lt;pygplates.Feature&gt;, or a single instance of &lt;pygplates.Feature&gt;, or an instance of &lt;pygplates.FeatureCollection&gt;</span>
<span class="sd">            Regular reconstructable features (including motion paths and flowlines). Can be provided as a feature collection, or</span>
<span class="sd">            filename, or feature, or sequence of features, or a sequence (eg, list or tuple) of any combination of those four types.</span>

<span class="sd">        time : float, or pygplates.GeoTimeInstant</span>
<span class="sd">            The specific geological time to reconstruct to.</span>

<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Anchor plate ID. Defaults to the current anchor plate ID (:py:attr:`anchor_plate_id` attribute).</span>

<span class="sd">        from_time : float, default=0</span>
<span class="sd">            The specific geological time to reconstruct from. By default, this is set to present day.</span>
<span class="sd">            If not set to 0 Ma (present day) then the geometry in &quot;feature&quot; is assumed to be a reconstructed snapshot</span>
<span class="sd">            at &quot;from_time&quot;, in which case it is reverse reconstructed to present day before reconstructing to &quot;to_time&quot;.</span>
<span class="sd">            Usually features should contain present day geometry but might contain reconstructed geometry in some cases,</span>
<span class="sd">            such as those generated by the reconstruction export in GPlates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reconstruct_snapshot : pygplates.ReconstructSnapshot</span>
<span class="sd">            A `pygplates.ReconstructSnapshot &lt;https://www.gplates.org/docs/pygplates/generated/pygplates.ReconstructSnapshot&gt;`__</span>
<span class="sd">            of the specified reconstructable features reconstructed using the internal rotation model to the specified reconstruction time.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the features represent a snapshot at a *past* geological time then we need to reverse reconstruct them</span>
        <span class="c1"># such that they contain present-day geometry (not reconstructed geometry).</span>
        <span class="k">if</span> <span class="n">from_time</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Extract the reconstructed features and clone them so we don&#39;t modify the caller&#39;s features.</span>
            <span class="n">reconstructable_features</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">feature</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeaturesFunctionArgument</span><span class="p">(</span>
                    <span class="n">reconstructable_features</span>
                <span class="p">)</span><span class="o">.</span><span class="n">get_features</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="c1"># Reverse reconstruct in-place (modifies each feature&#39;s geometry).</span>

            <span class="n">pygplates</span><span class="o">.</span><span class="n">reverse_reconstruct</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="n">reconstructable_features</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                <span class="n">from_time</span><span class="p">,</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ReconstructSnapshot</span><span class="p">(</span>
            <span class="n">reconstructable_features</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PlateReconstruction.reconstruct">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.reconstruct">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstruct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">feature</span><span class="p">,</span>
        <span class="n">to_time</span><span class="p">,</span>
        <span class="n">from_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">reconstruct_type</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ReconstructType</span><span class="o">.</span><span class="n">feature_geometry</span><span class="p">,</span>
        <span class="n">group_with_feature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconstructs regular geological features, motion paths or flowlines to a specific geological time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        feature : str/os.PathLike, or instance of &lt;pygplates.FeatureCollection&gt;, or &lt;pygplates.Feature&gt;, or sequence of &lt;pygplates.Feature&gt;</span>
<span class="sd">            The geological features to reconstruct. Can be provided as a feature collection, or filename,</span>
<span class="sd">            or feature, or sequence of features, or a sequence (eg, a list or tuple) of any combination of</span>
<span class="sd">            those four types.</span>

<span class="sd">        to_time : float, or pygplates.GeoTimeInstant</span>
<span class="sd">            The specific geological time to reconstruct to.</span>

<span class="sd">        from_time : float, default=0</span>
<span class="sd">            The specific geological time to reconstruct from. By default, this is set to present day.</span>
<span class="sd">            If not set to 0 Ma (present day) then the geometry in &quot;feature&quot; is assumed to be a reconstructed snapshot</span>
<span class="sd">            at &quot;from_time&quot;, in which case it is reverse reconstructed to present day before reconstructing to &quot;to_time&quot;.</span>
<span class="sd">            Usually features should contain present day geometry but might contain reconstructed geometry in some cases,</span>
<span class="sd">            such as those generated by the reconstruction export in GPlates.</span>

<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Anchor plate ID. Defaults to the current anchor plate ID (:py:attr:`anchor_plate_id` attribute).</span>

<span class="sd">        reconstruct_type : pygplates.ReconstructType, default=pygplates.ReconstructType.feature_geometry</span>
<span class="sd">            The specific reconstruction type to generate based on input feature geometry type. Can be provided as</span>
<span class="sd">            pygplates.ReconstructType.feature_geometry to only reconstruct regular feature geometries, or</span>
<span class="sd">            pygplates.ReconstructType.motion_path to only reconstruct motion path features, or</span>
<span class="sd">            pygplates.ReconstructType.flowline to only reconstruct flowline features.</span>
<span class="sd">            Generates pygplates.ReconstructedFeatureGeometry, or pygplates.ReconstructedMotionPath, or</span>
<span class="sd">            pygplates.ReconstructedFlowline respectively.</span>

<span class="sd">        group_with_feature : bool, default=False</span>
<span class="sd">            Used to group reconstructed geometries with their features. This can be useful when a feature has more than one</span>
<span class="sd">            geometry and hence more than one reconstructed geometry. The returned list then becomes a list of tuples where</span>
<span class="sd">            each tuple contains a pygplates.Feature and a list of reconstructed geometries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reconstructed_features : list</span>
<span class="sd">            The reconstructed geological features.</span>
<span class="sd">            The reconstructed geometries are output in the same order as that of their respective input features (in the</span>
<span class="sd">            parameter &quot;features&quot;). This includes the order across any input feature collections or files. If &quot;group_with_feature&quot;</span>
<span class="sd">            is True then the list contains tuples that group each pygplates.Feature with a list of its reconstructed geometries.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        reconstruct_snapshot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reconstruct_snapshot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruct_snapshot</span><span class="p">(</span>
            <span class="n">feature</span><span class="p">,</span>
            <span class="n">to_time</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
            <span class="n">from_time</span><span class="o">=</span><span class="n">from_time</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">group_with_feature</span><span class="p">:</span>
            <span class="c1"># These are always sorted in same order as the input features.</span>
            <span class="k">return</span> <span class="n">reconstruct_snapshot</span><span class="o">.</span><span class="n">get_reconstructed_features</span><span class="p">(</span><span class="n">reconstruct_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reconstruct_snapshot</span><span class="o">.</span><span class="n">get_reconstructed_geometries</span><span class="p">(</span>
                <span class="n">reconstruct_type</span><span class="p">,</span> <span class="n">same_order_as_reconstructable_features</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="PlateReconstruction.get_point_velocities">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.get_point_velocities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_point_velocities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lons</span><span class="p">,</span>
        <span class="n">lats</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">delta_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">velocity_delta_time_type</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityDeltaTimeType</span><span class="o">.</span><span class="n">t_plus_delta_t_to_t</span><span class="p">,</span>
        <span class="n">velocity_units</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">kms_per_my</span><span class="p">,</span>
        <span class="n">earth_radius_in_kms</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span><span class="p">,</span>
        <span class="n">include_networks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_east_north_arrays</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the north and east components of the velocity vector (in kms/myr) for each specified point</span>
<span class="sd">        (from &quot;lons&quot; and &quot;lats&quot;) at a particular geological &quot;time&quot;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lons : array</span>
<span class="sd">            A 1D array of point data&#39;s longitudes.</span>

<span class="sd">        lats : array</span>
<span class="sd">            A 1D array of point data&#39;s latitudes.</span>

<span class="sd">        time : float</span>
<span class="sd">            The specific geological time (Ma) at which to calculate plate velocities.</span>

<span class="sd">        delta_time : float, default=1.0</span>
<span class="sd">            The time interval used for velocity calculations. 1.0Ma by default.</span>

<span class="sd">        velocity_delta_time_type : pygplates.VelocityDeltaTimeType, default=pygplates.VelocityDeltaTimeType.t_plus_delta_t_to_t</span>
<span class="sd">            How the two velocity times are calculated relative to &quot;time&quot; (defaults to &quot;[time + velocity_delta_time, time]&quot;).</span>

<span class="sd">        velocity_units : pygplates.VelocityUnits, default=pygplates.VelocityUnits.kms_per_my</span>
<span class="sd">            Whether to return velocities in centimetres per year or kilometres per million years (defaults to kilometres per million years).</span>

<span class="sd">        earth_radius_in_kms : float, default=pygplates.Earth.mean_radius_in_kms</span>
<span class="sd">            Radius of the Earth in kilometres.</span>
<span class="sd">            This is only used to calculate velocities (strain rates always use pygplates.Earth.equatorial_radius_in_kms).</span>

<span class="sd">        include_networks : bool, default=True</span>
<span class="sd">            Whether to include deforming networks when calculating velocities.</span>
<span class="sd">            By default they are included (and also given precedence since they typically overlay a rigid plate).</span>

<span class="sd">        include_topological_slab_boundaries : bool, default=False</span>
<span class="sd">            Whether to include features of type gpml:TopologicalSlabBoundary when calculating velocities.</span>
<span class="sd">            By default they are not included (they tend to overlay a rigid plate which should instead be used to calculate plate velocity).</span>

<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Anchor plate ID. Defaults to the current anchor plate ID (:py:attr:`anchor_plate_id` attribute).</span>

<span class="sd">        return_east_north_arrays : bool, default=False</span>
<span class="sd">            Return the velocities as arrays separately containing the east and north components of the velocities.</span>
<span class="sd">            Note that setting this to True matches the output of :py:meth:`gplately.Points.plate_velocity`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        north_east_velocities : 2D ndarray</span>
<span class="sd">            Only provided if &quot;return_east_north_arrays&quot; is False.</span>
<span class="sd">            Each array element contains the (north, east) velocity components of a single point.</span>
<span class="sd">        east_velocities, north_velocities : 1D ndarray</span>
<span class="sd">            Only provided if &quot;return_east_north_arrays&quot; is True.</span>
<span class="sd">            The east and north components of velocities as separate arrays.</span>
<span class="sd">            These are also ordered (east, north) instead of (north, east).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If topology features have not been set in this :py:class:`gplately.PlateReconstruction` object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The velocities are in &quot;kilometres per million years&quot; by default (not &quot;centimetres per year&quot;, the default in :py:meth:`gplately.Points.plate_velocity`).</span>
<span class="sd">        This difference is maintained for backward compatibility.</span>

<span class="sd">        For each velocity, the &quot;north&quot; component is first followed by the &quot;east&quot; component.</span>
<span class="sd">        This is different to :py:meth:`gplately.Points.plate_velocity` where the &quot;east&quot; component is first.</span>
<span class="sd">        This difference is maintained for backward compatibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add points to a multipoint geometry</span>

        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">)]</span>

        <span class="n">topological_snapshot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_snapshot</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
            <span class="n">include_topological_slab_boundaries</span><span class="o">=</span><span class="n">include_topological_slab_boundaries</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If requested, exclude resolved topological *networks*.</span>
        <span class="n">resolve_topology_types</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ResolveTopologyType</span><span class="o">.</span><span class="n">boundary</span>
        <span class="k">if</span> <span class="n">include_networks</span><span class="p">:</span>
            <span class="n">resolve_topology_types</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">resolve_topology_types</span> <span class="o">|</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ResolveTopologyType</span><span class="o">.</span><span class="n">network</span>
            <span class="p">)</span>

        <span class="n">point_velocities</span> <span class="o">=</span> <span class="n">topological_snapshot</span><span class="o">.</span><span class="n">get_point_velocities</span><span class="p">(</span>
            <span class="n">points</span><span class="p">,</span>
            <span class="n">resolve_topology_types</span><span class="o">=</span><span class="n">resolve_topology_types</span><span class="p">,</span>
            <span class="n">velocity_delta_time</span><span class="o">=</span><span class="n">delta_time</span><span class="p">,</span>
            <span class="n">velocity_delta_time_type</span><span class="o">=</span><span class="n">velocity_delta_time_type</span><span class="p">,</span>
            <span class="n">velocity_units</span><span class="o">=</span><span class="n">velocity_units</span><span class="p">,</span>
            <span class="n">earth_radius_in_kms</span><span class="o">=</span><span class="n">earth_radius_in_kms</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Replace any missing velocities with zero velocity.</span>
        <span class="c1">#</span>
        <span class="c1"># If a point does not intersect a topological plate (or network) then its velocity is None.</span>
        <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">point_velocities</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">point_velocities</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Vector3D</span><span class="o">.</span><span class="n">zero</span>

        <span class="c1"># Convert global 3D velocity vectors to local (North, East, Down) vectors (one per point).</span>
        <span class="n">point_velocities_north_east_down</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">LocalCartesian</span><span class="o">.</span><span class="n">convert_from_geocentric_to_north_east_down</span><span class="p">(</span>
                <span class="n">points</span><span class="p">,</span> <span class="n">point_velocities</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_east_north_arrays</span><span class="p">:</span>
            <span class="c1"># Extract the East and North velocity components into separate arrays.</span>
            <span class="n">east_velocities</span> <span class="o">=</span> <span class="p">[</span><span class="n">ned</span><span class="o">.</span><span class="n">get_y</span><span class="p">()</span> <span class="k">for</span> <span class="n">ned</span> <span class="ow">in</span> <span class="n">point_velocities_north_east_down</span><span class="p">]</span>
            <span class="n">north_velocities</span> <span class="o">=</span> <span class="p">[</span><span class="n">ned</span><span class="o">.</span><span class="n">get_x</span><span class="p">()</span> <span class="k">for</span> <span class="n">ned</span> <span class="ow">in</span> <span class="n">point_velocities_north_east_down</span><span class="p">]</span>
            <span class="c1"># Note: This is the opposite order (ie, (east,north) instead of (north,east)).</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">east_velocities</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">north_velocities</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Extract the North and East velocity components into a single array.</span>
            <span class="n">north_east_velocities</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">ned</span><span class="o">.</span><span class="n">get_x</span><span class="p">(),</span> <span class="n">ned</span><span class="o">.</span><span class="n">get_y</span><span class="p">())</span> <span class="k">for</span> <span class="n">ned</span> <span class="ow">in</span> <span class="n">point_velocities_north_east_down</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">north_east_velocities</span><span class="p">)</span></div>


<div class="viewcode-block" id="PlateReconstruction.create_motion_path">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.create_motion_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_motion_path</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lons</span><span class="p">,</span>
        <span class="n">lats</span><span class="p">,</span>
        <span class="n">time_array</span><span class="p">,</span>
        <span class="n">plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_rate_of_motion</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a path of points to mark the trajectory of a plate&#39;s motion</span>
<span class="sd">        through geological time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lons : arr</span>
<span class="sd">            An array containing the longitudes of seed points on a plate in motion.</span>
<span class="sd">        lats : arr</span>
<span class="sd">            An array containing the latitudes of seed points on a plate in motion.</span>
<span class="sd">        time_array : arr</span>
<span class="sd">            An array of reconstruction times at which to determine the trajectory</span>
<span class="sd">            of a point on a plate. For example:</span>

<span class="sd">            .. code-block:: python</span>
<span class="sd">                :linenos:</span>

<span class="sd">                import numpy as np</span>
<span class="sd">                min_time = 30</span>
<span class="sd">                max_time = 100</span>
<span class="sd">                time_step = 2.5</span>
<span class="sd">                time_array = np.arange(min_time, max_time + time_step, time_step)</span>

<span class="sd">        plate_id : int, optional</span>
<span class="sd">            The ID of the moving plate. If this is not passed, the plate ID of the</span>
<span class="sd">            seed points are ascertained using pygplates&#39; `PlatePartitioner`.</span>
<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            The ID of the anchor plate. Defaults to the default anchor plate</span>
<span class="sd">            (specified in `__init__` or set with `anchor_plate_id` attribute).</span>
<span class="sd">        return_rate_of_motion : bool, default=False</span>
<span class="sd">            Choose whether to return the rate of plate motion through time for each</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rlons : ndarray</span>
<span class="sd">            An n-dimensional array with columns containing the longitudes of</span>
<span class="sd">            the seed points at each timestep in `time_array`. There are n</span>
<span class="sd">            columns for n seed points.</span>
<span class="sd">        rlats : ndarray</span>
<span class="sd">            An n-dimensional array with columns containing the latitudes of</span>
<span class="sd">            the seed points at each timestep in `time_array`. There are n</span>
<span class="sd">            columns for n seed points.</span>
<span class="sd">        StepTimes</span>
<span class="sd">        StepRates</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If *plate_id* is `None` and topology features have not been set in this `PlateReconstruction`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To access the latitudes and longitudes of each seed point&#39;s motion path:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            for i in np.arange(0,len(seed_points)):</span>
<span class="sd">                current_lons = lon[:,i]</span>
<span class="sd">                current_lats = lat[:,i]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="n">time_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span>

        <span class="c1"># ndarrays to fill with reconstructed points and</span>
        <span class="c1"># rates of motion (if requested)</span>
        <span class="n">rlons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>
        <span class="n">rlats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query_plate_id</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">plate_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">query_plate_id</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">plate_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">plate_id</span>

        <span class="n">seed_points</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_rate_of_motion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">StepTimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>
            <span class="n">StepRates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">StepTimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">StepRates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lat_lon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seed_points</span><span class="p">):</span>
            <span class="n">seed_points_at_digitisation_time</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">LatLonPoint</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">lat_lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">lat_lon</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="p">)</span>
            <span class="c1"># Allocate the present-day plate ID to the PointOnSphere if</span>
            <span class="c1"># it was not given.</span>
            <span class="k">if</span> <span class="n">query_plate_id</span><span class="p">:</span>
                <span class="n">plate_id</span> <span class="o">=</span> <span class="n">_tools</span><span class="o">.</span><span class="n">plate_partitioner_for_point</span><span class="p">(</span>
                    <span class="n">lat_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_topology_features</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plate_id</span> <span class="o">=</span> <span class="n">plate_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Create the motion path feature. enforce float and int for C++ signature.</span>
            <span class="n">motion_path_feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="o">.</span><span class="n">create_motion_path</span><span class="p">(</span>
                <span class="n">seed_points_at_digitisation_time</span><span class="p">,</span>
                <span class="n">time_array</span><span class="p">,</span>
                <span class="n">valid_time</span><span class="o">=</span><span class="p">(</span><span class="n">time_array</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">time_array</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
                <span class="n">relative_plate</span><span class="o">=</span><span class="p">(</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
                    <span class="n">anchor_plate_id</span>
                    <span class="k">if</span> <span class="n">anchor_plate_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span>
                <span class="p">),</span>
                <span class="n">reconstruction_plate_id</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">plate_id</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="n">reconstructed_motion_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span>
                <span class="n">motion_path_feature</span><span class="p">,</span>
                <span class="n">to_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">reconstruct_type</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ReconstructType</span><span class="o">.</span><span class="n">motion_path</span><span class="p">,</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses &#39;self.anchor_plate_id&#39; (default anchor plate of &#39;self.rotation_model&#39;)</span>
            <span class="p">)</span>
            <span class="c1"># Turn motion paths in to lat-lon coordinates</span>
            <span class="n">trail</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">reconstructed_motion_path</span> <span class="ow">in</span> <span class="n">reconstructed_motion_paths</span><span class="p">:</span>
                <span class="c1"># not sure about this. always set the &quot;trail&quot; to the last one in reconstructed_motion_paths?</span>
                <span class="c1"># or there is only one path in reconstructed_motion_paths? -- Michael Chin</span>
                <span class="n">trail</span> <span class="o">=</span> <span class="n">reconstructed_motion_path</span><span class="o">.</span><span class="n">get_motion_path</span><span class="p">()</span><span class="o">.</span><span class="n">to_lat_lon_array</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">trail</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">trail</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">trail</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="n">rlons</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span>
            <span class="n">rlats</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span>

            <span class="c1"># Obtain step-plot coordinates for rate of motion</span>
            <span class="k">if</span> <span class="n">return_rate_of_motion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Get timestep</span>
                <span class="n">TimeStep</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">TimeStep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

                <span class="c1"># Iterate over each segment in the reconstructed motion path, get the distance travelled by the moving</span>
                <span class="c1"># plate relative to the fixed plate in each time step</span>
                <span class="n">Dist</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">reconstructed_motion_path</span> <span class="ow">in</span> <span class="n">reconstructed_motion_paths</span><span class="p">:</span>
                    <span class="k">for</span> <span class="p">(</span>
                        <span class="n">segment</span>
                    <span class="p">)</span> <span class="ow">in</span> <span class="n">reconstructed_motion_path</span><span class="o">.</span><span class="n">get_motion_path</span><span class="p">()</span><span class="o">.</span><span class="n">get_segments</span><span class="p">():</span>
                        <span class="n">Dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">segment</span><span class="o">.</span><span class="n">get_arc_length</span><span class="p">()</span>
                            <span class="o">*</span> <span class="n">_tools</span><span class="o">.</span><span class="n">geocentric_radius</span><span class="p">(</span>
                                <span class="n">segment</span><span class="o">.</span><span class="n">get_start_point</span><span class="p">()</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="o">/</span> <span class="mf">1e3</span>
                        <span class="p">)</span>

                <span class="c1"># Note that the motion path coordinates come out starting with the oldest time and working forwards</span>
                <span class="c1"># So, to match our &#39;times&#39; array, we flip the order</span>
                <span class="n">Dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">Dist</span><span class="p">)</span>

                <span class="c1"># Get rate of motion as distance per Myr</span>
                <span class="n">Rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Dist</span><span class="p">)</span> <span class="o">/</span> <span class="n">TimeStep</span>

                <span class="c1"># Manipulate arrays to get a step plot</span>
                <span class="n">StepRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">StepRate</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rate</span>
                <span class="n">StepRate</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rate</span>

                <span class="n">StepTime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">StepTime</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">StepTime</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                <span class="c1"># Append the nth point&#39;s step time and step rate coordinates to the ndarray</span>
                <span class="n">StepTimes</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">StepTime</span>
                <span class="n">StepRates</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">StepRate</span> <span class="o">*</span> <span class="mf">0.1</span>  <span class="c1"># cm/yr</span>

                <span class="c1"># Obseleted by Lauren&#39;s changes above (though it is more efficient)</span>
                <span class="c1"># multiply arc length of the motion path segment by a latitude-dependent Earth radius</span>
                <span class="c1"># use latitude of the segment start point</span>
                <span class="c1"># distance.append( segment.get_arc_length() * _tools.geocentric_radius(segment.get_start_point().to_lat_lon()[0]) / 1e3)</span>
                <span class="c1"># rate = np.asarray(distance)/np.diff(time_array)</span>
                <span class="c1"># rates[:,i] = np.flipud(rate)</span>
                <span class="c1"># rates *= 0.1 # cm/yr</span>

        <span class="k">if</span> <span class="n">return_rate_of_motion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">rlons</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">rlats</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">StepTimes</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">StepRates</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">rlons</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">rlats</span><span class="p">)</span></div>


<div class="viewcode-block" id="PlateReconstruction.create_flowline">
<a class="viewcode-back" href="../../generated/gplately.PlateReconstruction.html#gplately.PlateReconstruction.create_flowline">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_flowline</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lons</span><span class="p">,</span>
        <span class="n">lats</span><span class="p">,</span>
        <span class="n">time_array</span><span class="p">,</span>
        <span class="n">left_plate_ID</span><span class="p">,</span>
        <span class="n">right_plate_ID</span><span class="p">,</span>
        <span class="n">return_rate_of_motion</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a path of points to track plate motion away from</span>
<span class="sd">        spreading ridges over time using half-stage rotations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lons : arr</span>
<span class="sd">            An array of longitudes of points along spreading ridges.</span>
<span class="sd">        lats : arr</span>
<span class="sd">            An array of latitudes of points along spreading ridges.</span>
<span class="sd">        time_array : arr</span>
<span class="sd">            A list of times to obtain seed point locations at.</span>
<span class="sd">        left_plate_ID : int</span>
<span class="sd">            The plate ID of the polygon to the left of the spreading</span>
<span class="sd">            ridge.</span>
<span class="sd">        right_plate_ID : int</span>
<span class="sd">            The plate ID of the polygon to the right of the spreading</span>
<span class="sd">            ridge.</span>
<span class="sd">        return_rate_of_motion : bool, default False</span>
<span class="sd">            Choose whether to return a step time and step rate array</span>
<span class="sd">            for a step plot of motion.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        left_lon : ndarray</span>
<span class="sd">            The longitudes of the left flowline for n seed points.</span>
<span class="sd">            There are n columns for n seed points, and m rows</span>
<span class="sd">            for m time steps in time_array.</span>
<span class="sd">        left_lat : ndarray</span>
<span class="sd">            The latitudes of the left flowline of n seed points.</span>
<span class="sd">            There are n columns for n seed points, and m rows</span>
<span class="sd">            for m time steps in time_array.</span>
<span class="sd">        right_lon : ndarray</span>
<span class="sd">            The longitudes of the right flowline of n seed points.</span>
<span class="sd">            There are n columns for n seed points, and m rows</span>
<span class="sd">            for m time steps in time_array.</span>
<span class="sd">        right_lat : ndarray</span>
<span class="sd">            The latitudes of the right flowline of n seed points.</span>
<span class="sd">            There are n columns for n seed points, and m rows</span>
<span class="sd">            for m time steps in time_array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To access the i\\ :sup:`th` seed point&#39;s left and right latitudes and</span>
<span class="sd">        longitudes:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            for i in np.arange(0,len(seed_points)):</span>
<span class="sd">                left_flowline_longitudes = left_lon[:,i]</span>
<span class="sd">                left_flowline_latitudes = left_lat[:,i]</span>
<span class="sd">                right_flowline_longitudes = right_lon[:,i]</span>
<span class="sd">                right_flowline_latitudes = right_lat[:,i]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="n">time_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span>

        <span class="n">seed_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">))</span>
        <span class="n">multi_point</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span><span class="n">seed_points</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">time_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">time_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_array</span><span class="p">])</span>

        <span class="c1"># Create the flowline feature</span>
        <span class="n">flowline_feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="o">.</span><span class="n">create_flowline</span><span class="p">(</span>
            <span class="n">multi_point</span><span class="p">,</span>
            <span class="n">time_array</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="n">valid_time</span><span class="o">=</span><span class="p">(</span><span class="n">time_array</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">time_array</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
            <span class="n">left_plate</span><span class="o">=</span><span class="n">left_plate_ID</span><span class="p">,</span>
            <span class="n">right_plate</span><span class="o">=</span><span class="n">right_plate_ID</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># reconstruct the flowline in present-day coordinates</span>
        <span class="n">reconstructed_flowlines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span>
            <span class="n">flowline_feature</span><span class="p">,</span>
            <span class="n">to_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">reconstruct_type</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ReconstructType</span><span class="o">.</span><span class="n">flowline</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Wrap things to the dateline, to avoid plotting artefacts.</span>
        <span class="n">date_line_wrapper</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">DateLineWrapper</span><span class="p">()</span>

        <span class="c1"># Create lat-lon ndarrays to store the left and right lats and lons of flowlines</span>
        <span class="n">left_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>
        <span class="n">left_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>
        <span class="n">right_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>
        <span class="n">right_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>
        <span class="n">StepTimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>
        <span class="n">StepRates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>

        <span class="c1"># Iterate over the reconstructed flowlines. Each seed point results in a &#39;left&#39; and &#39;right&#39; flowline</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reconstructed_flowline</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reconstructed_flowlines</span><span class="p">):</span>
            <span class="c1"># Get the points for the left flowline only</span>
            <span class="n">left_latlon</span> <span class="o">=</span> <span class="n">reconstructed_flowline</span><span class="o">.</span><span class="n">get_left_flowline</span><span class="p">()</span><span class="o">.</span><span class="n">to_lat_lon_array</span><span class="p">()</span>
            <span class="n">left_lon</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_latlon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">left_lat</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_latlon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Repeat for the right flowline points</span>
            <span class="n">right_latlon</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">reconstructed_flowline</span><span class="o">.</span><span class="n">get_right_flowline</span><span class="p">()</span><span class="o">.</span><span class="n">to_lat_lon_array</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">right_lon</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">right_latlon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">right_lat</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">right_latlon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_rate_of_motion</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reconstructed_motion_path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reconstructed_flowlines</span><span class="p">):</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="p">(</span>
                    <span class="n">segment</span>
                <span class="p">)</span> <span class="ow">in</span> <span class="n">reconstructed_motion_path</span><span class="o">.</span><span class="n">get_left_flowline</span><span class="p">()</span><span class="o">.</span><span class="n">get_segments</span><span class="p">():</span>
                    <span class="n">distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">segment</span><span class="o">.</span><span class="n">get_arc_length</span><span class="p">()</span>
                        <span class="o">*</span> <span class="n">_tools</span><span class="o">.</span><span class="n">geocentric_radius</span><span class="p">(</span>
                            <span class="n">segment</span><span class="o">.</span><span class="n">get_start_point</span><span class="p">()</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="o">/</span> <span class="mf">1e3</span>
                    <span class="p">)</span>

                <span class="c1"># Get rate of motion as distance per Myr</span>
                <span class="c1"># Need to multiply rate by 2, since flowlines give us half-spreading rate</span>
                <span class="n">time_step</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Rate</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="o">/</span> <span class="n">time_step</span>
                <span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># since we created the flowline at X increment</span>

                <span class="c1"># Manipulate arrays to get a step plot</span>
                <span class="n">StepRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">StepRate</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rate</span>
                <span class="n">StepRate</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rate</span>

                <span class="n">StepTime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">StepTime</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">StepTime</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                <span class="c1"># Append the nth point&#39;s step time and step rate coordinates to the ndarray</span>
                <span class="n">StepTimes</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">StepTime</span>
                <span class="n">StepRates</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">StepRate</span> <span class="o">*</span> <span class="mf">0.1</span>  <span class="c1"># cm/yr</span>

            <span class="k">return</span> <span class="p">(</span>
                <span class="n">left_lon</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span>
                <span class="n">left_lat</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span>
                <span class="n">right_lon</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span>
                <span class="n">right_lat</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span>
                <span class="n">StepTimes</span><span class="p">,</span>
                <span class="n">StepRates</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">left_lon</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span>
                <span class="n">left_lat</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span>
                <span class="n">right_lon</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span>
                <span class="n">right_lat</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span>
            <span class="p">)</span></div>
</div>



<span class="c1"># FROM RECONSTRUCT_BY_TOPOLOGIES.PY</span>
<span class="k">class</span><span class="w"> </span><span class="nc">_DefaultCollision</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Default collision detection function class (the function is the &#39;__call__&#39; method).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">DEFAULT_GLOBAL_COLLISION_PARAMETERS</span> <span class="o">=</span> <span class="p">(</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Default collision parameters for all feature types.</span>

<span class="sd">    This is a 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my):</span>
<span class="sd">    Here we default to the same constants used internally in GPlates 2.0 (ie, 7.0 and 10.0).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">global_collision_parameters</span><span class="o">=</span><span class="n">DEFAULT_GLOBAL_COLLISION_PARAMETERS</span><span class="p">,</span>
        <span class="n">feature_specific_collision_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        global_collision_parameters: The collision parameters to use for any feature type not specified in &#39;feature_specific_collision_parameters&#39;.</span>
<span class="sd">                                     Should be a 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my).</span>
<span class="sd">                                     The first threshold parameter means:</span>
<span class="sd">                                        A point that transitions from one plate to another can disappear if the change in velocity exceeds this threshold.</span>
<span class="sd">                                     The second threshold parameter means:</span>
<span class="sd">                                        Only those transitioning points exceeding the threshold velocity delta and that are close enough to a plate boundary can disappear.</span>
<span class="sd">                                        The distance is proportional to the relative velocity (change in velocity), plus a constant offset based on the threshold distance to boundary</span>
<span class="sd">                                        to account for plate boundaries that change shape significantly from one time step to the next</span>
<span class="sd">                                        (note that some boundaries are meant to do this and others are a result of digitisation).</span>
<span class="sd">                                        The actual distance threshold used is (threshold_distance_to_boundary + relative_velocity) * time_interval</span>
<span class="sd">                                     Defaults to parameters used in GPlates 2.0, if not specified.</span>

<span class="sd">        feature_specific_collision_parameters: Optional sequence of collision parameters specific to feature types.</span>
<span class="sd">                                               If specified then should be a sequence of 2-tuples, with each 2-tuple specifying (feature_type, collision_parameters).</span>
<span class="sd">                                               And where each &#39;collision_parameters&#39; is a 2-tuple of (threshold velocity delta in kms/my, threshold distance to boundary per My in kms/my).</span>
<span class="sd">                                                   See &#39;global_collision_parameters&#39; for details on these thresholds.</span>
<span class="sd">                                               Any feature type not specified here defaults to using &#39;global_collision_parameters&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Convert list of (feature_type, collision_parameters) tuples to a dictionary.</span>
        <span class="k">if</span> <span class="n">feature_specific_collision_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feature_specific_collision_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">feature_specific_collision_parameters</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feature_specific_collision_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># Fallback for any feature type not specified in the optional feature-specific list.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_collision_parameters</span> <span class="o">=</span> <span class="n">global_collision_parameters</span>

        <span class="c1"># Used to improve performance by caching velocity stage rotations in a dict (for a specific reconstruction time).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_stage_rotation_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_stage_rotation_time</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rotation_model</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">reconstruction_time_interval</span><span class="p">,</span>
        <span class="n">prev_point</span><span class="p">,</span>
        <span class="n">curr_point</span><span class="p">,</span>
        <span class="n">prev_topology_plate_id</span><span class="p">,</span>
        <span class="n">prev_resolved_plate_boundary</span><span class="p">,</span>
        <span class="n">curr_topology_plate_id</span><span class="p">,</span>
        <span class="n">curr_resolved_plate_boundary</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if a collision was detected.</span>

<span class="sd">        If transitioning from a rigid plate to another rigid plate with a different plate ID then</span>
<span class="sd">        calculate the difference in velocities and continue testing as follows</span>
<span class="sd">        (otherwise, if there&#39;s no transition, then the point is still active)...</span>

<span class="sd">        If the velocity difference is below a threshold then we assume the previous plate was split,</span>
<span class="sd">        or two plates joined. In this case the point has not subducted (forward in time) or</span>
<span class="sd">        been consumed by a mid-ocean (backward in time) and hence is still active.</span>

<span class="sd">        If the velocity difference is large enough then we see if the distance of the *previous* position</span>
<span class="sd">        to the polygon boundary (of rigid plate containing it) exceeds a threshold.</span>
<span class="sd">        If the distance exceeds the threshold then the point is far enough away from the boundary that it</span>
<span class="sd">        cannot be subducted or consumed by it and hence the point is still active.</span>
<span class="sd">        However if the point is close enough then we assume the point was subducted/consumed</span>
<span class="sd">        (remember that the point switched plate IDs).</span>
<span class="sd">        Also note that the threshold distance increases according to the velocity difference to account for fast</span>
<span class="sd">        moving points (that would otherwise tunnel through the boundary and accrete onto the other plate).</span>
<span class="sd">        The reason for testing the distance from the *previous* point, and not from the *current* point, is:</span>

<span class="sd">          (i)  A topological boundary may *appear* near the current point (such as a plate split at the current time)</span>
<span class="sd">               and we don&#39;t want that split to consume the current point regardless of the velocity difference.</span>
<span class="sd">               It won&#39;t get consumed because the *previous* point was not near a boundary (because before split happened).</span>
<span class="sd">               If the velocity difference is large enough then it might cause the current point to transition to the</span>
<span class="sd">               adjacent split plate in the *next* time step (and that&#39;s when it should get consumed, not in the current time step).</span>
<span class="sd">               An example of this is a mid-ocean ridge suddenly appearing (going forward in time).</span>

<span class="sd">          (ii) A topological boundary may *disappear* near the current point (such as a plate merge at the current time)</span>
<span class="sd">               and we want that merge to consume the current point if the velocity difference is large enough.</span>
<span class="sd">               In this case the *previous* point is near a boundary (because before plate merged) and hence can be</span>
<span class="sd">               consumed (provided velocity difference is large enough). And since the boundary existed in the previous</span>
<span class="sd">               time step, it will affect position of the current point (and whether it gets consumed or not).</span>
<span class="sd">               An example of this is a mid-ocean ridge suddenly disappearing (going backward in time).</span>

<span class="sd">        ...note that items (i) and (ii) above apply both going forward and backward in time.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># See if a collision occurred.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">curr_topology_plate_id</span> <span class="o">!=</span> <span class="n">prev_topology_plate_id</span>
            <span class="ow">and</span> <span class="n">prev_topology_plate_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">curr_topology_plate_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="c1">#</span>
            <span class="c1"># Speed up by caching velocity stage rotations in a dict.</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="n">time</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_stage_rotation_time</span><span class="p">:</span>
                <span class="c1"># We&#39;ve just switched to a new time so clear the cache.</span>
                <span class="c1">#</span>
                <span class="c1"># We only cache stage rotations for a specific time.</span>
                <span class="c1"># We only really need to cache different plate IDs at the same &#39;time&#39;, so this avoids caching for all times</span>
                <span class="c1"># (which would also require including &#39;time&#39; in the key) and using memory unnecessarily.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity_stage_rotation_dict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity_stage_rotation_time</span> <span class="o">=</span> <span class="n">time</span>
            <span class="n">prev_location_velocity_stage_rotation</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity_stage_rotation_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">prev_topology_plate_id</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prev_location_velocity_stage_rotation</span><span class="p">:</span>
                <span class="n">prev_location_velocity_stage_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
                    <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prev_topology_plate_id</span><span class="p">,</span> <span class="n">time</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity_stage_rotation_dict</span><span class="p">[</span><span class="n">prev_topology_plate_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">prev_location_velocity_stage_rotation</span>
                <span class="p">)</span>
            <span class="n">curr_location_velocity_stage_rotation</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity_stage_rotation_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">curr_topology_plate_id</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_location_velocity_stage_rotation</span><span class="p">:</span>
                <span class="n">curr_location_velocity_stage_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
                    <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">curr_topology_plate_id</span><span class="p">,</span> <span class="n">time</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity_stage_rotation_dict</span><span class="p">[</span><span class="n">curr_topology_plate_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">curr_location_velocity_stage_rotation</span>
                <span class="p">)</span>

            <span class="c1"># Note that even though the current point is not inside the previous boundary (because different plate ID), we can still</span>
            <span class="c1"># calculate a velocity using its plate ID (because we really should use the same point in our velocity comparison).</span>
            <span class="n">prev_location_velocity</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">calculate_velocities</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="p">(</span><span class="n">curr_point</span><span class="p">,),</span>
                <span class="n">prev_location_velocity_stage_rotation</span><span class="p">,</span>
                <span class="mi">1</span><span class="p">,</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">kms_per_my</span><span class="p">,</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">curr_location_velocity</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">calculate_velocities</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="p">(</span><span class="n">curr_point</span><span class="p">,),</span>
                <span class="n">curr_location_velocity_stage_rotation</span><span class="p">,</span>
                <span class="mi">1</span><span class="p">,</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">kms_per_my</span><span class="p">,</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">delta_velocity</span> <span class="o">=</span> <span class="n">curr_location_velocity</span> <span class="o">-</span> <span class="n">prev_location_velocity</span>
            <span class="n">delta_velocity_magnitude</span> <span class="o">=</span> <span class="n">delta_velocity</span><span class="o">.</span><span class="n">get_magnitude</span><span class="p">()</span>

            <span class="c1"># If we have feature-specific collision parameters then iterate over the boundary sub-segments of the *previous* topological boundary</span>
            <span class="c1"># and test proximity to each sub-segment individually (with sub-segment feature type specific collision parameters).</span>
            <span class="c1"># Otherwise just test proximity to the entire boundary polygon using the global collision parameters.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_specific_collision_parameters</span><span class="p">:</span>
                <span class="k">for</span> <span class="p">(</span>
                    <span class="n">prev_boundary_sub_segment</span>
                <span class="p">)</span> <span class="ow">in</span> <span class="n">prev_resolved_plate_boundary</span><span class="o">.</span><span class="n">get_boundary_sub_segments</span><span class="p">():</span>
                    <span class="c1"># Use feature-specific collision parameters if found (falling back to global collision parameters).</span>
                    <span class="p">(</span>
                        <span class="n">threshold_velocity_delta</span><span class="p">,</span>
                        <span class="n">threshold_distance_to_boundary_per_my</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_specific_collision_parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">prev_boundary_sub_segment</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_feature_type</span><span class="p">(),</span>
                        <span class="c1"># Default to global collision parameters if no collision parameters specified for sub-segment&#39;s feature type...</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">global_collision_parameters</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="c1"># Since each feature type could use different collision parameters we must use the current boundary sub-segment instead of the boundary polygon.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_collision_using_collision_parameters</span><span class="p">(</span>
                        <span class="n">reconstruction_time_interval</span><span class="p">,</span>
                        <span class="n">delta_velocity_magnitude</span><span class="p">,</span>
                        <span class="n">prev_point</span><span class="p">,</span>
                        <span class="n">prev_boundary_sub_segment</span><span class="o">.</span><span class="n">get_resolved_geometry</span><span class="p">(),</span>
                        <span class="n">threshold_velocity_delta</span><span class="p">,</span>
                        <span class="n">threshold_distance_to_boundary_per_my</span><span class="p">,</span>
                    <span class="p">):</span>
                        <span class="c1"># Detected a collision.</span>
                        <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No feature-specific collision parameters so use global fallback.</span>
                <span class="p">(</span>
                    <span class="n">threshold_velocity_delta</span><span class="p">,</span>
                    <span class="n">threshold_distance_to_boundary_per_my</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_collision_parameters</span>

                <span class="c1"># Since all feature types use the same collision parameters we can use the boundary polygon instead of iterating over its sub-segments.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_collision_using_collision_parameters</span><span class="p">(</span>
                    <span class="n">reconstruction_time_interval</span><span class="p">,</span>
                    <span class="n">delta_velocity_magnitude</span><span class="p">,</span>
                    <span class="n">prev_point</span><span class="p">,</span>
                    <span class="n">prev_resolved_plate_boundary</span><span class="o">.</span><span class="n">get_resolved_boundary</span><span class="p">(),</span>
                    <span class="n">threshold_velocity_delta</span><span class="p">,</span>
                    <span class="n">threshold_distance_to_boundary_per_my</span><span class="p">,</span>
                <span class="p">):</span>
                    <span class="c1"># Detected a collision.</span>
                    <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_detect_collision_using_collision_parameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reconstruction_time_interval</span><span class="p">,</span>
        <span class="n">delta_velocity_magnitude</span><span class="p">,</span>
        <span class="n">prev_point</span><span class="p">,</span>
        <span class="n">prev_boundary_geometry</span><span class="p">,</span>
        <span class="n">threshold_velocity_delta</span><span class="p">,</span>
        <span class="n">threshold_distance_to_boundary_per_my</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">delta_velocity_magnitude</span> <span class="o">&gt;</span> <span class="n">threshold_velocity_delta</span><span class="p">:</span>
            <span class="c1"># Add the minimum distance threshold to the delta velocity threshold.</span>
            <span class="c1"># The delta velocity threshold only allows those points that are close enough to the boundary to reach</span>
            <span class="c1"># it given their current relative velocity.</span>
            <span class="c1"># The minimum distance threshold accounts for sudden changes in the shape of a plate boundary</span>
            <span class="c1"># which are no supposed to represent a new or shifted boundary but are just a result of the topology</span>
            <span class="c1"># builder/user digitising a new boundary line that differs noticeably from that of the previous time period.</span>
            <span class="n">distance_threshold_radians</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">threshold_distance_to_boundary_per_my</span> <span class="o">+</span> <span class="n">delta_velocity_magnitude</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">reconstruction_time_interval</span>
                <span class="o">/</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">equatorial_radius_in_kms</span>
            <span class="p">)</span>
            <span class="n">distance_threshold_radians</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">distance_threshold_radians</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">distance_threshold_radians</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">distance_threshold_radians</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

            <span class="n">distance</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span>
                <span class="n">prev_point</span><span class="p">,</span>
                <span class="n">prev_boundary_geometry</span><span class="p">,</span>
                <span class="n">distance_threshold_radians</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">distance_threshold_radians</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Detected a collision.</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>


<span class="n">_DEFAULT_COLLISION</span> <span class="o">=</span> <span class="n">_DefaultCollision</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_ContinentCollision</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Continental collision detection function class (the function is the &#39;__call__&#39; method).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">grd_output_dir</span><span class="p">,</span>
        <span class="n">chain_collision_detection</span><span class="o">=</span><span class="n">_DEFAULT_COLLISION</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        grd_output_dir: The directory containing the continental grids.</span>

<span class="sd">        chain_collision_detection: Another collision detection class/function to reference if we find no collision.</span>
<span class="sd">                                   If None then no collision detection is chained. Defaults to the default collision detection.</span>

<span class="sd">        verbose: Print progress messages</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grd_output_dir</span> <span class="o">=</span> <span class="n">grd_output_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain_collision_detection</span> <span class="o">=</span> <span class="n">chain_collision_detection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># Load a new grid each time the reconstruction time changes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_time</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">grid_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_time</span>

    <span class="nd">@grid_time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">grid_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.grids</span><span class="w"> </span><span class="kn">import</span> <span class="n">read_netcdf_grid</span>

        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid_time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grd_output_dir</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Points masked against grid: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="n">gridZ</span><span class="p">,</span> <span class="n">gridX</span><span class="p">,</span> <span class="n">gridY</span> <span class="o">=</span> <span class="n">read_netcdf_grid</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">return_grids</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gridZ</span> <span class="o">=</span> <span class="n">gridZ</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ni</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nj</span> <span class="o">=</span> <span class="n">gridZ</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">gridX</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">gridX</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">gridY</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">gridY</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid_time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rotation_model</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">reconstruction_time_interval</span><span class="p">,</span>
        <span class="n">prev_point</span><span class="p">,</span>
        <span class="n">curr_point</span><span class="p">,</span>
        <span class="n">prev_topology_plate_id</span><span class="p">,</span>
        <span class="n">prev_resolved_plate_boundary</span><span class="p">,</span>
        <span class="n">curr_topology_plate_id</span><span class="p">,</span>
        <span class="n">curr_resolved_plate_boundary</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if a collision with a continent was detected, or returns result of</span>
<span class="sd">        chained collision detection if &#39;self.chain_collision_detection&#39; is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load the grid for the current time if encountering a new time.</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_time</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_time</span> <span class="o">=</span> <span class="n">time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_deletion_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Sample mask grid, which is one over continents and zero over oceans.</span>
        <span class="n">point_lat</span><span class="p">,</span> <span class="n">point_lon</span> <span class="o">=</span> <span class="n">curr_point</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>
        <span class="n">point_i</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">point_lat</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ymax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">))</span>
        <span class="n">point_j</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">point_lon</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">))</span>
        <span class="n">point_i_uint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">point_i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>
        <span class="n">point_j_uint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">point_j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mask_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridZ</span><span class="p">[</span><span class="n">point_i_uint</span><span class="p">,</span> <span class="n">point_j_uint</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">point_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">point_i</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
            <span class="n">point_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">point_j</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
            <span class="n">mask_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridZ</span><span class="p">[</span><span class="n">point_i</span><span class="p">,</span> <span class="n">point_j</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mask_value</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="c1"># Detected a collision.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continent_deletion_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># We didn&#39;t find a collision, so ask the chained collision detection if it did (if we have anything chained).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_collision_detection</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_collision_detection</span><span class="p">(</span>
                <span class="n">rotation_model</span><span class="p">,</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">reconstruction_time_interval</span><span class="p">,</span>
                <span class="n">prev_point</span><span class="p">,</span>
                <span class="n">curr_point</span><span class="p">,</span>
                <span class="n">prev_topology_plate_id</span><span class="p">,</span>
                <span class="n">prev_resolved_plate_boundary</span><span class="p">,</span>
                <span class="n">curr_topology_plate_id</span><span class="p">,</span>
                <span class="n">curr_resolved_plate_boundary</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span><span class="w"> </span><span class="nf">reconstruct_points</span><span class="p">(</span>
    <span class="n">rotation_features_or_model</span><span class="p">,</span>
    <span class="n">topology_features</span><span class="p">,</span>
    <span class="n">reconstruction_begin_time</span><span class="p">,</span>
    <span class="n">reconstruction_end_time</span><span class="p">,</span>
    <span class="n">reconstruction_time_interval</span><span class="p">,</span>
    <span class="n">points</span><span class="p">,</span>
    <span class="n">point_begin_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">point_end_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">point_plate_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">detect_collisions</span><span class="o">=</span><span class="n">_DEFAULT_COLLISION</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruct points using the topological polygons.&quot;&quot;&quot;</span>

    <span class="n">topology_reconstruction</span> <span class="o">=</span> <span class="n">_ReconstructByTopologies</span><span class="p">(</span>
        <span class="n">rotation_features_or_model</span><span class="p">,</span>
        <span class="n">topology_features</span><span class="p">,</span>
        <span class="n">reconstruction_begin_time</span><span class="p">,</span>
        <span class="n">reconstruction_end_time</span><span class="p">,</span>
        <span class="n">reconstruction_time_interval</span><span class="p">,</span>
        <span class="n">points</span><span class="p">,</span>
        <span class="n">point_begin_times</span><span class="p">,</span>
        <span class="n">point_end_times</span><span class="p">,</span>
        <span class="n">point_plate_ids</span><span class="p">,</span>
        <span class="n">detect_collisions</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">topology_reconstruction</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_ReconstructByTopologies</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruct geometries using topologies. Currently only points are supported.&quot;&quot;&quot;</span>

    <span class="n">use_plate_partitioner</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;If the use_plate_partitioner is True then use pygplates.PlatePartitioner to partition points,</span>
<span class="sd">        otherwise use faster points_in_polygons.find_polygons().&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rotation_features_or_model</span><span class="p">,</span>
        <span class="n">topology_features</span><span class="p">,</span>
        <span class="n">reconstruction_begin_time</span><span class="p">,</span>
        <span class="n">reconstruction_end_time</span><span class="p">,</span>
        <span class="n">reconstruction_time_interval</span><span class="p">,</span>
        <span class="n">points</span><span class="p">,</span>
        <span class="n">point_begin_times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">point_end_times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">point_plate_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">detect_collisions</span><span class="o">=</span><span class="n">_DEFAULT_COLLISION</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        rotation_features_or_model: Rotation model or feature collection(s), or list of features, or filename(s).</span>

<span class="sd">        topology_features: Topology feature collection(s), or list of features, or filename(s) or any combination of those.</span>

<span class="sd">        detect_collisions: Collision detection function, or None. Defaults to _DEFAULT_COLLISION.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">rotation_features_or_model</span><span class="p">)</span>

        <span class="c1"># Turn topology data into a list of features (if not already).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeaturesFunctionArgument</span><span class="p">(</span>
            <span class="n">topology_features</span>
        <span class="p">)</span><span class="o">.</span><span class="n">get_features</span><span class="p">()</span>

        <span class="c1"># Set up an array of reconstruction times covering the reconstruction time span.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_begin_time</span> <span class="o">=</span> <span class="n">reconstruction_begin_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_end_time</span> <span class="o">=</span> <span class="n">reconstruction_end_time</span>
        <span class="k">if</span> <span class="n">reconstruction_time_interval</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;reconstruction_time_interval&#39; must be positive.&quot;</span><span class="p">)</span>
        <span class="c1"># Reconstruction can go forward or backward in time.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_begin_time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_end_time</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_time_step</span> <span class="o">=</span> <span class="o">-</span><span class="n">reconstruction_time_interval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_time_step</span> <span class="o">=</span> <span class="n">reconstruction_time_interval</span>
        <span class="c1"># Get number of times including end time if time span is a multiple of time step.</span>
        <span class="c1"># The &#39;1&#39; is because, for example, 2 time intervals is 3 times.</span>
        <span class="c1"># The &#39;1e-6&#39; deals with limited floating-point precision, eg, we want (3.0 - 0.0) / 1.0 to be 3.0 and not 2.999999 (which gets truncated to 2).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_times</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
                <span class="mf">1e-6</span>
                <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_end_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_begin_time</span><span class="p">)</span>
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_time_step</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># It&#39;s possible the time step is larger than the time span, in which case we change it to equal the time span.</span>
        <span class="c1"># This guarantees there&#39;ll be at least one time step (which has two times; one at either end of interval).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_times</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_times</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_time_step</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_end_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_begin_time</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_time_interval</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_time_step</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">last_time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_times</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># Use the specified point begin times if provided (otherwise use &#39;inf&#39;).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point_begin_times</span> <span class="o">=</span> <span class="n">point_begin_times</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_begin_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">point_begin_times</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_begin_times</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Length of &#39;point_begin_times&#39; must match length of &#39;points&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Use the specified point end times if provided (otherwise use &#39;-inf&#39;).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point_end_times</span> <span class="o">=</span> <span class="n">point_end_times</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_end_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">point_end_times</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_end_times</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Length of &#39;point_end_times&#39; must match length of &#39;points&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Use the specified point plate IDs if provided (otherwise use &#39;0&#39;).</span>
        <span class="c1"># These plate IDs are only used when a point falls outside all resolved topologies during a time step.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point_plate_ids</span> <span class="o">=</span> <span class="n">point_plate_ids</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_plate_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">point_plate_ids</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_plate_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Length of &#39;point_plate_ids&#39; must match length of &#39;points&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">detect_collisions</span> <span class="o">=</span> <span class="n">detect_collisions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">reconstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Initialise the reconstruction.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">begin_reconstruction</span><span class="p">()</span>

        <span class="c1"># Loop over the reconstruction times until reached end of the reconstruction time span, or</span>
        <span class="c1"># all points have entered their valid time range *and* either exited their time range or</span>
        <span class="c1"># have been deactivated (subducted forward in time or consumed by MOR backward in time).</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruct_to_next_time</span><span class="p">():</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_current_points</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">begin_reconstruction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_time_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Set up point arrays.</span>
        <span class="c1"># Store active and inactive points here (inactive points have None in corresponding entries).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>

        <span class="c1"># Each point can only get activated once (after deactivation it cannot be reactivated).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point_has_been_activated</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_activated_points</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Set up topology arrays (corresponding to active/inactive points at same indices).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_topology_plate_ids</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_topology_plate_ids</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_resolved_plate_boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_resolved_plate_boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>

        <span class="c1"># Array to store indices of points found in continents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_continent_indices</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_continent_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">deletedpoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_activate_deactivate_points</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_find_resolved_topologies_containing_points</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_current_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_begin_time</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_time_index</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_time_step</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_all_current_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_active_current_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Return only the active points (the ones that are not None).</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">point</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_current_points</span><span class="p">()</span> <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_in_continent_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_continent_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_continent_indices</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">reconstruct_to_next_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If we&#39;re at the last time then there is no next time to reconstruct to.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_time_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_time_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If all points have been previously activated, but none are currently active then we&#39;re finished.</span>
        <span class="c1"># This means all points have entered their valid time range *and* either exited their time range or</span>
        <span class="c1"># have been deactivated (subducted forward in time or consumed by MOR backward in time).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_activated_points</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Cache stage rotations by plate ID.</span>
        <span class="c1"># Use different dicts since using different rotation models and time steps, etc.</span>
        <span class="n">reconstruct_stage_rotation_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">current_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_time</span><span class="p">()</span>

        <span class="c1"># Iterate over all points to reconstruct them to the next time step.</span>
        <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">):</span>
            <span class="n">curr_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">curr_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Current point is not currently active.</span>
                <span class="c1"># So we cannot reconstruct to next time.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">next_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>

            <span class="c1"># Get plate ID of resolved topology containing current point</span>
            <span class="c1"># (this was determined in last call to &#39;_find_resolved_topologies_containing_points()&#39;).</span>
            <span class="n">curr_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_topology_plate_ids</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">curr_plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Current point is currently active but it fell outside all resolved polygons.</span>
                <span class="c1"># So instead we just reconstruct using its plate ID (that was manually assigned by the user/caller).</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_plate_ids</span>
                <span class="n">curr_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_plate_ids</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>

            <span class="c1"># Get the stage rotation that will move the point from where it is at the current time to its</span>
            <span class="c1"># location at the next time step, based on the plate id that contains the point at the current time.</span>

            <span class="c1"># Speed up by caching stage rotations in a dict.</span>
            <span class="n">stage_rotation</span> <span class="o">=</span> <span class="n">reconstruct_stage_rotation_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">curr_plate_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stage_rotation</span><span class="p">:</span>
                <span class="n">stage_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
                    <span class="c1"># Positive/negative time step means reconstructing backward/forward in time.</span>
                    <span class="n">current_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_time_step</span><span class="p">,</span>
                    <span class="n">curr_plate_id</span><span class="p">,</span>
                    <span class="n">current_time</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">reconstruct_stage_rotation_dict</span><span class="p">[</span><span class="n">curr_plate_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">stage_rotation</span>

            <span class="c1"># Use the stage rotation to reconstruct the tracked point from position at current time</span>
            <span class="c1"># to position at the next time step.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">stage_rotation</span> <span class="o">*</span> <span class="n">curr_point</span>

        <span class="c1">#</span>
        <span class="c1"># Set up for next loop iteration.</span>
        <span class="c1">#</span>
        <span class="c1"># Rotate previous, current and next point arrays.</span>
        <span class="c1"># The new previous will be the old current.</span>
        <span class="c1"># The new current will be the old next.</span>
        <span class="c1"># The new next will be the old previous (but values are ignored and overridden in next time step; just re-using its memory).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_points</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_points</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_points</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Swap previous and current topology arrays.</span>
        <span class="c1"># The new previous will be the old current.</span>
        <span class="c1"># The new current will be the old previous (but values are ignored and overridden in next time step; just re-using its memory).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_topology_plate_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_topology_plate_ids</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curr_topology_plate_ids</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_topology_plate_ids</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_resolved_plate_boundaries</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_resolved_plate_boundaries</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curr_resolved_plate_boundaries</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_resolved_plate_boundaries</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Move the current time to the next time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_time_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_time</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_activate_deactivate_points</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_find_resolved_topologies_containing_points</span><span class="p">()</span>

        <span class="c1"># Iterate over all points to detect collisions.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect_collisions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">):</span>
                <span class="n">prev_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                <span class="n">curr_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">prev_point</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">curr_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># If current point is not currently active then no need to detect a collision for it (to deactivate it).</span>
                    <span class="c1"># Also previous point might just have been activated now, at end of current time step, and hence</span>
                    <span class="c1"># not active at beginning of time step.</span>
                    <span class="k">continue</span>

                <span class="c1"># Get plate IDs of resolved topology containing previous and current point</span>
                <span class="c1"># (this was determined in last call to &#39;_find_resolved_topologies_containing_points()&#39;).</span>
                <span class="c1">#</span>
                <span class="c1"># Note that could be None, so the collision detection needs to handle that.</span>
                <span class="n">prev_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_topology_plate_ids</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                <span class="n">curr_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_topology_plate_ids</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>

                <span class="c1"># Detect collisions at the end of the current time step since we need previous, and current, points and topologies.</span>
                <span class="c1"># De-activate point (in &#39;curr_points&#39;) if subducted (forward in time) or consumed back into MOR (backward in time).</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect_collisions</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                    <span class="n">current_time</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_time_interval</span><span class="p">,</span>
                    <span class="n">prev_point</span><span class="p">,</span>
                    <span class="n">curr_point</span><span class="p">,</span>
                    <span class="n">prev_plate_id</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prev_resolved_plate_boundaries</span><span class="p">[</span><span class="n">point_index</span><span class="p">],</span>
                    <span class="n">curr_plate_id</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">curr_resolved_plate_boundaries</span><span class="p">[</span><span class="n">point_index</span><span class="p">],</span>
                <span class="p">):</span>
                    <span class="c1"># An inactive point in &#39;curr_points&#39; becomes None.</span>
                    <span class="c1"># It may have been reconstructed from the previous time step to a valid position</span>
                    <span class="c1"># but now we override that result as inactive.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># self.curr_points.remove(self.curr_points[point_index])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">deletedpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_index</span><span class="p">)</span>

        <span class="c1"># We successfully reconstructed to the next time.</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_activate_deactivate_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_time</span><span class="p">()</span>

        <span class="c1"># Iterate over all points and activate/deactivate as necessary depending on each point&#39;s valid time range.</span>
        <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_has_been_activated</span><span class="p">[</span><span class="n">point_index</span><span class="p">]:</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_begin_times</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_end_times</span>
                    <span class="c1"># Point is not active and has never been activated, so see if can activate it.</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">current_time</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_begin_times</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                        <span class="ow">and</span> <span class="n">current_time</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_end_times</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="c1"># The initial point is assumed to be the position at the current time</span>
                        <span class="c1"># which is typically the point&#39;s begin time (approximately).</span>
                        <span class="c1"># But it could be the beginning of the reconstruction time span (specified in constructor)</span>
                        <span class="c1"># if that falls in the middle of the point&#39;s valid time range - in this case the</span>
                        <span class="c1"># initial point position is assumed to be in a position that is some time *after*</span>
                        <span class="c1"># it appeared (at its begin time) - and this can happen, for example, if you have a</span>
                        <span class="c1"># uniform grids of points at some intermediate time and want to see how they</span>
                        <span class="c1"># reconstruct to either a younger or older time (remembering that points can</span>
                        <span class="c1"># be subducted forward in time and consumed back into a mid-ocean ridge going</span>
                        <span class="c1"># backward in time).</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">point_has_been_activated</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">num_activated_points</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_begin_times</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_end_times</span>
                <span class="c1"># Point is active, so see if can deactivate it.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">current_time</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_begin_times</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="n">current_time</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_end_times</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_resolved_topologies_containing_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">ptt</span> <span class="k">as</span> <span class="n">_ptt</span>

        <span class="n">current_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_time</span><span class="p">()</span>

        <span class="c1"># Resolve the plate polygons for the current time.</span>
        <span class="n">resolved_topologies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pygplates</span><span class="o">.</span><span class="n">resolve_topologies</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
            <span class="n">resolved_topologies</span><span class="p">,</span>
            <span class="n">current_time</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">_ReconstructByTopologies</span><span class="o">.</span><span class="n">use_plate_partitioner</span><span class="p">:</span>
            <span class="c1"># Create a plate partitioner from the resolved polygons.</span>
            <span class="n">plate_partitioner</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PlatePartitioner</span><span class="p">(</span>
                <span class="n">resolved_topologies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Some of &#39;curr_points&#39; will be None so &#39;curr_valid_points&#39; contains only the valid (not None)</span>
            <span class="c1"># points, and &#39;curr_valid_points_indices&#39; is the same length as &#39;curr_points&#39; but indexes into</span>
            <span class="c1"># &#39;curr_valid_points&#39; so we can quickly find which point (and hence which resolved topology)</span>
            <span class="c1"># in &#39;curr_valid_points&#39; is associated with the a particular point in &#39;curr_points&#39;.</span>
            <span class="n">curr_valid_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">curr_valid_points_indices</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span>
            <span class="k">for</span> <span class="n">point_index</span><span class="p">,</span> <span class="n">curr_point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">curr_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">curr_valid_points_indices</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_valid_points</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                    <span class="n">curr_valid_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_point</span><span class="p">)</span>
            <span class="c1"># For each valid current point find the resolved topology containing it.</span>
            <span class="n">resolved_topologies_containing_curr_valid_points</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_ptt</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">points_in_polygons</span><span class="o">.</span><span class="n">find_polygons</span><span class="p">(</span>
                    <span class="n">curr_valid_points</span><span class="p">,</span>
                    <span class="p">[</span>
                        <span class="n">resolved_topology</span><span class="o">.</span><span class="n">get_resolved_boundary</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">resolved_topology</span> <span class="ow">in</span> <span class="n">resolved_topologies</span>
                    <span class="p">],</span>
                    <span class="n">resolved_topologies</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Iterate over all points.</span>
        <span class="k">for</span> <span class="n">point_index</span><span class="p">,</span> <span class="n">curr_point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_points</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">curr_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Current point is not currently active - so skip it.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">curr_topology_plate_ids</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">curr_resolved_plate_boundaries</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>

            <span class="c1"># Find the plate id of the polygon that contains &#39;curr_point&#39;.</span>
            <span class="k">if</span> <span class="n">_ReconstructByTopologies</span><span class="o">.</span><span class="n">use_plate_partitioner</span><span class="p">:</span>
                <span class="n">curr_polygon</span> <span class="o">=</span> <span class="n">plate_partitioner</span><span class="o">.</span><span class="n">partition_point</span><span class="p">(</span><span class="n">curr_point</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_polygon</span> <span class="o">=</span> <span class="n">resolved_topologies_containing_curr_valid_points</span><span class="p">[</span>  <span class="c1"># type: ignore</span>
                    <span class="c1"># Index back into &#39;curr_valid_points&#39; and hence also into</span>
                    <span class="c1"># &#39;resolved_topologies_containing_curr_valid_points&#39;.</span>
                    <span class="n">curr_valid_points_indices</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="p">]</span>  <span class="c1"># type: ignore</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curr_resolved_plate_boundaries</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_polygon</span>

            <span class="c1"># If the polygon is None, that means (presumably) that it fell into a crack between</span>
            <span class="c1"># topologies. So it will be skipped and thrown away from future iterations.</span>
            <span class="k">if</span> <span class="n">curr_polygon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">curr_topology_plate_ids</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>

            <span class="c1"># Set the plate ID of resolved topology containing current point.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curr_topology_plate_ids</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">curr_polygon</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
            <span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, The University of Sydney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>