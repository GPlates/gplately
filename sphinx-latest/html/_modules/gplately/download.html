

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gplately.download &mdash; gplately 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            gplately
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basic_usages.html">Minimal working example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../use_cases.html">Common Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Trouble-shooting and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../command_line_interface.html">Command Line Interface (CLI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primer.html">Primer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">GPlately API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">gplately</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gplately.download</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gplately.download</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">#    Copyright (C) 2024 The University of Sydney, Australia</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1">#    the terms of the GNU General Public License, version 2, as published by</span>
<span class="c1">#    the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c1">#    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c1">#    for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License along</span>
<span class="c1">#    with this program; if not, write to Free Software Foundation, Inc.,</span>
<span class="c1">#    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions for downloading assorted plate reconstruction data to use with GPlately&#39;s</span>
<span class="sd">main objects. Files are stored in the user&#39;s cache and can be reused after being</span>
<span class="sd">downloaded once.</span>

<span class="sd">These data have been created and used in plate reconstruction models and studies, and</span>
<span class="sd">are available from public web servers (like EarthByte&#39;s webDAV server, or the GPlates</span>
<span class="sd">2.3 sample dataset library).</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">hashlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_hashlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_pathlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">shutil</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_shutil</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">urllib.request</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_request</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pooch</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_pooch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pygplates</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_pygplates</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">requests</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_requests</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">image</span> <span class="k">as</span> <span class="n">_image</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">plate_model_manager</span><span class="w"> </span><span class="kn">import</span> <span class="n">PlateModelManager</span><span class="p">,</span> <span class="n">PresentDayRasterManager</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pooch</span><span class="w"> </span><span class="kn">import</span> <span class="n">Decompress</span> <span class="k">as</span> <span class="n">_Decompress</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pooch</span><span class="w"> </span><span class="kn">import</span> <span class="n">HTTPDownloader</span> <span class="k">as</span> <span class="n">_HTTPDownloader</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pooch</span><span class="w"> </span><span class="kn">import</span> <span class="n">Unzip</span> <span class="k">as</span> <span class="n">_Unzip</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pooch</span><span class="w"> </span><span class="kn">import</span> <span class="n">os_cache</span> <span class="k">as</span> <span class="n">_os_cache</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pooch</span><span class="w"> </span><span class="kn">import</span> <span class="n">retrieve</span> <span class="k">as</span> <span class="n">_retrieve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pooch</span><span class="w"> </span><span class="kn">import</span> <span class="n">utils</span> <span class="k">as</span> <span class="n">_utils</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">gplately</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_gplately</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gplately.data</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataCollection</span>


<div class="viewcode-block" id="DownloadWarning">
<a class="viewcode-back" href="../../gplately.html#gplately.DownloadWarning">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DownloadWarning</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">):</span>
    <span class="k">pass</span></div>



<div class="viewcode-block" id="_test_internet_connection">
<a class="viewcode-back" href="../../gplately.html#gplately._test_internet_connection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_test_internet_connection</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test whether a connection to the required web server</span>
<span class="sd">    can be made given a `url`.</span>

<span class="sd">    Returns `False` the `url` is incorrect, and/or if there</span>
<span class="sd">    is no internet connection.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="_determine_processor">
<a class="viewcode-back" href="../../gplately.html#gplately._determine_processor">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_determine_processor</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set instructions for how to process/unpack a file depending on</span>
<span class="sd">    its filetype. The unpacked file paths will have an .unzip, or</span>
<span class="sd">    .decomp, or no file extension in their processed form.&quot;&quot;&quot;</span>
    <span class="n">archive_formats</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="s2">&quot;.gz&quot;</span><span class="p">,</span> <span class="s2">&quot;.xz&quot;</span><span class="p">,</span> <span class="s2">&quot;.bz2&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">url</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.zip&quot;</span><span class="p">):</span>
        <span class="n">processor</span> <span class="o">=</span> <span class="n">_Unzip</span><span class="p">()</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s2">&quot;.unzip&quot;</span>
    <span class="k">elif</span> <span class="n">url</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">archive_formats</span><span class="p">):</span>
        <span class="n">processor</span> <span class="o">=</span> <span class="n">_Decompress</span><span class="p">()</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s2">&quot;.decomp&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">processor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">return</span> <span class="n">processor</span><span class="p">,</span> <span class="n">ext</span></div>



<div class="viewcode-block" id="path_of_cached_file">
<a class="viewcode-back" href="../../gplately.html#gplately.path_of_cached_file">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">path_of_cached_file</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine the absolute path where the file(s) from `url`</span>
<span class="sd">    will be downloaded to.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    url : str</span>
<span class="sd">        The full download URL for the file passed as a string.</span>

<span class="sd">    model_name : str, default None</span>
<span class="sd">        An optional substring that ideally describes/labels the file.</span>
<span class="sd">        This will help name the file(s) when it is downloaded to the</span>
<span class="sd">        gplately cache (this directory can be</span>
<span class="sd">        found using `gplately.download.path_to_cache()`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cached_filename</span> <span class="o">=</span> <span class="n">_pooch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">unique_file_name</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">cached_filename</span> <span class="o">=</span> <span class="n">_remove_hash</span><span class="p">(</span><span class="n">cached_filename</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">path_to_cache</span><span class="p">()</span>

    <span class="n">processor_to_use</span><span class="p">,</span> <span class="n">processor_extension</span> <span class="o">=</span> <span class="n">_determine_processor</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

    <span class="c1"># If the requested files need processing (i.e. zip, gz folders)</span>
    <span class="k">if</span> <span class="n">processor_extension</span><span class="p">:</span>
        <span class="c1"># Are they from plate models? These typically are the .zip folders for plate models</span>
        <span class="k">if</span> <span class="n">model_name</span><span class="p">:</span>
            <span class="n">cached_filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">model_name</span> <span class="o">+</span> <span class="n">processor_extension</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
            <span class="n">unprocessed_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">model_name</span>
            <span class="c1"># cached_filename = cached_filename = str(path) + &#39;/&#39; + model_name</span>

        <span class="c1"># If not from plate models but need processing, i.e. ETOPO1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cached_filename</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;gplately_&quot;</span>
                <span class="o">+</span> <span class="n">_parse_url_for_filenames</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">processor_extension</span>
                <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
            <span class="p">)</span>
            <span class="n">unprocessed_path</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="s2">&quot;gplately_&quot;</span> <span class="o">+</span> <span class="n">_parse_url_for_filenames</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># cached_filename = &quot;gplately_&quot;+_parse_url_for_filenames(url)</span>

    <span class="c1"># If the requested files do not need processing, like standalone .nc files:</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">model_name</span><span class="p">:</span>
            <span class="n">cached_filename</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">model_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">_parse_url_for_filenames</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">unprocessed_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cached_filename</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="s2">&quot;gplately_&quot;</span> <span class="o">+</span> <span class="n">_parse_url_for_filenames</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">unprocessed_path</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_pooch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">make_local_storage</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">full_path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span> <span class="o">/</span> <span class="n">cached_filename</span>

    <span class="k">return</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">unprocessed_path</span></div>



<div class="viewcode-block" id="_extract_processed_files">
<a class="viewcode-back" href="../../gplately.html#gplately._extract_processed_files">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_extract_processed_files</span><span class="p">(</span><span class="n">processed_directory</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of all full filenames from a given directory</span>
<span class="sd">    in the GPlately cache.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">processed_directory</span><span class="p">):</span>
        <span class="n">fnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">_os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">processed_directory</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="n">fnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">file</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">fnames</span>
    <span class="k">elif</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">processed_directory</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">processed_directory</span></div>



<div class="viewcode-block" id="path_to_cache">
<a class="viewcode-back" href="../../gplately.html#gplately.path_to_cache">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">path_to_cache</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine the absolute path to the system gplately cache.&quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">_pooch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">cache_location</span><span class="p">(</span><span class="n">_os_cache</span><span class="p">(</span><span class="s2">&quot;gplately&quot;</span><span class="p">),</span> <span class="n">env</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span></div>



<div class="viewcode-block" id="clear_cache">
<a class="viewcode-back" href="../../gplately.html#gplately.clear_cache">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">clear_cache</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Clear the `gplately` cache directory.</span>

<span class="sd">    The absolute path of this directory can be found by running</span>
<span class="sd">    [gplately.download.path_to_cache()](file:///Users/laurenilano/gplately/api/gplately/download.html#gplately.download.path_to_cache).</span>

<span class="sd">    Caution - when called, all files in /path/to/caches/gplately will</span>
<span class="sd">    be deleted. This action cannot be undone.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cache_path</span> <span class="o">=</span> <span class="n">path_to_cache</span><span class="p">()</span>
    <span class="n">_shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cache_path</span><span class="p">))</span>
    <span class="n">_pooch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">make_local_storage</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cache_path</span><span class="p">))</span>
    <span class="k">return</span></div>



<div class="viewcode-block" id="_parse_url_for_filenames">
<a class="viewcode-back" href="../../gplately.html#gplately._parse_url_for_filenames">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_parse_url_for_filenames</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">return_hash</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Determine the filename of an E-Tag txt file</span>
    <span class="n">md5</span> <span class="o">=</span> <span class="n">_hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">url</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">_pooch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">parse_url</span><span class="p">(</span><span class="n">url</span><span class="p">)[</span><span class="s2">&quot;path&quot;</span><span class="p">])</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">fname</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="mi">255</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">md5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="n">return_hash</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">md5</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span></div>



<div class="viewcode-block" id="_get_url_etag">
<a class="viewcode-back" href="../../gplately.html#gplately._get_url_etag">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_get_url_etag</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Obtain the E-Tag of a web server URL.</span>

<span class="sd">    The E-Tag identifies a resource under a URL. If the resource</span>
<span class="sd">    is modified, a new E-Tag is generated. DataServer uses the</span>
<span class="sd">    E-Tag to determine whether local copies of plate model files</span>
<span class="sd">    available from a web server need to be updated to match the</span>
<span class="sd">    version on the web server.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine E-Tag of the URL</span>
    <span class="n">etag</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">_requests</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ETag&quot;</span><span class="p">))</span>

    <span class="c1"># Determine the filename of an E-Tag txt file</span>
    <span class="n">parsed_fname</span><span class="p">,</span> <span class="n">filehash</span> <span class="o">=</span> <span class="n">_parse_url_for_filenames</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">return_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">unique_name</span> <span class="o">=</span> <span class="n">filehash</span> <span class="o">+</span> <span class="s2">&quot;-ETAG.txt&quot;</span>

    <span class="n">cachepath</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">_pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">_os_cache</span><span class="p">(</span><span class="s2">&quot;gplately&quot;</span><span class="p">)))))</span>

    <span class="n">text_path</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cachepath</span><span class="p">,</span> <span class="n">unique_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">etag</span><span class="p">,</span> <span class="n">text_path</span><span class="p">)</span></div>



<div class="viewcode-block" id="_save_url_etag_to_txt">
<a class="viewcode-back" href="../../gplately.html#gplately._save_url_etag_to_txt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_save_url_etag_to_txt</span><span class="p">(</span><span class="n">etag</span><span class="p">,</span> <span class="n">text_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write an E-Tag to a text file.&quot;&quot;&quot;</span>
    <span class="c1"># Write E-Tag to a text file on the GPlately cache.</span>
    <span class="n">text_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">text_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="n">text_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">etag</span><span class="p">)</span>
    <span class="n">text_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>



<div class="viewcode-block" id="_match_url_to_extension">
<a class="viewcode-back" href="../../gplately.html#gplately._match_url_to_extension">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_match_url_to_extension</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">url</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">url</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;.nc&quot;</span>
    <span class="k">elif</span> <span class="n">url</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.jpg&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;.jpg&quot;</span>
    <span class="k">elif</span> <span class="n">url</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.png&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;.png&quot;</span>
    <span class="k">elif</span> <span class="n">url</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.tif&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;.tif&quot;</span></div>



<div class="viewcode-block" id="_first_time_download_from_web">
<a class="viewcode-back" href="../../gplately.html#gplately._first_time_download_from_web">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_first_time_download_from_web</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # Provided a web connection to a server can be established,</span>
<span class="sd">    download the files from the URL into the GPlately cache.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">_test_internet_connection</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">_pooch</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span>
            <span class="n">log_level</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">level</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>

        <span class="c1"># The filename pooch saves the requested file is derived from</span>
        <span class="c1"># one of four permutations:</span>
        <span class="c1"># 1. File is from a plate model and needs processing (i.e. zip --&gt; unzip)</span>
        <span class="c1"># 2. File is from a plate model and does not need processing (i.e. .nc age grids)</span>
        <span class="c1"># 3. File is not from a plate model but needs processing (i.e. ETOPO, .grd.gz --&gt; .decomp)</span>
        <span class="c1"># 4. File is not from a plate model and does not need processing</span>
        <span class="n">processor_to_use</span><span class="p">,</span> <span class="n">processor_extension</span> <span class="o">=</span> <span class="n">_determine_processor</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

        <span class="c1"># If the requested files need processing (i.e. zip, gz folders)</span>
        <span class="k">if</span> <span class="n">processor_extension</span><span class="p">:</span>
            <span class="c1"># Are they from plate models? These typically are the .zip folders for plate models</span>
            <span class="k">if</span> <span class="n">model_name</span><span class="p">:</span>
                <span class="c1"># Download the files with a naming structure like:</span>
                <span class="c1"># /path/to/cache/gplately/model_name+processor_extension</span>
                <span class="n">used_fname</span> <span class="o">=</span> <span class="n">model_name</span>
                <span class="n">fnames</span> <span class="o">=</span> <span class="n">_retrieve</span><span class="p">(</span>
                    <span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span>
                    <span class="n">known_hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">downloader</span><span class="o">=</span><span class="n">_HTTPDownloader</span><span class="p">(</span><span class="n">progressbar</span><span class="o">=</span><span class="n">verbose</span><span class="p">),</span>
                    <span class="n">fname</span><span class="o">=</span><span class="n">used_fname</span><span class="p">,</span>
                    <span class="n">path</span><span class="o">=</span><span class="n">_os_cache</span><span class="p">(</span><span class="s2">&quot;gplately&quot;</span><span class="p">),</span>
                    <span class="n">processor</span><span class="o">=</span><span class="n">processor_to_use</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># If not from plate models but need processing, i.e. ETOPO1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Download the files with a naming structure like:</span>
                <span class="c1"># /path/to/cache/gplately/file_name-as_inteded_in_url+processor_extension</span>
                <span class="n">used_fname</span> <span class="o">=</span> <span class="s2">&quot;gplately_&quot;</span> <span class="o">+</span> <span class="n">_parse_url_for_filenames</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                <span class="n">fnames</span> <span class="o">=</span> <span class="n">_retrieve</span><span class="p">(</span>
                    <span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span>
                    <span class="n">known_hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">downloader</span><span class="o">=</span><span class="n">_HTTPDownloader</span><span class="p">(</span><span class="n">progressbar</span><span class="o">=</span><span class="n">verbose</span><span class="p">),</span>
                    <span class="n">fname</span><span class="o">=</span><span class="n">used_fname</span><span class="p">,</span>
                    <span class="n">path</span><span class="o">=</span><span class="n">_os_cache</span><span class="p">(</span><span class="s2">&quot;gplately&quot;</span><span class="p">),</span>
                    <span class="n">processor</span><span class="o">=</span><span class="n">processor_to_use</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># If the requested files do not need processing, like standalone .nc files:</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Are they from plate models? These typically are age or spreading rate grids</span>
            <span class="k">if</span> <span class="n">model_name</span><span class="p">:</span>
                <span class="c1"># Download the files with a naming structure like:</span>
                <span class="c1"># /path/to/cache/gplately/file_name-as_inteded_in_url+processor_extension</span>
                <span class="n">used_fname</span> <span class="o">=</span> <span class="n">model_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">_parse_url_for_filenames</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                <span class="n">fnames</span> <span class="o">=</span> <span class="n">_retrieve</span><span class="p">(</span>
                    <span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span>
                    <span class="n">known_hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">downloader</span><span class="o">=</span><span class="n">_HTTPDownloader</span><span class="p">(</span><span class="n">progressbar</span><span class="o">=</span><span class="n">verbose</span><span class="p">),</span>
                    <span class="n">fname</span><span class="o">=</span><span class="n">used_fname</span><span class="p">,</span>
                    <span class="n">path</span><span class="o">=</span><span class="n">_os_cache</span><span class="p">(</span><span class="s2">&quot;gplately&quot;</span><span class="p">),</span>
                    <span class="n">processor</span><span class="o">=</span><span class="n">processor_to_use</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># If not from plate models and do not need processing,</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">used_fname</span> <span class="o">=</span> <span class="s2">&quot;gplately_&quot;</span> <span class="o">+</span> <span class="n">_parse_url_for_filenames</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                <span class="n">fnames</span> <span class="o">=</span> <span class="n">_retrieve</span><span class="p">(</span>
                    <span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span>
                    <span class="n">known_hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">downloader</span><span class="o">=</span><span class="n">_HTTPDownloader</span><span class="p">(</span><span class="n">progressbar</span><span class="o">=</span><span class="n">verbose</span><span class="p">),</span>
                    <span class="n">fname</span><span class="o">=</span><span class="n">used_fname</span><span class="p">,</span>
                    <span class="n">path</span><span class="o">=</span><span class="n">_os_cache</span><span class="p">(</span><span class="s2">&quot;gplately&quot;</span><span class="p">),</span>
                    <span class="n">processor</span><span class="o">=</span><span class="n">processor_to_use</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>

        <span class="c1"># Get the URL&#39;s E-Tag for the first time</span>
        <span class="n">etag</span><span class="p">,</span> <span class="n">textfilename</span> <span class="o">=</span> <span class="n">_get_url_etag</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">_save_url_etag_to_txt</span><span class="p">(</span><span class="n">etag</span><span class="p">,</span> <span class="n">textfilename</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">fnames</span><span class="p">,</span> <span class="n">etag</span><span class="p">,</span> <span class="n">textfilename</span><span class="p">,</span> <span class="n">used_fname</span><span class="p">)</span></div>



<div class="viewcode-block" id="download_from_web">
<a class="viewcode-back" href="../../gplately.html#gplately.download_from_web">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">download_from_web</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">download_changes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Download a file from a `url` into the `gplately` cache.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    After the file belonging to the given `url` is downloaded</span>
<span class="sd">    to the `gplately` cache once, subsequent runs of</span>
<span class="sd">    `download_from_web` with this `url` will not redownload</span>
<span class="sd">    the file as long as:</span>

<span class="sd">    * The file has not been updated on the web server,</span>
<span class="sd">    * The file has not been removed from the `gplately` cache.</span>

<span class="sd">    Instead, the file will be re-accessed from the `gplately`</span>
<span class="sd">    cache it was downloaded to.</span>

<span class="sd">    However, if the file has been updated on the web server,</span>
<span class="sd">    `download_from_web` overwrites the cached file with the</span>
<span class="sd">    updated version. The following messages will be displayed</span>
<span class="sd">    to the user:</span>

<span class="sd">        &quot;Checking whether the requested files need to be updated...&quot;</span>
<span class="sd">        &quot;Yes - updating requested files...&quot;</span>
<span class="sd">        &quot;Requested files downloaded to the GPlately cache folder!&quot;</span>

<span class="sd">    If ever a connection to the web server (and the file(s)) in</span>
<span class="sd">    `url` is unsuccessful, this is likely because:</span>

<span class="sd">    * An internet connection could not be established; or</span>
<span class="sd">    * The `url` passed to `download_from_web` is incorrect</span>

<span class="sd">    In either case, `download_from_web` attempts to find a version</span>
<span class="sd">    of the requested file(s) in `url` already stored in the</span>
<span class="sd">    `gplately` cache (assuming it has been downloaded from the same</span>
<span class="sd">    `url` once before). This version may not match the one on the web</span>
<span class="sd">    server. If a copy of the file(s) cannot be found in the `gplately`</span>
<span class="sd">    cache, a `ConnectionError` is raised.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    url : str</span>
<span class="sd">        The full URL used to download a file from a public web server</span>
<span class="sd">        like webDAV.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Choose whether to print user alerts regarding file availability,</span>
<span class="sd">        data server/internet connection status etc.</span>
<span class="sd">    download_changes : bool, default=True</span>
<span class="sd">        Permit the re-downloading/update of the file from `url` if</span>
<span class="sd">        it has been updated on the web server since the last download.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fnames : list of str</span>
<span class="sd">        A list of strings representing the full paths to all cached data</span>
<span class="sd">        downloaded from the given `url`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ConnectionError</span>
<span class="sd">        If a connection to the web server and file(s) in the given `url` is</span>
<span class="sd">        unsuccessful (because there is no internet access, and/or the `url`</span>
<span class="sd">        is incorrect) and no version of the requested file(s) have been</span>
<span class="sd">        cached before. In this case, nothing is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#   NOTE: We need a way to verify the existence of requested file(s) in the gplately</span>
    <span class="c1">#   cache to determine whether a file needs to be installed, updated, or re-accessed</span>
    <span class="c1">#   from the cache. Every time a file is installed for the first time,</span>
    <span class="c1">#   DataServer creates a directory called `full_path`. Its existence verifies the</span>
    <span class="c1">#   existence</span>
    <span class="c1">#</span>
    <span class="c1">#   The nature of `full_path` is dependent on the file-type:</span>
    <span class="c1">#</span>
    <span class="c1">#   .zip files will be downloaded and expanded in an inside folder:</span>
    <span class="c1">#</span>
    <span class="c1">#   /path/to/cache/gplately/fname.zip.unzip/</span>
    <span class="c1">#</span>
    <span class="c1">#   Thus, for zips, `full_path` is a directory that ends in &quot;.zip.unzip&quot;:</span>
    <span class="c1">#</span>
    <span class="c1">#   For example: /Users/laurenilano/Library/Caches/gplately/Muller2019.zip.unzip/</span>

    <span class="c1">#   Other types of files that need processing, like .gz --&gt; .decomp, aren&#39;t</span>
    <span class="c1">#   expanded in an internal folder. This is also the case for files that do not</span>
    <span class="c1">#   need processing, e.g. &quot;.nc&quot; files. In these cases, `full_path` is the exact</span>
    <span class="c1">#   directory that the cached file is saved to.</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#   For example: /Users/laurenilano/Library/Caches/gplately/Muller_etal_2019_Tectonics_v2.0_AgeGrid-100.nc</span>
    <span class="c1">#</span>
    <span class="c1">#   `full_path` is an empty directory for non-zips, and is the parent directory of</span>
    <span class="c1">#   unzipped contents in &quot;.zip&quot; URLs.</span>
    <span class="c1">#</span>
    <span class="c1">#   Why do we need `full_path`?</span>
    <span class="c1">#   We search the top-level gplately cache directory for the `full_path` directory as it is</span>
    <span class="c1">#   installed with the requested files. Its existence verifies the</span>
    <span class="c1">#   existence of the requested file(s), and thus to decide whether to install the</span>
    <span class="c1">#   files or re-access existing cached versions. This also helps with E-Tag versioning</span>
    <span class="c1">#   in instances where the download URL remains the same but its contents may have changed</span>
    <span class="c1">#   since the file(s) were last cached.</span>

    <span class="n">full_path</span><span class="p">,</span> <span class="n">unprocessed_path</span> <span class="o">=</span> <span class="n">path_of_cached_file</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">model_name</span><span class="p">)</span>

    <span class="c1"># If the file required processing (zips make a directory to unzip in, and .gz for example</span>
    <span class="c1"># makes a file just saved to the top-level directory), and the directory or file is not</span>
    <span class="c1"># yet on the cache,</span>
    <span class="k">if</span> <span class="n">_determine_processor</span><span class="p">(</span><span class="n">url</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">))</span> <span class="ow">or</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">))</span>
    <span class="p">):</span>

        <span class="c1"># ...and if a connection to the web server can be established,</span>
        <span class="c1"># download files from the URL and create a textfile for this URL&#39;s E-Tag</span>
        <span class="k">if</span> <span class="n">_test_internet_connection</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
            <span class="n">fnames</span><span class="p">,</span> <span class="n">etag</span><span class="p">,</span> <span class="n">textfilename</span><span class="p">,</span> <span class="n">used_fname</span> <span class="o">=</span> <span class="n">_first_time_download_from_web</span><span class="p">(</span>
                <span class="n">url</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Requested files downloaded to the GPlately cache folder!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fnames</span>

        <span class="c1"># ... if a connection to the web server cannot be established</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ConnectionError</span><span class="p">(</span>
                <span class="s2">&quot;A connection to </span><span class="si">{}</span><span class="s2"> could not be made. Please check your internet connection and/or ensure the URL is correct. No file from the given URL has been cached to </span><span class="si">{}</span><span class="s2"> yet - nothing has been returned.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">url</span><span class="p">,</span> <span class="n">full_path</span><span class="o">.</span><span class="n">parent</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="c1"># If the file does not require processing, it did not open up a directory, so check isfile,</span>
    <span class="c1"># and if the file is not yet on the cache,</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">_determine_processor</span><span class="p">(</span><span class="n">url</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">)):</span>
        <span class="c1"># ...and if a connection to the web server can be established,</span>
        <span class="c1"># download files from the URL and create a textfile for this URL&#39;s E-Tag</span>
        <span class="k">if</span> <span class="n">_test_internet_connection</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
            <span class="n">fnames</span><span class="p">,</span> <span class="n">etag</span><span class="p">,</span> <span class="n">textfilename</span><span class="p">,</span> <span class="n">used_fname</span> <span class="o">=</span> <span class="n">_first_time_download_from_web</span><span class="p">(</span>
                <span class="n">url</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Requested files downloaded to the GPlately cache folder!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fnames</span>

        <span class="c1"># ... if a connection to the web server cannot be established</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ConnectionError</span><span class="p">(</span>
                <span class="s2">&quot;A connection to </span><span class="si">{}</span><span class="s2"> could not be made. Please check your internet connection and/or ensure the URL is correct. No file from the given URL has been cached to </span><span class="si">{}</span><span class="s2"> yet - nothing has been returned.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">url</span><span class="p">,</span> <span class="n">full_path</span><span class="o">.</span><span class="n">parent</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="c1"># If the files have been downloaded before...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># ... and if a connection to the web server can be made...</span>
        <span class="k">if</span> <span class="n">_test_internet_connection</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">local_etag_txtfile</span> <span class="o">=</span> <span class="n">_get_url_etag</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

            <span class="c1"># If the newest version of the files in `url` must be cached</span>
            <span class="c1"># at all times, perform E-Tag comparisons:</span>
            <span class="k">if</span> <span class="n">download_changes</span><span class="p">:</span>

                <span class="c1"># Walk through the top-level cache directory to find an E-Tag textfile unique to the URL</span>
                <span class="n">etag_exists</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">cache_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">path_to_cache</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">local_etag_txtfile</span><span class="p">):</span>
                    <span class="n">etag_exists</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># If an e-tag text file does not exist, erase the cached files</span>
                <span class="c1"># and download the latest version from the web server. This, in turn,</span>
                <span class="c1"># creates an e-tag textfile for this version.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">etag_exists</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">full_path</span><span class="p">):</span>
                        <span class="n">_shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">full_path</span><span class="p">):</span>
                        <span class="n">_os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">unprocessed_path</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">unprocessed_path</span><span class="p">):</span>
                            <span class="n">_shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">unprocessed_path</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">unprocessed_path</span><span class="p">):</span>
                            <span class="n">_os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">unprocessed_path</span><span class="p">)</span>

                    <span class="n">fnames</span><span class="p">,</span> <span class="n">etag</span><span class="p">,</span> <span class="n">local_etag_txtfile</span><span class="p">,</span> <span class="n">used_fname</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">_first_time_download_from_web</span><span class="p">(</span>
                            <span class="n">url</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">fnames</span>

                <span class="c1"># If the e-tag textfile exists for the local files,</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Checking whether the requested files need to be updated...&quot;</span>
                        <span class="p">)</span>

                    <span class="c1"># Determine the local file&#39;s URL e-tag from the textfile</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">local_etag_txtfile</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">local_etag</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># Get the e-tag of the web server URL at current time</span>
                    <span class="n">remote_etag</span><span class="p">,</span> <span class="n">remote_etag_textfile</span> <span class="o">=</span> <span class="n">_get_url_etag</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

                    <span class="c1"># If the local and remote e-tags are unequal, the web-server URL</span>
                    <span class="c1"># contains an updated version of the cached files.</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">remote_etag</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">local_etag</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Yes - updating requested files...&quot;</span><span class="p">)</span>

                        <span class="c1"># Update the e-tag textfile with this newly-identified URL e-tag</span>
                        <span class="n">_save_url_etag_to_txt</span><span class="p">(</span><span class="n">remote_etag</span><span class="p">,</span> <span class="n">local_etag_txtfile</span><span class="p">)</span>

                        <span class="c1"># Delete existing version of the files...</span>
                        <span class="c1"># If it didn&#39;t need processing, i.e. &#39;unzipping&#39;, just delete as-is</span>
                        <span class="k">if</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">full_path</span><span class="p">):</span>
                            <span class="n">_shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">full_path</span><span class="p">):</span>
                            <span class="n">_os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span>

                        <span class="c1"># If it&#39;s the kind of file that needs processing, delete the</span>
                        <span class="c1"># unprocessed version so we can re-download it</span>
                        <span class="k">if</span> <span class="n">unprocessed_path</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">unprocessed_path</span><span class="p">):</span>
                                <span class="n">_shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">unprocessed_path</span><span class="p">))</span>
                            <span class="k">elif</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">unprocessed_path</span><span class="p">):</span>
                                <span class="n">_os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">unprocessed_path</span><span class="p">)</span>

                        <span class="c1"># Treat as if downloading the file(s) from the URL for the first time</span>
                        <span class="n">fnames</span><span class="p">,</span> <span class="n">etag</span><span class="p">,</span> <span class="n">local_etag_txtfile</span><span class="p">,</span> <span class="n">used_fname</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">_first_time_download_from_web</span><span class="p">(</span>
                                <span class="n">url</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;Updated requested files downloaded to the GPlately cache folder!&quot;</span>
                            <span class="p">)</span>
                        <span class="k">return</span> <span class="n">fnames</span>

                    <span class="c1"># If the e-tags are equal, the local and remote files are the same.</span>
                    <span class="c1"># Just return the file(s) as-is.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Requested files are up-to-date!&quot;</span><span class="p">)</span>

                        <span class="c1"># If files were processed once, return the processed files.</span>
                        <span class="k">if</span> <span class="n">_determine_processor</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">_determine_processor</span><span class="p">(</span><span class="n">url</span><span class="p">)[</span><span class="mi">1</span><span class="p">]):</span>
                                <span class="k">return</span> <span class="n">_extract_processed_files</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">)))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">return</span> <span class="n">_extract_processed_files</span><span class="p">(</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span> <span class="o">+</span> <span class="n">_determine_processor</span><span class="p">(</span><span class="n">url</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="p">)</span>
                        <span class="c1"># If not, return as-is.</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">_extract_processed_files</span><span class="p">(</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span> <span class="o">+</span> <span class="n">_match_url_to_extension</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                            <span class="p">)</span>

            <span class="c1"># If file versioning doesn&#39;t matter, just keep returning the cached files.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fnames</span><span class="p">,</span> <span class="n">etag</span><span class="p">,</span> <span class="n">local_etag_txtfile</span> <span class="o">=</span> <span class="n">_first_time_download_from_web</span><span class="p">(</span>
                    <span class="n">url</span><span class="p">,</span> <span class="n">model_name</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">fnames</span>

        <span class="c1"># If a connection to the web server could not be made, and the files exist in</span>
        <span class="c1"># the GPlately cache, just return the files as-is.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;No connection to </span><span class="si">{}</span><span class="s2"> established. The requested file(s) (potentially older versions) exist in the GPlately cache (</span><span class="si">{}</span><span class="s2">) and have been returned.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">url</span><span class="p">,</span> <span class="n">full_path</span><span class="o">.</span><span class="n">parent</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># print(str(full_path)+_determine_processor(url)[1])</span>
            <span class="k">return</span> <span class="n">_extract_processed_files</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">))</span></div>

            <span class="c1"># This created zip.unzip.unzip, so i deleted it but not sure if this will affect other files.</span>
            <span class="c1"># return(_extract_processed_files(str(full_path)+_determine_processor(url)[1]))</span>


<div class="viewcode-block" id="_collect_file_extension">
<a class="viewcode-back" href="../../gplately.html#gplately._collect_file_extension">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_collect_file_extension</span><span class="p">(</span><span class="n">fnames</span><span class="p">,</span> <span class="n">file_extension</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Searches cached directory for filenames with a specified extension(s).&quot;&quot;&quot;</span>
    <span class="n">sorted_fnames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">file_extension</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">file_extension</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">file_extension</span><span class="p">):</span>
            <span class="n">sorted_fnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sorted_fnames</span></div>



<div class="viewcode-block" id="_str_in_folder">
<a class="viewcode-back" href="../../gplately.html#gplately._str_in_folder">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_str_in_folder</span><span class="p">(</span><span class="n">fnames</span><span class="p">,</span> <span class="n">strings_to_include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strings_to_ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">fnames_to_ignore</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fnames_to_include</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sorted_fnames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fnames</span><span class="p">):</span>
        <span class="n">parent_directory</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strings_to_ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strings_to_ignore</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">parent_directory</span><span class="p">:</span>
                    <span class="n">fnames_to_ignore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">sorted_fnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">fnames_to_ignore</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">strings_to_include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">sorted_fnames</span><span class="p">:</span>
            <span class="n">parent_directory</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strings_to_include</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">parent_directory</span><span class="p">:</span>
                    <span class="n">fnames_to_include</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">sorted_fnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sorted_fnames</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fnames_to_include</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">sorted_fnames</span></div>



<div class="viewcode-block" id="_str_in_filename">
<a class="viewcode-back" href="../../gplately.html#gplately._str_in_filename">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_str_in_filename</span><span class="p">(</span>
    <span class="n">fnames</span><span class="p">,</span>
    <span class="n">strings_to_include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">strings_to_ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">file_collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">file_collection_sensitive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">filter_func</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="n">basename</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">strings_to_include</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If a file collection was passed to the string to include, there is at least one file specific to</span>
            <span class="c1"># this model that must be included. Such a file should be presented in the respective</span>
            <span class="c1"># strings_to_include list in data.py with format:</span>

            <span class="c1">#    &quot;file_collection string_to_include&quot;</span>

            <span class="c1"># That is, a whitespace must be placed between the file collection and the string to include.</span>
            <span class="c1"># The file collection must be identical to the string allocated to the key.</span>

            <span class="c1"># For example, strings_to_include = [&quot;Muller2022 1000_0_rotfile_Merdith_et_al_optimised.rot&quot;]</span>

            <span class="c1"># In this example, &quot;Muller2022&quot; and the strings_to_include list from data.py are passed to this function</span>
            <span class="c1"># when sorting through rotation files.</span>
            <span class="c1"># The list is looped through - if the current string has &quot;Muller2022&quot; (case insensitive) in it,</span>
            <span class="c1"># we will only pass through the filename following &quot;Muller2022&quot;, i.e. the optmised plate model.</span>
            <span class="c1"># All other rotation files bundled in the webDAV zip (including the published Merdith et al. 2021 rot files)</span>
            <span class="c1"># are excluded from the filter.</span>

            <span class="c1"># If no strings in the list include the passed file collection, we have one of two options, depending on whether</span>
            <span class="c1"># file_collection_sensitive is True or False.</span>

            <span class="c1"># If it is set to True, that means that we should only treat strings_to_include as True if and only if the</span>
            <span class="c1">#  passed file collection was found in the strings_to_include list. Otherwise, we have to treat strings_to_include</span>
            <span class="c1"># as if it was NoneType, and therefore place no filter for the files we accept through (that is, accept all files).</span>

            <span class="c1"># If it is set to False, that means that we should treat strings_to_include as True always, irrespective of</span>
            <span class="c1"># whether the passed file collection was found in the strings_to_include list. An example is the static polygon</span>
            <span class="c1"># filetype - this relies on strings_to_include being True no matter what.</span>

            <span class="c1"># For example, Merdith2021, Muller2019 would have file_collection_sensitive = False because these</span>
            <span class="c1"># models currently don&#39;t have any files that MUST be excluded for their own instance, but MUST</span>
            <span class="c1"># be included for other model instances.</span>

            <span class="c1"># Conversely, Muller2022 would have file_collection_sensitive = True because it requires all published Merdith2021</span>
            <span class="c1"># rot models to be ignored (in favour of the optimised model). However, we do not want to ignore Merdith2021 rot</span>
            <span class="c1"># models when we are using DataServer to collect Merdith2021 files.</span>

            <span class="k">if</span> <span class="n">file_collection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># If the file collection is in the provided list of strings to include...</span>
                <span class="n">strings_with_file_collection</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">s</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strings_to_include</span>
                    <span class="k">if</span> <span class="n">file_collection</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="n">strings_with_file_collection</span><span class="p">:</span>

                    <span class="c1"># Include the string, and break out.</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strings_with_file_collection</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">basename</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                            <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>

                <span class="c1"># If there is a file collection passed, but none of the strings to include include the file collection,</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If we no longer require strings_to_include, treat as if strings_to_include is False, and just pass</span>
                    <span class="c1"># all files through.</span>
                    <span class="k">if</span> <span class="n">file_collection_sensitive</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># If we still need strings_to_include, treat as if strings_to_include is True, and pass only required</span>
                    <span class="c1"># files through.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strings_to_include</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">basename</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                                <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">break</span>

            <span class="c1"># If a file collection is not passed, but strings_to_include exists, only pass through those requested.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strings_to_include</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">basename</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                        <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

        <span class="k">if</span> <span class="n">strings_to_ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strings_to_ignore</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">basename</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">keep</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">filter_func</span><span class="p">,</span> <span class="n">fnames</span><span class="p">))</span></div>



<div class="viewcode-block" id="_check_gpml_or_shp">
<a class="viewcode-back" href="../../gplately.html#gplately._check_gpml_or_shp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_check_gpml_or_shp</span><span class="p">(</span><span class="n">fnames</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For topology features, returns GPML by default. Searches for ESRI Shapefiles</span>
<span class="sd">    instead if GPML files not found.&quot;&quot;&quot;</span>
    <span class="n">sorted_fnames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.gpml&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.gpmlz&quot;</span><span class="p">):</span>
            <span class="n">sorted_fnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.shp&quot;</span><span class="p">):</span>
            <span class="n">sorted_fnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sorted_fnames</span></div>



<div class="viewcode-block" id="_remove_hash">
<a class="viewcode-back" href="../../gplately.html#gplately._remove_hash">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_remove_hash</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes hashes (32 character file IDs) from cached filenames.&quot;&quot;&quot;</span>
    <span class="n">split_paths</span> <span class="o">=</span> <span class="n">fname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
    <span class="n">cache_path</span> <span class="o">=</span> <span class="n">split_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span>
    <span class="n">new_path</span> <span class="o">=</span> <span class="n">cache_path</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">split_paths</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">new_path</span></div>



<div class="viewcode-block" id="_order_filenames_by_time">
<a class="viewcode-back" href="../../gplately.html#gplately._order_filenames_by_time">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_order_filenames_by_time</span><span class="p">(</span><span class="n">fnames</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Orders filenames in a list from present day to deeper geological time if they</span>
<span class="sd">    are labelled by time.&quot;&quot;&quot;</span>
    <span class="c1"># Collect all digits in each filename.</span>
    <span class="n">filepath_digits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fnames</span><span class="p">):</span>
        <span class="n">digits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">_re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;([0-9]+)&quot;</span><span class="p">,</span> <span class="n">_remove_hash</span><span class="p">(</span><span class="n">file</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">digits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">)))</span>
        <span class="n">filepath_digits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>

    <span class="c1"># Ignore digits common to all full file paths. This leaves behind the files&#39;</span>
    <span class="c1"># geological time label.</span>
    <span class="n">geological_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">filepath_digits</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filepath_digits</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">for</span> <span class="n">digit_array</span> <span class="ow">in</span> <span class="n">filepath_digits</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">digit</span> <span class="o">==</span> <span class="n">digit_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">digit</span> <span class="ow">in</span> <span class="n">digit_array</span><span class="p">):</span>
            <span class="n">geological_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">digit_array</span><span class="p">)</span>

    <span class="c1"># If files have geological time labels, allocate indices to the current filename order,</span>
    <span class="c1"># and sort files from recent to deep geological time.</span>
    <span class="k">if</span> <span class="n">geological_times</span><span class="p">:</span>
        <span class="n">sorted_geological_times</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">enumerate</span><span class="p">(</span><span class="n">geological_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">sorted_geological_time_indices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">geo_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">geo_time</span> <span class="ow">in</span> <span class="n">sorted_geological_times</span>
        <span class="p">]</span>
        <span class="n">filenames_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">fnames</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">sorted_geological_time_indices</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If given filenames do not have a time label, return them as is.</span>
        <span class="n">filenames_sorted</span> <span class="o">=</span> <span class="n">fnames</span>
    <span class="k">return</span> <span class="n">filenames_sorted</span></div>



<div class="viewcode-block" id="_collection_sorter">
<a class="viewcode-back" href="../../gplately.html#gplately._collection_sorter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_collection_sorter</span><span class="p">(</span><span class="n">fnames</span><span class="p">,</span> <span class="n">string_identifier</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;If multiple file collections or plate reconstruction models are downloaded from</span>
<span class="sd">    a single zip folder, only return the needed model.</span>

<span class="sd">    The plate models that need separating are listed.&quot;&quot;&quot;</span>

    <span class="n">needs_sorting</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;merdith2021&quot;</span><span class="p">,</span>
        <span class="s2">&quot;scotese2008&quot;</span><span class="p">,</span>
        <span class="s2">&quot;golonka2007&quot;</span><span class="p">,</span>
        <span class="s2">&quot;clennett2020&quot;</span><span class="p">,</span>
        <span class="s2">&quot;johansson2018&quot;</span><span class="p">,</span>
        <span class="s2">&quot;whittaker2015&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">string_identifier</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">needs_sorting</span><span class="p">:</span>
        <span class="n">studyname</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[A-Za-z]+|\d+&quot;</span><span class="p">,</span> <span class="n">string_identifier</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">newfnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">studyname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">newfnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newfnames</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fnames</span></div>



<div class="viewcode-block" id="_match_filetype_to_extension">
<a class="viewcode-back" href="../../gplately.html#gplately._match_filetype_to_extension">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_match_filetype_to_extension</span><span class="p">(</span><span class="n">filetype</span><span class="p">):</span>
    <span class="n">extensions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;netCDF&quot;</span><span class="p">:</span>
        <span class="n">extensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;jpeg&quot;</span><span class="p">:</span>
        <span class="n">extensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;.jpg&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;png&quot;</span><span class="p">:</span>
        <span class="n">extensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;.png&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;TIFF&quot;</span><span class="p">:</span>
        <span class="n">extensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;.tif&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">extensions</span></div>



<div class="viewcode-block" id="get_raster">
<a class="viewcode-back" href="../../gplately.html#gplately.get_raster">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_raster</span><span class="p">(</span><span class="n">raster_id_string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Downloads assorted raster data that are not associated with the plate</span>
<span class="sd">    reconstruction models supported by GPlately&#39;s `DataServer`. Stores rasters in the</span>
<span class="sd">    &quot;gplately&quot; cache.</span>

<span class="sd">    Currently, gplately supports the following rasters and images:</span>

<span class="sd">    * __[ETOPO1](https://www.ngdc.noaa.gov/mgg/global/)__:</span>
<span class="sd">        * Filetypes available : TIF, netCDF (GRD)</span>
<span class="sd">        * `raster_id_string` = `&quot;ETOPO1_grd&quot;`, `&quot;ETOPO1_tif&quot;` (depending on the requested format)</span>
<span class="sd">        * A 1-arc minute global relief model combining lang topography and ocean bathymetry.</span>
<span class="sd">        * Citation: doi:10.7289/V5C8276M</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raster_id_string : str, default=None</span>
<span class="sd">        A string to identify which raster to download.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a gplately.Raster object</span>
<span class="sd">        A gplately.Raster object containing the raster data. The gridded data can be extracted</span>
<span class="sd">        into a numpy ndarray or MaskedArray by appending `.data` to the variable assigned to `get_raster()`.</span>

<span class="sd">        For example:</span>

<span class="sd">            graster = gplately.download.get_raster(raster_id_string, verbose)</span>

<span class="sd">            graster_data = graster.data</span>

<span class="sd">        where `graster_data` is a numpy ndarray. This array can be visualised using</span>
<span class="sd">        `matplotlib.pyplot.imshow` on a `cartopy.mpl.GeoAxis` GeoAxesSubplot</span>
<span class="sd">        (see example below).</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        * if a `raster_id_string` is not supplied.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Rasters obtained by this method are (so far) only reconstructed to present-day.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    To download ETOPO1 and plot it on a Mollweide projection:</span>

<span class="sd">        import gplately</span>
<span class="sd">        import numpy as np</span>
<span class="sd">        import matplotlib.pyplot as plt</span>
<span class="sd">        import cartopy.crs as ccrs</span>

<span class="sd">        etopo1 = gplately.download.get_raster(&quot;ETOPO1_tif&quot;)</span>
<span class="sd">        etopo1_data = etopo1.data</span>

<span class="sd">        fig = plt.figure(figsize=(18,14), dpi=300)</span>
<span class="sd">        ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))</span>
<span class="sd">        etopo1.imshow(ax)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">image</span>

    <span class="k">if</span> <span class="n">raster_id_string</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please specify which raster to download.&quot;</span><span class="p">)</span>
    <span class="c1"># filetype = &quot;.&quot;+&quot;_&quot;.split(raster_id_string)[-1]</span>

    <span class="n">archive_formats</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="s2">&quot;.gz&quot;</span><span class="p">,</span> <span class="s2">&quot;.xz&quot;</span><span class="p">,</span> <span class="s2">&quot;.bz2&quot;</span><span class="p">])</span>
    <span class="n">grid_extensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="s2">&quot;.grd&quot;</span><span class="p">,</span> <span class="s2">&quot;.nc&quot;</span><span class="p">])</span>

    <span class="c1"># Set to true if we find the given collection in database</span>
    <span class="n">found_collection</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">raster_filenames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">database</span> <span class="o">=</span> <span class="n">_gplately</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_rasters</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">collection</span><span class="p">,</span> <span class="n">zip_url</span> <span class="ow">in</span> <span class="n">database</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Isolate the raster name and the file type</span>
        <span class="c1"># raster_name = collection.split(&quot;_&quot;)[0]</span>
        <span class="c1"># raster_type = &quot;.&quot;+collection.split(&quot;_&quot;)[-1]</span>
        <span class="k">if</span> <span class="n">raster_id_string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">collection</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">raster_filenames</span> <span class="o">=</span> <span class="n">download_from_web</span><span class="p">(</span><span class="n">zip_url</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">verbose</span><span class="p">)</span>
            <span class="n">found_collection</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">found_collection</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> not in collection database.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">raster_id_string</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If the downloaded raster is a grid, process it with the gplately.Raster object</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">grid_extension</span> <span class="ow">in</span> <span class="n">raster_filenames</span> <span class="k">for</span> <span class="n">grid_extension</span> <span class="ow">in</span> <span class="n">grid_extensions</span>
        <span class="p">):</span>
            <span class="n">raster</span> <span class="o">=</span> <span class="n">_gplately</span><span class="o">.</span><span class="n">grids</span><span class="o">.</span><span class="n">Raster</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">raster_filenames</span><span class="p">)</span>

        <span class="c1"># Otherwise, the raster is an image; use imread to process</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raster_matrix</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">raster_filenames</span><span class="p">)</span>
            <span class="n">raster</span> <span class="o">=</span> <span class="n">_gplately</span><span class="o">.</span><span class="n">grids</span><span class="o">.</span><span class="n">Raster</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">raster_matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">raster_id_string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;etopo1_tif&quot;</span><span class="p">:</span>
            <span class="n">raster</span><span class="o">.</span><span class="n">lats</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">lats</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">raster_id_string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;etopo1_grd&quot;</span><span class="p">:</span>
            <span class="n">raster</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">raster</span></div>



<div class="viewcode-block" id="get_feature_data">
<a class="viewcode-back" href="../../gplately.html#gplately.get_feature_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_feature_data</span><span class="p">(</span><span class="n">feature_data_id_string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Downloads assorted geological feature data from web servers (i.e.</span>
<span class="sd">    [GPlates 2.3 sample data](https://www.earthbyte.org/gplates-2-3-software-and-data-sets/))</span>
<span class="sd">    into the &quot;gplately&quot; cache.</span>

<span class="sd">    Currently, gplately supports the following feature data:</span>

<span class="sd">    --------------</span>

<span class="sd">    | **Feature data string identifier** | **Description**                                                                                                                                                                              |</span>
<span class="sd">    |------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|</span>
<span class="sd">    | Johansson2018                      | Large igneous provinces from  Johansson et al. (2018)                                                                                                                                        |</span>
<span class="sd">    | Whittaker2015                      | Large igneous province products  interpreted as plume products  from Whittaker et al. (2015).                                                                                                |</span>
<span class="sd">    | SeafloorFabric                     | Seafloor tectonic fabric  (fracture zones, discordant zones,  V-shaped structures, unclassified  V-anomalies, propagating ridge  lineations and extinct ridges)  from Matthews et al. (2011) |</span>
<span class="sd">    | Hotspots                           | Present day surface hotspot/plume  locations from Whittaker et al. (2013)                                                                                                                    |</span>

<span class="sd">    ---------------</span>

<span class="sd">    Detailed descriptions can be found below:</span>

<span class="sd">    * __Large igneous provinces from Johansson et al. (2018)__</span>

<span class="sd">        Information</span>
<span class="sd">        -----------</span>
<span class="sd">        * Formats: .gpmlz</span>
<span class="sd">        * `feature_data_id_string` = `Johansson2018`</span>

<span class="sd">        Citations</span>
<span class="sd">        ---------</span>
<span class="sd">        * Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The</span>
<span class="sd">        interplay between the eruption and weathering of Large Igneous Provinces and</span>
<span class="sd">        the deep-time carbon cycle: Geophysical Research Letters.</span>


<span class="sd">    - __Large igneous province products interpreted as plume products from Whittaker</span>
<span class="sd">    et al. (2015)__.</span>

<span class="sd">        Information</span>
<span class="sd">        -----------</span>
<span class="sd">        * Formats: .gpmlz, .shp</span>
<span class="sd">        * `feature_data_id_string` = `Whittaker2015`</span>

<span class="sd">        Citations</span>
<span class="sd">        ---------</span>
<span class="sd">        * Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D.,</span>
<span class="sd">        Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between</span>
<span class="sd">        mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483.</span>
<span class="sd">        doi:10.1038/ngeo2437.</span>


<span class="sd">    - __Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures,</span>
<span class="sd">    unclassified V-anomalies, propagating ridge lineations and extinct ridges) from</span>
<span class="sd">    Matthews et al. (2011)__</span>

<span class="sd">        Information</span>
<span class="sd">        -----------</span>
<span class="sd">        * Formats: .gpml</span>
<span class="sd">        * `feature_data_id_string` = `SeafloorFabric`</span>

<span class="sd">        Citations</span>
<span class="sd">        ---------</span>
<span class="sd">        * Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The</span>
<span class="sd">        tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12):</span>
<span class="sd">        B12109, DOI: 10.1029/2011JB008413.</span>


<span class="sd">    - __Present day surface hotspot/plume locations from Whittaker et al. (2013)__</span>

<span class="sd">        Information</span>
<span class="sd">        -----------</span>
<span class="sd">        * Formats: .gpmlz</span>
<span class="sd">        * `feature_data_id_string` = `Hotspots`</span>

<span class="sd">        Citation</span>
<span class="sd">        --------</span>
<span class="sd">        * Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P.,</span>
<span class="sd">        Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and</span>
<span class="sd">        mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feature_data_id_string : str, default=None</span>
<span class="sd">        A string to identify which feature data to download to the cache (see list of supported</span>
<span class="sd">        feature data above).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    feature_data_filenames : instance of &lt;pygplates.FeatureCollection&gt;, or list of instance &lt;pygplates.FeatureCollection&gt;</span>
<span class="sd">        If a single set of feature data is downloaded, a single pyGPlates `FeatureCollection`</span>
<span class="sd">        object is returned. Otherwise, a list containing multiple pyGPlates `FeatureCollection`</span>
<span class="sd">        objects is returned (like for `SeafloorFabric`). In the latter case, feature reconstruction</span>
<span class="sd">        and plotting may have to be done iteratively.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If a `feature_data_id_string` is not provided.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For examples of plotting data downloaded with `get_feature_data`, see GPlately&#39;s sample</span>
<span class="sd">    notebook 05 - Working With Feature Geometries [here](https://github.com/GPlates/gplately/blob/master/Notebooks/05-WorkingWithFeatureGeometries.ipynb).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">feature_data_id_string</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please specify which feature data to fetch.&quot;</span><span class="p">)</span>

    <span class="n">database</span> <span class="o">=</span> <span class="n">_gplately</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_feature_data</span><span class="p">()</span>

    <span class="n">found_collection</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">collection</span><span class="p">,</span> <span class="n">zip_url</span> <span class="ow">in</span> <span class="n">database</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">feature_data_id_string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">collection</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">found_collection</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">feature_data_filenames</span> <span class="o">=</span> <span class="n">_collection_sorter</span><span class="p">(</span>
                <span class="n">_collect_file_extension</span><span class="p">(</span>
                    <span class="n">download_from_web</span><span class="p">(</span><span class="n">zip_url</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">verbose</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;.gpml&quot;</span><span class="p">,</span> <span class="s2">&quot;.gpmlz&quot;</span><span class="p">]</span>
                <span class="p">),</span>
                <span class="n">collection</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">break</span>

    <span class="k">if</span> <span class="n">found_collection</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> are not in GPlately&#39;s DataServer.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">feature_data_id_string</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">feat_data</span> <span class="o">=</span> <span class="n">_pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_data_filenames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">feat_data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">feature_data_filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">feat_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">feat_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">feature_data_filenames</span><span class="p">:</span>
            <span class="n">feat_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">feat_data</span></div>



<div class="viewcode-block" id="DataServer">
<a class="viewcode-back" href="../../gplately.html#gplately.DataServer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DataServer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The DataServer class may be deprecated in the future.</span>
<span class="sd">    We recommend using the newer `plate-model-manager &lt;https://pypi.org/project/plate-model-manager/&gt;`__ module whenever possible.</span>

<span class="sd">    The methods in this DataServer class download plate reconstruction models to the cache folder on your computer from</span>
<span class="sd">    EarthByte&#39;s [WebDAV server](https://repo.gplates.org/webdav/pmm/).</span>

<span class="sd">    If the `DataServer` object and its methods are called for the first time, i.e. by:</span>

<span class="sd">        # string identifier to access the Muller et al. 2019 model</span>
<span class="sd">        gDownload = gplately.download.DataServer(&quot;Muller2019&quot;)</span>

<span class="sd">    all requested files are downloaded into the user&#39;s &#39;gplately&#39; cache folder only _once_. If the same</span>
<span class="sd">    object and method(s) are re-run, the files will be re-accessed from the cache provided they have not been</span>
<span class="sd">    moved or deleted.</span>

<span class="sd">    [This page](https://gplates.github.io/gplately/dev-doc/#dataserver) contains a list of available plate reconstruction models.</span>
<span class="sd">    For more information about these plate models, visit this [EarthByte web page](https://www.earthbyte.org/category/resources/data-models/global-regional-plate-motion-models/).</span>

<span class="sd">    You can also use the `pmm ls` command to retrieve more information about a model.</span>
<span class="sd">    For instance, running `pmm ls cao2024` will display details about the &quot;Cao2024&quot; model.</span>
<span class="sd">    Make sure to install the `plate-model-manager` module first by running `pip install plate-model-manager` before executing this command.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DataServer.__init__">
<a class="viewcode-back" href="../../generated/gplately.DataServer.html#gplately.DataServer.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_collection</span><span class="p">,</span> <span class="n">data_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_collection: str</span>
<span class="sd">            model name</span>

<span class="sd">        verbose: bool, default=True</span>
<span class="sd">            Toggle print messages regarding server/internet connection status, file availability etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_dir</span><span class="p">:</span>
            <span class="n">_data_dir</span> <span class="o">=</span> <span class="n">path_to_cache</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_data_dir</span> <span class="o">=</span> <span class="n">data_dir</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span> <span class="o">=</span> <span class="n">file_collection</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span> <span class="o">=</span> <span class="n">PlateModelManager</span><span class="p">()</span><span class="o">.</span><span class="n">get_model</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="p">,</span> <span class="n">data_dir</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">_data_dir</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to get plate model </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span><span class="si">}</span><span class="s2">. Check if the model name is correct.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_available_layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_avail_layers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># initialise empty attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotation_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_topology_features</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coastlines</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_continents</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_COBs</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="DataServer._create_feature_collection">
<a class="viewcode-back" href="../../gplately.html#gplately.DataServer._create_feature_collection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_feature_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_list</span><span class="p">):</span>
        <span class="n">feature_collection</span> <span class="o">=</span> <span class="n">_pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
            <span class="n">feature_collection</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">feature</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">feature_collection</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotation_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation_model</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rotation_model</span> <span class="o">=</span> <span class="n">_pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_rotation_model</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rotation_model</span><span class="o">.</span><span class="n">reconstruction_identifier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation_model</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">topology_features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology_features</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;Topologies&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_available_layers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_topology_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_feature_collection</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_topologies</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_topology_features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology_features</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">static_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;StaticPolygons&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_available_layers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_feature_collection</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_static_polygons</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_polygons</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coastlines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coastlines</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;Coastlines&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_available_layers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_coastlines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_feature_collection</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_coastlines</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_coastlines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coastlines</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">continents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_continents</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;ContinentalPolygons&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_available_layers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_continents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_feature_collection</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_continental_polygons</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_continents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_continents</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">COBs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COBs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;COBs&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_available_layers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_COBs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_feature_collection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_COBs</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_COBs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COBs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_age</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_big_time</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_age</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_small_time</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_age</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_age</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">valid_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_age</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_age</span>

<div class="viewcode-block" id="DataServer.get_plate_reconstruction_files">
<a class="viewcode-back" href="../../gplately.html#gplately.DataServer.get_plate_reconstruction_files">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_plate_reconstruction_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Downloads and constructs a `rotation model`, a set of `topology features` and</span>
<span class="sd">        and a set of `static polygons`. These objects can then be used to create `PlateReconstruction` object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation_model : instance of &lt;pygplates.RotationModel&gt;</span>
<span class="sd">            A rotation model to query equivalent and/or relative topological plate rotations</span>
<span class="sd">            from a time in the past relative to another time in the past or to present day.</span>
<span class="sd">        topology_features : instance of &lt;pygplates.FeatureCollection&gt;</span>
<span class="sd">            Point, polyline and/or polygon feature data that are reconstructable through</span>
<span class="sd">            geological time.</span>
<span class="sd">        static_polygons : instance of &lt;pygplates.FeatureCollection&gt;</span>
<span class="sd">            Present-day polygons whose shapes do not change through geological time. They are</span>
<span class="sd">            used to cookie-cut dynamic polygons into identifiable topological plates (assigned</span>
<span class="sd">            an ID) according to their present-day locations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The get_plate_reconstruction_files() method downloads reconstruction files from a given plate model.</span>
<span class="sd">        For example,</span>

<span class="sd">            gDownload = gplately.download.DataServer(&quot;Muller2019&quot;)</span>
<span class="sd">            rotation_model, topology_features, static_polygons = gDownload.get_plate_reconstruction_files()</span>

<span class="sd">        The code above downloads `rotation model`, `topology features` and `static polygons` files from the</span>
<span class="sd">        Müller et al. (2019) plate reconstruction model. These files can then be used to create `PlateReconstruction` object.</span>

<span class="sd">            model = gplately.reconstruction.PlateReconstruction(rotation_model, topology_features, static_polygons)</span>

<span class="sd">        If the requested plate model does not have certain file(s), a warning message will alert user of the missing file(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology_features</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_polygons</span></div>


<div class="viewcode-block" id="DataServer.get_topology_geometries">
<a class="viewcode-back" href="../../gplately.html#gplately.DataServer.get_topology_geometries">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_topology_geometries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Uses the [plate-model-manager](https://pypi.org/project/plate-model-manager/) to download coastline, continent and COB (continent-ocean boundary)</span>
<span class="sd">        Shapely geometries from the requested plate model. These are needed to call the `PlotTopologies`</span>
<span class="sd">        object and visualise topological plates through time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose : bool, default True</span>
<span class="sd">            Toggle print messages regarding server/internet connection status, file availability etc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coastlines : instance of &lt;pygplates.FeatureCollection&gt;</span>
<span class="sd">            Present-day global coastline Shapely polylines cookie-cut using static polygons. Ready for</span>
<span class="sd">            reconstruction to a particular geological time and for plotting.</span>

<span class="sd">        continents : instance of &lt;pygplates.FeatureCollection&gt;</span>
<span class="sd">            Cookie-cutting Shapely polygons for non-oceanic regions (continents, inta-oceanic arcs, etc.)</span>
<span class="sd">            ready for reconstruction to a particular geological time and for plotting.</span>

<span class="sd">        COBs : instance of &lt;pygplates.FeatureCollection&gt;</span>
<span class="sd">            Shapely polylines resolved from .shp and/or .gpml topology files that represent the</span>
<span class="sd">            locations of the boundaries between oceanic and continental crust.</span>
<span class="sd">            Ready for reconstruction to a particular geological time and for plotting.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method accesses the plate reconstruction model ascribed to the `file_collection`</span>
<span class="sd">        string passed into the `DataServer` object. For example, if the object was called with</span>
<span class="sd">        `&quot;Muller2019&quot;`:</span>

<span class="sd">            gDownload = gplately.download.DataServer(&quot;Muller2019&quot;)</span>
<span class="sd">            coastlines, continents, COBs = gDownload.get_topology_geometries()</span>

<span class="sd">        the method will attempt to download `coastlines`, `continents` and `COBs` from the Müller</span>
<span class="sd">        et al. (2019) plate reconstruction model. If found, these files are returned as individual</span>
<span class="sd">        pyGPlates Feature Collections. They can be passed into:</span>

<span class="sd">            gPlot = gplately.plot.PlotTopologies(gplately.reconstruction.PlateReconstruction, time, continents, coastlines, COBs)</span>

<span class="sd">        to reconstruct features to a certain geological time. The `PlotTopologies`</span>
<span class="sd">        object provides simple methods to plot these geometries along with trenches, ridges and</span>
<span class="sd">        transforms (see documentation for more info). Note that the `PlateReconstruction` object</span>
<span class="sd">        is a parameter.</span>

<span class="sd">        * Note: If the requested plate model does not have a certain geometry, a</span>
<span class="sd">        message will be printed to alert the user. For example, if `get_topology_geometries()`</span>
<span class="sd">        is used with the `&quot;Matthews2016&quot;` plate model, the workflow will print the following</span>
<span class="sd">        message:</span>

<span class="sd">                No continent-ocean boundaries in Matthews2016.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coastlines</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">continents</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">COBs</span></div>


<div class="viewcode-block" id="DataServer.get_age_grid">
<a class="viewcode-back" href="../../gplately.html#gplately.DataServer.get_age_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_age_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Downloads seafloor and paleo-age grids from the plate reconstruction model (`file_collection`)</span>
<span class="sd">        passed into the `DataServer` object. Stores grids in the &quot;gplately&quot; cache.</span>

<span class="sd">        Currently, `DataServer` supports the following age grids:</span>

<span class="sd">        * __Muller et al. 2019__</span>

<span class="sd">            * `file_collection` = `Muller2019`</span>
<span class="sd">            * Time range: 0-250 Ma</span>
<span class="sd">            * Seafloor age grid rasters in netCDF format.</span>

<span class="sd">        * __Muller et al. 2016__</span>

<span class="sd">            * `file_collection` = `Muller2016`</span>
<span class="sd">            * Time range: 0-240 Ma</span>
<span class="sd">            * Seafloor age grid rasters in netCDF format.</span>

<span class="sd">        * __Seton et al. 2012__</span>

<span class="sd">            * `file_collection` = `Seton2012`</span>
<span class="sd">            * Time range: 0-200 Ma</span>
<span class="sd">            * Paleo-age grid rasters in netCDF format.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : int, or list of int, default=None</span>
<span class="sd">            Request an age grid from one (an integer) or multiple reconstruction times (a</span>
<span class="sd">            list of integers).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a gplately.Raster object</span>
<span class="sd">            A gplately.Raster object containing the age grid. The age grid data can be extracted</span>
<span class="sd">            into a numpy ndarray or MaskedArray by appending `.data` to the variable assigned to</span>
<span class="sd">            `get_age_grid()`.</span>

<span class="sd">            For example:</span>

<span class="sd">                gdownload = gplately.DataServer(&quot;Muller2019&quot;)</span>

<span class="sd">                graster = gdownload.get_age_grid(time=100)</span>

<span class="sd">                graster_data = graster.data</span>

<span class="sd">            where `graster_data` is a numpy ndarray.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `time` (a single integer, or a list of integers representing reconstruction</span>
<span class="sd">            times to extract the age grids from) is not passed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The first time that `get_age_grid` is called for a specific time(s), the age grid(s)</span>
<span class="sd">        will be downloaded into the GPlately cache once. Upon successive calls of `get_age_grid`</span>
<span class="sd">        for the same reconstruction time(s), the age grids will not be re-downloaded; rather,</span>
<span class="sd">        they are re-accessed from the same cache provided the age grid(s) have not been moved or deleted.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        if the `DataServer` object was called with the `Muller2019` `file_collection` string:</span>

<span class="sd">            gDownload = gplately.download.DataServer(&quot;Muller2019&quot;)</span>

<span class="sd">        `get_age_grid` will download seafloor age grids from the Müller et al. (2019) plate</span>
<span class="sd">        reconstruction model for the geological time(s) requested in the `time` parameter.</span>
<span class="sd">        If found, these age grids are returned as masked arrays.</span>

<span class="sd">        For example, to download  Müller et al. (2019) seafloor age grids for 0Ma, 1Ma and</span>
<span class="sd">        100 Ma:</span>

<span class="sd">            age_grids = gDownload.get_age_grid([0, 1, 100])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The plate model object is None. Unable to get agegrid.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;AgeGrids&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_cfg</span><span class="p">()[</span><span class="s2">&quot;TimeDepRasters&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;AgeGrids are not currently available for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">age_grids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">time_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_array</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_age</span> <span class="ow">or</span> <span class="n">time_array</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_age</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specify a time range between </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_range</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="n">time_array</span><span class="p">:</span>
            <span class="n">agegrid_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_raster</span><span class="p">(</span><span class="s2">&quot;AgeGrids&quot;</span><span class="p">,</span> <span class="n">ti</span><span class="p">)</span>
            <span class="n">agegrid</span> <span class="o">=</span> <span class="n">_gplately</span><span class="o">.</span><span class="n">grids</span><span class="o">.</span><span class="n">Raster</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">agegrid_filename</span><span class="p">)</span>
            <span class="n">age_grids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">agegrid</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">age_grids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">age_grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">age_grids</span></div>


<div class="viewcode-block" id="DataServer.get_spreading_rate_grid">
<a class="viewcode-back" href="../../gplately.html#gplately.DataServer.get_spreading_rate_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_spreading_rate_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Downloads seafloor spreading rate grids from the plate reconstruction</span>
<span class="sd">        model (`file_collection`) passed into the `DataServer` object. Stores</span>
<span class="sd">        grids in the &quot;gplately&quot; cache.</span>

<span class="sd">        Currently, `DataServer` supports spreading rate grids from the following plate</span>
<span class="sd">        models:</span>

<span class="sd">        * __Clennett et al. 2020__</span>

<span class="sd">            * `file_collection` = `Clennett2020`</span>
<span class="sd">            * Time range: 0-250 Ma</span>
<span class="sd">            * Seafloor spreading rate grids in netCDF format.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : int, or list of int, default=None</span>
<span class="sd">            Request a spreading grid from one (an integer) or multiple reconstruction</span>
<span class="sd">            times (a list of integers).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a gplately.Raster object</span>
<span class="sd">            A gplately.Raster object containing the spreading rate grid. The spreading</span>
<span class="sd">            rate grid data can be extracted into a numpy ndarray or MaskedArray by</span>
<span class="sd">            appending `.data` to the variable assigned to `get_spreading_rate_grid()`.</span>

<span class="sd">            For example:</span>

<span class="sd">                gdownload = gplately.DataServer(&quot;Clennett2020&quot;)</span>

<span class="sd">                graster = gdownload.get_spreading_rate_grid(time=100)</span>

<span class="sd">                graster_data = graster.data</span>

<span class="sd">            where `graster_data` is a numpy ndarray.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `time` (a single integer, or a list of integers representing reconstruction</span>
<span class="sd">            times to extract the spreading rate grids from) is not passed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The first time that `get_spreading_rate_grid` is called for a specific time(s),</span>
<span class="sd">        the spreading rate grid(s) will be downloaded into the GPlately cache once.</span>
<span class="sd">        Upon successive calls of `get_spreading_rate_grid` for the same reconstruction</span>
<span class="sd">        time(s), the grids will not be re-downloaded; rather, they are re-accessed from</span>
<span class="sd">        the same cache location provided they have not been moved or deleted.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        if the `DataServer` object was called with the `Clennett2020` `file_collection` string:</span>

<span class="sd">            gDownload = gplately.download.DataServer(&quot;Clennett2020&quot;)</span>

<span class="sd">        `get_spreading_rate_grid` will download seafloor spreading rate grids from the</span>
<span class="sd">        Clennett et al. (2020) plate reconstruction model for the geological time(s)</span>
<span class="sd">        requested in the `time` parameter. When found, these spreading rate grids are</span>
<span class="sd">        returned as masked arrays.</span>

<span class="sd">        For example, to download Clennett et al. (2020) seafloor spreading rate grids for</span>
<span class="sd">        0Ma, 1Ma and 100 Ma as MaskedArray objects:</span>

<span class="sd">            spreading_rate_grids = gDownload.get_spreading_rate_grid([0, 1, 100])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;The plate model object is None. Unable to get spreading rate grids.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;SpreadingRateGrids&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_cfg</span><span class="p">()[</span><span class="s2">&quot;TimeDepRasters&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;SpreadingRateGrids are not currently available for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">file_collection</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">spread_grids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">time_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_array</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_age</span> <span class="ow">or</span> <span class="n">time_array</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_age</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specify a time range between </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_range</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="n">time_array</span><span class="p">:</span>
            <span class="n">spreadgrid_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmm</span><span class="o">.</span><span class="n">get_raster</span><span class="p">(</span><span class="s2">&quot;SpreadingRateGrids&quot;</span><span class="p">,</span> <span class="n">ti</span><span class="p">)</span>
            <span class="n">spreadgrid</span> <span class="o">=</span> <span class="n">_gplately</span><span class="o">.</span><span class="n">grids</span><span class="o">.</span><span class="n">Raster</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">spreadgrid_filename</span><span class="p">)</span>
            <span class="n">spread_grids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spreadgrid</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spread_grids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spread_grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spread_grids</span></div>


<div class="viewcode-block" id="DataServer.get_valid_times">
<a class="viewcode-back" href="../../gplately.html#gplately.DataServer.get_valid_times">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_valid_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a tuple of the valid plate model time range, (max_time, min_time).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_age</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_age</span></div>


<div class="viewcode-block" id="DataServer.get_raster">
<a class="viewcode-back" href="../../gplately.html#gplately.DataServer.get_raster">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raster_id_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Downloads assorted raster data that are not associated with the plate</span>
<span class="sd">        reconstruction models supported by GPlately&#39;s `DataServer`. Stores rasters in the</span>
<span class="sd">        &quot;gplately&quot; cache.</span>

<span class="sd">        Currently, `DataServer` supports the following rasters and images:</span>

<span class="sd">        * __[ETOPO1](https://www.ngdc.noaa.gov/mgg/global/)__:</span>
<span class="sd">            * Filetypes available : TIF, netCDF (GRD)</span>
<span class="sd">            * `raster_id_string` = `&quot;ETOPO1_grd&quot;`, `&quot;ETOPO1_tif&quot;` (depending on the requested format)</span>
<span class="sd">            * A 1-arc minute global relief model combining lang topography and ocean bathymetry.</span>
<span class="sd">            * Citation: doi:10.7289/V5C8276M</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        raster_id_string : str, default=None</span>
<span class="sd">            A string to identify which raster to download.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a gplately.Raster object</span>
<span class="sd">            A gplately.Raster object containing the raster data. The gridded data can be extracted</span>
<span class="sd">            into a numpy ndarray or MaskedArray by appending `.data` to the variable assigned to `get_raster()`.</span>

<span class="sd">            For example:</span>

<span class="sd">                gdownload = gplately.DataServer(&quot;Muller2019&quot;)</span>

<span class="sd">                graster = gdownload.get_raster(raster_id_string, verbose)</span>

<span class="sd">                graster_data = graster.data</span>

<span class="sd">            where `graster_data` is a numpy ndarray. This array can be visualised using</span>
<span class="sd">            `matplotlib.pyplot.imshow` on a `cartopy.mpl.GeoAxis` GeoAxesSubplot</span>
<span class="sd">            (see example below).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * if a `raster_id_string` is not supplied.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Rasters obtained by this method are (so far) only reconstructed to present-day.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To download ETOPO1 and plot it on a Mollweide projection:</span>

<span class="sd">            import gplately</span>
<span class="sd">            import numpy as np</span>
<span class="sd">            import matplotlib.pyplot as plt</span>
<span class="sd">            import cartopy.crs as ccrs</span>

<span class="sd">            gdownload = gplately.DataServer(&quot;Muller2019&quot;)</span>
<span class="sd">            etopo1 = gdownload.get_raster(&quot;ETOPO1_tif&quot;)</span>
<span class="sd">            fig = plt.figure(figsize=(18,14), dpi=300)</span>
<span class="sd">            ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))</span>
<span class="sd">            ax2.imshow(etopo1, extent=[-180,180,-90,90], transform=ccrs.PlateCarree())</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">raster_id_string</span><span class="p">:</span>
            <span class="n">raster_path</span> <span class="o">=</span> <span class="n">PresentDayRasterManager</span><span class="p">()</span><span class="o">.</span><span class="n">get_raster</span><span class="p">(</span><span class="n">raster_id_string</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">raster_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.grd&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">raster_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">):</span>
                <span class="n">raster</span> <span class="o">=</span> <span class="n">_gplately</span><span class="o">.</span><span class="n">grids</span><span class="o">.</span><span class="n">Raster</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">raster_path</span><span class="p">)</span>
            <span class="c1"># Otherwise, the raster is an image; use imread to process</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">image</span>

                <span class="n">raster_matrix</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span>
                <span class="n">raster</span> <span class="o">=</span> <span class="n">_gplately</span><span class="o">.</span><span class="n">grids</span><span class="o">.</span><span class="n">Raster</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">raster_matrix</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">raster_id_string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;etopo1_tif&quot;</span><span class="p">:</span>
                <span class="n">raster</span><span class="o">.</span><span class="n">lats</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">lats</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">raster_id_string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;etopo1_grd&quot;</span><span class="p">:</span>
                <span class="n">raster</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="k">return</span> <span class="n">raster</span></div>


<div class="viewcode-block" id="DataServer.get_feature_data">
<a class="viewcode-back" href="../../gplately.html#gplately.DataServer.get_feature_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_feature_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_data_id_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Downloads assorted geological feature data from web servers (i.e.</span>
<span class="sd">        [GPlates 2.3 sample data](https://www.earthbyte.org/gplates-2-3-software-and-data-sets/))</span>
<span class="sd">        into the &quot;gplately&quot; cache.</span>

<span class="sd">        Currently, `DataServer` supports the following feature data:</span>

<span class="sd">        * __Large igneous provinces from Johansson et al. (2018)__</span>

<span class="sd">            Information</span>
<span class="sd">            -----------</span>
<span class="sd">            * Formats: .gpmlz</span>
<span class="sd">            * `feature_data_id_string` = `Johansson2018`</span>

<span class="sd">            Citations</span>
<span class="sd">            ---------</span>
<span class="sd">            * Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The</span>
<span class="sd">            interplay between the eruption and weathering of Large Igneous Provinces and</span>
<span class="sd">            the deep-time carbon cycle: Geophysical Research Letters.</span>


<span class="sd">        - __Large igneous province products interpreted as plume products from Whittaker</span>
<span class="sd">        et al. (2015)__.</span>

<span class="sd">            Information</span>
<span class="sd">            -----------</span>
<span class="sd">            * Formats: .gpmlz, .shp</span>
<span class="sd">            * `feature_data_id_string` = `Whittaker2015`</span>

<span class="sd">            Citations</span>
<span class="sd">            ---------</span>
<span class="sd">            * Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D.,</span>
<span class="sd">            Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between</span>
<span class="sd">            mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483.</span>
<span class="sd">            doi:10.1038/ngeo2437.</span>


<span class="sd">        - __Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures,</span>
<span class="sd">        unclassified V-anomalies, propagating ridge lineations and extinct ridges) from</span>
<span class="sd">        Matthews et al. (2011)__</span>

<span class="sd">            Information</span>
<span class="sd">            -----------</span>
<span class="sd">            * Formats: .gpml</span>
<span class="sd">            * `feature_data_id_string` = `SeafloorFabric`</span>

<span class="sd">            Citations</span>
<span class="sd">            ---------</span>
<span class="sd">            * Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The</span>
<span class="sd">            tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12):</span>
<span class="sd">            B12109, DOI: 10.1029/2011JB008413.</span>


<span class="sd">        - __Present day surface hotspot/plume locations from Whittaker et al. (2013)__</span>

<span class="sd">            Information</span>
<span class="sd">            -----------</span>
<span class="sd">            * Formats: .gpmlz</span>
<span class="sd">            * `feature_data_id_string` = `Hotspots`</span>

<span class="sd">            Citation</span>
<span class="sd">            --------</span>
<span class="sd">            * Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P.,</span>
<span class="sd">            Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and</span>
<span class="sd">            mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        feature_data_id_string : str, default=None</span>
<span class="sd">            A string to identify which feature data to download to the cache (see list of supported</span>
<span class="sd">            feature data above).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        feature_data_filenames : instance of &lt;pygplates.FeatureCollection&gt;, or list of instance &lt;pygplates.FeatureCollection&gt;</span>
<span class="sd">            If a single set of feature data is downloaded, a single pyGPlates `FeatureCollection`</span>
<span class="sd">            object is returned. Otherwise, a list containing multiple pyGPlates `FeatureCollection`</span>
<span class="sd">            objects is returned (like for `SeafloorFabric`). In the latter case, feature reconstruction</span>
<span class="sd">            and plotting may have to be done iteratively.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a `feature_data_id_string` is not provided.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        For examples of plotting data downloaded with `get_feature_data`, see GPlately&#39;s sample</span>
<span class="sd">        notebook 05 - Working With Feature Geometries [here](https://github.com/GPlates/gplately/blob/master/Notebooks/05-WorkingWithFeatureGeometries.ipynb).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">feature_data_id_string</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please specify which feature data to fetch.&quot;</span><span class="p">)</span>

        <span class="n">database</span> <span class="o">=</span> <span class="n">_gplately</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_feature_data</span><span class="p">()</span>

        <span class="n">found_collection</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">collection</span><span class="p">,</span> <span class="n">zip_url</span> <span class="ow">in</span> <span class="n">database</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">feature_data_id_string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">collection</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="n">found_collection</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">feature_data_filenames</span> <span class="o">=</span> <span class="n">_collection_sorter</span><span class="p">(</span>
                    <span class="n">_collect_file_extension</span><span class="p">(</span>
                        <span class="n">download_from_web</span><span class="p">(</span><span class="n">zip_url</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;.gpml&quot;</span><span class="p">,</span> <span class="s2">&quot;.gpmlz&quot;</span><span class="p">]</span>
                    <span class="p">),</span>
                    <span class="n">collection</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">break</span>

        <span class="k">if</span> <span class="n">found_collection</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> are not in GPlately&#39;s DataServer.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">feature_data_id_string</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">feat_data</span> <span class="o">=</span> <span class="n">_pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_data_filenames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">feat_data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">feature_data_filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">feat_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feat_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">feature_data_filenames</span><span class="p">:</span>
                <span class="n">feat_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">feat_data</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, The University of Sydney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>