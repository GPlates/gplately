

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gplately.points &mdash; gplately 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=51b770b3"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            gplately
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basic_usages.html">Minimal working example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../use_cases.html">Common Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Trouble-shooting and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../command_line_interface.html">Command Line Interface (CLI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primer.html">Primer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Main Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../secondaries.html">Other Classes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">gplately</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gplately.points</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gplately.points</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">#    Copyright (C) 2024 The University of Sydney, Australia</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1">#    the terms of the GNU General Public License, version 2, as published by</span>
<span class="c1">#    the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c1">#    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="c1">#    for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License along</span>
<span class="c1">#    with this program; if not, write to Free Software Foundation, Inc.,</span>
<span class="c1">#    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="c1">#</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pygplates</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">tools</span> <span class="k">as</span> <span class="n">_tools</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;gplately&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Points">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Points</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruct and work with geological point data.</span>

<span class="sd">    The locations and plate velocities of point data can be calculated at a specific geological time.</span>
<span class="sd">    The :py:class:`Points` class depends on the :py:class:`PlateReconstruction` class,</span>
<span class="sd">    as it provides essential components for reconstructing plate motions.</span>
<span class="sd">    Specifically, it uses the :py:attr:`PlateReconstruction.rotation_model` to compute point rotations through time,</span>
<span class="sd">    and the :py:attr:`PlateReconstruction.static_polygons` to assign points to their respective tectonic plates.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Points.__init__">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">plate_reconstruction</span><span class="p">,</span>
        <span class="n">lons</span><span class="p">,</span>
        <span class="n">lats</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">age</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">remove_unreconstructable_points</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plate_reconstruction : PlateReconstruction</span>
<span class="sd">            Object to provide the following essential components for reconstructing points.</span>

<span class="sd">            * :py:attr:`PlateReconstruction.rotation_model`</span>
<span class="sd">            * :py:attr:`PlateReconstruction.topology_featues`</span>
<span class="sd">            * :py:attr:`PlateReconstruction.static_polygons`</span>

<span class="sd">        lons : float or 1D array</span>
<span class="sd">            Longitudes of the initial points at the initial ``time``.</span>

<span class="sd">        lats : float or 1D array</span>
<span class="sd">            Latitudes of the initial points at the initial ``time``.</span>

<span class="sd">        time : float, default=0</span>
<span class="sd">            The initial time (Ma) of the points.</span>
<span class="sd">            The ``lons`` and ``lats`` are the initial coordinates of the points at this time.</span>
<span class="sd">            By default, it is set to the present day (0 Ma).</span>

<span class="sd">        plate_id : int or 1D array or None, default=None</span>
<span class="sd">            Plate ID(s) of a particular tectonic plate on which point data lies, if known.</span>
<span class="sd">            If it is a single integer then all points will have the same plate ID. If it is a 1D array then length must match the number of points.</span>
<span class="sd">            If ``None`` then plate IDs are determined using the :py:attr:`PlateReconstruction.static_polygons`.</span>
<span class="sd">            By default, the plate IDs are determined using the static polygons.</span>

<span class="sd">        age : float or 1D array or None, default=numpy.inf</span>
<span class="sd">            Age(s) at which each point appears, if known.</span>
<span class="sd">            If it is a single float then all points will have the same age.</span>
<span class="sd">            If it is a 1D array then length must match the number of points.</span>
<span class="sd">            If ``None`` then ages are determined using the :py:attr:`PlateReconstruction.static_polygons`.</span>
<span class="sd">            For points on oceanic crust this is when they were created at a mid-ocean ridge.</span>
<span class="sd">            By default, all points exist for all time (ie, time of appearance is infinity). This default is for backward</span>
<span class="sd">            compatibility, but you&#39;ll typically only want this if all your points are on **continental** crust (not *oceanic*).</span>

<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Anchor plate ID that the specified ``lons`` and ``lats`` are relative to.</span>
<span class="sd">            Defaults to the current anchor plate ID of ``plate_reconstruction`` (its ``anchor_plate_id`` attribute).</span>

<span class="sd">        remove_unreconstructable_points : bool or list, default=False</span>
<span class="sd">            Whether to remove points that cannot be reconstructed.</span>
<span class="sd">            By default, all unreconstructable points are retained.</span>
<span class="sd">            A point cannot be reconstructed if it cannot be assigned a plate ID, or cannot be assigned an age, because it did not</span>
<span class="sd">            intersect any reconstructed static polygons (note that this can only happen when ``plate_id`` and/or ``age`` is None).</span>
<span class="sd">            Also, a point cannot be reconstructed if point ages were **explicitly** provided (ie, ``age`` was **not** None) and</span>
<span class="sd">            a point&#39;s age was less than (younger than) ``time``, meaning it did not exist as far back as ``time``.</span>
<span class="sd">            Additionally, if this variable is a :py:class:`list` then the indices (into the supplied ``lons`` and ``lats`` arguments)</span>
<span class="sd">            of any removed points (ie, that are unreconstructable) are appended to that list.</span>


<span class="sd">        .. _points-note:</span>
<span class="sd">        .. note::</span>

<span class="sd">            If ``time`` is non-zero (ie, not present day) then ``lons`` and ``lats`` are assumed to be the **reconstructed** point</span>
<span class="sd">            locations at ``time``. And the reconstructed positions are assumed to be relative to the anchor plate</span>
<span class="sd">            (which is ``plate_reconstruction.anchor_plate_id`` if ``anchor_plate_id`` is None).</span>

<span class="sd">            If ``plate_id`` and/or ``age`` is None then the plate ID and/or age of each point is determined by reconstructing the static polygons</span>
<span class="sd">            of ``plate_reconstruction`` to ``time`` and reconstructing relative to the anchor plate (regardless of whether ``time`` is present day or not).</span>
<span class="sd">            And then, for each point, assigning the plate ID and/or time-of-appearance (begin time) of the static polygon containing the point.</span>

<span class="sd">            A point is considered unreconstructable if it does not exist at ``time``. This can happen if its age was explicitly provided (ie, ``age`` is **not** None)</span>
<span class="sd">            but is younger than ``time``. It can also happen if the point is automatically assigned a plate ID (ie, ``plate_id`` is None) or an age (ie, ``age`` is None)</span>
<span class="sd">            but does not intersect any reconstructed static polygons (at ``time``). In either of these cases it is marked as unreconstructable and will not be available</span>
<span class="sd">            for any method outputing a reconstruction, such as :meth:`reconstruct()`, or any method depending on a reconstruction, such as :meth:`plate_velocity`.</span>
<span class="sd">            However, all the initial locations and their associated plate IDs and ages will still be accessible as attributes, regardless of whether all the points</span>
<span class="sd">            are reconstructable or not. That is, unless ``remove_unreconstructable_points`` is True (or a :py:class:`list`),</span>
<span class="sd">            in which case only the reconstructable points are retained.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If anchor plate is None then use default anchor plate of &#39;plate_reconstruction&#39;.</span>
        <span class="k">if</span> <span class="n">anchor_plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">anchor_plate_id</span> <span class="o">=</span> <span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">anchor_plate_id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">anchor_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_anchor_plate_id</span><span class="p">(</span><span class="n">anchor_plate_id</span><span class="p">)</span>

        <span class="n">point_ages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">point_plate_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># The caller can specify a &#39;list&#39; for the &#39;remove_unreconstructable_points&#39; argument if they want us to</span>
        <span class="c1"># return the indices of any points that are NOT reconstructable.</span>
        <span class="c1">#</span>
        <span class="c1"># Otherwise &#39;remove_unreconstructable_points&#39; must be true or false.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">remove_unreconstructable_points</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">unreconstructable_point_indices_list</span> <span class="o">=</span> <span class="n">remove_unreconstructable_points</span>
            <span class="n">remove_unreconstructable_points</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unreconstructable_point_indices_list</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Most common case first: both are sequences.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">lats</span><span class="p">):</span>
            <span class="c1"># Make sure numpy arrays (if not already).</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lats</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;lons&#39; and &#39;lats&#39; must be of equal length (</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">lats</span><span class="p">):</span>
            <span class="c1"># Both are scalars. Convert to arrays with one element.</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Both &#39;lats&#39; and &#39;lons&#39; must both be a sequence or both a scalar&quot;</span>
            <span class="p">)</span>

        <span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>

        <span class="c1"># If caller provided plate IDs.</span>
        <span class="k">if</span> <span class="n">plate_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If plate ID is a scalar then all points have the same plate ID.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">plate_id</span><span class="p">):</span>
                <span class="n">point_plate_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="n">plate_id</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point_plate_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">plate_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_plate_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_points</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;plate_id&#39; must be same length as &#39;lons&#39; and &#39;lats&#39; (</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">point_plate_ids</span><span class="p">),</span> <span class="n">num_points</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="c1"># If caller provided begin ages.</span>
        <span class="k">if</span> <span class="n">age</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If age is a scalar then all points have the same age.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
                <span class="n">point_ages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point_ages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_ages</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_points</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;age&#39; must be same length as &#39;lons&#39; and &#39;lats&#39; (</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">point_ages</span><span class="p">),</span> <span class="n">num_points</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="c1"># Create pygplates points.</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)]</span>

        <span class="c1"># If plate IDs and/or ages are automatically assigned using reconstructed static polygons then</span>
        <span class="c1"># some points might be outside all reconstructed static polygons, and hence not reconstructable.</span>
        <span class="c1">#</span>
        <span class="c1"># However, if the user provided both plate IDs and ages then all points will be reconstructable.</span>
        <span class="n">points_are_reconstructable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># If caller did not provide plate IDs or begin ages then</span>
        <span class="c1"># we need to determine them using the static polygons.</span>
        <span class="k">if</span> <span class="n">plate_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">age</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">point_plate_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">age</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">point_ages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span>

            <span class="c1"># Assign a plate ID to each point based on which reconstructed static polygon it&#39;s inside.</span>
            <span class="n">static_polygons_snapshot</span> <span class="o">=</span> <span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">static_polygons_snapshot</span><span class="p">(</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">reconstructed_static_polygons_containing_points</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">static_polygons_snapshot</span><span class="o">.</span><span class="n">get_point_locations</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_points</span><span class="p">):</span>
                <span class="n">reconstructed_static_polygon</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">reconstructed_static_polygons_containing_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="c1"># If current point is inside a reconstructed static polygon then assign its plate ID to the point,</span>
                <span class="c1"># otherwise assign the anchor plate to the point.</span>
                <span class="k">if</span> <span class="n">reconstructed_static_polygon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">reconstructed_static_polygon_feature</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">reconstructed_static_polygon</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">point_plate_ids</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">reconstructed_static_polygon_feature</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">age</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">point_ages</span><span class="p">[</span><span class="n">point_index</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">reconstructed_static_polygon_feature</span><span class="o">.</span><span class="n">get_valid_time</span><span class="p">()</span>
                        <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># current point did NOT intersect a reconstructed static polygon ...</span>

                    <span class="c1"># We&#39;re trying to assign a plate ID or assign an age (or both), neither of which we can assign.</span>
                    <span class="c1"># That essentially makes the current point unreconstructable.</span>
                    <span class="c1">#</span>
                    <span class="c1"># Mark the current point as unreconstructable.</span>
                    <span class="n">points_are_reconstructable</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="k">if</span> <span class="n">plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Assign the anchor plate ID to indicate we could NOT assign a proper plate ID.</span>
                        <span class="n">point_plate_ids</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">anchor_plate_id</span>
                    <span class="k">if</span> <span class="n">age</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Assign the distant future (not distant past) to indicate we could NOT assign a proper age.</span>
                        <span class="n">point_ages</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># distant future</span>

        <span class="c1"># If point ages were explicitly provided by the caller then we need to check if points existed at &#39;time&#39;.</span>
        <span class="k">if</span> <span class="n">age</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Any point with an age younger than &#39;time&#39; did not exist at &#39;time&#39; and hence is not reconstructable.</span>
            <span class="n">points_are_reconstructable</span><span class="p">[</span><span class="n">point_ages</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># If requested, remove any unreconstructable points.</span>
        <span class="k">if</span> <span class="n">remove_unreconstructable_points</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">points_are_reconstructable</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">unreconstructable_point_indices_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Caller requested the indices of points that are NOT reconstructable.</span>
                <span class="n">unreconstructable_point_indices_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">points_are_reconstructable</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="n">points_are_reconstructable</span><span class="p">]</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="p">[</span><span class="n">points_are_reconstructable</span><span class="p">]</span>
            <span class="n">point_plate_ids</span> <span class="o">=</span> <span class="n">point_plate_ids</span><span class="p">[</span><span class="n">points_are_reconstructable</span><span class="p">]</span>
            <span class="n">point_ages</span> <span class="o">=</span> <span class="n">point_ages</span><span class="p">[</span><span class="n">points_are_reconstructable</span><span class="p">]</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">points_are_reconstructable</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="c1"># All points are now reconstructable.</span>
            <span class="n">points_are_reconstructable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Create a feature for each point.</span>
        <span class="c1">#</span>
        <span class="c1"># Each feature has a point, a plate ID and a valid time range.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: The valid time range always includes present day.</span>
        <span class="n">point_features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_points</span><span class="p">):</span>
            <span class="n">point_feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="p">()</span>
            <span class="c1"># Set the geometry.</span>
            <span class="n">point_feature</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">point_index</span><span class="p">])</span>
            <span class="c1"># Set the plate ID.</span>
            <span class="n">point_feature</span><span class="o">.</span><span class="n">set_reconstruction_plate_id</span><span class="p">(</span><span class="n">point_plate_ids</span><span class="p">[</span><span class="n">point_index</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># Set the begin/end time.</span>
            <span class="n">point_feature</span><span class="o">.</span><span class="n">set_valid_time</span><span class="p">(</span>
                <span class="n">point_ages</span><span class="p">[</span><span class="n">point_index</span><span class="p">],</span>  <span class="c1"># begin (age)</span>
                <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>  <span class="c1"># end (distant future; could also be zero for present day)</span>
            <span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">point_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_feature</span><span class="p">)</span>

        <span class="c1"># If the points represent a snapshot at a *past* geological time then we need to reverse reconstruct them</span>
        <span class="c1"># such that their features contain present-day points.</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pygplates</span><span class="o">.</span><span class="n">reverse_reconstruct</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="n">point_features</span><span class="p">,</span>
                <span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span><span class="p">,</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Map each unique plate ID to indices of points assigned that plate ID.</span>
        <span class="n">unique_plate_id_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">unique_plate_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">point_plate_ids</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">unique_plate_id</span> <span class="ow">in</span> <span class="n">unique_plate_ids</span><span class="p">:</span>
            <span class="c1"># Determine which points have the current unique plate ID.</span>
            <span class="n">unique_plate_id_point_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">point_plate_ids</span> <span class="o">==</span> <span class="n">unique_plate_id</span>
            <span class="p">)[</span>
                <span class="mi">0</span>
            <span class="p">]</span>  <span class="c1"># convert 1-tuple of 1D array to 1D array</span>
            <span class="n">unique_plate_id_groups</span><span class="p">[</span><span class="n">unique_plate_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_plate_id_point_indices</span>

        <span class="c1">#</span>
        <span class="c1"># Assign data members.</span>
        <span class="c1">#</span>

        <span class="c1"># Note: These are documented attributes (in class docstring).</span>
        <span class="c1">#       And they cannot be changed later (they are properties with no setter).</span>
        <span class="c1">#       The other attributes probably should be readonly too (but at least they&#39;re not documented).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plate_reconstruction</span> <span class="o">=</span> <span class="n">plate_reconstruction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span> <span class="o">=</span> <span class="n">lons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span> <span class="o">=</span> <span class="n">lats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plate_id</span> <span class="o">=</span> <span class="n">point_plate_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_age</span> <span class="o">=</span> <span class="n">point_ages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_anchor_plate_id</span> <span class="o">=</span> <span class="n">anchor_plate_id</span>

        <span class="c1"># get Cartesian coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">_tools</span><span class="o">.</span><span class="n">lonlat2xyz</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># scale by average radius of the Earth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*=</span> <span class="n">_tools</span><span class="o">.</span><span class="n">EARTH_RADIUS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*=</span> <span class="n">_tools</span><span class="o">.</span><span class="n">EARTH_RADIUS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">*=</span> <span class="n">_tools</span><span class="o">.</span><span class="n">EARTH_RADIUS</span>
        <span class="c1"># store concatenated arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lonlat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reconstructable</span> <span class="o">=</span> <span class="n">points_are_reconstructable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_plate_id_groups</span> <span class="o">=</span> <span class="n">unique_plate_id_groups</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">=</span> <span class="n">point_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_collection</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">point_features</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Remove the unpicklable entries.</span>
        <span class="c1">#</span>
        <span class="c1"># This includes pygplates reconstructed feature geometries and resolved topological geometries.</span>
        <span class="c1"># Note: PyGPlates features and features collections (and rotation models) can be pickled though.</span>
        <span class="c1">#</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1"># Restore the unpicklable entries.</span>
        <span class="c1">#</span>
        <span class="c1"># This includes pygplates reconstructed feature geometries and resolved topological geometries.</span>
        <span class="c1"># Note: PyGPlates features and features collections (and rotation models) can be pickled though.</span>
        <span class="c1">#</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plate_reconstruction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Object to provide the following essential components for reconstructing points.</span>

<span class="sd">        * :py:attr:`PlateReconstruction.rotation_model`</span>
<span class="sd">        * :py:attr:`PlateReconstruction.topology_featues`</span>
<span class="sd">        * :py:attr:`PlateReconstruction.static_polygons`</span>

<span class="sd">        :type: PlateReconstruction</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plate_reconstruction</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Longitudes of the initial points at the initial ``time``.</span>

<span class="sd">        :type: float 1D array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lons</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Latitudes of the initial points at the initial ``time``.</span>

<span class="sd">        :type: float 1D array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lats</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plate_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 1D array containing the plate IDs of the points.</span>
<span class="sd">        The length must match that of ``lons`` and ``lats``.</span>

<span class="sd">        :type: int 1D array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plate_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">age</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 1D array containing the ages (time of appearance) of the points.</span>
<span class="sd">        The length must match that of ``lons`` and ``lats``.</span>
<span class="sd">        For points on oceanic crust this is when they were created at a mid-ocean ridge.</span>
<span class="sd">        Any points existing for all time will have a value of ``numpy.inf`` (equivalent to ``float(&#39;inf&#39;)``).</span>

<span class="sd">        :type: float 1D array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of points.</span>
<span class="sd">        This is the size of ``lons``, ``lats``, ``plate_id`` and ``age``.</span>

<span class="sd">        :type: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The initial time (Ma) of the points.</span>
<span class="sd">        The initial ``lons`` and ``lats`` are the coordinates of the points at this time.</span>

<span class="sd">        :type: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">anchor_plate_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Anchor plate that the initial ``lons`` and ``lats`` are relative to, at the initial ``time``.</span>
<span class="sd">        This is also used as the default anchor plate when reconstructing the points.</span>
<span class="sd">        It does not change, even if the anchor plate of ``plate_reconstruction`` subsequently changes.</span>

<span class="sd">        :type: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anchor_plate_id</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_check_anchor_plate_id</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid anchor plate ID: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">id</span>

<div class="viewcode-block" id="Points.copy">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a copy of the :py:class:`Points` object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Points</span>
<span class="sd">            A copy of the current :py:class:`Points` object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gpts</span> <span class="o">=</span> <span class="n">Points</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plate_id</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">gpts</span><span class="o">.</span><span class="n">add_attributes</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>


<div class="viewcode-block" id="Points.add_attributes">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.add_attributes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds the value of a feature attribute associated with a key.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : sequence of key=item/s</span>
<span class="sd">            A single key=value pair, or a sequence of key=value pairs denoting the name and</span>
<span class="sd">            value of an attribute.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            # Define latitudes and longitudes to set up a Points object</span>
<span class="sd">            pt_lons = np.array([140., 150., 160.])</span>
<span class="sd">            pt_lats = np.array([-30., -40., -50.])</span>

<span class="sd">            gpts = gplately.Points(model, pt_lons, pt_lats)</span>

<span class="sd">            # Add the attributes a, b and c to the points in the Points object</span>
<span class="sd">            gpts.add_attributes(</span>
<span class="sd">                a=[10,2,2],</span>
<span class="sd">                b=[2,3,3],</span>
<span class="sd">                c=[30,0,0],</span>
<span class="sd">            )</span>

<span class="sd">            print(gpts.attributes)</span>

<span class="sd">        The output would be:</span>

<span class="sd">        .. code:: console</span>

<span class="sd">            {&#39;a&#39;: [10, 2, 2], &#39;b&#39;: [2, 3, 3], &#39;c&#39;: [30, 0, 0]}</span>


<span class="sd">        .. note::</span>

<span class="sd">            An **assertion** is raised if the number of points in the Points object is not equal</span>
<span class="sd">            to the number of values associated with an attribute key. For example, consider an instance</span>
<span class="sd">            of the Points object with 3 points. If the points are ascribed an attribute ``temperature``,</span>
<span class="sd">            there must be one ``temperature`` value per point, i.e. ``temperature = [20, 15, 17.5]``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">attribute</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="c1"># make sure attribute is the same size as self.lons</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
                <span class="n">attribute</span> <span class="o">=</span> <span class="n">array</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">attribute</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">attribute</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">attribute</span> <span class="o">=</span> <span class="n">array</span>

            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="o">.</span><span class="n">size</span>
            <span class="p">),</span> <span class="s2">&quot;Size mismatch, ensure attributes have the same number of entries as Points&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">attribute</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># add these to the FeatureCollection</span>
            <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_collection</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="c1"># extract value for each row in attribute</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">f</span><span class="p">]</span>

                    <span class="c1"># set this attribute on the feature</span>
                    <span class="n">feature</span><span class="o">.</span><span class="n">set_shapefile_attribute</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>


<div class="viewcode-block" id="Points.get_geopandas_dataframe">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.get_geopandas_dataframe">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_geopandas_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a ``geopandas.GeoDataFrame`` object for the points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoDataFrame : geopandas.GeoDataFrame</span>
<span class="sd">            A ``geopandas.GeoDataFrame`` object with rows equal to the number of points in the :class:`Points` object,</span>
<span class="sd">            and an additional column containing a shapely ``geometry`` attribute.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            pt_lons = np.array([140., 150., 160.])</span>
<span class="sd">            pt_lats = np.array([-30., -40., -50.])</span>

<span class="sd">            gpts = gplately.Points(model, pt_lons, pt_lats)</span>

<span class="sd">            # Add sample attributes a, b and c to the points in the Points object</span>
<span class="sd">            gpts.add_attributes(</span>
<span class="sd">                a=[10,2,2],</span>
<span class="sd">                b=[2,3,3],</span>
<span class="sd">                c=[30,0,0],</span>
<span class="sd">            )</span>

<span class="sd">            gpts.get_geopandas_dataframe()</span>

<span class="sd">        has the output:</span>

<span class="sd">        .. code:: console</span>

<span class="sd">                a  b   c                     geometry</span>
<span class="sd">            0  10  2  30  POINT (140.00000 -30.00000)</span>
<span class="sd">            1   2  3   0  POINT (150.00000 -40.00000)</span>
<span class="sd">            2   2  3   0  POINT (160.00000 -50.00000)</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="kn">import</span> <span class="n">geometry</span>

        <span class="c1"># create shapely points</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">):</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span>

        <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Points.get_geodataframe">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.get_geodataframe">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_geodataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The same as :meth:`get_geopandas_dataframe`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_geopandas_dataframe</span><span class="p">()</span></div>


<div class="viewcode-block" id="Points.reconstruct">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.reconstruct">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstruct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_point_indices</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconstruct points from the initial time (``self.time``) to the specified time (``time``).</span>

<span class="sd">        Only those points that are reconstructable (See :ref:`Notes &lt;points-note&gt;`) and that have ages greater than or equal</span>
<span class="sd">        to ``time`` (ie, at points that exist at ``time``) are reconstructed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : float</span>
<span class="sd">            The specific geological time (Ma) to reconstruct features to.</span>

<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Reconstruct features with respect to a certain anchor plate.</span>
<span class="sd">            By default, reconstructions are made with respect to ``self.anchor_plate_id``</span>
<span class="sd">            (which is the anchor plate that the initial points at the initial time are relative to).</span>

<span class="sd">        return_array : bool, default=False</span>
<span class="sd">            Return a 2-tuple of ``numpy.ndarray``, rather than a :class:`Points` object.</span>

<span class="sd">        return_point_indices : bool, default=False</span>
<span class="sd">            Return the indices of the points that are reconstructed.</span>
<span class="sd">            Those points with an age less than ``time`` have not yet appeared at ``time``, and therefore are not reconstructed.</span>
<span class="sd">            These are indices into ``self.lons``, ``self.lats``, ``self.plate_id`` and ``self.age``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reconstructed_points : :class:`Points`</span>
<span class="sd">            If the ``return_array`` is False, return the reconstructed points in a :class:`Points` object.</span>
<span class="sd">        rlons, rlats : ndarray</span>
<span class="sd">            If the ``return_array`` is True, return the longitude and latitude coordinate arrays of the reconstructed points.</span>
<span class="sd">        point_indices : ndarray</span>
<span class="sd">            If the ``return_point_indices`` is True, return the indices of the returned points (that are reconstructed).</span>
<span class="sd">            This array is the same size as ``rlons`` and ``rlats`` (or size of ``reconstructed_points``).</span>
<span class="sd">            These are indices into ``self.lons``, ``self.lats``, ``self.plate_id`` and ``self.age``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">anchor_plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">anchor_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span>

        <span class="c1"># Start with an empty array.</span>
        <span class="n">lat_lon_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Determine which points are valid.</span>
        <span class="c1">#</span>
        <span class="c1"># These are those points that are reconstructable and have appeared before (or at) &#39;time&#39;</span>
        <span class="c1"># (ie, have a time-of-appearance that&#39;s greater than or equal to &#39;time&#39;).</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconstructable</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="n">time</span><span class="p">)</span>

        <span class="c1"># Iterate over groups of points with the same plate ID.</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">plate_id</span><span class="p">,</span>
            <span class="n">point_indices_with_plate_id</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_plate_id_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Determine which points (indices) with the current unique plate ID are valid.</span>
            <span class="n">point_indices_with_plate_id</span> <span class="o">=</span> <span class="n">point_indices_with_plate_id</span><span class="p">[</span>
                <span class="n">valid_mask</span><span class="p">[</span><span class="n">point_indices_with_plate_id</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="c1"># If none of the points (with the current unique plate ID) are valid then skip to next unique plate ID.</span>
            <span class="k">if</span> <span class="n">point_indices_with_plate_id</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Get the reconstructed points with the current unique plate ID that have appeared before (or at) &#39;time&#39;.</span>
            <span class="n">reconstructed_points_with_plate_id</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="n">point_indices_with_plate_id</span>
            <span class="p">)</span>

            <span class="c1"># First reconstruct the internal points from the initial time (&#39;self.time&#39;) to present day using</span>
            <span class="c1"># our internal anchor plate ID (the same anchor plate used in &#39;__init__&#39;).</span>
            <span class="c1"># Then reconstruct from present day to &#39;time&#39; using the *requested* anchor plate ID.</span>
            <span class="c1">#</span>
            <span class="c1"># Note &#39;self.points&#39; (and hence &#39;reconstructed_points_with_plate_id&#39;) are the locations at &#39;self.time&#39;</span>
            <span class="c1">#      (just like &#39;self.lons&#39; and &#39;self.lats&#39;).</span>
            <span class="n">reconstruct_rotation</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
                    <span class="n">to_time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">moving_plate_id</span><span class="o">=</span><span class="n">plate_id</span><span class="p">,</span>
                    <span class="n">from_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
                    <span class="n">to_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">moving_plate_id</span><span class="o">=</span><span class="n">plate_id</span><span class="p">,</span>
                    <span class="n">from_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">anchor_plate_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">reconstructed_points_with_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">reconstruct_rotation</span> <span class="o">*</span> <span class="n">reconstructed_points_with_plate_id</span>
            <span class="p">)</span>

            <span class="c1"># Write the reconstructed points.</span>
            <span class="n">lat_lon_points</span><span class="p">[</span><span class="n">point_indices_with_plate_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">rpoint</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span> <span class="k">for</span> <span class="n">rpoint</span> <span class="ow">in</span> <span class="n">reconstructed_points_with_plate_id</span>
            <span class="p">]</span>

        <span class="n">rlonslats</span> <span class="o">=</span> <span class="n">lat_lon_points</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>  <span class="c1"># remove invalid points</span>
        <span class="n">rlons</span> <span class="o">=</span> <span class="n">rlonslats</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">rlats</span> <span class="o">=</span> <span class="n">rlonslats</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">return_tuple</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">if</span> <span class="n">return_array</span><span class="p">:</span>
            <span class="n">return_tuple</span> <span class="o">+=</span> <span class="n">rlons</span><span class="p">,</span> <span class="n">rlats</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reconstructed_points</span> <span class="o">=</span> <span class="n">Points</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="p">,</span>
                <span class="n">rlons</span><span class="p">,</span>
                <span class="n">rlats</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">plate_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plate_id</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span>  <span class="c1"># remove invalid points</span>
                <span class="n">age</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span>  <span class="c1"># remove invalid points</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">reconstructed_points</span><span class="o">.</span><span class="n">add_attributes</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">return_tuple</span> <span class="o">+=</span> <span class="p">(</span><span class="n">reconstructed_points</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">return_point_indices</span><span class="p">:</span>
            <span class="n">all_point_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">point_indices</span> <span class="o">=</span> <span class="n">all_point_indices</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>  <span class="c1"># remove invalid points</span>
            <span class="n">return_tuple</span> <span class="o">+=</span> <span class="p">(</span><span class="n">point_indices</span><span class="p">,)</span>

        <span class="c1"># Return tuple of objects (unless only a single object, eg, just a &#39;Points&#39; object).</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_tuple</span></div>


<div class="viewcode-block" id="Points.reconstruct_to_birth_age">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.reconstruct_to_birth_age">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstruct_to_birth_age</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ages</span><span class="p">,</span> <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_point_indices</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconstruct points from the initial time (``self.time``) to a range of times.</span>

<span class="sd">        The number of supplied times must equal the number of points supplied to this :class:`Points` object (ie, ``self.size`` attribute).</span>
<span class="sd">        Only those points that are reconstructable (See :ref:`Notes &lt;points-note&gt;`) and that have ages greater than or equal</span>
<span class="sd">        to the respective supplied ages (ie, at points that exist at the supplied ages) are reconstructed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ages : array</span>
<span class="sd">            Geological times to reconstruct points to. Must have the same length as the number of points (``self.size`` attribute).</span>

<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Reconstruct points with respect to a certain anchor plate.</span>
<span class="sd">            By default, reconstructions are made with respect to ``self.anchor_plate_id``</span>
<span class="sd">            (which is the anchor plate that the initial points at the initial time are relative to).</span>

<span class="sd">        return_point_indices : bool, default=False</span>
<span class="sd">            Return the indices of the points that are reconstructed.</span>
<span class="sd">            Those points with an age less than their respective supplied age have not yet appeared, and therefore are not reconstructed.</span>
<span class="sd">            These are indices into ``self.lons``, ``self.lats``, ``self.plate_id`` and ``self.age``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of ages is not equal to the number of points supplied to this :class:`Points` object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rlons, rlats : ndarray</span>
<span class="sd">            The longitude and latitude coordinate arrays of points reconstructed to the specified ages.</span>
<span class="sd">        point_indices : ndarray</span>
<span class="sd">            Only provided if ``return_point_indices`` is True.</span>
<span class="sd">            The indices of the returned points (that are reconstructed).</span>
<span class="sd">            This array is the same size as ``rlons`` and ``rlats``.</span>
<span class="sd">            These are indices into ``self.lons``, ``self.lats``, ``self.plate_id`` and ``self.age``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To reconstruct n seed points to B Ma (for this example n=2, with (lon,lat) = (78,30) and (56,22) at time=0 Ma,</span>
<span class="sd">        and we reconstruct to B=10 Ma):</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            # Longitude and latitude of n=2 seed points</span>
<span class="sd">            pt_lon = np.array([78., 56])</span>
<span class="sd">            pt_lat = np.array([30., 22])</span>

<span class="sd">            # Call the Points object!</span>
<span class="sd">            gpts = gplately.Points(model, pt_lon, pt_lat)</span>
<span class="sd">            print(gpts.features[0].get_all_geometries())   # Confirms we have features represented as points on a sphere</span>

<span class="sd">            ages = numpy.linspace(10,10, len(pt_lon))</span>
<span class="sd">            rlons, rlats = gpts.reconstruct_to_birth_age(ages)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">anchor_plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">anchor_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span>

        <span class="c1"># Call it &#39;reconstruct_ages&#39; to avoid confusion with &#39;self.age&#39; (which is time-of-appearance of points).</span>
        <span class="n">reconstruct_ages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ages</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reconstruct_ages</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;ages&#39; must be same length as number of points (</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">reconstruct_ages</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Start with an empty array.</span>
        <span class="n">lat_lon_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Determine which points are valid.</span>
        <span class="c1">#</span>
        <span class="c1"># These are those points that are reconstructable and have appeared before (or at) their respective reconstruct ages</span>
        <span class="c1"># (ie, have a time-of-appearance that&#39;s greater than or equal to the respective reconstruct age).</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconstructable</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="n">reconstruct_ages</span><span class="p">)</span>

        <span class="c1"># Iterate over groups of points with the same plate ID.</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">plate_id</span><span class="p">,</span>
            <span class="n">point_indices_with_plate_id</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_plate_id_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Determine which points (indices) with the current unique plate ID are valid.</span>
            <span class="n">point_indices_with_plate_id</span> <span class="o">=</span> <span class="n">point_indices_with_plate_id</span><span class="p">[</span>
                <span class="n">valid_mask</span><span class="p">[</span><span class="n">point_indices_with_plate_id</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="c1"># If none of the points (with the current unique plate ID) are valid then skip to next unique plate ID.</span>
            <span class="k">if</span> <span class="n">point_indices_with_plate_id</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Get all the unique reconstruct ages of all valid points with the current unique plate ID.</span>
            <span class="n">point_reconstruct_ages_with_plate_id</span> <span class="o">=</span> <span class="n">reconstruct_ages</span><span class="p">[</span>
                <span class="n">point_indices_with_plate_id</span>
            <span class="p">]</span>
            <span class="n">unique_reconstruct_ages_with_plate_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">point_reconstruct_ages_with_plate_id</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">reconstruct_age</span> <span class="ow">in</span> <span class="n">unique_reconstruct_ages_with_plate_id</span><span class="p">:</span>
                <span class="c1"># Indices of points with the current unique plate ID and the current unique reconstruct age.</span>
                <span class="n">point_indices_with_plate_id_and_reconstruct_age</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">point_indices_with_plate_id</span><span class="p">[</span>
                        <span class="n">point_reconstruct_ages_with_plate_id</span> <span class="o">==</span> <span class="n">reconstruct_age</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="c1"># Get the reconstructed points with the current unique plate ID and unique reconstruct age</span>
                <span class="c1"># (that exist at their respective reconstruct age).</span>
                <span class="n">reconstructed_points_with_plate_id_and_reconstruct_age</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="n">point_indices_with_plate_id_and_reconstruct_age</span>
                <span class="p">)</span>

                <span class="c1"># First reconstruct the internal points from the initial time (&#39;self.time&#39;) to present day using</span>
                <span class="c1"># our internal anchor plate ID (the same anchor plate used in &#39;__init__&#39;).</span>
                <span class="c1"># Then reconstruct from present day to &#39;reconstruct_age&#39; using the *requested* anchor plate ID.</span>
                <span class="c1">#</span>
                <span class="c1"># Note &#39;self.points&#39; (and hence &#39;reconstructed_points_with_plate_id_and_reconstruct_age&#39;) are the locations at &#39;self.time&#39;</span>
                <span class="c1">#      (just like &#39;self.lons&#39; and &#39;self.lats&#39;).</span>
                <span class="n">reconstruct_rotation</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
                        <span class="n">to_time</span><span class="o">=</span><span class="n">reconstruct_age</span><span class="p">,</span>
                        <span class="n">moving_plate_id</span><span class="o">=</span><span class="n">plate_id</span><span class="p">,</span>
                        <span class="n">from_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
                        <span class="n">to_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">moving_plate_id</span><span class="o">=</span><span class="n">plate_id</span><span class="p">,</span>
                        <span class="n">from_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">reconstructed_points_with_plate_id_and_reconstruct_age</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">reconstruct_rotation</span>
                    <span class="o">*</span> <span class="n">reconstructed_points_with_plate_id_and_reconstruct_age</span>
                <span class="p">)</span>

                <span class="c1"># Write the reconstructed points.</span>
                <span class="n">lat_lon_points</span><span class="p">[</span><span class="n">point_indices_with_plate_id_and_reconstruct_age</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">rpoint</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">rpoint</span> <span class="ow">in</span> <span class="n">reconstructed_points_with_plate_id_and_reconstruct_age</span>
                <span class="p">]</span>

        <span class="n">rlonslats</span> <span class="o">=</span> <span class="n">lat_lon_points</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>  <span class="c1"># remove invalid points</span>
        <span class="n">rlons</span> <span class="o">=</span> <span class="n">rlonslats</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">rlats</span> <span class="o">=</span> <span class="n">rlonslats</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">return_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">rlons</span><span class="p">,</span> <span class="n">rlats</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_point_indices</span><span class="p">:</span>
            <span class="n">all_point_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">point_indices</span> <span class="o">=</span> <span class="n">all_point_indices</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>  <span class="c1"># remove invalid points</span>
            <span class="n">return_tuple</span> <span class="o">+=</span> <span class="p">(</span><span class="n">point_indices</span><span class="p">,)</span>

        <span class="k">return</span> <span class="n">return_tuple</span></div>


<div class="viewcode-block" id="Points.plate_velocity">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.plate_velocity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plate_velocity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">delta_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">velocity_delta_time_type</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityDeltaTimeType</span><span class="o">.</span><span class="n">t_plus_delta_t_to_t</span><span class="p">,</span>
        <span class="n">velocity_units</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityUnits</span><span class="o">.</span><span class="n">cms_per_yr</span><span class="p">,</span>
        <span class="n">earth_radius_in_kms</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">Earth</span><span class="o">.</span><span class="n">mean_radius_in_kms</span><span class="p">,</span>
        <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_reconstructed_points</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_point_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the east and north components of the tectonic plate velocities of the internal points at a particular geological time.</span>

<span class="sd">        The point velocities are calculated using the plate IDs of the internal points and the rotation model of the internal :class:`PlateReconstruction` object.</span>
<span class="sd">        If the requested ``time`` differs from the initial time (``self.time``) then the internal points are first reconstructed to ``time`` before calculating velocities.</span>
<span class="sd">        Velocities are only calculated at points that are reconstructable (See :ref:`Notes &lt;points-note&gt;`) and that have ages greater than or equal to</span>
<span class="sd">        ``time`` (ie, at points that exist at ``time``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : float</span>
<span class="sd">            The specific geological time (Ma) at which to calculate plate velocities.</span>

<span class="sd">        delta_time : float, default=1.0</span>
<span class="sd">            The time interval used for velocity calculations. 1.0Ma by default.</span>

<span class="sd">        velocity_delta_time_type : pygplates.VelocityDeltaTimeType, default=pygplates.VelocityDeltaTimeType.t_plus_delta_t_to_t</span>
<span class="sd">            How the two velocity times are calculated relative to ``time`` (defaults to ``[time + velocity_delta_time, time]``).</span>

<span class="sd">        velocity_units : pygplates.VelocityUnits, default=pygplates.VelocityUnits.cms_per_yr</span>
<span class="sd">            Whether to return velocities in centimetres per year or kilometres per million years (defaults to centimetres per year).</span>

<span class="sd">        earth_radius_in_kms : float, default=pygplates.Earth.mean_radius_in_kms</span>
<span class="sd">            Radius of the Earth in kilometres.</span>
<span class="sd">            This is only used to calculate velocities (strain rates always use ``pygplates.Earth.equatorial_radius_in_kms``).</span>

<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Anchor plate used to reconstruct the points and calculate velocities at their locations.</span>
<span class="sd">            By default, reconstructions are made with respect to ``self.anchor_plate_id``</span>
<span class="sd">            (which is the anchor plate that the initial points at the initial time are relative to).</span>

<span class="sd">        return_reconstructed_points : bool, default=False</span>
<span class="sd">            Return the reconstructed points (as longitude and latitude arrays) in addition to the velocities.</span>

<span class="sd">        return_point_indices : bool, default=False</span>
<span class="sd">            Return the indices of those internal points at which velocities are calculated.</span>
<span class="sd">            These are indices into ``self.lons``, ``self.lats``, ``self.plate_id`` and ``self.age``.</span>
<span class="sd">            Those points with an age less than ``time`` have not yet appeared at ``time``, and therefore will not have velocities returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        velocity_lons, velocity_lats : ndarray</span>
<span class="sd">            The velocity arrays containing the **east** (longitude) and *north* (latitude) components of the velocity</span>
<span class="sd">            of each internal point that exists at ``time`` (ie, whose age greater than or equal to ``time``).</span>
<span class="sd">        rlons, rlats : ndarray</span>
<span class="sd">            Only provided if ``return_reconstructed_points`` is True.</span>
<span class="sd">            The longitude and latitude coordinate arrays of the reconstructed points (at which velocities are calculated).</span>
<span class="sd">            These arrays are the same size as ``velocity_lons`` and ``velocity_lats``.</span>
<span class="sd">        point_indices : ndarray</span>
<span class="sd">            Only provided if ``return_point_indices`` is True.</span>
<span class="sd">            The indices of the returned points (at which velocities are calculated).</span>
<span class="sd">            These are indices into ``self.lons``, ``self.lats``, ``self.plate_id`` and ``self.age``.</span>
<span class="sd">            This array is the same size as ``velocity_lons`` and ``velocity_lats``.</span>


<span class="sd">        .. note::</span>

<span class="sd">            The velocities are in **centimetres per year** by default (not **kilometres per million years**, the default</span>
<span class="sd">            in :meth:`PlateReconstruction.get_point_velocities`).</span>
<span class="sd">            This difference is maintained for backward compatibility.</span>

<span class="sd">            For each velocity, the *east** component is first followed by the *north* component.</span>
<span class="sd">            This is different to :meth:`PlateReconstruction.get_point_velocities` where the **north** component is first.</span>
<span class="sd">            This difference is maintained for backward compatibility.</span>


<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`PlateReconstruction.get_point_velocities` : Velocities of points calculated using topologies instead of plate IDs (assigned from static polygons).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">anchor_plate_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">anchor_plate_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span>

        <span class="c1"># Start with empty arrays.</span>
        <span class="n">north_east_velocities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">return_reconstructed_points</span><span class="p">:</span>
            <span class="n">lat_lon_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lat_lon_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># Determine time interval for velocity calculation.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">velocity_delta_time_type</span>
            <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityDeltaTimeType</span><span class="o">.</span><span class="n">t_plus_delta_t_to_t</span>
        <span class="p">):</span>
            <span class="n">from_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="n">delta_time</span>
            <span class="n">to_time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">velocity_delta_time_type</span>
            <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityDeltaTimeType</span><span class="o">.</span><span class="n">t_to_t_minus_delta_t</span>
        <span class="p">):</span>
            <span class="n">from_time</span> <span class="o">=</span> <span class="n">time</span>
            <span class="n">to_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">delta_time</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">velocity_delta_time_type</span>
            <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">VelocityDeltaTimeType</span><span class="o">.</span><span class="n">t_plus_minus_half_delta_t</span>
        <span class="p">):</span>
            <span class="n">from_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="n">delta_time</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">to_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">delta_time</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;velocity_delta_time_type&#39; value not one of pygplates.VelocityDeltaTimeType enumerated values&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Make sure time interval is non-negative.</span>
        <span class="k">if</span> <span class="n">to_time</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">from_time</span> <span class="o">-=</span> <span class="n">to_time</span>
            <span class="n">to_time</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Determine which points are valid.</span>
        <span class="c1">#</span>
        <span class="c1"># These are those points that are reconstructable and have appeared before (or at) &#39;time&#39;</span>
        <span class="c1"># (ie, have a time-of-appearance that&#39;s greater than or equal to &#39;time&#39;).</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconstructable</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="n">time</span><span class="p">)</span>

        <span class="c1"># Iterate over groups of points with the same plate ID.</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">plate_id</span><span class="p">,</span>
            <span class="n">point_indices_with_plate_id</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_plate_id_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Determine which points (indices) with the current unique plate ID are valid.</span>
            <span class="n">point_indices_with_plate_id</span> <span class="o">=</span> <span class="n">point_indices_with_plate_id</span><span class="p">[</span>
                <span class="n">valid_mask</span><span class="p">[</span><span class="n">point_indices_with_plate_id</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="c1"># If none of the points (with the current unique plate ID) are valid then skip to next unique plate ID.</span>
            <span class="k">if</span> <span class="n">point_indices_with_plate_id</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Get the reconstructed points with the current unique plate ID that have appeared before (or at) &#39;time&#39;.</span>
            <span class="n">reconstructed_points_with_plate_id</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="n">point_indices_with_plate_id</span>
            <span class="p">)</span>

            <span class="c1"># Stage rotation for the current unique plate ID.</span>
            <span class="n">velocity_equivalent_stage_rotation</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
                    <span class="n">to_time</span><span class="p">,</span> <span class="n">plate_id</span><span class="p">,</span> <span class="n">from_time</span><span class="p">,</span> <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># First reconstruct the internal points from the initial time (&#39;self.time&#39;) to present day using</span>
            <span class="c1"># our internal anchor plate ID (the same anchor plate used in &#39;__init__&#39;).</span>
            <span class="c1"># Then reconstruct from present day to &#39;time&#39; using the *requested* anchor plate ID.</span>
            <span class="c1">#</span>
            <span class="c1"># Note &#39;self.points&#39; (and hence &#39;reconstructed_points_with_plate_id&#39;) are the locations at &#39;self.time&#39;</span>
            <span class="c1">#      (just like &#39;self.lons&#39; and &#39;self.lats&#39;).</span>
            <span class="n">reconstruct_rotation</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
                    <span class="n">to_time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">moving_plate_id</span><span class="o">=</span><span class="n">plate_id</span><span class="p">,</span>
                    <span class="n">from_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
                    <span class="n">to_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">moving_plate_id</span><span class="o">=</span><span class="n">plate_id</span><span class="p">,</span>
                    <span class="n">from_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">anchor_plate_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor_plate_id</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">reconstructed_points_with_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">reconstruct_rotation</span> <span class="o">*</span> <span class="n">reconstructed_points_with_plate_id</span>
            <span class="p">)</span>

            <span class="n">velocity_vectors_with_plate_id</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">calculate_velocities</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="n">reconstructed_points_with_plate_id</span><span class="p">,</span>
                <span class="n">velocity_equivalent_stage_rotation</span><span class="p">,</span>
                <span class="n">delta_time</span><span class="p">,</span>
                <span class="n">velocity_units</span><span class="o">=</span><span class="n">velocity_units</span><span class="p">,</span>
                <span class="n">earth_radius_in_kms</span><span class="o">=</span><span class="n">earth_radius_in_kms</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">north_east_down_velocities_with_plate_id</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">pygplates</span><span class="o">.</span><span class="n">LocalCartesian</span><span class="o">.</span><span class="n">convert_from_geocentric_to_north_east_down</span><span class="p">(</span>
                    <span class="n">reconstructed_points_with_plate_id</span><span class="p">,</span> <span class="n">velocity_vectors_with_plate_id</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Write velocities of points with the current unique plate ID as (north, east) components.</span>
            <span class="n">north_east_velocities</span><span class="p">[</span><span class="n">point_indices_with_plate_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">ned</span><span class="o">.</span><span class="n">get_x</span><span class="p">(),</span> <span class="n">ned</span><span class="o">.</span><span class="n">get_y</span><span class="p">())</span>  <span class="c1"># north, east</span>
                <span class="k">for</span> <span class="n">ned</span> <span class="ow">in</span> <span class="n">north_east_down_velocities_with_plate_id</span>
            <span class="p">]</span>

            <span class="c1"># Also write the reconstructed points (if requested).</span>
            <span class="k">if</span> <span class="n">return_reconstructed_points</span><span class="p">:</span>
                <span class="n">lat_lon_points</span><span class="p">[</span><span class="n">point_indices_with_plate_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">rpoint</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span> <span class="k">for</span> <span class="n">rpoint</span> <span class="ow">in</span> <span class="n">reconstructed_points_with_plate_id</span>
                <span class="p">]</span>

        <span class="n">velocities</span> <span class="o">=</span> <span class="n">north_east_velocities</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>  <span class="c1"># remove invalid points</span>
        <span class="n">velocity_lons</span> <span class="o">=</span> <span class="n">velocities</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># east</span>
        <span class="n">velocity_lats</span> <span class="o">=</span> <span class="n">velocities</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># north</span>

        <span class="n">return_tuple</span> <span class="o">=</span> <span class="n">velocity_lons</span><span class="p">,</span> <span class="n">velocity_lats</span>

        <span class="k">if</span> <span class="n">return_reconstructed_points</span><span class="p">:</span>
            <span class="n">rlonslats</span> <span class="o">=</span> <span class="n">lat_lon_points</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>  <span class="c1"># remove invalid points</span>
            <span class="n">rlons</span> <span class="o">=</span> <span class="n">rlonslats</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">rlats</span> <span class="o">=</span> <span class="n">rlonslats</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">return_tuple</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rlons</span><span class="p">,</span> <span class="n">rlats</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_point_indices</span><span class="p">:</span>
            <span class="n">all_point_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">point_indices</span> <span class="o">=</span> <span class="n">all_point_indices</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>  <span class="c1"># remove invalid points</span>
            <span class="n">return_tuple</span> <span class="o">+=</span> <span class="p">(</span><span class="n">point_indices</span><span class="p">,)</span>

        <span class="k">return</span> <span class="n">return_tuple</span></div>


<div class="viewcode-block" id="Points.motion_path">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.motion_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">motion_path</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">time_array</span><span class="p">,</span> <span class="n">anchor_plate_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_rate_of_motion</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a path of points to mark the trajectory of a plate&#39;s motion through geological time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_array : arr</span>
<span class="sd">            An array of reconstruction times at which to determine the trajectory of a point on a plate.</span>

<span class="sd">            For example,</span>

<span class="sd">            .. code-block:: python</span>
<span class="sd">                :linenos:</span>

<span class="sd">                import numpy as np</span>
<span class="sd">                min_time = 30</span>
<span class="sd">                max_time = 100</span>
<span class="sd">                time_step = 2.5</span>
<span class="sd">                time_array = np.arange(min_time, max_time + time_step, time_step)</span>

<span class="sd">        anchor_plate_id : int, optional</span>
<span class="sd">            Reconstruct features with respect to a certain anchor plate. By default, reconstructions are made</span>
<span class="sd">            with respect to the anchor plate ID specified in the :class:`PlateReconstruction` object.</span>
<span class="sd">        return_rate_of_motion : bool, default=False</span>
<span class="sd">            Choose whether to return the rate of plate motion through time for each</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rlons : ndarray</span>
<span class="sd">            An n-dimensional array with columns containing the longitudes of</span>
<span class="sd">            the seed points at each timestep in ``time_array``. There are n columns for n seed points.</span>
<span class="sd">        rlats : ndarray</span>
<span class="sd">            An n-dimensional array with columns containing the latitudes of</span>
<span class="sd">            the seed points at each timestep in ``time_array``. There are n columns for n seed points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span>

        <span class="c1"># ndarrays to fill with reconstructed points and</span>
        <span class="c1"># rates of motion (if requested)</span>
        <span class="n">rlons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="p">)))</span>
        <span class="n">rlats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="p">)))</span>

        <span class="n">StepTimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">StepRates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point_feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_collection</span><span class="p">):</span>
            <span class="c1"># Create the motion path feature</span>
            <span class="n">motion_path_feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="o">.</span><span class="n">create_motion_path</span><span class="p">(</span>
                <span class="n">point_feature</span><span class="o">.</span><span class="n">get_geometry</span><span class="p">(),</span>
                <span class="n">time_array</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="n">valid_time</span><span class="o">=</span><span class="p">(</span><span class="n">time_array</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">time_array</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
                <span class="n">relative_plate</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plate_id</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                <span class="n">reconstruction_plate_id</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">anchor_plate_id</span>  <span class="c1"># if None then uses default anchor plate of &#39;self.plate_reconstruction&#39;</span>
                    <span class="k">if</span> <span class="n">anchor_plate_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">anchor_plate_id</span>
                <span class="p">),</span>
            <span class="p">)</span>

            <span class="n">reconstructed_motion_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span>
                <span class="n">motion_path_feature</span><span class="p">,</span>
                <span class="n">to_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="c1"># from_time=0,</span>
                <span class="n">reconstruct_type</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ReconstructType</span><span class="o">.</span><span class="n">motion_path</span><span class="p">,</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">anchor_plate_id</span><span class="p">,</span>  <span class="c1"># if None then uses default anchor plate of &#39;self.plate_reconstruction&#39;</span>
            <span class="p">)</span>

            <span class="c1"># Turn motion paths in to lat-lon coordinates</span>
            <span class="n">trail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">reconstructed_motion_path</span> <span class="ow">in</span> <span class="n">reconstructed_motion_paths</span><span class="p">:</span>
                <span class="c1"># not sure about this. always set the &quot;trail&quot; to the last one in reconstructed_motion_paths?</span>
                <span class="c1"># or there is only one path in reconstructed_motion_paths? -- Michael Chin</span>
                <span class="c1"># again???</span>
                <span class="n">trail</span> <span class="o">=</span> <span class="n">reconstructed_motion_path</span><span class="o">.</span><span class="n">get_motion_path</span><span class="p">()</span><span class="o">.</span><span class="n">to_lat_lon_array</span><span class="p">()</span>

            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">trail</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">trail</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="n">rlons</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span>
            <span class="n">rlats</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span>

            <span class="c1"># Obtain step-plot coordinates for rate of motion</span>
            <span class="k">if</span> <span class="n">return_rate_of_motion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">StepTimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="p">)))</span>
                <span class="n">StepRates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="p">)))</span>

                <span class="c1"># Get timestep</span>
                <span class="n">TimeStep</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">TimeStep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

                <span class="c1"># Iterate over each segment in the reconstructed motion path, get the distance travelled by the moving</span>
                <span class="c1"># plate relative to the fixed plate in each time step</span>
                <span class="n">Dist</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">reconstructed_motion_path</span> <span class="ow">in</span> <span class="n">reconstructed_motion_paths</span><span class="p">:</span>
                    <span class="k">for</span> <span class="p">(</span>
                        <span class="n">segment</span>
                    <span class="p">)</span> <span class="ow">in</span> <span class="n">reconstructed_motion_path</span><span class="o">.</span><span class="n">get_motion_path</span><span class="p">()</span><span class="o">.</span><span class="n">get_segments</span><span class="p">():</span>
                        <span class="n">Dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">segment</span><span class="o">.</span><span class="n">get_arc_length</span><span class="p">()</span>
                            <span class="o">*</span> <span class="n">_tools</span><span class="o">.</span><span class="n">geocentric_radius</span><span class="p">(</span>
                                <span class="n">segment</span><span class="o">.</span><span class="n">get_start_point</span><span class="p">()</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="o">/</span> <span class="mf">1e3</span>
                        <span class="p">)</span>

                <span class="c1"># Note that the motion path coordinates come out starting with the oldest time and working forwards</span>
                <span class="c1"># So, to match our &#39;times&#39; array, we flip the order</span>
                <span class="n">Dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">Dist</span><span class="p">)</span>

                <span class="c1"># Get rate of motion as distance per Myr</span>
                <span class="n">Rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Dist</span><span class="p">)</span> <span class="o">/</span> <span class="n">TimeStep</span>

                <span class="c1"># Manipulate arrays to get a step plot</span>
                <span class="n">StepRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">StepRate</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rate</span>
                <span class="n">StepRate</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rate</span>

                <span class="n">StepTime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">StepTime</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">StepTime</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                <span class="c1"># Append the nth point&#39;s step time and step rate coordinates to the ndarray</span>
                <span class="n">StepTimes</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">StepTime</span>
                <span class="n">StepRates</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">StepRate</span> <span class="o">*</span> <span class="mf">0.1</span>  <span class="c1"># cm/yr</span>

        <span class="k">if</span> <span class="n">return_rate_of_motion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">rlons</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">rlats</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">StepTimes</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">StepRates</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">rlons</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">rlats</span><span class="p">)</span></div>


<div class="viewcode-block" id="Points.flowline">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.flowline">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">flowline</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">time_array</span><span class="p">,</span> <span class="n">left_plate_ID</span><span class="p">,</span> <span class="n">right_plate_ID</span><span class="p">,</span> <span class="n">return_rate_of_motion</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a path of points to track plate motion away from spreading ridges over time using half-stage rotations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lons : arr</span>
<span class="sd">            An array of longitudes of points along spreading ridges.</span>
<span class="sd">        lats : arr</span>
<span class="sd">            An array of latitudes of points along spreading ridges.</span>
<span class="sd">        time_array : arr</span>
<span class="sd">            A list of times to obtain seed point locations at.</span>
<span class="sd">        left_plate_ID : int</span>
<span class="sd">            The plate ID of the polygon to the left of the spreading ridge.</span>
<span class="sd">        right_plate_ID : int</span>
<span class="sd">            The plate ID of the polygon to the right of the spreading ridge.</span>
<span class="sd">        return_rate_of_motion : bool, default False</span>
<span class="sd">            Choose whether to return a step time and step rate array for a step-plot of flowline motion.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        left_lon : ndarray</span>
<span class="sd">            The longitudes of the **left** flowline for n seed points.</span>
<span class="sd">            There are n columns for n seed points, and m rows for m time steps in ``time_array``.</span>
<span class="sd">        left_lat : ndarray</span>
<span class="sd">            The latitudes of the **left** flowline of n seed points.</span>
<span class="sd">            There are n columns for n seed points, and m rows for m time steps in ``time_array``.</span>
<span class="sd">        right_lon : ndarray</span>
<span class="sd">            The longitudes of the **right** flowline of n seed points.</span>
<span class="sd">            There are n columns for n seed points, and m rows for m time steps in ``time_array``.</span>
<span class="sd">        right_lat : ndarray</span>
<span class="sd">            The latitudes of the **right** flowline of n seed points.</span>
<span class="sd">            There are n columns for n seed points, and m rows for m time steps in ``time_array``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To access the i\\ :sup:`th`  seed point&#39;s left and right latitudes and longitudes:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            for i in np.arange(0,len(seed_points)):</span>
<span class="sd">                left_flowline_longitudes = left_lon[:,i]</span>
<span class="sd">                left_flowline_latitudes = left_lat[:,i]</span>
<span class="sd">                right_flowline_longitudes = right_lon[:,i]</span>
<span class="sd">                right_flowline_latitudes = right_lat[:,i]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span>
        <span class="k">return</span> <span class="n">model</span><span class="o">.</span><span class="n">create_flowline</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">,</span>
            <span class="n">time_array</span><span class="p">,</span>
            <span class="n">left_plate_ID</span><span class="p">,</span>
            <span class="n">right_plate_ID</span><span class="p">,</span>
            <span class="n">return_rate_of_motion</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>

        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Longitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lons</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Latitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Plate_ID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_id</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<div class="viewcode-block" id="Points.save">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.save">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves the feature collection used in the Points object under a given filename to the current directory.</span>

<span class="sd">        The file format is determined from the filename extension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Can be provided as a string including the filename and the file format needed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Feature collection saved under given filename to current directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s2">&quot;.csv&quot;</span><span class="p">,</span> <span class="s2">&quot;.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;.dat&quot;</span><span class="p">)):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dataframe</span><span class="p">()</span>
            <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s2">&quot;.xls&quot;</span><span class="p">,</span> <span class="s2">&quot;.xlsx&quot;</span><span class="p">)):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dataframe</span><span class="p">()</span>
            <span class="n">df</span><span class="o">.</span><span class="n">to_excel</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;xml&quot;</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dataframe</span><span class="p">()</span>
            <span class="n">df</span><span class="o">.</span><span class="n">to_xml</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.gpml&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.gpmlz&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.shp&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feature_collection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot save to specified file type. Use csv, gpml, shp or xls file extension.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Points.rotate_reference_frames">
<a class="viewcode-back" href="../../generated/gplately.Points.html#gplately.Points.rotate_reference_frames">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate_reference_frames</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reconstruction_time</span><span class="p">,</span>
        <span class="n">from_rotation_features_or_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># filename(s), or pyGPlates feature(s)/collection(s) or a RotationModel</span>
        <span class="n">to_rotation_features_or_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># filename(s), or pyGPlates feature(s)/collection(s) or a RotationModel</span>
        <span class="n">from_rotation_reference_plate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">to_rotation_reference_plate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">non_reference_plate</span><span class="o">=</span><span class="mi">701</span><span class="p">,</span>
        <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate a grid defined in one plate model reference frame within a :class:`Raster` object to another plate</span>
<span class="sd">        reconstruction model reference frame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reconstruction_time : float</span>
<span class="sd">            The time at which to rotate the reconstructed points.</span>
<span class="sd">        from_rotation_features_or_model : str/os.PathLike, list of str/os.PathLike, or instance of pygplates.RotationModel</span>
<span class="sd">            A filename, or a list of filenames, or a pyGPlates</span>
<span class="sd">            RotationModel object that defines the rotation model</span>
<span class="sd">            that the input grid is currently associated with.</span>
<span class="sd">            ``self.plate_reconstruction.rotation_model`` is default.</span>
<span class="sd">        to_rotation_features_or_model : str/os.PathLike, list of str/os.PathLike, or instance of pygplates.RotationModel</span>
<span class="sd">            A filename, or a list of filenames, or a pyGPlates</span>
<span class="sd">            RotationModel object that defines the rotation model</span>
<span class="sd">            that the input grid shall be rotated with.</span>
<span class="sd">            ``self.plate_reconstruction.rotation_model`` is default.</span>
<span class="sd">        from_rotation_reference_plate : int, default = 0</span>
<span class="sd">            The current reference plate for the plate model the points</span>
<span class="sd">            are defined in. Defaults to the anchor plate 0.</span>
<span class="sd">        to_rotation_reference_plate : int, default = 0</span>
<span class="sd">            The desired reference plate for the plate model the points</span>
<span class="sd">            to be rotated to. Defaults to the anchor plate 0.</span>
<span class="sd">        non_reference_plate : int, default = 701</span>
<span class="sd">            An arbitrary placeholder reference frame with which</span>
<span class="sd">            to define the &quot;from&quot; and &quot;to&quot; reference frames.</span>
<span class="sd">        output_name : str, default None</span>
<span class="sd">            If passed, the rotated points are saved as a gpml to this filename.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Points</span>
<span class="sd">            An instance of the :class:`Points` object containing the rotated points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;output_name&#39; parameter is not implemented&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">from_rotation_features_or_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">from_rotation_features_or_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span>
        <span class="k">if</span> <span class="n">to_rotation_features_or_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_rotation_features_or_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="o">.</span><span class="n">rotation_model</span>

        <span class="c1"># Create the pygplates.FiniteRotation that rotates</span>
        <span class="c1"># between the two reference frames.</span>
        <span class="n">from_rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">from_rotation_features_or_model</span><span class="p">)</span>
        <span class="n">to_rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="n">to_rotation_features_or_model</span><span class="p">)</span>
        <span class="n">from_rotation</span> <span class="o">=</span> <span class="n">from_rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
            <span class="n">reconstruction_time</span><span class="p">,</span>
            <span class="n">non_reference_plate</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">from_rotation_reference_plate</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">to_rotation</span> <span class="o">=</span> <span class="n">to_rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span>
            <span class="n">reconstruction_time</span><span class="p">,</span>
            <span class="n">non_reference_plate</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">to_rotation_reference_plate</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">reference_frame_conversion_rotation</span> <span class="o">=</span> <span class="n">to_rotation</span> <span class="o">*</span> <span class="n">from_rotation</span><span class="o">.</span><span class="n">get_inverse</span><span class="p">()</span>

        <span class="c1"># reconstruct points to reconstruction_time</span>
        <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span>
            <span class="n">reconstruction_time</span><span class="p">,</span>
            <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">from_rotation_reference_plate</span><span class="p">,</span>
            <span class="n">return_array</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># convert FeatureCollection to MultiPointOnSphere</span>
        <span class="n">input_points</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">MultiPointOnSphere</span><span class="p">(</span>
            <span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span>

        <span class="c1"># Rotate grid nodes to the other reference frame</span>
        <span class="n">output_points</span> <span class="o">=</span> <span class="n">reference_frame_conversion_rotation</span> <span class="o">*</span> <span class="n">input_points</span>

        <span class="c1"># Assemble rotated points with grid values.</span>
        <span class="n">out_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lons</span><span class="p">)</span>
        <span class="n">out_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_points</span><span class="p">):</span>
            <span class="n">out_lat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">out_lon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">return_array</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out_lon</span><span class="p">,</span> <span class="n">out_lat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Points</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plate_reconstruction</span><span class="p">,</span>
                <span class="n">out_lon</span><span class="p">,</span>
                <span class="n">out_lat</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">reconstruction_time</span><span class="p">,</span>
                <span class="n">plate_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plate_id</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">age</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">anchor_plate_id</span><span class="o">=</span><span class="n">to_rotation_reference_plate</span><span class="p">,</span>
            <span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, The University of Sydney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>