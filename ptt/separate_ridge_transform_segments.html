<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gplately.ptt.separate_ridge_transform_segments API documentation</title>
<meta name="description" content="Copyright (C) 2017 The University of Sydney, Australia …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.ptt.separate_ridge_transform_segments</code></h1>
</header>
<section id="section-intro">
<p>Copyright (C) 2017 The University of Sydney, Australia</p>
<p>This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License
for more details.</p>
<p>You should have received a copy of the GNU General Public License along
with this program; if not, write to Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
    Copyright (C) 2017 The University of Sydney, Australia
    
    This program is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License, version 2, as published by
    the Free Software Foundation.
    
    This program is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
&#34;&#34;&#34;


#################################################################################################################
# Split the geometries of isochrons and mid-ocean ridges into ridge and transform segments
# based on each segment’s alignment with the geometry’s stage pole at its time of appearance.
#
# Source code is based on:
#   http://www.gplates.org/docs/pygplates/sample-code/pygplates_split_isochron_into_ridges_and_transforms.html
#
#################################################################################################################


from __future__ import print_function
import math
import os.path
import pygplates
import sys


# How much a segment can deviate from the stage pole before it&#39;s considered a transform segment.
DEFAULT_TRANSFORM_SEGMENT_DEVIATION_DEGREES = 45   # An even 45 degrees split
DEFAULT_TRANSFORM_SEGMENT_DEVIATION_RADIANS = math.radians(DEFAULT_TRANSFORM_SEGMENT_DEVIATION_DEGREES)


def separate_features_into_ridges_and_transforms(
        rotation_features_or_model,
        spreading_features,
        spreading_feature_types = None,
        transform_segment_deviation_in_radians = DEFAULT_TRANSFORM_SEGMENT_DEVIATION_RADIANS):
    &#34;&#34;&#34;
    Split the geometries of isochrons and mid-ocean ridges into ridge and transform segments based
    on each segment’s alignment with the geometry’s stage pole at its time of appearance.
    
    rotation_features_or_model: Rotation model or feature collection(s), or list of features, or filename(s).
    
    spreading_features: Spreading feature collection(s), or list of features, or filename(s) or any combination of those.
    
    spreading_feature_types: Only spreading features with a feature type contained in this list are considered.
                             If None then all spreading features are considered.
    
    transform_segment_deviation_in_radians: How much a segment can deviate from the stage pole before
                                            it&#39;s considered a transform segment (in radians).
    
    Returns: The separated ridge and transform features respectively, of type
             2-tuple (list of pygplates.Feature, list of pygplates.Feature).
    &#34;&#34;&#34;
    
    # Turn rotation data into a RotationModel (if not already).
    #
    # OPTIMISATION:
    # We will be reconstructing (and reverse reconstructing) mid-ocean ridges in groups, where ridges in each
    # group have the same time-of-appearance. They need to have the same time of appearance because, in pyGPlates,
    # version 3 half-stage rotations start spreading from the time-of-appearance in 10 My intervals
    # (ie, the 10My intervals are &#39;begin_time&#39;, &#39;begin_time-10&#39;, begin_time-20&#39;, ..., reconstruction_time).
    # And because the mid-ocean ridges with the same time-of-appearance also have the same time intervals
    # they&#39;ll reuse the cached reconstruction trees (one cached tree per time interval).
    # This will avoid a lot of wasted time recreating these trees if the cache is continually flushed
    # (eg, by mixing mid-ocean ridges with different appearance times).
    #
    # A cache size of 100 is enough to go back to 1,000Ma (100 entries * 10My interval).
    rotation_model = pygplates.RotationModel(rotation_features_or_model, 100)
    
    # Turn spreading feature data into a list of features (if not already).
    spreading_features = pygplates.FeaturesFunctionArgument(spreading_features)
    
    # Gather all spreading features with the same begin time (time-of-appearance) into groups.
    #
    # This is an optimisation that enables reconstructing multiple mid-ocean ridges with the same begin time together.
    # This can make a *big* difference to the running time (see note above regarding rotation model cache size).
    spreading_features_grouped_by_begin_time = {}
    
    # Iterate over all geometries in spreading features.
    for spreading_feature in spreading_features.get_features():
        
        # Filter spreading feature types if requested.
        if (spreading_feature_types and
            spreading_feature.get_feature_type() not in spreading_feature_types):
            continue
        
        begin_time, _ = spreading_feature.get_valid_time()
        
        # Add to list of spreading features with same begin time.
        if begin_time not in spreading_features_grouped_by_begin_time:
            spreading_features_grouped_by_begin_time[begin_time] = []
        spreading_features_grouped_by_begin_time[begin_time].append(spreading_feature)
    
    # The separated ridge/transform segment features.
    # Both types of segment feature will have the same feature type as the feature they are extracted from.
    ridge_segment_features = []
    transform_segment_features = []
    
    # Iterate over groups of spreading features with the same begin time (time-of-appearance).
    for begin_time, spreading_features_with_begin_time in spreading_features_grouped_by_begin_time.items():
        
        # Reconstruct the spreading features to their common birth time.
        reconstructed_spreading_features = []
        pygplates.reconstruct(
                spreading_features_with_begin_time,
                rotation_model,
                reconstructed_spreading_features,
                begin_time,
                group_with_feature=True)
        
        ridge_segment_features_with_begin_time = []
        transform_segment_features_with_begin_time = []
        
        # Iterate over reconstructed spreading features.
        for spreading_feature, reconstructed_spreading_geometries in reconstructed_spreading_features:
            
            # Find the stage rotation of the spreading feature in the frame of reference of its
            # geometry at its birth time. The stage pole can then be directly geometrically compared
            # to the reconstructed spreading geometry.
            stage_rotation = get_stage_rotation_for_reconstructed_geometry(spreading_feature, rotation_model, begin_time)
            if not stage_rotation:
                # Skip current feature - it&#39;s not a spreading feature.
                continue
            
            ridge_segment_geometries = []
            transform_segment_geometries = []
            
            # A feature usually has a single geometry but it could have more - iterate over them all.
            for reconstructed_spreading_geometry in reconstructed_spreading_geometries:
                ridge_and_transform_segment_geometries = separate_geometry_into_ridges_and_transforms(
                        stage_rotation,
                        reconstructed_spreading_geometry.get_reconstructed_geometry(),
                        transform_segment_deviation_in_radians)
                if ridge_and_transform_segment_geometries:
                    ridge_segment_geometries.extend(ridge_and_transform_segment_geometries[0])
                    transform_segment_geometries.extend(ridge_and_transform_segment_geometries[1])
            
            # Put all ridge segment geometries into one feature and transform segment geometries into another.
            if ridge_segment_geometries:
                ridge_segment_feature = spreading_feature.clone()
                ridge_segment_feature.set_geometry(ridge_segment_geometries)
                ridge_segment_features_with_begin_time.append(ridge_segment_feature)
            if transform_segment_geometries:
                transform_segment_feature = spreading_feature.clone()
                transform_segment_feature.set_geometry(transform_segment_geometries)
                transform_segment_features_with_begin_time.append(transform_segment_feature)
        
        # Reverse reconstruct the segmented spreading features from their common birth time.
        #
        # Each new feature needs to be reverse reconstructed from birth time to present day because the
        # geometries are reconstructed (but need to be stored in present day positions within the feature).
        pygplates.reverse_reconstruct(
                (ridge_segment_features_with_begin_time, transform_segment_features_with_begin_time),
                rotation_model,
                begin_time)
        
        ridge_segment_features.extend(ridge_segment_features_with_begin_time)
        transform_segment_features.extend(transform_segment_features_with_begin_time)
    
    return ridge_segment_features, transform_segment_features


def separate_geometry_into_ridges_and_transforms(
        stage_rotation,
        geometry_at_spreading_time,
        transform_segment_deviation_in_radians = DEFAULT_TRANSFORM_SEGMENT_DEVIATION_RADIANS):
    &#34;&#34;&#34;
    Split the geometry of an isochron or mid-ocean ridge (at a time when there is spreading) into ridge and
    transform segments based on each segment’s alignment with the geometry’s stage pole at its time of appearance.
    
    For isochrons the geometry should be at its time of appearance (ie, when formed at mid-ocean ridge).
    For mid-ocean ridges the geometry can be any time when the ridge is actively spreading.
    
    stage_rotation: The stage rotation that can be applied to the geometry at the spreading time.
                    NOTE: It must have already had transforms to and from the stage pole reference frame applied.
                    In other words, if you get the stage pole from it, using &#39;get_euler_pole_and_angle()&#39;, then it
                    should be the stage pole in the frame of reference of the geometry at the spreading time.
    
    geometry_at_spreading_time: The polyline (or polygon) at the spreading time.
    
    transform_segment_deviation_in_radians: How much a segment can deviate from the stage pole before
                                            it&#39;s considered a transform segment (in radians).
    
    Returns: The separated ridge and transform geometries respectively, of type
             2-tuple (list of pygplates.Polyline, list of pygplates.Polyline).
             Returns None if &#39;geometry_at_spreading_time&#39; is not a polyline (or polygon).
    &#34;&#34;&#34;
    
    # Iterate over the segments of the geometry.
    # Note that we&#39;re assuming the geometry is a polyline (or polygon) - otherwise we ignore the geometry.
    try:
        segments = geometry_at_spreading_time.get_segments()
    except AttributeError:
        return
    
    # Get the stage pole of the stage rotation.
    # Note that the stage rotation is already in frame of reference of the geometry at the spreading time.
    stage_pole, _ = stage_rotation.get_euler_pole_and_angle()
    
    ridge_segment_geometries = []
    transform_segment_geometries = []
    
    # Points of contiguous segments belonging either to a ridge or transform.
    contiguous_segment_points = []
    is_transform = False
    
    for segment in segments:
        # Ignore zero length segments - they don&#39;t have a direction.
        if segment.is_zero_length():
            continue
        
        # Get the point in the middle of the segment and its tangential direction.
        segment_midpoint = segment.get_arc_point(0.5)
        segment_direction_at_midpoint = segment.get_arc_direction(0.5)
        
        # Get the direction from the segment midpoint to the stage pole.
        # This is the tangential direction at the start of an arc from the segment
        # midpoint to the stage pole (the zero parameter indicates the arc start point
        # which is the segment midpoint).
        segment_to_stage_pole_direction = pygplates.GreatCircleArc(
                segment_midpoint, stage_pole).get_arc_direction(0)
        
        # The angle that the segment deviates from the stage pole direction.
        deviation_of_segment_direction_from_stage_pole = pygplates.Vector3D.angle_between(
                segment_direction_at_midpoint, segment_to_stage_pole_direction)
        
        # When comparing the deviation angle we need to consider the case where the two
        # direction vectors are aligned but pointing in opposite directions.
        if (deviation_of_segment_direction_from_stage_pole &lt; transform_segment_deviation_in_radians or
            deviation_of_segment_direction_from_stage_pole &gt; math.pi - transform_segment_deviation_in_radians):
            
            # If switching from transform to ridge.
            if is_transform:
                # Emit transform polyline (if any) and restart contiguous segments.
                if contiguous_segment_points:
                    transform_segment_geometries.append(pygplates.PolylineOnSphere(contiguous_segment_points))
                    contiguous_segment_points = []
            
            is_transform = False
            
        else: # transform
            
            # If switching from ridge to transform.
            if not is_transform:
                # Emit ridge polyline (if any) and restart contiguous segments.
                if contiguous_segment_points:
                    ridge_segment_geometries.append(pygplates.PolylineOnSphere(contiguous_segment_points))
                    contiguous_segment_points = []
            
            is_transform = True
        
        # Add segment start point if first segment.
        if not contiguous_segment_points:
            contiguous_segment_points.append(segment.get_start_point())
        
        # Add segment end point.
        contiguous_segment_points.append(segment.get_end_point())
    
    # Emit last ridge or transform polyline (if any).
    if contiguous_segment_points:
        if is_transform:
            transform_segment_geometries.append(pygplates.PolylineOnSphere(contiguous_segment_points))
        else:
            ridge_segment_geometries.append(pygplates.PolylineOnSphere(contiguous_segment_points))
    
    return ridge_segment_geometries, transform_segment_geometries


def get_stage_rotation_for_reconstructed_geometry(
        spreading_feature,
        rotation_model,
        spreading_time = None):
    &#34;&#34;&#34;
    Find the stage rotation of the spreading feature in the frame of reference of its geometry at the spreading time.
    The stage pole can then be directly geometrically compared to the reconstructed spreading geometry.
    
    spreading_feature: Can be a feature with half-stage rotation reconstruction (using left/right plate IDs)
                       or a regular feature with a conjugate plate ID.
                       An example of the former is a mid-ocean ridge, and of the latter an isochron.
    
    rotation_model: Rotation model of type pygplates.RotationModel.
    
    spreading_time: A time at which spreading is happening.
                    For isochrons this should be its time of appearance (ie, when formed at mid-ocean ridge).
                    For mid-ocean ridges this can be any time when the ridge is actively spreading.
                    Defaults to the time of appearance of &#39;spreading_feature&#39;.
    
    Returns: The stage rotation that can be applied to the geometry at the spreading time.
             NOTE: It has already had transforms to and from the stage pole reference frame applied.
             So if you get the stage pole from it, using &#39;get_euler_pole_and_angle()&#39;, then it
             will be the stage pole in the frame of reference of the geometry at the spreading time.
             
             Returns None if &#39;spreading_feature&#39; does not satisfy requirements of a spreading feature.
             (ie, have left/right plate IDs or reconstruction/conjugate plate IDs, and
             have spreading time not in distant past or future, and
             have non-zero stage rotation from &#39;spreading_time + 1&#39; to &#39;spreading_time&#39;).
    &#34;&#34;&#34;
    
    # If the spreading time is not specified then default to the feature&#39;s time of appearance.
    if spreading_time is None:
        spreading_time, _ = spreading_feature.get_valid_time()
    
    # Spreading time must not be distant past or future.
    if (pygplates.GeoTimeInstant(spreading_time).is_distant_past() or
        pygplates.GeoTimeInstant(spreading_time).is_distant_future()):
        return
    
    # Reconstructing either by plate ID or by half stage rotation.
    if spreading_feature.get_reconstruction_method() == &#39;ByPlateId&#39;:
        
        # See if spreading feature has reconstruction and conjugate plate ids.
        reconstruction_and_conjugate_plate_ids = _get_reconstruction_and_conjugate_plate_ids(spreading_feature)
        if not reconstruction_and_conjugate_plate_ids:
            # Spreading feature has no reconstruction/conjugate plate pair.
            return
        
        reconstruction_plate_id, conjugate_plate_id = reconstruction_and_conjugate_plate_ids
        
        #
        # In order to compare spreading geometries with the pole of the stage rotation at spreading time
        # we need to transform either (1) present day spreading geometries, or (2) geometries reconstructed
        # to spreading time, into the reference frame of the stage rotation (so can compare to stage pole).
        #
        # To help us decide this we start by writing the equation for a regular feature (with a conjugate plate)...
        #
        #   geometry_reconstructed = R(0-&gt;t, A-&gt;Recon) * geometry_present_day
        #                          = R(0-&gt;t, A-&gt;Conj) * R(0-&gt;t, Conj-&gt;Recon) * geometry_present_day
        #                          = R(0-&gt;t, A-&gt;Conj) * R(t+1-&gt;t, Conj-&gt;Recon) * R(0-&gt;t+1, Conj-&gt;Recon) * geometry_present_day
        #
        # ...where &#39;Recon&#39; is reconstruction plate ID and &#39;Conj&#39; is conjugate plate ID.
        #
        # We want to transform the spreading geometry into the stage pole reference frame at time &#39;t=spreading_time&#39;.
        # The easiest way to do this is to transform &#39;geometry_reconstructed&#39; instead of &#39;geometry_present_day&#39; since
        # it&#39;s easier to get into the reference frame of the &#39;R(t+1-&gt;t, Conj-&gt;Recon)&#39; rotation
        # which is the stage rotation we&#39;re interested in when &#39;t=spreading_time&#39;.
        # Rearranging the above equation we get...
        #
        #   geometry_present_day = inverse[R(0-&gt;spreading_time+1, Conj-&gt;Recon)]
        #                          * inverse[R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)]
        #                          * inverse[R(0-&gt;spreading_time, A-&gt;Conj)]
        #                          * geometry_reconstructed
        #                        = inverse[R(0-&gt;spreading_time+1, Conj-&gt;Recon)]
        #                          * inverse[R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)]
        #                          * geometry_in_stage_pole_reference_frame
        #
        #   geometry_in_stage_pole_reference_frame = inverse[R(0-&gt;spreading_time, A-&gt;Conj)] * geometry_reconstructed
        #
        # ...where &#39;geometry_in_stage_pole_reference_frame&#39; is in the stage pole reference frame because it gets rotated by
        # the stage pole rotation &#39;inverse[R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)]&#39; which differs from
        # &#39;R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)&#39; only in angle (has negated angle but pole remains the same).
        #
        # So to get reconstructed spreading geometry in the stage pole reference frame we reverse rotate &#39;geometry_reconstructed&#39;
        # by &#39;inverse[R(0-&gt;spreading_time, A-&gt;Conj)]&#39;.
        #
        # So to apply the stage rotation to the reconstructed spreading geometry we rotate it in stage pole reference frame,
        # then apply stage rotation and then rotate back from the stage pole reference frame...
        #
        #   stage_rotate_geometry_reconstructed = R(0-&gt;spreading_time, A-&gt;Conj)
        #                                         * R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)
        #                                         * inverse[R(0-&gt;spreading_time, A-&gt;Conj)]
        #                                         * geometry_reconstructed
        #
        # For more detail see:
        #   http://www.gplates.org/docs/pygplates/sample-code/pygplates_split_isochron_into_ridges_and_transforms.html
        #
        stage_rotation = rotation_model.get_rotation(spreading_time, reconstruction_plate_id, spreading_time + 1, conjugate_plate_id)
        if stage_rotation.represents_identity_rotation():
            return
        from_stage_pole_reference_frame = rotation_model.get_rotation(spreading_time, conjugate_plate_id)
        to_stage_pole_reference_frame = from_stage_pole_reference_frame.get_inverse()
        stage_rotation = from_stage_pole_reference_frame * stage_rotation * to_stage_pole_reference_frame
    
    else: # Reconstruction is by half stage rotation...
        
        # See if spreading feature has left and right plate ids (it should).
        left_and_right_plate_ids = _get_left_and_right_plate_ids(spreading_feature)
        if not left_and_right_plate_ids:
            # Spreading feature has no left/right plate pair.
            return
        
        left_plate_id, right_plate_id = left_and_right_plate_ids
        
        #
        # In order to compare spreading geometries with the pole of the stage rotation at birth time
        # we need to transform either (1) present day spreading geometries, or (2) geometries reconstructed
        # to birth time, into the reference frame of the stage rotation (so can compare to stage pole).
        #
        # To help us decide this we start by writing the equation for a mid-ocean ridge (MOR)...
        #
        #   geometry_reconstructed = R(0-&gt;t, A-&gt;MOR) * geometry_present_day
        #                          = R(0-&gt;t, A-&gt;Left) * R(0-&gt;t, Left-&gt;MOR) * geometry_present_day
        #                          = R(0-&gt;t, A-&gt;Left) * spread(ts-&gt;t, Left-&gt;Right) * geometry_present_day
        #
        # ...where &#39;MOR&#39; is not a plate ID, which is why we do half-spreading (or asymmetric spreading) of
        # right plate relative to left plate. The function &#39;spread()&#39; usually splits the time interval from
        # spreading start time &#39;ts&#39; to time &#39;t&#39; into N stages and accumulates spreading over those N stages...
        #
        #   geometry_reconstructed = R(0-&gt;t, A-&gt;Left) * spread(ts-&gt;t, Left-&gt;Right) * geometry_present_day
        #                          = R(0-&gt;t, A-&gt;Left)
        #                            * spread(t[N-1]-&gt;t, Left-&gt;Right) * spread(t[N-2]-&gt;t[N-1], Left-&gt;Right) * ... * spread(t1-&gt;t2, Left-&gt;Right) * spread(ts-&gt;t1, Left-&gt;Right)
        #                            * geometry_present_day
        #
        # ...in GPlates the &#34;gpml:ReconstructionMethodEnumeration&#34; property currently supports &#39;HalfStageRotation&#39; versions 1, 2 and 3.
        # They only differ in the spreading start time &#39;ts&#39; and the number of stages N.
        # Version 1 has &#39;ts=0&#39; and &#39;N=1&#39;.
        # Version 2 has &#39;ts=0&#39; and &#39;N&gt;1&#39;.
        # Version 3 has &#39;ts=spreading_time&#39; and &#39;N&gt;1&#39;.
        #
        # We want to transform the spreading geometry into the stage pole reference frame at time &#39;t=spreading_time&#39;.
        # The easiest way to do this is to transform &#39;geometry_reconstructed&#39; instead of &#39;geometry_present_day&#39; since
        # it&#39;s easier to get into the reference frame of the &#39;spread(t[N-1]-&gt;t, Left-&gt;Right)&#39; rotation
        # which is the stage rotation we&#39;re interested in when &#39;t=spreading_time&#39;.
        # Rearranging the above equation we get...
        #
        #   geometry_present_day = inverse[spread(ts-&gt;t1, Left-&gt;Right)] * ... * inverse[spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)]
        #                          * inverse[R(0-&gt;t, A-&gt;Left)]
        #                          * geometry_reconstructed
        #                        = inverse[spread(ts-&gt;t1, Left-&gt;Right)] * ... * inverse[spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)]
        #                          * geometry_in_stage_pole_reference_frame
        #
        #   geometry_in_stage_pole_reference_frame = inverse[R(0-&gt;spreading_time, A-&gt;Left)] * geometry_reconstructed
        #
        # ...where &#39;geometry_in_stage_pole_reference_frame&#39; is in the stage pole reference frame because it gets rotated by
        # the stage pole rotation &#39;inverse[spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)]&#39; which differs from
        # &#39;spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)&#39; only in angle (has negated angle but pole remains the same).
        #
        # So to get reconstructed spreading geometry in the stage pole reference frame we reverse rotate &#39;geometry_reconstructed&#39; by &#39;inverse[R(0-&gt;spreading_time, A-&gt;Left)]&#39;.
        #
        # So to apply the stage rotation to the reconstructed spreading geometry we rotate it in stage pole reference frame,
        # then apply stage rotation and then rotate back from the stage pole reference frame...
        #
        #   stage_rotate_geometry_reconstructed = R(0-&gt;spreading_time, A-&gt;Left)
        #                                         * R(spreading_time+1-&gt;spreading_time, Left-&gt;Right)
        #                                         * inverse[R(0-&gt;spreading_time, A-&gt;Left)]
        #                                         * geometry_reconstructed
        #
        stage_rotation = rotation_model.get_rotation(spreading_time, right_plate_id, spreading_time + 1, left_plate_id)
        if stage_rotation.represents_identity_rotation():
            return
        from_stage_pole_reference_frame = rotation_model.get_rotation(spreading_time, left_plate_id)
        to_stage_pole_reference_frame = from_stage_pole_reference_frame.get_inverse()
        stage_rotation = from_stage_pole_reference_frame * stage_rotation * to_stage_pole_reference_frame
    
    return stage_rotation

#
# Private function.
#
# Returns a tuple of left and right plate ids from a &#39;feature&#39;, or None if not found.
#
def _get_left_and_right_plate_ids(feature):
    # Get left and right plate ids (if any).
    left_plate_id = feature.get_left_plate(None)
    right_plate_id = feature.get_right_plate(None)
    if left_plate_id is not None and right_plate_id is not None:
        return left_plate_id, right_plate_id


#
# Private function.
#
# Returns a tuple of reconstruction and conjugate plate ids from a &#39;feature&#39;,
# otherwise looks for plate/conjugate ids if feature came from a PLATES data file,
# otherwise returns None.
#
def _get_reconstruction_and_conjugate_plate_ids(feature):
    reconstruction_plate_id = feature.get_reconstruction_plate_id(None)
    conjugate_plate_id = feature.get_conjugate_plate_id(None)
    # If missing either then attempt to get reconstruction/conjugate from the &#39;gpml:OldPlatesHeader&#39; property.
    if reconstruction_plate_id is not None and conjugate_plate_id is not None:
        return reconstruction_plate_id, conjugate_plate_id
    
    gpml_old_plates_header = feature.get_value(pygplates.PropertyName.create_gpml(&#39;oldPlatesHeader&#39;))
    if gpml_old_plates_header:
        try:
            reconstruction_plate_id = gpml_old_plates_header.get_plate_id_number()
            conjugate_plate_id = gpml_old_plates_header.get_conjugate_plate_id_number()
            return reconstruction_plate_id, conjugate_plate_id
        except AttributeError:
            # The property value type did not match the property name.
            # This indicates the data does not conform to the GPlates Geological Information Model (GPGIM).
            pass




if __name__ == &#39;__main__&#39;:
    
    import argparse
    
    
    DEFAULT_OUTPUT_RIDGES_FILENAME_SUFFIX = &#39;_ridges&#39;
    DEFAULT_OUTPUT_TRANSFORMS_FILENAME_SUFFIX = &#39;_transforms&#39;

    __description__ = \
    &#34;&#34;&#34;Split the geometries of isochrons and mid-ocean ridges into ridge and transform segments.
    
    The splitting is based on each segment&#39;s alignment with the geometry&#39;s stage pole at its time of appearance.

    NOTE: Separate the positional and optional arguments with &#39;--&#39; (workaround for bug in argparse module).
    For example...

    python %(prog)s -r rotations.rot -d 45 -s _ridges -t _transforms -- spreading_features.gpml
    &#34;&#34;&#34;
    
    # The command-line parser.
    parser = argparse.ArgumentParser(description = __description__, formatter_class=argparse.RawDescriptionHelpFormatter)
    
    parser.add_argument(&#39;-r&#39;, &#39;--rotation_filenames&#39;, type=str, nargs=&#39;+&#39;, required=True,
            metavar=&#39;rotation_filename&#39;, help=&#39;One or more rotation files.&#39;)
    
    parser.add_argument(&#39;-s&#39;, &#39;--output_ridges_filename_suffix&#39;, type=str,
            default=&#39;{0}&#39;.format(DEFAULT_OUTPUT_RIDGES_FILENAME_SUFFIX),
            help=&#34;The suffix to append to each input filename to get each output ridges filename - &#34;
                &#34;the default suffix is &#39;{0}&#39;&#34;.format(DEFAULT_OUTPUT_RIDGES_FILENAME_SUFFIX))
    parser.add_argument(&#39;-t&#39;, &#39;--output_transforms_filename_suffix&#39;, type=str,
            default=&#39;{0}&#39;.format(DEFAULT_OUTPUT_TRANSFORMS_FILENAME_SUFFIX),
            help=&#34;The suffix to append to each input filename to get each output transforms filename - &#34;
                &#34;the default suffix is &#39;{0}&#39;&#34;.format(DEFAULT_OUTPUT_TRANSFORMS_FILENAME_SUFFIX))
    
    parser.add_argument(&#39;-d&#39;, &#39;--transform_segment_deviation_degrees&#39;, type=float,
            default=&#39;{0}&#39;.format(DEFAULT_TRANSFORM_SEGMENT_DEVIATION_DEGREES),
            help=&#34;How many degrees a spreading segment can deviate from the stage pole before it&#39;s considered a transform segment - &#34;
                &#34;default is &#39;{0}&#39;&#34;.format(DEFAULT_TRANSFORM_SEGMENT_DEVIATION_DEGREES))
    
    parser.add_argument(&#39;-f&#39;, &#39;--spreading_feature_types&#39;, type=str, nargs=&#39;+&#39;,
            metavar=&#39;spreading_feature_type&#39;,
            help=&#39;The feature type(s) to split into ridge/transform segments. &#39;
                &#39;All other feature types will be ignored (and not end up in separated ridge/transform output files). &#39;
                &#39;The format should match the format of &#39;
                &#39;http://www.gplates.org/docs/pygplates/generated/pygplates.FeatureType.html#pygplates.FeatureType.get_name . &#39;
                &#39;For example, mid-ocean ridges are specified as MidOceanRidge (without the gpml: prefix). &#39;
                &#39;Defaults to splitting all features (although features that are not spreading are ignored).&#39;)
    
    parser.add_argument(&#39;input_filenames&#39;, type=str, nargs=&#39;+&#39;,
            metavar=&#39;input_filename&#39;,
            help=&#39;One or more input filenames (original files).&#39;)
    
    # Parse command-line options.
    args = parser.parse_args()
    
    # Convert strings into feature types.
    # For example, &#39;MidOceanRidge&#39; into pygplates.FeatureType.create_gpml(&#39;MidOceanRidge&#39;)
    if args.spreading_feature_types:
        args.spreading_feature_types = [pygplates.FeatureType.create_gpml(feature_type)
                for feature_type in args.spreading_feature_types]
    
    for input_filename in args.input_filenames:
        ridge_features, transform_features = separate_features_into_ridges_and_transforms(
                args.rotation_filenames,
                args.input_filenames,
                args.spreading_feature_types,
                math.radians(args.transform_segment_deviation_degrees))
        
        # Each output filename is the input filename with a suffix appended.
        filename_root, filename_ext = os.path.splitext(input_filename)
        output_ridges_filename = &#39;&#39;.join((filename_root, args.output_ridges_filename_suffix, filename_ext))
        pygplates.FeatureCollection(ridge_features).write(output_ridges_filename)
        
        # Each output filename is the input filename with a suffix appended.
        filename_root, filename_ext = os.path.splitext(input_filename)
        output_transforms_filename = &#39;&#39;.join((filename_root, args.output_transforms_filename_suffix, filename_ext))
        pygplates.FeatureCollection(transform_features).write(output_transforms_filename)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gplately.ptt.separate_ridge_transform_segments.get_stage_rotation_for_reconstructed_geometry"><code class="name flex">
<span>def <span class="ident">get_stage_rotation_for_reconstructed_geometry</span></span>(<span>spreading_feature, rotation_model, spreading_time=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the stage rotation of the spreading feature in the frame of reference of its geometry at the spreading time.
The stage pole can then be directly geometrically compared to the reconstructed spreading geometry.</p>
<p>spreading_feature: Can be a feature with half-stage rotation reconstruction (using left/right plate IDs)
or a regular feature with a conjugate plate ID.
An example of the former is a mid-ocean ridge, and of the latter an isochron.</p>
<p>rotation_model: Rotation model of type pygplates.RotationModel.</p>
<p>spreading_time: A time at which spreading is happening.
For isochrons this should be its time of appearance (ie, when formed at mid-ocean ridge).
For mid-ocean ridges this can be any time when the ridge is actively spreading.
Defaults to the time of appearance of 'spreading_feature'.</p>
<p>Returns: The stage rotation that can be applied to the geometry at the spreading time.
NOTE: It has already had transforms to and from the stage pole reference frame applied.
So if you get the stage pole from it, using 'get_euler_pole_and_angle()', then it
will be the stage pole in the frame of reference of the geometry at the spreading time.</p>
<pre><code>     Returns None if 'spreading_feature' does not satisfy requirements of a spreading feature.
     (ie, have left/right plate IDs or reconstruction/conjugate plate IDs, and
     have spreading time not in distant past or future, and
     have non-zero stage rotation from 'spreading_time + 1' to 'spreading_time').
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stage_rotation_for_reconstructed_geometry(
        spreading_feature,
        rotation_model,
        spreading_time = None):
    &#34;&#34;&#34;
    Find the stage rotation of the spreading feature in the frame of reference of its geometry at the spreading time.
    The stage pole can then be directly geometrically compared to the reconstructed spreading geometry.
    
    spreading_feature: Can be a feature with half-stage rotation reconstruction (using left/right plate IDs)
                       or a regular feature with a conjugate plate ID.
                       An example of the former is a mid-ocean ridge, and of the latter an isochron.
    
    rotation_model: Rotation model of type pygplates.RotationModel.
    
    spreading_time: A time at which spreading is happening.
                    For isochrons this should be its time of appearance (ie, when formed at mid-ocean ridge).
                    For mid-ocean ridges this can be any time when the ridge is actively spreading.
                    Defaults to the time of appearance of &#39;spreading_feature&#39;.
    
    Returns: The stage rotation that can be applied to the geometry at the spreading time.
             NOTE: It has already had transforms to and from the stage pole reference frame applied.
             So if you get the stage pole from it, using &#39;get_euler_pole_and_angle()&#39;, then it
             will be the stage pole in the frame of reference of the geometry at the spreading time.
             
             Returns None if &#39;spreading_feature&#39; does not satisfy requirements of a spreading feature.
             (ie, have left/right plate IDs or reconstruction/conjugate plate IDs, and
             have spreading time not in distant past or future, and
             have non-zero stage rotation from &#39;spreading_time + 1&#39; to &#39;spreading_time&#39;).
    &#34;&#34;&#34;
    
    # If the spreading time is not specified then default to the feature&#39;s time of appearance.
    if spreading_time is None:
        spreading_time, _ = spreading_feature.get_valid_time()
    
    # Spreading time must not be distant past or future.
    if (pygplates.GeoTimeInstant(spreading_time).is_distant_past() or
        pygplates.GeoTimeInstant(spreading_time).is_distant_future()):
        return
    
    # Reconstructing either by plate ID or by half stage rotation.
    if spreading_feature.get_reconstruction_method() == &#39;ByPlateId&#39;:
        
        # See if spreading feature has reconstruction and conjugate plate ids.
        reconstruction_and_conjugate_plate_ids = _get_reconstruction_and_conjugate_plate_ids(spreading_feature)
        if not reconstruction_and_conjugate_plate_ids:
            # Spreading feature has no reconstruction/conjugate plate pair.
            return
        
        reconstruction_plate_id, conjugate_plate_id = reconstruction_and_conjugate_plate_ids
        
        #
        # In order to compare spreading geometries with the pole of the stage rotation at spreading time
        # we need to transform either (1) present day spreading geometries, or (2) geometries reconstructed
        # to spreading time, into the reference frame of the stage rotation (so can compare to stage pole).
        #
        # To help us decide this we start by writing the equation for a regular feature (with a conjugate plate)...
        #
        #   geometry_reconstructed = R(0-&gt;t, A-&gt;Recon) * geometry_present_day
        #                          = R(0-&gt;t, A-&gt;Conj) * R(0-&gt;t, Conj-&gt;Recon) * geometry_present_day
        #                          = R(0-&gt;t, A-&gt;Conj) * R(t+1-&gt;t, Conj-&gt;Recon) * R(0-&gt;t+1, Conj-&gt;Recon) * geometry_present_day
        #
        # ...where &#39;Recon&#39; is reconstruction plate ID and &#39;Conj&#39; is conjugate plate ID.
        #
        # We want to transform the spreading geometry into the stage pole reference frame at time &#39;t=spreading_time&#39;.
        # The easiest way to do this is to transform &#39;geometry_reconstructed&#39; instead of &#39;geometry_present_day&#39; since
        # it&#39;s easier to get into the reference frame of the &#39;R(t+1-&gt;t, Conj-&gt;Recon)&#39; rotation
        # which is the stage rotation we&#39;re interested in when &#39;t=spreading_time&#39;.
        # Rearranging the above equation we get...
        #
        #   geometry_present_day = inverse[R(0-&gt;spreading_time+1, Conj-&gt;Recon)]
        #                          * inverse[R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)]
        #                          * inverse[R(0-&gt;spreading_time, A-&gt;Conj)]
        #                          * geometry_reconstructed
        #                        = inverse[R(0-&gt;spreading_time+1, Conj-&gt;Recon)]
        #                          * inverse[R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)]
        #                          * geometry_in_stage_pole_reference_frame
        #
        #   geometry_in_stage_pole_reference_frame = inverse[R(0-&gt;spreading_time, A-&gt;Conj)] * geometry_reconstructed
        #
        # ...where &#39;geometry_in_stage_pole_reference_frame&#39; is in the stage pole reference frame because it gets rotated by
        # the stage pole rotation &#39;inverse[R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)]&#39; which differs from
        # &#39;R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)&#39; only in angle (has negated angle but pole remains the same).
        #
        # So to get reconstructed spreading geometry in the stage pole reference frame we reverse rotate &#39;geometry_reconstructed&#39;
        # by &#39;inverse[R(0-&gt;spreading_time, A-&gt;Conj)]&#39;.
        #
        # So to apply the stage rotation to the reconstructed spreading geometry we rotate it in stage pole reference frame,
        # then apply stage rotation and then rotate back from the stage pole reference frame...
        #
        #   stage_rotate_geometry_reconstructed = R(0-&gt;spreading_time, A-&gt;Conj)
        #                                         * R(spreading_time+1-&gt;spreading_time, Conj-&gt;Recon)
        #                                         * inverse[R(0-&gt;spreading_time, A-&gt;Conj)]
        #                                         * geometry_reconstructed
        #
        # For more detail see:
        #   http://www.gplates.org/docs/pygplates/sample-code/pygplates_split_isochron_into_ridges_and_transforms.html
        #
        stage_rotation = rotation_model.get_rotation(spreading_time, reconstruction_plate_id, spreading_time + 1, conjugate_plate_id)
        if stage_rotation.represents_identity_rotation():
            return
        from_stage_pole_reference_frame = rotation_model.get_rotation(spreading_time, conjugate_plate_id)
        to_stage_pole_reference_frame = from_stage_pole_reference_frame.get_inverse()
        stage_rotation = from_stage_pole_reference_frame * stage_rotation * to_stage_pole_reference_frame
    
    else: # Reconstruction is by half stage rotation...
        
        # See if spreading feature has left and right plate ids (it should).
        left_and_right_plate_ids = _get_left_and_right_plate_ids(spreading_feature)
        if not left_and_right_plate_ids:
            # Spreading feature has no left/right plate pair.
            return
        
        left_plate_id, right_plate_id = left_and_right_plate_ids
        
        #
        # In order to compare spreading geometries with the pole of the stage rotation at birth time
        # we need to transform either (1) present day spreading geometries, or (2) geometries reconstructed
        # to birth time, into the reference frame of the stage rotation (so can compare to stage pole).
        #
        # To help us decide this we start by writing the equation for a mid-ocean ridge (MOR)...
        #
        #   geometry_reconstructed = R(0-&gt;t, A-&gt;MOR) * geometry_present_day
        #                          = R(0-&gt;t, A-&gt;Left) * R(0-&gt;t, Left-&gt;MOR) * geometry_present_day
        #                          = R(0-&gt;t, A-&gt;Left) * spread(ts-&gt;t, Left-&gt;Right) * geometry_present_day
        #
        # ...where &#39;MOR&#39; is not a plate ID, which is why we do half-spreading (or asymmetric spreading) of
        # right plate relative to left plate. The function &#39;spread()&#39; usually splits the time interval from
        # spreading start time &#39;ts&#39; to time &#39;t&#39; into N stages and accumulates spreading over those N stages...
        #
        #   geometry_reconstructed = R(0-&gt;t, A-&gt;Left) * spread(ts-&gt;t, Left-&gt;Right) * geometry_present_day
        #                          = R(0-&gt;t, A-&gt;Left)
        #                            * spread(t[N-1]-&gt;t, Left-&gt;Right) * spread(t[N-2]-&gt;t[N-1], Left-&gt;Right) * ... * spread(t1-&gt;t2, Left-&gt;Right) * spread(ts-&gt;t1, Left-&gt;Right)
        #                            * geometry_present_day
        #
        # ...in GPlates the &#34;gpml:ReconstructionMethodEnumeration&#34; property currently supports &#39;HalfStageRotation&#39; versions 1, 2 and 3.
        # They only differ in the spreading start time &#39;ts&#39; and the number of stages N.
        # Version 1 has &#39;ts=0&#39; and &#39;N=1&#39;.
        # Version 2 has &#39;ts=0&#39; and &#39;N&gt;1&#39;.
        # Version 3 has &#39;ts=spreading_time&#39; and &#39;N&gt;1&#39;.
        #
        # We want to transform the spreading geometry into the stage pole reference frame at time &#39;t=spreading_time&#39;.
        # The easiest way to do this is to transform &#39;geometry_reconstructed&#39; instead of &#39;geometry_present_day&#39; since
        # it&#39;s easier to get into the reference frame of the &#39;spread(t[N-1]-&gt;t, Left-&gt;Right)&#39; rotation
        # which is the stage rotation we&#39;re interested in when &#39;t=spreading_time&#39;.
        # Rearranging the above equation we get...
        #
        #   geometry_present_day = inverse[spread(ts-&gt;t1, Left-&gt;Right)] * ... * inverse[spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)]
        #                          * inverse[R(0-&gt;t, A-&gt;Left)]
        #                          * geometry_reconstructed
        #                        = inverse[spread(ts-&gt;t1, Left-&gt;Right)] * ... * inverse[spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)]
        #                          * geometry_in_stage_pole_reference_frame
        #
        #   geometry_in_stage_pole_reference_frame = inverse[R(0-&gt;spreading_time, A-&gt;Left)] * geometry_reconstructed
        #
        # ...where &#39;geometry_in_stage_pole_reference_frame&#39; is in the stage pole reference frame because it gets rotated by
        # the stage pole rotation &#39;inverse[spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)]&#39; which differs from
        # &#39;spread(t[N-1]-&gt;spreading_time, Left-&gt;Right)&#39; only in angle (has negated angle but pole remains the same).
        #
        # So to get reconstructed spreading geometry in the stage pole reference frame we reverse rotate &#39;geometry_reconstructed&#39; by &#39;inverse[R(0-&gt;spreading_time, A-&gt;Left)]&#39;.
        #
        # So to apply the stage rotation to the reconstructed spreading geometry we rotate it in stage pole reference frame,
        # then apply stage rotation and then rotate back from the stage pole reference frame...
        #
        #   stage_rotate_geometry_reconstructed = R(0-&gt;spreading_time, A-&gt;Left)
        #                                         * R(spreading_time+1-&gt;spreading_time, Left-&gt;Right)
        #                                         * inverse[R(0-&gt;spreading_time, A-&gt;Left)]
        #                                         * geometry_reconstructed
        #
        stage_rotation = rotation_model.get_rotation(spreading_time, right_plate_id, spreading_time + 1, left_plate_id)
        if stage_rotation.represents_identity_rotation():
            return
        from_stage_pole_reference_frame = rotation_model.get_rotation(spreading_time, left_plate_id)
        to_stage_pole_reference_frame = from_stage_pole_reference_frame.get_inverse()
        stage_rotation = from_stage_pole_reference_frame * stage_rotation * to_stage_pole_reference_frame
    
    return stage_rotation</code></pre>
</details>
</dd>
<dt id="gplately.ptt.separate_ridge_transform_segments.separate_features_into_ridges_and_transforms"><code class="name flex">
<span>def <span class="ident">separate_features_into_ridges_and_transforms</span></span>(<span>rotation_features_or_model, spreading_features, spreading_feature_types=None, transform_segment_deviation_in_radians=0.7853981633974483)</span>
</code></dt>
<dd>
<div class="desc"><p>Split the geometries of isochrons and mid-ocean ridges into ridge and transform segments based
on each segment’s alignment with the geometry’s stage pole at its time of appearance.</p>
<p>rotation_features_or_model: Rotation model or feature collection(s), or list of features, or filename(s).</p>
<p>spreading_features: Spreading feature collection(s), or list of features, or filename(s) or any combination of those.</p>
<p>spreading_feature_types: Only spreading features with a feature type contained in this list are considered.
If None then all spreading features are considered.</p>
<p>transform_segment_deviation_in_radians: How much a segment can deviate from the stage pole before
it's considered a transform segment (in radians).</p>
<p>Returns: The separated ridge and transform features respectively, of type
2-tuple (list of pygplates.Feature, list of pygplates.Feature).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def separate_features_into_ridges_and_transforms(
        rotation_features_or_model,
        spreading_features,
        spreading_feature_types = None,
        transform_segment_deviation_in_radians = DEFAULT_TRANSFORM_SEGMENT_DEVIATION_RADIANS):
    &#34;&#34;&#34;
    Split the geometries of isochrons and mid-ocean ridges into ridge and transform segments based
    on each segment’s alignment with the geometry’s stage pole at its time of appearance.
    
    rotation_features_or_model: Rotation model or feature collection(s), or list of features, or filename(s).
    
    spreading_features: Spreading feature collection(s), or list of features, or filename(s) or any combination of those.
    
    spreading_feature_types: Only spreading features with a feature type contained in this list are considered.
                             If None then all spreading features are considered.
    
    transform_segment_deviation_in_radians: How much a segment can deviate from the stage pole before
                                            it&#39;s considered a transform segment (in radians).
    
    Returns: The separated ridge and transform features respectively, of type
             2-tuple (list of pygplates.Feature, list of pygplates.Feature).
    &#34;&#34;&#34;
    
    # Turn rotation data into a RotationModel (if not already).
    #
    # OPTIMISATION:
    # We will be reconstructing (and reverse reconstructing) mid-ocean ridges in groups, where ridges in each
    # group have the same time-of-appearance. They need to have the same time of appearance because, in pyGPlates,
    # version 3 half-stage rotations start spreading from the time-of-appearance in 10 My intervals
    # (ie, the 10My intervals are &#39;begin_time&#39;, &#39;begin_time-10&#39;, begin_time-20&#39;, ..., reconstruction_time).
    # And because the mid-ocean ridges with the same time-of-appearance also have the same time intervals
    # they&#39;ll reuse the cached reconstruction trees (one cached tree per time interval).
    # This will avoid a lot of wasted time recreating these trees if the cache is continually flushed
    # (eg, by mixing mid-ocean ridges with different appearance times).
    #
    # A cache size of 100 is enough to go back to 1,000Ma (100 entries * 10My interval).
    rotation_model = pygplates.RotationModel(rotation_features_or_model, 100)
    
    # Turn spreading feature data into a list of features (if not already).
    spreading_features = pygplates.FeaturesFunctionArgument(spreading_features)
    
    # Gather all spreading features with the same begin time (time-of-appearance) into groups.
    #
    # This is an optimisation that enables reconstructing multiple mid-ocean ridges with the same begin time together.
    # This can make a *big* difference to the running time (see note above regarding rotation model cache size).
    spreading_features_grouped_by_begin_time = {}
    
    # Iterate over all geometries in spreading features.
    for spreading_feature in spreading_features.get_features():
        
        # Filter spreading feature types if requested.
        if (spreading_feature_types and
            spreading_feature.get_feature_type() not in spreading_feature_types):
            continue
        
        begin_time, _ = spreading_feature.get_valid_time()
        
        # Add to list of spreading features with same begin time.
        if begin_time not in spreading_features_grouped_by_begin_time:
            spreading_features_grouped_by_begin_time[begin_time] = []
        spreading_features_grouped_by_begin_time[begin_time].append(spreading_feature)
    
    # The separated ridge/transform segment features.
    # Both types of segment feature will have the same feature type as the feature they are extracted from.
    ridge_segment_features = []
    transform_segment_features = []
    
    # Iterate over groups of spreading features with the same begin time (time-of-appearance).
    for begin_time, spreading_features_with_begin_time in spreading_features_grouped_by_begin_time.items():
        
        # Reconstruct the spreading features to their common birth time.
        reconstructed_spreading_features = []
        pygplates.reconstruct(
                spreading_features_with_begin_time,
                rotation_model,
                reconstructed_spreading_features,
                begin_time,
                group_with_feature=True)
        
        ridge_segment_features_with_begin_time = []
        transform_segment_features_with_begin_time = []
        
        # Iterate over reconstructed spreading features.
        for spreading_feature, reconstructed_spreading_geometries in reconstructed_spreading_features:
            
            # Find the stage rotation of the spreading feature in the frame of reference of its
            # geometry at its birth time. The stage pole can then be directly geometrically compared
            # to the reconstructed spreading geometry.
            stage_rotation = get_stage_rotation_for_reconstructed_geometry(spreading_feature, rotation_model, begin_time)
            if not stage_rotation:
                # Skip current feature - it&#39;s not a spreading feature.
                continue
            
            ridge_segment_geometries = []
            transform_segment_geometries = []
            
            # A feature usually has a single geometry but it could have more - iterate over them all.
            for reconstructed_spreading_geometry in reconstructed_spreading_geometries:
                ridge_and_transform_segment_geometries = separate_geometry_into_ridges_and_transforms(
                        stage_rotation,
                        reconstructed_spreading_geometry.get_reconstructed_geometry(),
                        transform_segment_deviation_in_radians)
                if ridge_and_transform_segment_geometries:
                    ridge_segment_geometries.extend(ridge_and_transform_segment_geometries[0])
                    transform_segment_geometries.extend(ridge_and_transform_segment_geometries[1])
            
            # Put all ridge segment geometries into one feature and transform segment geometries into another.
            if ridge_segment_geometries:
                ridge_segment_feature = spreading_feature.clone()
                ridge_segment_feature.set_geometry(ridge_segment_geometries)
                ridge_segment_features_with_begin_time.append(ridge_segment_feature)
            if transform_segment_geometries:
                transform_segment_feature = spreading_feature.clone()
                transform_segment_feature.set_geometry(transform_segment_geometries)
                transform_segment_features_with_begin_time.append(transform_segment_feature)
        
        # Reverse reconstruct the segmented spreading features from their common birth time.
        #
        # Each new feature needs to be reverse reconstructed from birth time to present day because the
        # geometries are reconstructed (but need to be stored in present day positions within the feature).
        pygplates.reverse_reconstruct(
                (ridge_segment_features_with_begin_time, transform_segment_features_with_begin_time),
                rotation_model,
                begin_time)
        
        ridge_segment_features.extend(ridge_segment_features_with_begin_time)
        transform_segment_features.extend(transform_segment_features_with_begin_time)
    
    return ridge_segment_features, transform_segment_features</code></pre>
</details>
</dd>
<dt id="gplately.ptt.separate_ridge_transform_segments.separate_geometry_into_ridges_and_transforms"><code class="name flex">
<span>def <span class="ident">separate_geometry_into_ridges_and_transforms</span></span>(<span>stage_rotation, geometry_at_spreading_time, transform_segment_deviation_in_radians=0.7853981633974483)</span>
</code></dt>
<dd>
<div class="desc"><p>Split the geometry of an isochron or mid-ocean ridge (at a time when there is spreading) into ridge and
transform segments based on each segment’s alignment with the geometry’s stage pole at its time of appearance.</p>
<p>For isochrons the geometry should be at its time of appearance (ie, when formed at mid-ocean ridge).
For mid-ocean ridges the geometry can be any time when the ridge is actively spreading.</p>
<p>stage_rotation: The stage rotation that can be applied to the geometry at the spreading time.
NOTE: It must have already had transforms to and from the stage pole reference frame applied.
In other words, if you get the stage pole from it, using 'get_euler_pole_and_angle()', then it
should be the stage pole in the frame of reference of the geometry at the spreading time.</p>
<p>geometry_at_spreading_time: The polyline (or polygon) at the spreading time.</p>
<p>transform_segment_deviation_in_radians: How much a segment can deviate from the stage pole before
it's considered a transform segment (in radians).</p>
<p>Returns: The separated ridge and transform geometries respectively, of type
2-tuple (list of pygplates.Polyline, list of pygplates.Polyline).
Returns None if 'geometry_at_spreading_time' is not a polyline (or polygon).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def separate_geometry_into_ridges_and_transforms(
        stage_rotation,
        geometry_at_spreading_time,
        transform_segment_deviation_in_radians = DEFAULT_TRANSFORM_SEGMENT_DEVIATION_RADIANS):
    &#34;&#34;&#34;
    Split the geometry of an isochron or mid-ocean ridge (at a time when there is spreading) into ridge and
    transform segments based on each segment’s alignment with the geometry’s stage pole at its time of appearance.
    
    For isochrons the geometry should be at its time of appearance (ie, when formed at mid-ocean ridge).
    For mid-ocean ridges the geometry can be any time when the ridge is actively spreading.
    
    stage_rotation: The stage rotation that can be applied to the geometry at the spreading time.
                    NOTE: It must have already had transforms to and from the stage pole reference frame applied.
                    In other words, if you get the stage pole from it, using &#39;get_euler_pole_and_angle()&#39;, then it
                    should be the stage pole in the frame of reference of the geometry at the spreading time.
    
    geometry_at_spreading_time: The polyline (or polygon) at the spreading time.
    
    transform_segment_deviation_in_radians: How much a segment can deviate from the stage pole before
                                            it&#39;s considered a transform segment (in radians).
    
    Returns: The separated ridge and transform geometries respectively, of type
             2-tuple (list of pygplates.Polyline, list of pygplates.Polyline).
             Returns None if &#39;geometry_at_spreading_time&#39; is not a polyline (or polygon).
    &#34;&#34;&#34;
    
    # Iterate over the segments of the geometry.
    # Note that we&#39;re assuming the geometry is a polyline (or polygon) - otherwise we ignore the geometry.
    try:
        segments = geometry_at_spreading_time.get_segments()
    except AttributeError:
        return
    
    # Get the stage pole of the stage rotation.
    # Note that the stage rotation is already in frame of reference of the geometry at the spreading time.
    stage_pole, _ = stage_rotation.get_euler_pole_and_angle()
    
    ridge_segment_geometries = []
    transform_segment_geometries = []
    
    # Points of contiguous segments belonging either to a ridge or transform.
    contiguous_segment_points = []
    is_transform = False
    
    for segment in segments:
        # Ignore zero length segments - they don&#39;t have a direction.
        if segment.is_zero_length():
            continue
        
        # Get the point in the middle of the segment and its tangential direction.
        segment_midpoint = segment.get_arc_point(0.5)
        segment_direction_at_midpoint = segment.get_arc_direction(0.5)
        
        # Get the direction from the segment midpoint to the stage pole.
        # This is the tangential direction at the start of an arc from the segment
        # midpoint to the stage pole (the zero parameter indicates the arc start point
        # which is the segment midpoint).
        segment_to_stage_pole_direction = pygplates.GreatCircleArc(
                segment_midpoint, stage_pole).get_arc_direction(0)
        
        # The angle that the segment deviates from the stage pole direction.
        deviation_of_segment_direction_from_stage_pole = pygplates.Vector3D.angle_between(
                segment_direction_at_midpoint, segment_to_stage_pole_direction)
        
        # When comparing the deviation angle we need to consider the case where the two
        # direction vectors are aligned but pointing in opposite directions.
        if (deviation_of_segment_direction_from_stage_pole &lt; transform_segment_deviation_in_radians or
            deviation_of_segment_direction_from_stage_pole &gt; math.pi - transform_segment_deviation_in_radians):
            
            # If switching from transform to ridge.
            if is_transform:
                # Emit transform polyline (if any) and restart contiguous segments.
                if contiguous_segment_points:
                    transform_segment_geometries.append(pygplates.PolylineOnSphere(contiguous_segment_points))
                    contiguous_segment_points = []
            
            is_transform = False
            
        else: # transform
            
            # If switching from ridge to transform.
            if not is_transform:
                # Emit ridge polyline (if any) and restart contiguous segments.
                if contiguous_segment_points:
                    ridge_segment_geometries.append(pygplates.PolylineOnSphere(contiguous_segment_points))
                    contiguous_segment_points = []
            
            is_transform = True
        
        # Add segment start point if first segment.
        if not contiguous_segment_points:
            contiguous_segment_points.append(segment.get_start_point())
        
        # Add segment end point.
        contiguous_segment_points.append(segment.get_end_point())
    
    # Emit last ridge or transform polyline (if any).
    if contiguous_segment_points:
        if is_transform:
            transform_segment_geometries.append(pygplates.PolylineOnSphere(contiguous_segment_points))
        else:
            ridge_segment_geometries.append(pygplates.PolylineOnSphere(contiguous_segment_points))
    
    return ridge_segment_geometries, transform_segment_geometries</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="GPlately logo" height="172" width="205">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately.ptt" href="index.html">gplately.ptt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gplately.ptt.separate_ridge_transform_segments.get_stage_rotation_for_reconstructed_geometry" href="#gplately.ptt.separate_ridge_transform_segments.get_stage_rotation_for_reconstructed_geometry">get_stage_rotation_for_reconstructed_geometry</a></code></li>
<li><code><a title="gplately.ptt.separate_ridge_transform_segments.separate_features_into_ridges_and_transforms" href="#gplately.ptt.separate_ridge_transform_segments.separate_features_into_ridges_and_transforms">separate_features_into_ridges_and_transforms</a></code></li>
<li><code><a title="gplately.ptt.separate_ridge_transform_segments.separate_geometry_into_ridges_and_transforms" href="#gplately.ptt.separate_ridge_transform_segments.separate_geometry_into_ridges_and_transforms">separate_geometry_into_ridges_and_transforms</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>