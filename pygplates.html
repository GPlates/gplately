<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gplately.pygplates API documentation</title>
<meta name="description" content="A light wrapping of some
[`pyGPlates`](https://www.gplates.org/docs/pygplates/index.html)
classes to keep track of filenames …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.pygplates</code></h1>
</header>
<section id="section-intro">
<p>A light wrapping of some
<a href="https://www.gplates.org/docs/pygplates/index.html"><code>pyGPlates</code></a>
classes to keep track of filenames.</p>
<p>Each object listed here will have a <code>self.filenames</code> attribute.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A light wrapping of some 
[`pyGPlates`](https://www.gplates.org/docs/pygplates/index.html) 
classes to keep track of filenames.

Each object listed here will have a `self.filenames` attribute.
&#34;&#34;&#34;

import warnings as _warnings
from copy import copy
from typing import List, Union

import pygplates as _pygplates
from pygplates import *

_warnings.simplefilter(&#34;always&#34;, ImportWarning)


def _is_string(value):
    # convert sets to list
    if type(value) is set:
        value = list(value)

    # check for strings inside a list
    if type(value) is list:
        bl = []
        for val in value:
            bl.append(type(val) is str)
        return all(bl)

    # if no list, check if string
    else:
        return type(value) is str


class RotationModel(_pygplates.RotationModel):
    &#34;&#34;&#34;A class that wraps the
    [`pyGPlates.RotationModel` class](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel).
    This queries a finite rotation of a moving plate relative to any other plate,
    optionally between two instants in geological time.

    See [Plate reconstruction hierarchy](https://www.gplates.org/docs/pygplates/pygplates_foundations.html#pygplates-foundations-plate-reconstruction-hierarchy).

    This class provides an easy way to query rotations in any of the four
    combinations of total/stage and equivalent/relative rotations using
    [`get_rotation()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation).

    Reconstruction trees can also be created at any instant
    of geological time and these are cached internally depending on a
    user-specified cache size parameter pass to `gplately.pygplates.RotationModel.__init__()`.
    The reconstruction_tree_cache_size parameter of those methods controls the
    size of an internal least-recently-used cache of reconstruction trees
    (evicts least recently requested reconstruction tree when a new
    reconstruction time is requested that does not currently exist in the cache).
    This enables reconstruction trees associated with different reconstruction
    times to be re-used instead of re-creating them, provided they have not been
    evicted from the cache. This benefit also applies when querying rotations with
    [`get_rotation()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation)
    since it, in turn, requests reconstruction trees.


    This wrapping of `pygplates.RotationModel` contains all
    [`pygplates.RotationModel` functionality](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel),
    and in addition tracks the names of files from which the rotation feature(s) are read
    using the `gplately.pygplates.RotationModel.filenames` attribute.


    &#34;&#34;&#34;

    def __init__(self, rotation_features, default_anchor_plate_id=0):
        &#34;&#34;&#34;**A RotationModel object can be constructed in three ways.**

        ---
        **1. Create from rotation feature collection(s) and/or rotation filename(s)**
        --------------------------------------------------------------------------

        Parameters
        ----------
        rotation_features : instance of `pygplates.FeatureCollection` or `str` or instance of `pygplates.Feature` or sequence of `pygplates.Feature` or sequence of any combination of those four types
            A rotation feature collection, or rotation filename, or rotation feature,
            or sequence of rotation features, or a sequence (eg, `list` or `tuple`) of
            any combination of those four types.

        reconstruction_tree_cache_size : int, default 150
            Number of reconstruction trees to cache internally. Defaults to 150.

        extend_total_reconstruction_poles_to_distant_past : bool, default False
            Extend each moving plate sequence back infinitely far into the distant
            past such that reconstructed geometries will not snap back to their
            present day positions when the reconstruction time is older than
            the oldest times specified in the rotation features (defaults to False).

        default_anchor_plate_id : int, default 0
            The default anchored plate id to use when
            [`get_rotation()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation)
            and [`get_reconstruction_tree()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_reconstruction_tree)
            are called without specifying their `anchor_plate_id` parameter. Defaults to 0.

        Raises
        ------
        OpenFileForReadingError
            If any file is not readable (when filenames specified)

        FileFormatNotSupportedError
            If any file format (identified by the filename extensions)
            does not support reading (when filenames specified)


        Note that `rotation_features` can be a rotation `FeatureCollection` or a rotation filename or a rotation Feature or a sequence of rotation features, or a sequence (eg, `list` or `tuple`) of any combination of those four types.

        If any rotation filenames are specified then this method uses `FeatureCollection` internally to read the rotation files.


        Example
        -------
        Load a rotation file and some rotation adjustments (as a collection of rotation features) into a rotation model:

            rotation_adjustments = pygplates.FeatureCollection()
            ...
            rotation_model = pygplates.RotationModel([&#39;rotations.rot&#39;, rotation_adjustments])


        ---
        **2. Create from an existing rotation model but adapt it with a potentially different cache size and/or default anchor plate ID**
        ---------------------------------------------------------------------------------------------------------------------------------

        Parameters
        ----------
        rotation_model : instance of `pygplates.RotationModel`
            An existing rotation model.

        reconstruction_tree_cache_size : int, default 2
            Number of reconstruction trees to cache internally.
            Defaults to 2 - this is much lower than the usual default
            cache size since the existing rotation model likely
            already has a sizeable cache anyway - and if you are
            leaving this at its default value then you are presumably
            only interested in changing the default anchor plate ID
            (not increasing the cache size).

        default_anchor_plate_id : int, defaults to the default anchor plate of `rotation_model`
            The default anchored plate id to use when
            [`get_rotation()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation)
            and [`get_reconstruction_tree()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_reconstruction_tree)
            are called without specifying their `anchor_plate_id` parameter.
            Defaults to the default anchor plate of `rotation_model`.


        This is useful if you want to use an existing rotation model but with a
        larger cache size or a different default anchor plate ID:

        Example
        -------
        The below example changes the default anchor plate ID:

            rotation_model = pygplates.RotationModel(rotation_files)
            ...
            rotation_model_anchor_1 = pygplates.RotationModel(rotation_model, default_anchor_plate_id=1)

        ---
        **3. Return an existing rotation model as a convenience**
        -------------------------------------------------------

        This is useful when defining your own function that accepts
        rotation features or a rotation model. It avoids the hassle
        of having to explicitly test for each source type:

            def my_function(rotation_features_or_model):
            # The appropriate constructor (__init__) overload is chosen depending on argument type.
            rotation_model = pygplates.RotationModel(rotation_features_or_model)
            ...

        Parameters
        ----------
        rotation_model : instance of `pygplates.RotationModel` or `gplately.pygplates.RotationModel`
            An existing rotation model.

        ---
        &#34;&#34;&#34;
        super(RotationModel, self).__init__(
            rotation_features, default_anchor_plate_id=default_anchor_plate_id
        )
        self.filenames = []

        # update filename list
        if _is_string(rotation_features) and type(rotation_features) is list:
            self.filenames = rotation_features
        elif _is_string(rotation_features) and type(rotation_features) is str:
            self.filenames = [rotation_features]
        elif rotation_features is None:
            self.filenames = []
        elif isinstance(rotation_features, RotationModel):
            self.filenames = rotation_features.filenames
        elif hasattr(rotation_features, &#34;filenames&#34;):
            self.filenames = rotation_features.filenames
        else:
            msg = &#34;\nRotationModel: No filename associated with {} in __init__&#34;.format(
                type(rotation_features)
            )
            msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
            msg += &#34;\n from gplately import pygplates&#34;
            _warnings.warn(msg, ImportWarning)
            self.filenames = []


class Feature(_pygplates.Feature):
    &#34;&#34;&#34;A class that wraps the `pyGPlates.Feature` class. This contains tools to query and set
    geological or plate-tectonic feature properties defined by the
    [GPlates Geological Information Model (GPGIM)](https://www.gplates.org/docs/gpgim/).
    A feature consists of a collection of `properties`, a `feature type` and a `feature id`.

    See the link below for inherited methods

    https://www.gplates.org/docs/pygplates/generated/pygplates.feature

    &#34;&#34;&#34;

    #
    # this class seems unfinished. need to implement properly in the future.
    #

    def __init__(
        self,
        feature_type: _pygplates.FeatureType = _pygplates.FeatureType.gpml_unclassified_feature,
        feature_id: str = None,
        verify_information_model=_pygplates.VerifyInformationModel.yes,
        *,
        filenames: Union[str, List[str]] = [],
        feature: &#34;Feature&#34; = None,
    ):
        &#34;&#34;&#34;
        Notes
        -----
        The signature of this constructor has been changed since gplately 1.3.0 to be compatible with pygplates.
        THe &#39;filenames&#39; and &#39;feature&#39; parameters must be given as keyword argument.

        Parameters
        ----------

        feature_type : instance of `pygplates.FeatureType`
            The type of feature. See
            [here](https://www.gplates.org/docs/pygplates/generated/pygplates.featuretype#pygplates.FeatureType)
            for a list of pygplates feature types.

        feature_id : instance of `pygplates.FeatureId`
            The [feature identifier](https://www.gplates.org/docs/pygplates/generated/pygplates.featureid#pygplates.FeatureID).

        verify_information_model : instance of `VerifyInformationModel.yes` or `VerifyInformationModel.no`
            Specify whether to check `feature_type` with the information model (default) or not.

        filenames: `str` or `list` of `str`
            The filenames being associated with this feature.

        feature: instance of `gplately.pygplates.Feature`
            The other &#34;Feature&#34; object

        Raises
        ------
        ImportWarning
            If neither a `str` nor `list` of `str` is passed, no
            `Feature` filenames will be collected, and the user will be alerted of this.

        InformationModelError
            if `verify_information_model` is `VerifyInformationModel.yes` and `feature_type` is not a recognised feature type.

        &#34;&#34;&#34;

        # bugfix: gplately.pygplates.Feature is not compatible with pygplates.Feature
        # see https://github.com/GPlates/gplately/issues/150
        # this gplately.pygplates.Feature class seems not completed yet. for example, the clone() method returns nothing. It looks unfinished.
        # Why is a feature associated with multiple file names?
        super().__init__(feature_type, feature_id, verify_information_model)
        self.filenames = []

        # try the best to detect backward compatibility issue
        if not isinstance(feature_type, _pygplates.FeatureType):
            raise Exception(
                &#34;The __init__() signature has been changed. The first positional argument(besides self) is &#39;feature_type&#39; now. &#34;
                + &#34;Check the online documentation https://gplates.github.io/gplately/pygplates.html&#34;
            )

        # update filename list
        if isinstance(filenames, list) and all(
            isinstance(filename, str) for filename in filenames
        ):
            self.filenames = filenames
        elif isinstance(filenames, str):
            self.filenames = [filenames]
        else:
            msg = (
                f&#34;\nFeature: No filename associated with {type(filenames)} in __init__&#34;
                + &#34;\n ensure pygplates is imported from gplately. Run,&#34;
                + &#34;\n from gplately import pygplates&#34;
            )
            _warnings.warn(msg, ImportWarning)
            self.filenames = []

        if feature:
            self.filenames = feature.filenames
            # TODO: also need to copy everything else in the other feature into this feature

    def add(self, feature):
        &#34;&#34;&#34;Adds a property (or properties) to this feature. See original docs
        [here](https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature.add).

        Parameters
        ----------
        property_name : instance of `pygplates.PropertyName`
            The name of the property (or properties) to add.

        property_value : instance of `pygplates.PropertyValue` or sequence (eg, `list` or `tuple`) of `pygplates.PropertyValue`
            The value (or values) of the property (or properties) to add.

        verify_information_model : instance of `VerifyInformationModel.yes` or `VerifyInformationModel.no`
            Specify whether to check `feature_type` with the information model (default) or not.


        Returns
        -------
        property_added : `Property` or `list` of `Property` depending on whether `property_value` is a `PropertyValue` or sequence of `PropertyValue`
            The property (or properties) added to the feature.
        &#34;&#34;&#34;
        super().add(feature)
        if isinstance(feature, Feature):
            self.filenames.extend(feature.filenames)
        elif _is_string(feature):
            self.filenames.extend(feature)
        elif hasattr(feature, &#34;filenames&#34;):
            self.filenames.extend(feature.filenames)
        else:
            msg = &#34;\nFeature: No filename associated with {} in add&#34;.format(
                type(feature)
            )
            msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
            msg += &#34;\n from gplately import pygplates&#34;
            _warnings.warn(msg, ImportWarning)

    def clone(self):
        &#34;&#34;&#34;Create a duplicate of this `Feature` instance.

        This creates a new `Feature` instance with cloned versions of this feature’s `properties`.
        The cloned feature is created with its own unique `pygplates.FeatureId`.

        Returns
        -------
        Feature : instance of `gplately.pygplates.Feature`
            The cloned `Feature` instance.

        &#34;&#34;&#34;
        feat = super().clone()
        feat.filenames = self.filenames


class FeatureCollection(_pygplates.FeatureCollection):
    &#34;&#34;&#34;A thin wrap of [`pyGPlates.FeatureCollection`](https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection).
    The derived FeatureCollection class contains a &#34;filenames&#34; attribute to track the names of files from which the feature collection is loaded.

    See the doc of base class at https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection.

    &#34;&#34;&#34;

    def __init__(self, features=None, *, filenames: List[str] = []):
        &#34;&#34;&#34;The constructor is compatible with the base class pygplates.FeatureCollection.

        Parameters
        ----------
        features : instance of `Feature` or `str` or a sequence (eg, `list` or `tuple`) of `Feature`
            An optional filename, or sequence of features, or a single feature

        filenames: a list of file path strings (must be given as keyword argument)
            file paths

        Raises
        ------
        OpenFileForReadingError
            If file is not readable (if filename specified).

        FileFormatNotSupportedError
            If file format (identified by the filename extension) does not support reading (when filename specified).

        &#34;&#34;&#34;
        super().__init__(features)
        self._filenames = filenames

    @classmethod
    def from_file_list(cls, filenames: List[str] = []):
        &#34;&#34;&#34;class method to load a feature collection from multiple files.&#34;&#34;&#34;

        if not (
            isinstance(filenames, list)
            and all(isinstance(filename, str) for filename in filenames)
        ):
            raise Exception(
                f&#34;The &#39;filenames&#39; parameter must be a list of file path strings.&#34;
            )

        fc = _pygplates.FeatureCollection()
        for filename in filenames:
            fc.add(_pygplates.FeatureCollection(filename))

        ret = cls([f for f in fc], filenames=filenames)
        return ret

    @property
    def filenames(self):
        return self._filenames

    @filenames.setter
    def filenames(self, filenames):
        self._filenames = filenames

    @filenames.deleter
    def filenames(self):
        del self._filenames

    def add(self, feature=[], *, filename: str = None):
        &#34;&#34;&#34;load one more file into the feature collection

        Parameters
        ----------

        feature : (Feature or sequence (eg, list or tuple) of Feature)
            one or more features to add

        filename : str
            file path string(must be passed as keyword argument)

        &#34;&#34;&#34;
        if isinstance(feature, str):
            raise Exception(
                &#34;The filename argument must be passed as keyword argument. The &#39;feature&#39; argument must be Feature or sequence of Features.&#34;
            )

        if feature:
            super().add(feature)
        if filename:
            super().add(_pygplates.FeatureCollection(filename))
            self.filenames.append(filename)

    def clone(self):
        &#34;&#34;&#34;Create a duplicate of this feature collection instance.

        Returns
        -------
        feature_collection : instance of `gplately.pygplates.FeatureCollection`
            The cloned `FeatureCollection`.

        &#34;&#34;&#34;
        return FeatureCollection([f for f in self], filenames=copy(self.filenames))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.pygplates.Feature"><code class="flex name class">
<span>class <span class="ident">Feature</span></span>
<span>(</span><span>feature_type: pygplates.FeatureType = &lt;pygplates.FeatureType object&gt;, feature_id: str = None, verify_information_model=pygplates.VerifyInformationModel.yes, *, filenames: Union[str, List[str]] = [], feature: <a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that wraps the <code>pyGPlates.Feature</code> class. This contains tools to query and set
geological or plate-tectonic feature properties defined by the
<a href="https://www.gplates.org/docs/gpgim/">GPlates Geological Information Model (GPGIM)</a>.
A feature consists of a collection of <code>properties</code>, a <code>feature type</code> and a <code>feature id</code>.</p>
<p>See the link below for inherited methods</p>
<p><a href="https://www.gplates.org/docs/pygplates/generated/pygplates.feature">https://www.gplates.org/docs/pygplates/generated/pygplates.feature</a></p>
<h2 id="notes">Notes</h2>
<p>The signature of this constructor has been changed since gplately 1.3.0 to be compatible with pygplates.
THe 'filenames' and 'feature' parameters must be given as keyword argument.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_type</code></strong> :&ensp;<code>instance</code> of <code>pygplates.FeatureType</code></dt>
<dd>The type of feature. See
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.featuretype#pygplates.FeatureType">here</a>
for a list of pygplates feature types.</dd>
<dt><strong><code>feature_id</code></strong> :&ensp;<code>instance</code> of <code>pygplates.FeatureId</code></dt>
<dd>The <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.featureid#pygplates.FeatureID">feature identifier</a>.</dd>
<dt><strong><code>verify_information_model</code></strong> :&ensp;<code>instance</code> of <code>VerifyInformationModel.yes</code> or <code>VerifyInformationModel.no</code></dt>
<dd>Specify whether to check <code>feature_type</code> with the information model (default) or not.</dd>
<dt><strong><code>filenames</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>The filenames being associated with this feature.</dd>
<dt><strong><code>feature</code></strong> :&ensp;<code>instance</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></dt>
<dd>The other "Feature" object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ImportWarning</code></dt>
<dd>If neither a <code>str</code> nor <code>list</code> of <code>str</code> is passed, no
<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> filenames will be collected, and the user will be alerted of this.</dd>
<dt><code>InformationModelError</code></dt>
<dd>if <code>verify_information_model</code> is <code>VerifyInformationModel.yes</code> and <code>feature_type</code> is not a recognised feature type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Feature(_pygplates.Feature):
    &#34;&#34;&#34;A class that wraps the `pyGPlates.Feature` class. This contains tools to query and set
    geological or plate-tectonic feature properties defined by the
    [GPlates Geological Information Model (GPGIM)](https://www.gplates.org/docs/gpgim/).
    A feature consists of a collection of `properties`, a `feature type` and a `feature id`.

    See the link below for inherited methods

    https://www.gplates.org/docs/pygplates/generated/pygplates.feature

    &#34;&#34;&#34;

    #
    # this class seems unfinished. need to implement properly in the future.
    #

    def __init__(
        self,
        feature_type: _pygplates.FeatureType = _pygplates.FeatureType.gpml_unclassified_feature,
        feature_id: str = None,
        verify_information_model=_pygplates.VerifyInformationModel.yes,
        *,
        filenames: Union[str, List[str]] = [],
        feature: &#34;Feature&#34; = None,
    ):
        &#34;&#34;&#34;
        Notes
        -----
        The signature of this constructor has been changed since gplately 1.3.0 to be compatible with pygplates.
        THe &#39;filenames&#39; and &#39;feature&#39; parameters must be given as keyword argument.

        Parameters
        ----------

        feature_type : instance of `pygplates.FeatureType`
            The type of feature. See
            [here](https://www.gplates.org/docs/pygplates/generated/pygplates.featuretype#pygplates.FeatureType)
            for a list of pygplates feature types.

        feature_id : instance of `pygplates.FeatureId`
            The [feature identifier](https://www.gplates.org/docs/pygplates/generated/pygplates.featureid#pygplates.FeatureID).

        verify_information_model : instance of `VerifyInformationModel.yes` or `VerifyInformationModel.no`
            Specify whether to check `feature_type` with the information model (default) or not.

        filenames: `str` or `list` of `str`
            The filenames being associated with this feature.

        feature: instance of `gplately.pygplates.Feature`
            The other &#34;Feature&#34; object

        Raises
        ------
        ImportWarning
            If neither a `str` nor `list` of `str` is passed, no
            `Feature` filenames will be collected, and the user will be alerted of this.

        InformationModelError
            if `verify_information_model` is `VerifyInformationModel.yes` and `feature_type` is not a recognised feature type.

        &#34;&#34;&#34;

        # bugfix: gplately.pygplates.Feature is not compatible with pygplates.Feature
        # see https://github.com/GPlates/gplately/issues/150
        # this gplately.pygplates.Feature class seems not completed yet. for example, the clone() method returns nothing. It looks unfinished.
        # Why is a feature associated with multiple file names?
        super().__init__(feature_type, feature_id, verify_information_model)
        self.filenames = []

        # try the best to detect backward compatibility issue
        if not isinstance(feature_type, _pygplates.FeatureType):
            raise Exception(
                &#34;The __init__() signature has been changed. The first positional argument(besides self) is &#39;feature_type&#39; now. &#34;
                + &#34;Check the online documentation https://gplates.github.io/gplately/pygplates.html&#34;
            )

        # update filename list
        if isinstance(filenames, list) and all(
            isinstance(filename, str) for filename in filenames
        ):
            self.filenames = filenames
        elif isinstance(filenames, str):
            self.filenames = [filenames]
        else:
            msg = (
                f&#34;\nFeature: No filename associated with {type(filenames)} in __init__&#34;
                + &#34;\n ensure pygplates is imported from gplately. Run,&#34;
                + &#34;\n from gplately import pygplates&#34;
            )
            _warnings.warn(msg, ImportWarning)
            self.filenames = []

        if feature:
            self.filenames = feature.filenames
            # TODO: also need to copy everything else in the other feature into this feature

    def add(self, feature):
        &#34;&#34;&#34;Adds a property (or properties) to this feature. See original docs
        [here](https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature.add).

        Parameters
        ----------
        property_name : instance of `pygplates.PropertyName`
            The name of the property (or properties) to add.

        property_value : instance of `pygplates.PropertyValue` or sequence (eg, `list` or `tuple`) of `pygplates.PropertyValue`
            The value (or values) of the property (or properties) to add.

        verify_information_model : instance of `VerifyInformationModel.yes` or `VerifyInformationModel.no`
            Specify whether to check `feature_type` with the information model (default) or not.


        Returns
        -------
        property_added : `Property` or `list` of `Property` depending on whether `property_value` is a `PropertyValue` or sequence of `PropertyValue`
            The property (or properties) added to the feature.
        &#34;&#34;&#34;
        super().add(feature)
        if isinstance(feature, Feature):
            self.filenames.extend(feature.filenames)
        elif _is_string(feature):
            self.filenames.extend(feature)
        elif hasattr(feature, &#34;filenames&#34;):
            self.filenames.extend(feature.filenames)
        else:
            msg = &#34;\nFeature: No filename associated with {} in add&#34;.format(
                type(feature)
            )
            msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
            msg += &#34;\n from gplately import pygplates&#34;
            _warnings.warn(msg, ImportWarning)

    def clone(self):
        &#34;&#34;&#34;Create a duplicate of this `Feature` instance.

        This creates a new `Feature` instance with cloned versions of this feature’s `properties`.
        The cloned feature is created with its own unique `pygplates.FeatureId`.

        Returns
        -------
        Feature : instance of `gplately.pygplates.Feature`
            The cloned `Feature` instance.

        &#34;&#34;&#34;
        feat = super().clone()
        feat.filenames = self.filenames</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.Feature</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gplately.pygplates.Feature.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, feature)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a property (or properties) to this feature. See original docs
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature.add">here</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>property_name</code></strong> :&ensp;<code>instance</code> of <code>pygplates.PropertyName</code></dt>
<dd>The name of the property (or properties) to add.</dd>
<dt><strong><code>property_value</code></strong> :&ensp;<code>instance</code> of <code>pygplates.PropertyValue</code> or <code>sequence (eg, </code>list<code> or </code>tuple<code>)</code> of <code>pygplates.PropertyValue</code></dt>
<dd>The value (or values) of the property (or properties) to add.</dd>
<dt><strong><code>verify_information_model</code></strong> :&ensp;<code>instance</code> of <code>VerifyInformationModel.yes</code> or <code>VerifyInformationModel.no</code></dt>
<dd>Specify whether to check <code>feature_type</code> with the information model (default) or not.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>property_added</code></strong> :&ensp;<code>Property</code> or <code>list</code> of <code>Property<code>depending on whether</code>property_value<code>is a</code>PropertyValue</code> or <code>sequence</code> of <code>PropertyValue</code></dt>
<dd>The property (or properties) added to the feature.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, feature):
    &#34;&#34;&#34;Adds a property (or properties) to this feature. See original docs
    [here](https://www.gplates.org/docs/pygplates/generated/pygplates.feature#pygplates.Feature.add).

    Parameters
    ----------
    property_name : instance of `pygplates.PropertyName`
        The name of the property (or properties) to add.

    property_value : instance of `pygplates.PropertyValue` or sequence (eg, `list` or `tuple`) of `pygplates.PropertyValue`
        The value (or values) of the property (or properties) to add.

    verify_information_model : instance of `VerifyInformationModel.yes` or `VerifyInformationModel.no`
        Specify whether to check `feature_type` with the information model (default) or not.


    Returns
    -------
    property_added : `Property` or `list` of `Property` depending on whether `property_value` is a `PropertyValue` or sequence of `PropertyValue`
        The property (or properties) added to the feature.
    &#34;&#34;&#34;
    super().add(feature)
    if isinstance(feature, Feature):
        self.filenames.extend(feature.filenames)
    elif _is_string(feature):
        self.filenames.extend(feature)
    elif hasattr(feature, &#34;filenames&#34;):
        self.filenames.extend(feature.filenames)
    else:
        msg = &#34;\nFeature: No filename associated with {} in add&#34;.format(
            type(feature)
        )
        msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
        msg += &#34;\n from gplately import pygplates&#34;
        _warnings.warn(msg, ImportWarning)</code></pre>
</details>
</dd>
<dt id="gplately.pygplates.Feature.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a duplicate of this <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> instance.</p>
<p>This creates a new <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> instance with cloned versions of this feature’s <code>properties</code>.
The cloned feature is created with its own unique <code>pygplates.FeatureId</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Feature</code></strong> :&ensp;<code>instance</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></dt>
<dd>The cloned <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self):
    &#34;&#34;&#34;Create a duplicate of this `Feature` instance.

    This creates a new `Feature` instance with cloned versions of this feature’s `properties`.
    The cloned feature is created with its own unique `pygplates.FeatureId`.

    Returns
    -------
    Feature : instance of `gplately.pygplates.Feature`
        The cloned `Feature` instance.

    &#34;&#34;&#34;
    feat = super().clone()
    feat.filenames = self.filenames</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gplately.pygplates.FeatureCollection"><code class="flex name class">
<span>class <span class="ident">FeatureCollection</span></span>
<span>(</span><span>features=None, *, filenames: List[str] = [])</span>
</code></dt>
<dd>
<div class="desc"><p>A thin wrap of <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection"><code>pyGPlates.FeatureCollection</code></a>.
The derived FeatureCollection class contains a "filenames" attribute to track the names of files from which the feature collection is loaded.</p>
<p>See the doc of base class at <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection.">https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection.</a></p>
<p>The constructor is compatible with the base class pygplates.FeatureCollection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>instance</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> or <code>str</code> or <code>a sequence (eg, </code>list<code> or </code>tuple<code>)</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></dt>
<dd>An optional filename, or sequence of features, or a single feature</dd>
<dt><strong><code>filenames</code></strong> :&ensp;<code>a list</code> of <code>file path strings (must be given as keyword argument)</code></dt>
<dd>file paths</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>OpenFileForReadingError</code></dt>
<dd>If file is not readable (if filename specified).</dd>
<dt><code>FileFormatNotSupportedError</code></dt>
<dd>If file format (identified by the filename extension) does not support reading (when filename specified).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureCollection(_pygplates.FeatureCollection):
    &#34;&#34;&#34;A thin wrap of [`pyGPlates.FeatureCollection`](https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection).
    The derived FeatureCollection class contains a &#34;filenames&#34; attribute to track the names of files from which the feature collection is loaded.

    See the doc of base class at https://www.gplates.org/docs/pygplates/generated/pygplates.featurecollection#pygplates.FeatureCollection.

    &#34;&#34;&#34;

    def __init__(self, features=None, *, filenames: List[str] = []):
        &#34;&#34;&#34;The constructor is compatible with the base class pygplates.FeatureCollection.

        Parameters
        ----------
        features : instance of `Feature` or `str` or a sequence (eg, `list` or `tuple`) of `Feature`
            An optional filename, or sequence of features, or a single feature

        filenames: a list of file path strings (must be given as keyword argument)
            file paths

        Raises
        ------
        OpenFileForReadingError
            If file is not readable (if filename specified).

        FileFormatNotSupportedError
            If file format (identified by the filename extension) does not support reading (when filename specified).

        &#34;&#34;&#34;
        super().__init__(features)
        self._filenames = filenames

    @classmethod
    def from_file_list(cls, filenames: List[str] = []):
        &#34;&#34;&#34;class method to load a feature collection from multiple files.&#34;&#34;&#34;

        if not (
            isinstance(filenames, list)
            and all(isinstance(filename, str) for filename in filenames)
        ):
            raise Exception(
                f&#34;The &#39;filenames&#39; parameter must be a list of file path strings.&#34;
            )

        fc = _pygplates.FeatureCollection()
        for filename in filenames:
            fc.add(_pygplates.FeatureCollection(filename))

        ret = cls([f for f in fc], filenames=filenames)
        return ret

    @property
    def filenames(self):
        return self._filenames

    @filenames.setter
    def filenames(self, filenames):
        self._filenames = filenames

    @filenames.deleter
    def filenames(self):
        del self._filenames

    def add(self, feature=[], *, filename: str = None):
        &#34;&#34;&#34;load one more file into the feature collection

        Parameters
        ----------

        feature : (Feature or sequence (eg, list or tuple) of Feature)
            one or more features to add

        filename : str
            file path string(must be passed as keyword argument)

        &#34;&#34;&#34;
        if isinstance(feature, str):
            raise Exception(
                &#34;The filename argument must be passed as keyword argument. The &#39;feature&#39; argument must be Feature or sequence of Features.&#34;
            )

        if feature:
            super().add(feature)
        if filename:
            super().add(_pygplates.FeatureCollection(filename))
            self.filenames.append(filename)

    def clone(self):
        &#34;&#34;&#34;Create a duplicate of this feature collection instance.

        Returns
        -------
        feature_collection : instance of `gplately.pygplates.FeatureCollection`
            The cloned `FeatureCollection`.

        &#34;&#34;&#34;
        return FeatureCollection([f for f in self], filenames=copy(self.filenames))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.FeatureCollection</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="gplately.pygplates.FeatureCollection.from_file_list"><code class="name flex">
<span>def <span class="ident">from_file_list</span></span>(<span>filenames: List[str] = [])</span>
</code></dt>
<dd>
<div class="desc"><p>class method to load a feature collection from multiple files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file_list(cls, filenames: List[str] = []):
    &#34;&#34;&#34;class method to load a feature collection from multiple files.&#34;&#34;&#34;

    if not (
        isinstance(filenames, list)
        and all(isinstance(filename, str) for filename in filenames)
    ):
        raise Exception(
            f&#34;The &#39;filenames&#39; parameter must be a list of file path strings.&#34;
        )

    fc = _pygplates.FeatureCollection()
    for filename in filenames:
        fc.add(_pygplates.FeatureCollection(filename))

    ret = cls([f for f in fc], filenames=filenames)
    return ret</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gplately.pygplates.FeatureCollection.filenames"><code class="name">var <span class="ident">filenames</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def filenames(self):
    return self._filenames</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gplately.pygplates.FeatureCollection.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, feature=[], *, filename: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>load one more file into the feature collection</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature</code></strong> :&ensp;<code>(<a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> or <code>sequence (eg, list</code> or <code>tuple)</code> of <code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a>)</code></dt>
<dd>one or more features to add</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>file path string(must be passed as keyword argument)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, feature=[], *, filename: str = None):
    &#34;&#34;&#34;load one more file into the feature collection

    Parameters
    ----------

    feature : (Feature or sequence (eg, list or tuple) of Feature)
        one or more features to add

    filename : str
        file path string(must be passed as keyword argument)

    &#34;&#34;&#34;
    if isinstance(feature, str):
        raise Exception(
            &#34;The filename argument must be passed as keyword argument. The &#39;feature&#39; argument must be Feature or sequence of Features.&#34;
        )

    if feature:
        super().add(feature)
    if filename:
        super().add(_pygplates.FeatureCollection(filename))
        self.filenames.append(filename)</code></pre>
</details>
</dd>
<dt id="gplately.pygplates.FeatureCollection.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a duplicate of this feature collection instance.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>feature_collection</code></strong> :&ensp;<code>instance</code> of <code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code></dt>
<dd>The cloned <code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self):
    &#34;&#34;&#34;Create a duplicate of this feature collection instance.

    Returns
    -------
    feature_collection : instance of `gplately.pygplates.FeatureCollection`
        The cloned `FeatureCollection`.

    &#34;&#34;&#34;
    return FeatureCollection([f for f in self], filenames=copy(self.filenames))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gplately.pygplates.RotationModel"><code class="flex name class">
<span>class <span class="ident">RotationModel</span></span>
<span>(</span><span>rotation_features, default_anchor_plate_id=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that wraps the
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel"><code>pyGPlates.RotationModel</code> class</a>.
This queries a finite rotation of a moving plate relative to any other plate,
optionally between two instants in geological time.</p>
<p>See <a href="https://www.gplates.org/docs/pygplates/pygplates_foundations.html#pygplates-foundations-plate-reconstruction-hierarchy">Plate reconstruction hierarchy</a>.</p>
<p>This class provides an easy way to query rotations in any of the four
combinations of total/stage and equivalent/relative rotations using
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation"><code>get_rotation()</code></a>.</p>
<p>Reconstruction trees can also be created at any instant
of geological time and these are cached internally depending on a
user-specified cache size parameter pass to <code><a title="gplately.pygplates.RotationModel" href="#gplately.pygplates.RotationModel">RotationModel</a></code>.
The reconstruction_tree_cache_size parameter of those methods controls the
size of an internal least-recently-used cache of reconstruction trees
(evicts least recently requested reconstruction tree when a new
reconstruction time is requested that does not currently exist in the cache).
This enables reconstruction trees associated with different reconstruction
times to be re-used instead of re-creating them, provided they have not been
evicted from the cache. This benefit also applies when querying rotations with
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation"><code>get_rotation()</code></a>
since it, in turn, requests reconstruction trees.</p>
<p>This wrapping of <code>pygplates.RotationModel</code> contains all
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel"><code>pygplates.RotationModel</code> functionality</a>,
and in addition tracks the names of files from which the rotation feature(s) are read
using the <code>gplately.pygplates.RotationModel.filenames</code> attribute.</p>
<p><strong>A RotationModel object can be constructed in three ways.</strong></p>
<hr>
<h2 id="1-create-from-rotation-feature-collections-andor-rotation-filenames"><strong>1. Create from rotation feature collection(s) and/or rotation filename(s)</strong></h2>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rotation_features</code></strong> :&ensp;<code>instance</code> of <code>pygplates.FeatureCollection</code> or <code>str</code> or <code>instance</code> of <code>pygplates.Feature</code> or <code>sequence</code> of <code>pygplates.Feature</code> or <code>sequence</code> of <code>any combination</code> of <code>those four types</code></dt>
<dd>A rotation feature collection, or rotation filename, or rotation feature,
or sequence of rotation features, or a sequence (eg, <code>list</code> or <code>tuple</code>) of
any combination of those four types.</dd>
<dt><strong><code>reconstruction_tree_cache_size</code></strong> :&ensp;<code>int</code>, default <code>150</code></dt>
<dd>Number of reconstruction trees to cache internally. Defaults to 150.</dd>
<dt><strong><code>extend_total_reconstruction_poles_to_distant_past</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Extend each moving plate sequence back infinitely far into the distant
past such that reconstructed geometries will not snap back to their
present day positions when the reconstruction time is older than
the oldest times specified in the rotation features (defaults to False).</dd>
<dt><strong><code>default_anchor_plate_id</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>The default anchored plate id to use when
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation"><code>get_rotation()</code></a>
and <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_reconstruction_tree"><code>get_reconstruction_tree()</code></a>
are called without specifying their <code>anchor_plate_id</code> parameter. Defaults to 0.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>OpenFileForReadingError</code></dt>
<dd>If any file is not readable (when filenames specified)</dd>
<dt><code>FileFormatNotSupportedError</code></dt>
<dd>If any file format (identified by the filename extensions)
does not support reading (when filenames specified)</dd>
</dl>
<p>Note that <code>rotation_features</code> can be a rotation <code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code> or a rotation filename or a rotation Feature or a sequence of rotation features, or a sequence (eg, <code>list</code> or <code>tuple</code>) of any combination of those four types.</p>
<p>If any rotation filenames are specified then this method uses <code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code> internally to read the rotation files.</p>
<h2 id="example">Example</h2>
<p>Load a rotation file and some rotation adjustments (as a collection of rotation features) into a rotation model:</p>
<pre><code>rotation_adjustments = pygplates.FeatureCollection()
...
rotation_model = pygplates.RotationModel(['rotations.rot', rotation_adjustments])
</code></pre>
<hr>
<h2 id="2-create-from-an-existing-rotation-model-but-adapt-it-with-a-potentially-different-cache-size-andor-default-anchor-plate-id"><strong>2. Create from an existing rotation model but adapt it with a potentially different cache size and/or default anchor plate ID</strong></h2>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>rotation_model</code></strong> :&ensp;<code>instance</code> of <code>pygplates.RotationModel</code></dt>
<dd>An existing rotation model.</dd>
<dt><strong><code>reconstruction_tree_cache_size</code></strong> :&ensp;<code>int</code>, default <code>2</code></dt>
<dd>Number of reconstruction trees to cache internally.
Defaults to 2 - this is much lower than the usual default
cache size since the existing rotation model likely
already has a sizeable cache anyway - and if you are
leaving this at its default value then you are presumably
only interested in changing the default anchor plate ID
(not increasing the cache size).</dd>
<dt><strong><code>default_anchor_plate_id</code></strong> :&ensp;<code>int, defaults to the default anchor plate</code> of <code>rotation_model</code></dt>
<dd>The default anchored plate id to use when
<a href="https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation"><code>get_rotation()</code></a>
and <a href="https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_reconstruction_tree"><code>get_reconstruction_tree()</code></a>
are called without specifying their <code>anchor_plate_id</code> parameter.
Defaults to the default anchor plate of <code>rotation_model</code>.</dd>
</dl>
<p>This is useful if you want to use an existing rotation model but with a
larger cache size or a different default anchor plate ID:</p>
<h2 id="example_1">Example</h2>
<p>The below example changes the default anchor plate ID:</p>
<pre><code>rotation_model = pygplates.RotationModel(rotation_files)
...
rotation_model_anchor_1 = pygplates.RotationModel(rotation_model, default_anchor_plate_id=1)
</code></pre>
<hr>
<h2 id="3-return-an-existing-rotation-model-as-a-convenience"><strong>3. Return an existing rotation model as a convenience</strong></h2>
<p>This is useful when defining your own function that accepts
rotation features or a rotation model. It avoids the hassle
of having to explicitly test for each source type:</p>
<pre><code>def my_function(rotation_features_or_model):
# The appropriate constructor (__init__) overload is chosen depending on argument type.
rotation_model = pygplates.RotationModel(rotation_features_or_model)
...
</code></pre>
<h2 id="parameters_2">Parameters</h2>
<dl>
<dt><strong><code>rotation_model</code></strong> :&ensp;<code>instance</code> of <code>pygplates.RotationModel</code> or <code><a title="gplately.pygplates.RotationModel" href="#gplately.pygplates.RotationModel">RotationModel</a></code></dt>
<dd>An existing rotation model.</dd>
</dl>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RotationModel(_pygplates.RotationModel):
    &#34;&#34;&#34;A class that wraps the
    [`pyGPlates.RotationModel` class](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel).
    This queries a finite rotation of a moving plate relative to any other plate,
    optionally between two instants in geological time.

    See [Plate reconstruction hierarchy](https://www.gplates.org/docs/pygplates/pygplates_foundations.html#pygplates-foundations-plate-reconstruction-hierarchy).

    This class provides an easy way to query rotations in any of the four
    combinations of total/stage and equivalent/relative rotations using
    [`get_rotation()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation).

    Reconstruction trees can also be created at any instant
    of geological time and these are cached internally depending on a
    user-specified cache size parameter pass to `gplately.pygplates.RotationModel.__init__()`.
    The reconstruction_tree_cache_size parameter of those methods controls the
    size of an internal least-recently-used cache of reconstruction trees
    (evicts least recently requested reconstruction tree when a new
    reconstruction time is requested that does not currently exist in the cache).
    This enables reconstruction trees associated with different reconstruction
    times to be re-used instead of re-creating them, provided they have not been
    evicted from the cache. This benefit also applies when querying rotations with
    [`get_rotation()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation)
    since it, in turn, requests reconstruction trees.


    This wrapping of `pygplates.RotationModel` contains all
    [`pygplates.RotationModel` functionality](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel),
    and in addition tracks the names of files from which the rotation feature(s) are read
    using the `gplately.pygplates.RotationModel.filenames` attribute.


    &#34;&#34;&#34;

    def __init__(self, rotation_features, default_anchor_plate_id=0):
        &#34;&#34;&#34;**A RotationModel object can be constructed in three ways.**

        ---
        **1. Create from rotation feature collection(s) and/or rotation filename(s)**
        --------------------------------------------------------------------------

        Parameters
        ----------
        rotation_features : instance of `pygplates.FeatureCollection` or `str` or instance of `pygplates.Feature` or sequence of `pygplates.Feature` or sequence of any combination of those four types
            A rotation feature collection, or rotation filename, or rotation feature,
            or sequence of rotation features, or a sequence (eg, `list` or `tuple`) of
            any combination of those four types.

        reconstruction_tree_cache_size : int, default 150
            Number of reconstruction trees to cache internally. Defaults to 150.

        extend_total_reconstruction_poles_to_distant_past : bool, default False
            Extend each moving plate sequence back infinitely far into the distant
            past such that reconstructed geometries will not snap back to their
            present day positions when the reconstruction time is older than
            the oldest times specified in the rotation features (defaults to False).

        default_anchor_plate_id : int, default 0
            The default anchored plate id to use when
            [`get_rotation()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation)
            and [`get_reconstruction_tree()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_reconstruction_tree)
            are called without specifying their `anchor_plate_id` parameter. Defaults to 0.

        Raises
        ------
        OpenFileForReadingError
            If any file is not readable (when filenames specified)

        FileFormatNotSupportedError
            If any file format (identified by the filename extensions)
            does not support reading (when filenames specified)


        Note that `rotation_features` can be a rotation `FeatureCollection` or a rotation filename or a rotation Feature or a sequence of rotation features, or a sequence (eg, `list` or `tuple`) of any combination of those four types.

        If any rotation filenames are specified then this method uses `FeatureCollection` internally to read the rotation files.


        Example
        -------
        Load a rotation file and some rotation adjustments (as a collection of rotation features) into a rotation model:

            rotation_adjustments = pygplates.FeatureCollection()
            ...
            rotation_model = pygplates.RotationModel([&#39;rotations.rot&#39;, rotation_adjustments])


        ---
        **2. Create from an existing rotation model but adapt it with a potentially different cache size and/or default anchor plate ID**
        ---------------------------------------------------------------------------------------------------------------------------------

        Parameters
        ----------
        rotation_model : instance of `pygplates.RotationModel`
            An existing rotation model.

        reconstruction_tree_cache_size : int, default 2
            Number of reconstruction trees to cache internally.
            Defaults to 2 - this is much lower than the usual default
            cache size since the existing rotation model likely
            already has a sizeable cache anyway - and if you are
            leaving this at its default value then you are presumably
            only interested in changing the default anchor plate ID
            (not increasing the cache size).

        default_anchor_plate_id : int, defaults to the default anchor plate of `rotation_model`
            The default anchored plate id to use when
            [`get_rotation()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_rotation)
            and [`get_reconstruction_tree()`](https://www.gplates.org/docs/pygplates/generated/pygplates.rotationmodel#pygplates.RotationModel.get_reconstruction_tree)
            are called without specifying their `anchor_plate_id` parameter.
            Defaults to the default anchor plate of `rotation_model`.


        This is useful if you want to use an existing rotation model but with a
        larger cache size or a different default anchor plate ID:

        Example
        -------
        The below example changes the default anchor plate ID:

            rotation_model = pygplates.RotationModel(rotation_files)
            ...
            rotation_model_anchor_1 = pygplates.RotationModel(rotation_model, default_anchor_plate_id=1)

        ---
        **3. Return an existing rotation model as a convenience**
        -------------------------------------------------------

        This is useful when defining your own function that accepts
        rotation features or a rotation model. It avoids the hassle
        of having to explicitly test for each source type:

            def my_function(rotation_features_or_model):
            # The appropriate constructor (__init__) overload is chosen depending on argument type.
            rotation_model = pygplates.RotationModel(rotation_features_or_model)
            ...

        Parameters
        ----------
        rotation_model : instance of `pygplates.RotationModel` or `gplately.pygplates.RotationModel`
            An existing rotation model.

        ---
        &#34;&#34;&#34;
        super(RotationModel, self).__init__(
            rotation_features, default_anchor_plate_id=default_anchor_plate_id
        )
        self.filenames = []

        # update filename list
        if _is_string(rotation_features) and type(rotation_features) is list:
            self.filenames = rotation_features
        elif _is_string(rotation_features) and type(rotation_features) is str:
            self.filenames = [rotation_features]
        elif rotation_features is None:
            self.filenames = []
        elif isinstance(rotation_features, RotationModel):
            self.filenames = rotation_features.filenames
        elif hasattr(rotation_features, &#34;filenames&#34;):
            self.filenames = rotation_features.filenames
        else:
            msg = &#34;\nRotationModel: No filename associated with {} in __init__&#34;.format(
                type(rotation_features)
            )
            msg += &#34;\n ensure pygplates is imported from gplately. Run,&#34;
            msg += &#34;\n from gplately import pygplates&#34;
            _warnings.warn(msg, ImportWarning)
            self.filenames = []</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.RotationModel</li>
<li>Boost.Python.instance</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="GPlately logo" height="172" width="205">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></h4>
<ul class="">
<li><code><a title="gplately.pygplates.Feature.add" href="#gplately.pygplates.Feature.add">add</a></code></li>
<li><code><a title="gplately.pygplates.Feature.clone" href="#gplately.pygplates.Feature.clone">clone</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code></h4>
<ul class="">
<li><code><a title="gplately.pygplates.FeatureCollection.add" href="#gplately.pygplates.FeatureCollection.add">add</a></code></li>
<li><code><a title="gplately.pygplates.FeatureCollection.clone" href="#gplately.pygplates.FeatureCollection.clone">clone</a></code></li>
<li><code><a title="gplately.pygplates.FeatureCollection.filenames" href="#gplately.pygplates.FeatureCollection.filenames">filenames</a></code></li>
<li><code><a title="gplately.pygplates.FeatureCollection.from_file_list" href="#gplately.pygplates.FeatureCollection.from_file_list">from_file_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.pygplates.RotationModel" href="#gplately.pygplates.RotationModel">RotationModel</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>