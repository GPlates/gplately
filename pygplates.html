<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gplately.pygplates API documentation</title>
<meta name="description" content="A light wrapping of some pyGPlates classes to keep track of filenames â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.pygplates</code></h1>
</header>
<section id="section-intro">
<p>A light wrapping of some pyGPlates classes to keep track of filenames</p>
<p>Each object listed here will have a <code>self.filenames</code> attribute.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A light wrapping of some pyGPlates classes to keep track of filenames

Each object listed here will have a `self.filenames` attribute.
&#34;&#34;&#34;

import pygplates as _pygplates
from pygplates import *


def _is_string(value):
    # convert sets to list
    if type(value) is set:
        value = list(value)

    # check for strings inside a list
    if type(value) is list:
        bl = []
        for val in value:
            bl.append( type(val) is str )
        return all(bl)
    
    # if no list, check if string
    else:
        return type(value) is str


class RotationModel(_pygplates.RotationModel):

    def __init__(self, rotation_features):
        super(RotationModel, self).__init__(rotation_features)
        self.filenames = []

        # update filename list
        if _is_string(rotation_features) and type(rotation_features) is list:
            self.filenames = rotation_features
        elif _is_string(rotation_features) and type(rotation_features) is str:
            self.filenames = [rotation_features]
        elif rotation_features is None:
            self.filenames = []
        elif isinstance(rotation_features, RotationModel):
            self.filenames = rotation_features.filenames
        elif hasattr(rotation_features, &#34;filenames&#34;):
            self.filenames = rotation_features.filenames
        else:
            print(&#34;RotationModel: No filename associated with&#34;, type(rotation_features), &#34;in __init__&#34;)
            self.filenames = []

class Feature(_pygplates.Feature):

    def __init__(self, feature):
        super(Feature, self).__init__(feature)
        self.filenames = []

        # update filename list
        if _is_string(feature) and type(feature) is list:
            self.filenames = feature
        elif _is_string(feature) and type(feature) is str:
            self.filenames = [feature]
        elif feature is None:
            self.filenames = []
        elif isinstance(feature, Feature):
            self.filenames = feature.filenames
        elif hasattr(feature, &#34;filenames&#34;):
            self.filenames = feature.filenames
        else:
            print(&#34;Feature: No filename associated with&#34;, type(feature), &#34;in __init__&#34;)
            self.filenames = []


    def add(self, feature):
        super().add(feature)
        if isinstance(feature, Feature):
            self.filenames.extend(feature.filenames)
        elif _is_string(feature):
            self.filenames.extend(feature)
        elif hasattr(feature, &#34;filenames&#34;):
            self.filenames.extend(feature.filenames)
        else:
            print(&#34;Feature: No filename associated with&#34;, type(feature), &#34;in add&#34;)

    def clone(self):
        feat = super().clone()
        feat.filenames = self.filenames

class FeatureCollection(_pygplates.FeatureCollection):

    def __init__(self, features=None):
        super(FeatureCollection, self).__init__(features)
        self.filenames = []

        # update filename list
        if _is_string(features) and type(features) is list:
            self.filenames = features
        elif _is_string(features) and type(features) is str:
            self.filenames = [features]
        elif features is None:
            self.filenames = []
        elif isinstance(features, FeatureCollection):
            self.filenames = features.filenames
        elif hasattr(features, &#34;filenames&#34;):
            self.filenames = features.filenames
        else:
            print(&#34;FeatureCollection: No filename associated with&#34;, type(features), &#34;in __init__&#34;)
            self.filenames = []

    def add(self, features):
        super().add(features)

        # update filename list
        if isinstance(features, FeatureCollection):
            self.filenames.extend(features.filenames)
        elif _is_string(features):
            self.filenames.extend(features)
        elif hasattr(features, &#34;filenames&#34;):
            self.filenames.extend(features.filenames)
        else:
            print(&#34;FeatureCollection: No filename associated with&#34;, type(features), &#34;in add&#34;)

    def clone(self):
        fc = super().clone()
        fc.filenames = self.filenames
        return fc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.pygplates.Feature"><code class="flex name class">
<span>class <span class="ident">Feature</span></span>
<span>(</span><span>feature)</span>
</code></dt>
<dd>
<div class="desc"><p>The feature is an abstract model of some geological or plate-tectonic object or concept of interest defined by the <code>GPlates Geological Information Model &lt;http://www.gplates.org/docs/gpgim&gt;</code>_ (GPGIM). A feature consists of a collection of :class:<code>properties&lt;Property&gt;</code>, a :class:<code>feature type&lt;FeatureType&gt;</code> and a :class:<code>feature id&lt;FeatureId&gt;</code>.</p>
<p>The following operations for iterating over the properties in a feature are supported:</p>
<p>=========================== ==========================================================
Operation
Result
=========================== ==========================================================
<code>len(f)</code>
number of properties in feature <em>f</em>
<code>for p in f</code>
iterates over the properties <em>p</em> in feature <em>f</em>
=========================== ==========================================================</p>
<p>For example:
::</p>
<p>num_properties = len(feature)
properties_in_feature = [property for property in feature]
# assert(num_properties == len(properties_in_feature))</p>
<p>The following methods provide convenient ways to create :class:<code>features&lt;Feature&gt;</code>:</p>
<ul>
<li>:meth:<code>create_reconstructable_feature</code></li>
<li>:meth:<code>create_topological_feature</code></li>
<li>:meth:<code>create_tectonic_section</code></li>
<li>:meth:<code>create_flowline</code></li>
<li>:meth:<code>create_motion_path</code></li>
<li>:meth:<code>create_total_reconstruction_sequence</code></li>
</ul>
<p>The following methods return the :class:<code>feature type&lt;FeatureType&gt;</code> and :class:<code>feature id&lt;FeatureId&gt;</code>:</p>
<ul>
<li>:meth:<code>get_feature_type</code></li>
<li>:meth:<code>get_feature_id</code></li>
</ul>
<p>The following methods provide <em>generic</em> support for adding, removing, setting and getting properties:</p>
<ul>
<li>:meth:<code>add</code></li>
<li>:meth:<code>remove</code></li>
<li>:meth:<code>set</code></li>
<li>:meth:<code>get</code></li>
<li>:meth:<code>get_value</code></li>
</ul>
<p>The following methods provide a convenient way to set and get feature :class:<code>geometry&lt;GeometryOnSphere&gt;</code>:</p>
<ul>
<li>:meth:<code>set_geometry</code></li>
<li>:meth:<code>get_geometry</code></li>
<li>:meth:<code>get_geometries</code></li>
<li>:meth:<code>get_all_geometries</code></li>
</ul>
<p>The following methods provide a convenient way to set and get feature topological geometry (which can be topological a :class:<code>line&lt;GpmlTopologicalLine&gt;</code>, :class:<code>polygon&lt;GpmlTopologicalPolygon&gt;</code> or :class:<code>network&lt;GpmlTopologicalNetwork&gt;</code>):</p>
<ul>
<li>:meth:<code>set_topological_geometry</code></li>
<li>:meth:<code>get_topological_geometry</code></li>
<li>:meth:<code>get_topological_geometries</code></li>
<li>:meth:<code>get_all_topological_geometries</code></li>
</ul>
<p>The following methods provide a convenient way to set and get attributes imported from a Shapefile:</p>
<ul>
<li>:meth:<code>set_shapefile_attribute</code></li>
<li>:meth:<code>set_shapefile_attributes</code></li>
<li>:meth:<code>get_shapefile_attribute</code></li>
<li>:meth:<code>get_shapefile_attributes</code></li>
</ul>
<p>The following methods provide a convenient way to set and get :class:<code>enumeration&lt;Enumeration&gt;</code> properties:</p>
<ul>
<li>:meth:<code>set_enumeration</code></li>
<li>:meth:<code>get_enumeration</code></li>
</ul>
<p>The following methods provide a convenient way to set and get :class:<code>string&lt;XsString&gt;</code>, :class:<code>floating-point&lt;XsDouble&gt;</code>, :class:<code>integer&lt;XsInteger&gt;</code> and :class:<code>boolean&lt;XsBoolean&gt;</code> properties:</p>
<ul>
<li>:meth:<code>set_string</code></li>
<li>:meth:<code>get_string</code></li>
<li>:meth:<code>set_double</code></li>
<li>:meth:<code>get_double</code></li>
<li>:meth:<code>set_integer</code></li>
<li>:meth:<code>get_integer</code></li>
<li>:meth:<code>set_boolean</code></li>
<li>:meth:<code>get_boolean</code></li>
</ul>
<p>The following methods provide a convenient way to set and get some of the properties that are common to many feature types:</p>
<ul>
<li>:meth:<code>set_name</code></li>
<li>:meth:<code>get_name</code></li>
<li>:meth:<code>set_description</code></li>
<li>:meth:<code>get_description</code></li>
<li>:meth:<code>set_valid_time</code></li>
<li>:meth:<code>get_valid_time</code></li>
<li>:meth:<code>is_valid_at_time</code></li>
<li>:meth:<code>set_reconstruction_plate_id</code></li>
<li>:meth:<code>get_reconstruction_plate_id</code></li>
<li>:meth:<code>set_conjugate_plate_id</code></li>
<li>:meth:<code>get_conjugate_plate_id</code></li>
<li>:meth:<code>set_left_plate</code></li>
<li>:meth:<code>get_left_plate</code></li>
<li>:meth:<code>set_right_plate</code></li>
<li>:meth:<code>get_right_plate</code></li>
<li>:meth:<code>set_relative_plate</code></li>
<li>:meth:<code>get_relative_plate</code></li>
<li>:meth:<code>set_times</code></li>
<li>:meth:<code>get_times</code></li>
<li>:meth:<code>set_reconstruction_method</code></li>
<li>:meth:<code>get_reconstruction_method</code></li>
<li>:meth:<code>set_geometry_import_time</code></li>
<li>:meth:<code>get_geometry_import_time</code></li>
<li>:meth:<code>set_total_reconstruction_pole</code></li>
<li>:meth:<code>get_total_reconstruction_pole</code></li>
</ul>
<p>For other properties the generic :meth:<code>set</code>, :meth:<code>get</code> and :meth:<code>get_value</code> methods will still need to be used.</p>
<p>A feature can be deep copied using :meth:<code>clone</code>.</p>
<p><strong>init</strong>([feature_type], [feature_id], [verify_information_model=VerifyInformationModel.yes])
Create a new feature instance that is (initially) empty (has no properties).</p>
<p>:param feature_type: the type of feature
:type feature_type: :class:<code>FeatureType</code>
:param feature_id: the feature identifier
:type feature_id: :class:<code>FeatureId</code>
:param verify_information_model: whether to check <em>feature_type</em> with the information model (default) or not
:type verify_information_model: <em>VerifyInformationModel.yes</em> or <em>VerifyInformationModel.no</em>
:raises: InformationModelError if <em>verify_information_model</em> is <em>VerifyInformationModel.yes</em> and <em>feature_type</em> is not a recognised feature type</p>
<p>See :class:<code>FeatureType</code> for a list of available feature types.</p>
<p><em>feature_type</em> defaults to <em>gpml:UnclassifiedFeature</em> if not specified. There are no restrictions on the types and number of properties that can be added to features of type <em>gpml:UnclassifiedFeature</em> provided their property names are recognised by the <code>GPlates Geological Information Model &lt;http://www.gplates.org/docs/gpgim&gt;</code>_ (GPGIM). However all other feature types are restricted to a subset of recognised properties. The restriction is apparent when the features are created explicitly (see :meth:<code>add</code>) and when features are <em>read</em> from a GPML format file (there are no restrictions when the features are <em>written</em> to a GPML format file).</p>
<p>If <em>feature_id</em> is not specified then a unique feature identifier is created. In most cases a specific <em>feature_id</em> should not be specified because it avoids the possibility of accidentally having two feature instances with the same identifier which can cause problems with <em>topological</em> geometries.
::</p>
<pre><code>unclassified_feature = pygplates.Feature()

# This does the same thing as the code above.
unclassified_feature = pygplates.Feature(
    pygplates.FeatureType.gpml_unclassified_feature)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Feature(_pygplates.Feature):

    def __init__(self, feature):
        super(Feature, self).__init__(feature)
        self.filenames = []

        # update filename list
        if _is_string(feature) and type(feature) is list:
            self.filenames = feature
        elif _is_string(feature) and type(feature) is str:
            self.filenames = [feature]
        elif feature is None:
            self.filenames = []
        elif isinstance(feature, Feature):
            self.filenames = feature.filenames
        elif hasattr(feature, &#34;filenames&#34;):
            self.filenames = feature.filenames
        else:
            print(&#34;Feature: No filename associated with&#34;, type(feature), &#34;in __init__&#34;)
            self.filenames = []


    def add(self, feature):
        super().add(feature)
        if isinstance(feature, Feature):
            self.filenames.extend(feature.filenames)
        elif _is_string(feature):
            self.filenames.extend(feature)
        elif hasattr(feature, &#34;filenames&#34;):
            self.filenames.extend(feature.filenames)
        else:
            print(&#34;Feature: No filename associated with&#34;, type(feature), &#34;in add&#34;)

    def clone(self):
        feat = super().clone()
        feat.filenames = self.filenames</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.Feature</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gplately.pygplates.Feature.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, feature)</span>
</code></dt>
<dd>
<div class="desc"><p>add(property_name, property_value, [verify_information_model=VerifyInformationModel.yes])
Adds a property (or properties) to this feature.</p>
<p>:param property_name: the name of the property (or properties) to add
:type property_name: :class:<code>PropertyName</code>
:param property_value: the value (or values) of the property (or properties) to add
:type property_value: :class:<code>PropertyValue</code>, or sequence (eg, <code>list</code> or <code>tuple</code>) of :class:<code>PropertyValue</code>
:param verify_information_model: whether to check the information model before adding (default) or not
:type verify_information_model: <em>VerifyInformationModel.yes</em> or <em>VerifyInformationModel.no</em>
:returns: the property (or properties) added to the feature
:rtype: :class:<code>Property</code>, or list of :class:<code>Property</code> depending on whether <em>property_value</em> is a :class:<code>PropertyValue</code> or sequence of :class:<code>PropertyValue</code>
:raises: InformationModelError if <em>verify_information_model</em> is <em>VerifyInformationModel.yes</em> and <em>property_name</em> is not a recognised property name or is not supported by the feature type, or if <em>property_value</em> does not have a property value type supported by <em>property_name</em></p>
<p>::</p>
<pre><code>property_added = feature.add(property_name, property_value)
properties_added = feature.add(property_name, [property_value1, property_value2])
# assert(len(properties_added) == 2)
</code></pre>
<p>A feature is an <em>unordered</em> collection of properties so there is no concept of where a property is inserted in the sequence of properties.</p>
<p>Note that even a feature of :class:<code>type&lt;FeatureType&gt;</code> <em>gpml:UnclassifiedFeature</em> will raise <em>InformationModelError</em> if <em>verify_information_model</em> is <em>VerifyInformationModel.yes</em> and <em>property_name</em> is not recognised by the GPlates Geological Information Model (GPGIM).</p>
<p>!!! seealso "Seealso:&ensp;:meth:<code>remove</code>"</p>
<p>add(properties, [verify_information_model=VerifyInformationModel.yes])
Adds properties to this feature.</p>
<p>:param properties: the property name/value pairs to add
:type properties: a sequence (eg, <code>list</code> or <code>tuple</code>) of (:class:<code>PropertyName</code>, :class:<code>PropertyValue</code> or sequence of :class:<code>PropertyValue</code>)
:param verify_information_model: whether to check the information model before adding (default) or not
:type verify_information_model: <em>VerifyInformationModel.yes</em> or <em>VerifyInformationModel.no</em>
:returns: the list of properties added to the feature
:rtype: <code>list</code> of :class:<code>Property</code>
:raises: InformationModelError if <em>verify_information_model</em> is <em>VerifyInformationModel.yes</em> and any of the property names are not recognised property names or not supported by the feature type, or if any property value type is not supported by its associated property name</p>
<p>::</p>
<pre><code>properties_added = feature.add([
    (property_name1, property_value1),
    (property_name2, property_value2)])
# assert(len(properties_added) == 2)

properties_added = feature.add([
    (property_name3, (property_value3a, property_value3b, property_value3c)),
    (property_name4, [property_value4a, property_value4b])
    (property_name5, property_value5)
    ])
# assert(len(properties_added) == 6)
</code></pre>
<p>A feature is an <em>unordered</em> collection of properties so there is no concept of where a property is inserted in the sequence of properties.</p>
<p>Note that even a feature of :class:<code>type&lt;FeatureType&gt;</code> <em>gpml:UnclassifiedFeature</em> will raise <em>InformationModelError</em> if <em>verify_information_model</em> is <em>VerifyInformationModel.yes</em> and <em>property_name</em> is not recognised by the GPlates Geological Information Model (GPGIM).</p>
<p>!!! seealso "Seealso:&ensp;:meth:<code>remove</code>"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, feature):
    super().add(feature)
    if isinstance(feature, Feature):
        self.filenames.extend(feature.filenames)
    elif _is_string(feature):
        self.filenames.extend(feature)
    elif hasattr(feature, &#34;filenames&#34;):
        self.filenames.extend(feature.filenames)
    else:
        print(&#34;Feature: No filename associated with&#34;, type(feature), &#34;in add&#34;)</code></pre>
</details>
</dd>
<dt id="gplately.pygplates.Feature.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clone()
Create a duplicate of this feature instance.</p>
<p>:rtype: :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></p>
<p>This creates a new :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> instance with cloned versions of this feature's properties. And the cloned feature is created with its own unique :class:<code>FeatureId</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self):
    feat = super().clone()
    feat.filenames = self.filenames</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gplately.pygplates.FeatureCollection"><code class="flex name class">
<span>class <span class="ident">FeatureCollection</span></span>
<span>(</span><span>features=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A feature collection aggregates a set of features into a collection. This is traditionally so that a group of features can be loaded, saved or unloaded in a single operation.</p>
<p>For example, to read coastline features from a file:
::</p>
<p>coastline_feature_collection = pygplates.FeatureCollection('coastlines.gpml')</p>
<p>And to write coastline features to a file:
::</p>
<p>coastline_feature_collection = pygplates.FeatureCollection(coastline_features)
coastline_feature_collection.write('coastlines.gpml')</p>
<p>The following <em>feature collection</em> file formats are currently supported:</p>
<p>=============================== ======================= ============== =================
File Format
Filename Extension
Supports Read
Supports Write
=============================== ======================= ============== =================
GPlates Markup Language
'.gpml'
Yes
Yes
Compressed GPML
'.gpmlz' or '.gpml.gz'
Yes
Yes
PLATES4 line
'.dat' or '.pla'
Yes
Yes
PLATES4 rotation
'.rot'
Yes
Yes
GPlates rotation
'.grot'
Yes
Yes
ESRI Shapefile
'.shp'
Yes
Yes
GeoJSON
'.geojson' or '.json'
Yes
Yes
GeoPackage
'.gpkg'
Yes
Yes
OGR GMT
'.gmt'
Yes
Yes
GMT xy
'.xy'
No
Yes
GMAP Virtual Geomagnetic Poles
'.vgp'
Yes
No
=============================== ======================= ============== =================</p>
<p>In the future, support will be added to enable users to implement and register readers/writers for other file formats (or their own non-standard file formats).</p>
<p>The following operations for accessing the features are supported:</p>
<p>=========================== ==========================================================
Operation
Result
=========================== ==========================================================
<code>len(fc)</code>
number of features in feature collection <em>fc</em>
<code>for f in fc</code>
iterates over the features <em>f</em> in feature collection <em>fc</em>
<code>fc[i]</code>
the feature of <em>fc</em> at index <em>i</em>
=========================== ==========================================================</p>
<p>For example:
::</p>
<p>num_features = len(feature_collection)
features_in_collection = [feature for feature in feature_collection]
# assert(num_features == len(features_in_collection))</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;A feature collection can be deep copied using :meth:<code>clone</code>.</p>
</div>
<div class="admonition versionchanged">
<p class="admonition-title">Changed in version:&ensp;31</p>
<p>Can index a feature in feature collection <em>fc</em> with <code>fc[i]</code>.</p>
</div>
<p><strong>init</strong>([features])
Create a new feature collection instance.</p>
<p>:param features: an optional filename, or sequence of features, or a single feature
:type features: string, or a sequence (eg, <code>list</code> or <code>tuple</code>) of :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code>, or a single :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code>
:raises: OpenFileForReadingError if file is not readable (if filename specified)
:raises: FileFormatNotSupportedError if file format (identified by the filename extension) does not support reading (when filename specified)</p>
<p>To create a new feature collection from a file:
::</p>
<pre><code>coastline_feature_collection = pygplates.FeatureCollection('coastlines.gpml')
</code></pre>
<p>To create a new feature collection from a sequence of :class:<code>features&lt;Feature&gt;</code>:
::</p>
<pre><code>feature_collection = pygplates.FeatureCollection([feature1, feature2])

# ...is the equivalent of...

feature_collection = pygplates.FeatureCollection()
feature_collection.add(feature1)
feature_collection.add(feature2)
</code></pre>
<p>!!! note "Note:&ensp;Since a :class:<code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code> is an iterable sequence of features it can be used in the <em>features</em> argument."
This creates a shallow copy much in the same way as with a Python list (for example <code>shallow_copy_list = list(original_list)</code>):
::</p>
<pre><code>    shallow_copy_feature_collection = pygplates.FeatureCollection(original_feature_collection)

    # Modifying the collection/list of features in the shallow copy will not affect the original...
    shallow_copy_feature_collection.add(...)
    # assert(len(shallow_copy_feature_collection) != len(original_feature_collection))

    # Modifying the actual feature data in the collection will affect both feature collections
    # since the feature data is shared by both collections...
    for feature in original_feature_collection:
        # Changing the reconstruction plate ID affects both original and shallow copy collections.
        feature.set_reconstruction_plate_id(...)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureCollection(_pygplates.FeatureCollection):

    def __init__(self, features=None):
        super(FeatureCollection, self).__init__(features)
        self.filenames = []

        # update filename list
        if _is_string(features) and type(features) is list:
            self.filenames = features
        elif _is_string(features) and type(features) is str:
            self.filenames = [features]
        elif features is None:
            self.filenames = []
        elif isinstance(features, FeatureCollection):
            self.filenames = features.filenames
        elif hasattr(features, &#34;filenames&#34;):
            self.filenames = features.filenames
        else:
            print(&#34;FeatureCollection: No filename associated with&#34;, type(features), &#34;in __init__&#34;)
            self.filenames = []

    def add(self, features):
        super().add(features)

        # update filename list
        if isinstance(features, FeatureCollection):
            self.filenames.extend(features.filenames)
        elif _is_string(features):
            self.filenames.extend(features)
        elif hasattr(features, &#34;filenames&#34;):
            self.filenames.extend(features.filenames)
        else:
            print(&#34;FeatureCollection: No filename associated with&#34;, type(features), &#34;in add&#34;)

    def clone(self):
        fc = super().clone()
        fc.filenames = self.filenames
        return fc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.FeatureCollection</li>
<li>Boost.Python.instance</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gplately.pygplates.FeatureCollection.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, features)</span>
</code></dt>
<dd>
<div class="desc"><p>add(feature)
Adds one or more features to this collection.</p>
<p>:param feature: one or more features to add
:type feature: :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> or sequence (eg, <code>list</code> or <code>tuple</code>) of :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></p>
<p>A feature collection is an <em>unordered</em> collection of features so there is no concept of where a feature is inserted in the sequence of features.</p>
<p>::</p>
<pre><code>feature_collection.add(feature)
feature_collection.add([feature1, feature2])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, features):
    super().add(features)

    # update filename list
    if isinstance(features, FeatureCollection):
        self.filenames.extend(features.filenames)
    elif _is_string(features):
        self.filenames.extend(features)
    elif hasattr(features, &#34;filenames&#34;):
        self.filenames.extend(features.filenames)
    else:
        print(&#34;FeatureCollection: No filename associated with&#34;, type(features), &#34;in add&#34;)</code></pre>
</details>
</dd>
<dt id="gplately.pygplates.FeatureCollection.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clone()
Create a duplicate of this feature collection instance.</p>
<p>:rtype: :class:<code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code></p>
<p>This creates a new :class:<code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code> instance with cloned versions of this collection's features. And the cloned features (in the cloned collection) are each created with a unique :class:<code>FeatureId</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self):
    fc = super().clone()
    fc.filenames = self.filenames
    return fc</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gplately.pygplates.RotationModel"><code class="flex name class">
<span>class <span class="ident">RotationModel</span></span>
<span>(</span><span>rotation_features)</span>
</code></dt>
<dd>
<div class="desc"><p>Query a finite rotation of a moving plate relative to any other plate, optionally between two instants in geological time.</p>
<p>See :ref:<code>pygplates_foundations_plate_reconstruction_hierarchy</code>.</p>
<p>This class provides an easy way to query rotations in any of the four combinations of total/stage and equivalent/relative rotations using :meth:<code>get_rotation</code>. :class:<code>Reconstruction trees&lt;ReconstructionTree&gt;</code> can also be created at any instant of geological time and these are cached internally depending on a user-specified cache size parameter pass to :meth:<code>__init__</code>. The <em>reconstruction_tree_cache_size</em> parameter of those methods controls the size of an internal least-recently-used cache of reconstruction trees (evicts least recently requested reconstruction tree when a new reconstruction time is requested that does not currently exist in the cache). This enables reconstruction trees associated with different reconstruction times to be re-used instead of re-creating them, provided they have not been evicted from the cache. This benefit also applies when querying rotations with :meth:<code>get_rotation</code> since it, in turn, requests reconstruction trees.</p>
<p><strong>init</strong>(&hellip;)
A <em>RotationModel</em> object can be constructed in more than one way&hellip;</p>
<p><strong>init</strong>(rotation_features, [reconstruction_tree_cache_size=150], [extend_total_reconstruction_poles_to_distant_past=False], [default_anchor_plate_id=0])
Create from rotation feature collection(s) and/or rotation filename(s).</p>
<p>:param rotation_features: A rotation feature collection, or rotation filename, or rotation feature, or sequence of rotation features, or a sequence (eg, <code>list</code> or <code>tuple</code>) of any combination of those four types
:type rotation_features: :class:<code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code>, or string, or :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code>, or sequence of :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code>, or sequence of any combination of those four types
:param reconstruction_tree_cache_size: Number of reconstruction trees to cache internally. Defaults to 150.
:type reconstruction_tree_cache_size: int
:param extend_total_reconstruction_poles_to_distant_past: extend each moving plate sequence back infinitely far into the distant past such that reconstructed geometries will not snap back to their present day positions when the reconstruction time is older than the oldest times specified in the rotation features (defaults to <code>False</code>)
:type extend_total_reconstruction_poles_to_distant_past: bool
:param default_anchor_plate_id: The default anchored plate id to use when :meth:<code>get_rotation</code> and :meth:<code>get_reconstruction_tree</code> are called without specifying their <em>anchor_plate_id</em> parameter. Defaults to 0.
:type default_anchor_plate_id: int
:raises: OpenFileForReadingError if any file is not readable (when filenames specified)
:raises: FileFormatNotSupportedError if any file format (identified by the filename extensions) does not support reading (when filenames specified)</p>
<p>Note that <em>rotation_features</em> can be a rotation :class:<code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code> or a rotation filename or a rotation :class:<code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code> or a sequence of rotation :class:<code>features&lt;Feature&gt;</code>, or a sequence (eg, <code>list</code> or <code>tuple</code>) of any combination of those four types.</p>
<p>If any rotation filenames are specified then this method uses :class:<code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code> internally to read the rotation files.</p>
<p>Load a rotation file and some rotation adjustments (as a collection of rotation features) into a rotation model:
::</p>
<pre><code>rotation_adjustments = pygplates.FeatureCollection()
...
rotation_model = pygplates.RotationModel(['rotations.rot', rotation_adjustments])
</code></pre>
<p>!!! versionchanged "Changed in version:&ensp;25"
Added <em>extend_total_reconstruction_poles_to_distant_past</em> argument and removed <em>clone_rotation_features</em> argument.</p>
<p>!!! versionchanged "Changed in version:&ensp;26"
Added <em>default_anchor_plate_id</em> argument.</p>
<p><strong>init</strong>(rotation_model, [reconstruction_tree_cache_size=2], [default_anchor_plate_id])
Use an existing rotation model but adapt it with a potentially different cache size and/or default anchor plate ID.</p>
<p>:param rotation_model: an existing rotation model
:type rotation_model: :class:<code><a title="gplately.pygplates.RotationModel" href="#gplately.pygplates.RotationModel">RotationModel</a></code>
:param reconstruction_tree_cache_size: Number of reconstruction trees to cache internally. Defaults to 2 - this is much lower than the usual default cache size since the existing rotation model likely already has a sizeable cache anyway - and if you are leaving this at its default value then you are presumably only interested in changing the default anchor plate ID (not increasing the cache size).
:type reconstruction_tree_cache_size: int
:param default_anchor_plate_id: The default anchored plate id to use when :meth:<code>get_rotation</code> and :meth:<code>get_reconstruction_tree</code> are called without specifying their <em>anchor_plate_id</em> parameter. Defaults to the default anchor plate of <em>rotation_model</em>.
:type default_anchor_plate_id: int</p>
<p>This is useful if you want to use an existing rotation model but with a larger cache size or a different default anchor plate ID:
::</p>
<pre><code>rotation_model = pygplates.RotationModel(rotation_files)
...
rotation_model_anchor_1 = pygplates.RotationModel(rotation_model, default_anchor_plate_id=1)
</code></pre>
<p>!!! note "Note:&ensp;The above example just changes the <em>default</em> anchor plate ID. You can still explicitly specify any anchor plate ID to :meth:<code>get_rotation</code>. So the following two calls return the same results:"
::</p>
<pre><code>    rotation_model.get_rotation(100.0, 802, anchor_plate_id=1)
    rotation_model_anchor_1.get_rotation(100.0, 802)
</code></pre>
<p>!!! versionadded "Added in version:&ensp;29"</p>
<p><strong>init</strong>(rotation_model)
Simply return an existing rotation model as a convenience.</p>
<p>:param rotation_model: an existing rotation model
:type rotation_model: :class:<code><a title="gplately.pygplates.RotationModel" href="#gplately.pygplates.RotationModel">RotationModel</a></code></p>
<p>This is useful when defining your own function that accepts rotation features or a rotation model. It avoids the hassle of having to explicitly test for each source type:
::</p>
<pre><code>def my_function(rotation_features_or_model):
    # The appropriate constructor (__init__) overload is chosen depending on argument type.
    rotation_model = pygplates.RotationModel(rotation_features_or_model)
    ...
</code></pre>
<p>!!! note "Note:&ensp;This :meth:<code>constructor&lt;__init__&gt;</code> just returns a reference to the existing <em>rotation_model</em> because a <em>RotationModel</em> object is immutable (contains no operations or methods that modify its state) and hence a deep copy of <em>rotation_model</em> is not needed."</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RotationModel(_pygplates.RotationModel):

    def __init__(self, rotation_features):
        super(RotationModel, self).__init__(rotation_features)
        self.filenames = []

        # update filename list
        if _is_string(rotation_features) and type(rotation_features) is list:
            self.filenames = rotation_features
        elif _is_string(rotation_features) and type(rotation_features) is str:
            self.filenames = [rotation_features]
        elif rotation_features is None:
            self.filenames = []
        elif isinstance(rotation_features, RotationModel):
            self.filenames = rotation_features.filenames
        elif hasattr(rotation_features, &#34;filenames&#34;):
            self.filenames = rotation_features.filenames
        else:
            print(&#34;RotationModel: No filename associated with&#34;, type(rotation_features), &#34;in __init__&#34;)
            self.filenames = []</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygplates.RotationModel</li>
<li>Boost.Python.instance</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.pygplates.Feature" href="#gplately.pygplates.Feature">Feature</a></code></h4>
<ul class="">
<li><code><a title="gplately.pygplates.Feature.add" href="#gplately.pygplates.Feature.add">add</a></code></li>
<li><code><a title="gplately.pygplates.Feature.clone" href="#gplately.pygplates.Feature.clone">clone</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.pygplates.FeatureCollection" href="#gplately.pygplates.FeatureCollection">FeatureCollection</a></code></h4>
<ul class="">
<li><code><a title="gplately.pygplates.FeatureCollection.add" href="#gplately.pygplates.FeatureCollection.add">add</a></code></li>
<li><code><a title="gplately.pygplates.FeatureCollection.clone" href="#gplately.pygplates.FeatureCollection.clone">clone</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gplately.pygplates.RotationModel" href="#gplately.pygplates.RotationModel">RotationModel</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>