<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gplately.download API documentation</title>
<meta name="description" content="Functions for downloading assorted plate reconstruction data to use with GPlately&#39;s
main objects. Files are stored in the user&#39;s cache and can be …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.download</code></h1>
</header>
<section id="section-intro">
<p>Functions for downloading assorted plate reconstruction data to use with GPlately's
main objects. Files are stored in the user's cache and can be reused after being
downloaded once. </p>
<p>These data have been created and used in plate reconstruction models and studies, and
are available from public web servers (like EarthByte's webDAV server, or the GPlates
2.3 sample dataset library).</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Functions for downloading assorted plate reconstruction data to use with GPlately&#39;s
main objects. Files are stored in the user&#39;s cache and can be reused after being
downloaded once. 

These data have been created and used in plate reconstruction models and studies, and
are available from public web servers (like EarthByte&#39;s webDAV server, or the GPlates 
2.3 sample dataset library).

&#34;&#34;&#34;
import pooch as _pooch
from pooch import os_cache as _os_cache
from pooch import retrieve as _retrieve
from pooch import utils as _utils
from pooch import HTTPDownloader as _HTTPDownloader
from pooch import Unzip as _Unzip
from pooch import Decompress as _Decompress
from matplotlib import image as _image
from .pygplates import RotationModel as _RotationModel
from .pygplates import FeatureCollection as _FeatureCollection
from gplately.data import DataCollection
import gplately as _gplately
import pygplates as _pygplates
import re as _re
import os as _os
import numpy as _np
import urllib.request as _request
import hashlib as _hashlib
import pathlib as _pathlib
import shutil as _shutil
import requests as _requests

def _test_internet_connection(url):
    &#34;&#34;&#34;Test whether a connection to the required web server
    can be made given a `url`.
    
    Returns `False` the `url` is incorrect, and/or if there
    is no internet connection.&#34;&#34;&#34;
    try:
        _request.urlopen(url) 
        return True
    except:
        return False
    

def _determine_processor(url):
    &#34;&#34;&#34;Set instructions for how to process/unpack a file depending on
    its filetype. The unpacked file paths will have an .unzip, or 
    .decomp, or no file extension in their processed form.&#34;&#34;&#34;
    archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
    if url.endswith(&#34;.zip&#34;):
        processor=_Unzip()
        ext = &#34;.unzip&#34;
    elif url.endswith(archive_formats):
        processor=_Decompress()
        ext = &#34;.decomp&#34;
    else:
        processor = None
        ext = &#34;&#34;
    return processor, ext


def path_of_cached_file(url, model_name=None):
    &#34;&#34;&#34;Determine the full path to the cache where the file in `url` 
    will be downloaded to.&#34;&#34;&#34;

    cached_filename = _pooch.utils.unique_file_name(url)
    cached_filename = _remove_hash(cached_filename)
    path = path_to_cache()

    processor_to_use, processor_extension = _determine_processor(url)

    # If the requested files need processing (i.e. zip, gz folders)
    if processor_extension:
        # Are they from plate models? These typically are the .zip folders for plate models
        if model_name:
            cached_filename  = str(path) + &#39;/&#39; + model_name + processor_extension+&#39;/&#39;
            unprocessed_path = str(path) + &#39;/&#39; + model_name
            #cached_filename = cached_filename = str(path) + &#39;/&#39; + model_name

        # If not from plate models but need processing, i.e. ETOPO1
        else:
            cached_filename = str(path) + &#39;/&#39; + &#34;gplately_&#34;+_parse_url_for_filenames(url) + processor_extension+&#39;/&#39;
            unprocessed_path = str(path) + &#39;/&#39; + &#34;gplately_&#34;+_parse_url_for_filenames(url)
            #cached_filename = &#34;gplately_&#34;+_parse_url_for_filenames(url) 

    # If the requested files do not need processing, like standalone .nc files:
    else:
        if model_name:
            cached_filename = str(path) + &#39;/&#39; + model_name + &#34;_&#34; + _parse_url_for_filenames(url)
            unprocessed_path = None
        else:
            cached_filename = str(path) + &#39;/&#39; + &#34;gplately_&#34;+_parse_url_for_filenames(url)
            unprocessed_path = None
      
    _pooch.utils.make_local_storage(path)
    full_path = path.resolve() / cached_filename

    return full_path, unprocessed_path


def _extract_processed_files(processed_directory):
    &#34;&#34;&#34;Return a list of all full filenames from a given directory 
    in the GPlately cache.
    &#34;&#34;&#34;
    if _os.path.isdir(processed_directory):
        fnames = []
        for root, dirs, files in _os.walk(processed_directory):
            for file in files:
                fnames.append(_os.path.join(root,file))
        return(fnames)
    elif _os.path.isfile(str(processed_directory)):
        return(processed_directory)


def path_to_cache():
    path = _pooch.utils.cache_location(
        _os_cache(&#39;gplately&#39;), 
        env=None, 
        version=None
    )
    return path


def clear_cache():
    &#34;&#34;&#34;Caution - when called, this clears the entire gplately cache. 
    This action cannot be undone.&#34;&#34;&#34;
    cache_path = path_to_cache()
    _shutil.rmtree(str(cache_path))
    _pooch.utils.make_local_storage(str(cache_path))
    return

    
def _parse_url_for_filenames(url, return_hash=False):
    # Determine the filename of an E-Tag txt file
    md5 = _hashlib.md5(url.encode()).hexdigest()
    fname = _os.path.basename(_pooch.utils.parse_url(url)[&#34;path&#34;])
    fname = fname[-(255 - len(md5) - 1) :]
    if return_hash:
        return str(fname), str(md5)
    else:
        return str(fname)


def _get_url_etag(url):
    &#34;&#34;&#34;Obtain the E-Tag of a web server URL. 
    
    The E-Tag identifies a resource under a URL. If the resource
    is modified, a new E-Tag is generated. DataServer uses the
    E-Tag to determine whether local copies of plate model files
    available from a web server need to be updated to match the
    version on the web server.
    &#34;&#34;&#34;
    # Determine E-Tag of the URL
    etag = str(_requests.head(url).headers.get(&#34;ETag&#34;))

    # Determine the filename of an E-Tag txt file
    parsed_fname, filehash = _parse_url_for_filenames(url, return_hash=True)

    unique_name = filehash + &#34;-ETAG.txt&#34;

    cachepath = str(
        _pathlib.Path(
            _os.path.expanduser(str(_os_cache(&#39;gplately&#39;))))
    )

    text_path = _os.path.join(cachepath, unique_name)
    return(etag, text_path)
    
    
def _save_url_etag_to_txt(etag, text_path):
    &#34;&#34;&#34;Write an E-Tag to a text file.
    &#34;&#34;&#34;       
    # Write E-Tag to a text file on the GPlately cache. 
    text_file = open(text_path, &#34;w&#34;)
    text_file.write(etag)
    text_file.close()
    

def _match_url_to_extension(url):
    url = str(url)
    if url.endswith(&#34;.nc&#34;):
        return &#34;.nc&#34;
    elif url.endswith(&#34;.jpg&#34;):
        return &#34;.jpg&#34;
    elif url.endswith(&#34;.png&#34;):
        return &#34;.png&#34;
    elif url.endswith(&#34;.tif&#34;):
        return &#34;.tif&#34;


def _first_time_download_from_web(url, model_name=None, verbose=True):
    &#34;&#34;&#34;
    # Provided a web connection to a server can be established,
    download the files from the URL into the GPlately cache.
    &#34;&#34;&#34;

    if _test_internet_connection(url):

        if not verbose:
            logger = _pooch.get_logger()
            log_level = logger.level
            logger.setLevel(&#34;WARNING&#34;)

        # The filename pooch saves the requested file is derived from
        # one of four permutations:
        # 1. File is from a plate model and needs processing (i.e. zip --&gt; unzip)
        # 2. File is from a plate model and does not need processing (i.e. .nc age grids)
        # 3. File is not from a plate model but needs processing (i.e. ETOPO, .grd.gz --&gt; .decomp)
        # 4. File is not from a plate model and does not need processing
        processor_to_use, processor_extension = _determine_processor(url)

        # If the requested files need processing (i.e. zip, gz folders)
        if processor_extension:
            # Are they from plate models? These typically are the .zip folders for plate models
            if model_name:
                # Download the files with a naming structure like:
                # /path/to/cache/gplately/model_name+processor_extension
                used_fname = model_name
                fnames = _retrieve(
                        url=url,
                        known_hash=None,  
                        downloader=_HTTPDownloader(progressbar=verbose),
                        fname=used_fname,
                        path=_os_cache(&#39;gplately&#39;),
                        processor=processor_to_use
                )
            # If not from plate models but need processing, i.e. ETOPO1
            else:
                # Download the files with a naming structure like:
                # /path/to/cache/gplately/file_name-as_inteded_in_url+processor_extension
                used_fname = &#34;gplately_&#34;+_parse_url_for_filenames(url)
                fnames = _retrieve(
                    url=url,
                    known_hash=None,  
                    downloader=_HTTPDownloader(progressbar=verbose),
                    fname=used_fname,
                    path=_os_cache(&#39;gplately&#39;),
                    processor=processor_to_use
                )
        # If the requested files do not need processing, like standalone .nc files:
        else:
            # Are they from plate models? These typically are age or spreading rate grids
            if model_name:
                # Download the files with a naming structure like:
                # /path/to/cache/gplately/file_name-as_inteded_in_url+processor_extension
                used_fname = model_name+&#34;_&#34;+_parse_url_for_filenames(url)
                fnames = _retrieve(
                        url=url,
                        known_hash=None,  
                        downloader=_HTTPDownloader(progressbar=verbose),
                        fname=used_fname,
                        path=_os_cache(&#39;gplately&#39;),
                        processor=processor_to_use
                )
            # If not from plate models and do not need processing,
            else:
                used_fname = &#34;gplately_&#34;+_parse_url_for_filenames(url)
                fnames = _retrieve(
                        url=url,
                        known_hash=None,  
                        downloader=_HTTPDownloader(progressbar=verbose),
                        fname=used_fname,
                        path=_os_cache(&#39;gplately&#39;),
                        processor=processor_to_use
                )
        
        if not verbose:
            logger.setLevel(log_level)

        # Get the URL&#39;s E-Tag for the first time
        etag, textfilename = _get_url_etag(url)
        _save_url_etag_to_txt(etag, textfilename)
        return(fnames, etag, textfilename, used_fname)

    
def download_from_web(url, verbose=True, download_changes=True, model_name=None):
    &#34;&#34;&#34;Download a file from a `url` into the `gplately` cache.
    
    Notes
    -----
    After the file belonging to the given `url` is downloaded 
    to the `gplately` cache once, subsequent runs of 
    `download_from_web` with this `url` will not redownload 
    the file as long as:
    
    * The file has not been updated on the web server,
    * The file has not been removed from the `gplately` cache.
    
    Instead, the file will be re-accessed from the `gplately` 
    cache it was downloaded to. 
    
    However, if the file has been updated on the web server,
    `download_from_web` overwrites the cached file with the 
    updated version. The following messages will be displayed 
    to the user:
    
        &#34;Checking whether the requested files need to be updated...&#34;
        &#34;Yes - updating requested files...&#34;
        &#34;Requested files downloaded to the GPlately cache folder!&#34;
    
    If ever a connection to the web server (and the file(s)) in 
    `url` is unsuccessful, this is likely because:

    * An internet connection could not be established; or
    * The `url` passed to `download_from_web` is incorrect

    In either case, `download_from_web` attempts to find a version 
    of the requested file(s) in `url` already stored in the 
    `gplately` cache (assuming it has been downloaded from the same 
    `url` once before). This version may not match the one on the web
    server. If a copy of the file(s) cannot be found in the `gplately`
    cache, a `ConnectionError` is raised.
    
    Parameters
    ----------
    url : str
        The full URL used to download a file from a public web server
        like webDAV.
    verbose : bool
        Choose whether to print user alerts regarding file availability,
        data server/internet connection status etc. 
    download_changes : bool, default=True
        Permit the re-downloading/update of the file from `url` if 
        it has been updated on the web server since the last download.
        
    Returns
    -------
    fnames : list of str
        A list of strings representing the full paths to all cached data
        downloaded from the given `url`.

    Raises
    ------
    ConnectionError
        If a connection to the web server and file(s) in the given `url` is
        unsuccessful (because there is no internet access, and/or the `url`
        is incorrect) and no version of the requested file(s) have been
        cached before. In this case, nothing is returned. 
    &#34;&#34;&#34;


    #   NOTE: We need a way to verify the existence of requested file(s) in the gplately
    #   cache to determine whether a file needs to be installed, updated, or re-accessed 
    #   from the cache. Every time a file is installed for the first time,
    #   DataServer creates a directory called `full_path`. Its existence verifies the 
    #   existence
    #
    #   The nature of `full_path` is dependent on the file-type:
    #
    #   .zip files will be downloaded and expanded in an inside folder:
    #   
    #   /path/to/cache/gplately/fname.zip.unzip/
    #
    #   Thus, for zips, `full_path` is a directory that ends in &#34;.zip.unzip&#34;:
    #
    #   For example: /Users/laurenilano/Library/Caches/gplately/Muller2019.zip.unzip/

    #   Other types of files that need processing, like .gz --&gt; .decomp, aren&#39;t
    #   expanded in an internal folder. This is also the case for files that do not 
    #   need processing, e.g. &#34;.nc&#34; files. In these cases, `full_path` is the exact
    #   directory that the cached file is saved to.
    # 
    #
    #   For example: /Users/laurenilano/Library/Caches/gplately/Muller_etal_2019_Tectonics_v2.0_AgeGrid-100.nc
    #
    #   `full_path` is an empty directory for non-zips, and is the parent directory of
    #   unzipped contents in &#34;.zip&#34; URLs. 
    #
    #   Why do we need `full_path`?
    #   We search the top-level gplately cache directory for the `full_path` directory as it is
    #   installed with the requested files. Its existence verifies the
    #   existence of the requested file(s), and thus to decide whether to install the
    #   files or re-access existing cached versions. This also helps with E-Tag versioning
    #   in instances where the download URL remains the same but its contents may have changed
    #   since the file(s) were last cached. 
    
    full_path, unprocessed_path = path_of_cached_file(url, model_name)

    # If the file required processing (zips make a directory to unzip in, and .gz for example
    # makes a file just saved to the top-level directory), and the directory or file is not 
    # yet on the cache,
    if _determine_processor(url)[1] and not (
        _os.path.isdir(str(full_path)) or _os.path.isfile(str(full_path))
        ):

        # ...and if a connection to the web server can be established,
        # download files from the URL and create a textfile for this URL&#39;s E-Tag
        if _test_internet_connection(url):
            fnames, etag, textfilename, used_fname = _first_time_download_from_web(
                url, 
                model_name=model_name,
                verbose=verbose
            )
            if verbose:
                print(&#34;Requested files downloaded to the GPlately cache folder!&#34;)
            return(fnames)
    
        # ... if a connection to the web server cannot be established
        else:
            raise ConnectionError(
                    &#34;A connection to {} could not be made. Please check your internet connection and/or ensure the URL is correct. No file from the given URL has been cached to {} yet - nothing has been returned.&#34;.format(url, full_path.parent))


    # If the file does not require processing, it did not open up a directory, so check isfile,
    # and if the file is not yet on the cache,
    elif not _determine_processor(url)[1] and not _os.path.isfile(str(full_path)):
        # ...and if a connection to the web server can be established,
        # download files from the URL and create a textfile for this URL&#39;s E-Tag
        if _test_internet_connection(url):
            fnames, etag, textfilename, used_fname = _first_time_download_from_web(
                url, 
                model_name=model_name,
                verbose=verbose
            )
            if verbose:
                print(&#34;Requested files downloaded to the GPlately cache folder!&#34;)
            return(fnames)
    
        # ... if a connection to the web server cannot be established
        else:
            raise ConnectionError(
                    &#34;A connection to {} could not be made. Please check your internet connection and/or ensure the URL is correct. No file from the given URL has been cached to {} yet - nothing has been returned.&#34;.format(url, full_path.parent))


    # If the files have been downloaded before...
    else:
        #... and if a connection to the web server can be made...
        if _test_internet_connection(url):
            
            _, local_etag_txtfile = _get_url_etag(url)

            # If the newest version of the files in `url` must be cached 
            # at all times, perform E-Tag comparisons:
            if download_changes:

                # Walk through the top-level cache directory to find an E-Tag textfile unique to the URL
                etag_exists = False

                cache_path = str(path_to_cache())
                if _os.path.isfile(local_etag_txtfile):
                    etag_exists = True

                # If an e-tag text file does not exist, erase the cached files
                # and download the latest version from the web server. This, in turn,
                # creates an e-tag textfile for this version.
                if not etag_exists:
                    _shutil.rmtree(str(full_path))
                    fnames, etag, local_etag_txtfile, used_fname = _first_time_download_from_web(
                        url, 
                        model_name=model_name,
                        verbose=verbose
                    )
                    return(fnames)

                # If the e-tag textfile exists for the local files,
                else: 
                    if verbose:
                        print(&#34;Checking whether the requested files need to be updated...&#34;)

                    # Determine the local file&#39;s URL e-tag from the textfile
                    with open(local_etag_txtfile) as f:
                        local_etag = str(f.readlines()[0])

                    # Get the e-tag of the web server URL at current time
                    remote_etag, remote_etag_textfile = _get_url_etag(url)

                    # If the local and remote e-tags are unequal, the web-server URL 
                    # contains an updated version of the cached files.
                    if str(remote_etag) != str(local_etag):
                        if verbose:
                            print(&#34;Yes - updating requested files...&#34;)
                        
                        # Update the e-tag textfile with this newly-identified URL e-tag
                        _save_url_etag_to_txt(remote_etag, local_etag_txtfile)

                        # Re-download the file, and process it if need-be.
                        with _pooch.utils.temporary_file(path=str(full_path.parent)) as tmp:
                            downloader = _HTTPDownloader(progressbar=verbose)
                            downloader(url, tmp, _pooch) 
                            _shutil.move(tmp, str(full_path))
                            processor=_determine_processor(url)[0]

                            # If the file to update needs processing, pass the unprocessed file&#39;s
                            # absolute path to the processor
                            if unprocessed_path:
                                processor(str(unprocessed_path), &#34;update&#34;, None)
                            
                        # full_path holds the files to return to the user, irrespective of whether
                        # proceessing was needed
                        if verbose:
                            print(&#34;Requested files downloaded to the GPlately cache folder!&#34;)
                        return(_extract_processed_files(str(full_path)))

                    # If the e-tags are equal, the local and remote files are the same.
                    # Just return the file(s) as-is.
                    else:
                        if verbose:
                            print(&#34;Requested files are up-to-date!&#34;)

                        # If files were processed once, return the processed files.
                        if _determine_processor(url):
                            if str(full_path).endswith(_determine_processor(url)[1]):
                                return(_extract_processed_files((str(full_path))))
                            else:
                                return(_extract_processed_files(
                                    str(full_path)+_determine_processor(url)[1]))
                        # If not, return as-is.
                        else:
                            return(_extract_processed_files(
                                str(full_path)+_match_url_to_extension(url)))

            # If file versioning doesn&#39;t matter, just keep returning the cached files.
            else:
                fnames, etag, local_etag_txtfile = _first_time_download_from_web(url, model_name)
                return(fnames)
                
        # If a connection to the web server could not be made, and the files exist in
        # the GPlately cache, just return the files as-is.
        else:
            print(&#34;No connection to {} established. The requested file(s) (potentially older versions) exist in the GPlately cache ({}) and have been returned.&#34;.format(url, full_path.parent))
            #print(str(full_path)+_determine_processor(url)[1])
            return(_extract_processed_files(
                    str(full_path)))
            # This created zip.unzip.unzip, so i deleted it but not sure if this will affect other files. 
            # return(_extract_processed_files(str(full_path)+_determine_processor(url)[1]))



def _collect_file_extension(fnames, file_extension):
    &#34;&#34;&#34;Searches cached directory for filenames with a specified extension(s).&#34;&#34;&#34;
    sorted_fnames = []
    file_extension=tuple(file_extension)
    for file in fnames:
        if file.endswith(file_extension):
            sorted_fnames.append(file)
    return sorted_fnames


def _str_in_folder(fnames, strings_to_include=None, strings_to_ignore=None):
    fnames_to_ignore = []
    fnames_to_include = []
    sorted_fnames = []
    for i, fname in enumerate(fnames):
        parent_directory = _os.path.dirname(fname)
        if strings_to_ignore is not None:
            for s in strings_to_ignore:
                if s in parent_directory:
                    fnames_to_ignore.append(fname)
            sorted_fnames = list(set(fnames) - set(fnames_to_ignore))

    if strings_to_include is not None:
        for fname in sorted_fnames:
            parent_directory = _os.path.dirname(fname)
            for s in strings_to_include:
                if s in parent_directory:
                    fnames_to_include.append(fname)
        sorted_fnames = list(set(sorted_fnames).intersection(set(fnames_to_include)))
    return sorted_fnames


def _str_in_filename(fnames, strings_to_include=None, strings_to_ignore=None):
    out = []
    def filter_func(fname):
        basename = _os.path.basename(fname)
        keep = False
        if strings_to_include is None:
            keep = True
        else:
            for s in strings_to_include:
                if s.lower() in basename.lower():
                    keep = True
                    break
        if strings_to_ignore is not None:
            for s in strings_to_ignore:
                if s.lower() in basename.lower():
                    keep = False
                    break
        return keep
    return list(filter(filter_func, fnames))


def _check_gpml_or_shp(fnames):
    &#34;&#34;&#34;For topology features, returns GPML by default. Searches for ESRI Shapefiles 
    instead if GPML files not found.&#34;&#34;&#34;
    sorted_fnames = []
    for file in fnames:
        if file.endswith(&#34;.gpml&#34;) or file.endswith(&#34;.gpmlz&#34;):
            sorted_fnames.append(file)
        elif file.endswith(&#34;.shp&#34;):
            sorted_fnames.append(file)
    return sorted_fnames


def _remove_hash(fname):
    &#34;&#34;&#34;Removes hashes (32 character file IDs) from cached filenames.&#34;&#34;&#34;
    split_paths = fname.split(&#34;-&#34;)
    cache_path = split_paths[0][:-32]
    new_path = cache_path + &#34;-&#34;.join(split_paths[1:])
    return new_path


def _order_filenames_by_time(fnames):
    &#34;&#34;&#34;Orders filenames in a list from present day to deeper geological time if they
    are labelled by time.&#34;&#34;&#34;
    # Collect all digits in each filename.
    filepath_digits=[]
    for i, file in enumerate(fnames):
        digits = []
        for element in _re.split(&#39;([0-9]+)&#39;, _remove_hash(file)):
            if element.isdigit():
                digits.append(int(str(element)))
        filepath_digits.append(digits)

    # Ignore digits common to all full file paths. This leaves behind the files&#39; 
    # geological time label.
    geological_times = []
    filepath_digits = _np.array(filepath_digits).T
    for digit_array in filepath_digits:
        if not all(digit == digit_array[0] for digit in digit_array):
            geological_times.append(digit_array)

    # If files have geological time labels, allocate indices to the current filename order, 
    # and sort files from recent to deep geological time.
    if geological_times:
        sorted_geological_times = sorted(
            enumerate(geological_times[0]), 
            key=lambda x: x[1]
        )
        sorted_geological_time_indices = [geo_time[0] for geo_time in sorted_geological_times]
        filenames_sorted = [fnames[index] for index in sorted_geological_time_indices]
    else:
        # If given filenames do not have a time label, return them as is.
        filenames_sorted = fnames
    return filenames_sorted


def _collection_sorter(fnames, string_identifier):
    &#34;&#34;&#34;If multiple file collections or plate reconstruction models are downloaded from
    a single zip folder, only return the needed model. 

    The plate models that need separating are listed.&#34;&#34;&#34;

    needs_sorting = [
        &#34;merdith2021&#34;,
        &#34;scotese2008&#34;,
        &#34;golonka2007&#34;,
        &#34;clennett2020&#34;,
        &#34;johansson2018&#34;,
        &#34;whittaker2015&#34;
    ]
    if string_identifier.lower() in needs_sorting:
        studyname = _re.findall(r&#39;[A-Za-z]+|\d+&#39;, string_identifier)[0]
        newfnames = []
        for files in fnames:
            if studyname not in files:
                continue
            newfnames.append(files)
        return newfnames
    else:
        return fnames


def _match_filetype_to_extension(filetype):
    extensions = []
    if filetype == &#34;netCDF&#34;:
        extensions.append(&#34;.nc&#34;)
    elif filetype == &#34;jpeg&#34;:
        extensions.append(&#34;.jpg&#34;)
    elif filetype == &#34;png&#34;:
        extensions.append(&#34;.png&#34;)
    elif filetype == &#34;TIFF&#34;:
        extensions.append(&#34;.tif&#34;)
    return extensions


def get_raster(raster_id_string=None, verbose=True):
    &#34;&#34;&#34;Downloads assorted raster data that are not associated with the plate 
    reconstruction models supported by GPlately&#39;s `DataServer`. Stores rasters in the 
    &#34;gplately&#34; cache.

    Currently, gplately supports the following rasters and images:

    * __[ETOPO1](https://www.ngdc.noaa.gov/mgg/global/)__: 
        * Filetypes available : TIF, netCDF (GRD)
        * `raster_id_string` = `&#34;ETOPO1_grd&#34;`, `&#34;ETOPO1_tif&#34;` (depending on the requested format)
        * A 1-arc minute global relief model combining lang topography and ocean bathymetry.
        * Citation: doi:10.7289/V5C8276M


    Parameters
    ----------
    raster_id_string : str, default=None
        A string to identify which raster to download.

    Returns
    -------
    raster_filenames : ndarray or MaskedArray
        An ndarray or MaskedArray of the cached raster. This can be plotted using 
        `matplotlib.pyplot.imshow` on a `cartopy.mpl.GeoAxis` GeoAxesSubplot (see example below).

    Raises
    ------
    ValueError
        * if a `raster_id_string` is not supplied.

    Notes
    -----
    Rasters obtained by this method are (so far) only reconstructed to present-day. 

    Examples
    --------
    To download ETOPO1 and plot it on a Mollweide projection:

        import gplately
        import numpy as np
        import matplotlib.pyplot as plt
        import cartopy.crs as ccrs

        gdownload = gplately.DataServer(&#34;Muller2019&#34;)
        etopo1 = gdownload.get_raster(&#34;ETOPO1_tif&#34;)
        fig = plt.figure(figsize=(18,14), dpi=300)
        ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
        ax2.imshow(etopo1, extent=[-180,180,-90,90], transform=ccrs.PlateCarree()) 

    &#34;&#34;&#34;
    from matplotlib import image
    if raster_id_string is None:
        raise ValueError(
            &#34;Please specify which raster to download.&#34;
        )
    #filetype = &#34;.&#34;+&#34;_&#34;.split(raster_id_string)[-1]

    archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
    grid_extensions = tuple([&#34;.grd&#34;, &#34;.nc&#34;])

    # Set to true if we find the given collection in database
    found_collection = False
    raster_filenames = []
    database = _gplately.data._rasters()

    for collection, zip_url in database.items():
        # Isolate the raster name and the file type
        #raster_name = collection.split(&#34;_&#34;)[0]
        #raster_type = &#34;.&#34;+collection.split(&#34;_&#34;)[-1]
        if (raster_id_string.lower() == collection.lower()):
            raster_filenames = download_from_web(zip_url[0], verbose)
            found_collection = True
            break

    if found_collection is False:
        raise ValueError(&#34;{} not in collection database.&#34;.format(raster_id_string))
    else:
        # If the downloaded raster is a grid, process it with the gplately.Raster object
        if any(grid_extension in raster_filenames for grid_extension in grid_extensions):
            raster_matrix = _gplately.grids.Raster(data=raster_filenames).data

        # Otherwise, the raster is an image; use imread to process
        else:
            raster_matrix = image.imread(raster_filenames)
    return raster_matrix


def get_feature_data(feature_data_id_string=None, verbose=True):
    &#34;&#34;&#34;Downloads assorted geological feature data from web servers (i.e. 
    [GPlates 2.3 sample data](https://www.earthbyte.org/gplates-2-3-software-and-data-sets/))
    into the &#34;gplately&#34; cache.

    Currently, gplately supports the following feature data:

    * __Large igneous provinces from Johansson et al. (2018)__

        Information
        -----------
        * Formats: .gpmlz
        * `feature_data_id_string` = `Johansson2018`

        Citations
        ---------
        * Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The 
        interplay between the eruption and weathering of Large Igneous Provinces and 
        the deep-time carbon cycle: Geophysical Research Letters.


    - __Large igneous province products interpreted as plume products from Whittaker 
    et al. (2015)__.

        Information
        -----------
        * Formats: .gpmlz, .shp
        * `feature_data_id_string` = `Whittaker2015`
        
        Citations
        ---------
        * Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D., 
        Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between 
        mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483. 
        doi:10.1038/ngeo2437.


    - __Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures, 
    unclassified V-anomalies, propagating ridge lineations and extinct ridges) from 
    Matthews et al. (2011)__

        Information
        -----------
        * Formats: .gpml
        * `feature_data_id_string` = `SeafloorFabric`

        Citations
        ---------
        * Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The 
        tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12): 
        B12109, DOI: 10.1029/2011JB008413. 


    - __Present day surface hotspot/plume locations from Whittaker et al. (2013)__

        Information
        -----------
        * Formats: .gpmlz
        * `feature_data_id_string` = `Hotspots`

        Citation
        --------
        * Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P., 
        Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and 
        mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.

    
    Parameters
    ----------
    feature_data_id_string : str, default=None
        A string to identify which feature data to download to the cache (see list of supported
        feature data above).

    Returns
    -------
    feature_data_filenames : instance of &lt;pygplates.FeatureCollection&gt;, or list of instance &lt;pygplates.FeatureCollection&gt;
        If a single set of feature data is downloaded, a single pyGPlates `FeatureCollection` 
        object is returned. Otherwise, a list containing multiple pyGPlates `FeatureCollection` 
        objects is returned (like for `SeafloorFabric`). In the latter case, feature reconstruction 
        and plotting may have to be done iteratively.

    Raises
    ------
    ValueError
        If a `feature_data_id_string` is not provided.

    Examples
    --------
    For examples of plotting data downloaded with `get_feature_data`, see GPlately&#39;s sample 
    notebook 05 - Working With Feature Geometries [here](https://github.com/GPlates/gplately/blob/master/Notebooks/05-WorkingWithFeatureGeometries.ipynb).
    &#34;&#34;&#34;
    if feature_data_id_string is None:
        raise ValueError(
            &#34;Please specify which feature data to fetch.&#34;
        )

    database = _gplately.data._feature_data()

    found_collection = False
    for collection, zip_url in database.items():
        if feature_data_id_string.lower() == collection.lower():
            found_collection = True
            feature_data_filenames = _collection_sorter(
                _collect_file_extension(
                download_from_web(zip_url[0], verbose), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                ),
                collection
            )

            break

    if found_collection is False:
        raise ValueError(&#34;{} are not in GPlately&#39;s DataServer.&#34;.format(feature_data_id_string))

    feat_data = _FeatureCollection()
    if len(feature_data_filenames) == 1:
            feat_data.add(_FeatureCollection(feature_data_filenames[0]))
            return feat_data
    else:    
        feat_data=[]
        for file in feature_data_filenames:
            feat_data.append(_FeatureCollection(file))
        return feat_data


class DataServer(object):
    &#34;&#34;&#34;Uses [Pooch](https://www.fatiando.org/pooch/latest/) to download plate reconstruction 
    feature data from plate models and other studies that are stored on web servers 
    (e.g. EarthByte&#39;s [webDAV server](https://www.earthbyte.org/webdav/ftp/Data_Collections/)). 
    
    If the `DataServer` object and its methods are called for the first time, i.e. by:

        # string identifier to access the Muller et al. 2019 model
        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    all requested files are downloaded into the user&#39;s &#39;gplately&#39; cache folder only _once_. If the same
    object and method(s) are re-run, the files will be re-accessed from the cache provided they have not been 
    moved or deleted. 

    Currently, `DataServer` supports a number of plate reconstruction models. To call the object,
    supply a `file_collection` string from one of the following models:

    * __[Müller et al. 2019](https://www.earthbyte.org/muller-et-al-2019-deforming-plate-reconstruction-and-seafloor-age-grids-tectonics/):__ 

        file_collection = `Muller2019`
    
        Information
        -----------
        * Downloadable files: a `rotation_model`, `topology_features`, `static_polygons`, `coastlines`, `continents`, `COBs`, and
        seafloor `age_grids` from 0 to 250 Ma. 
        * Maximum reconstruction time: 250 Ma

        Citations
        ---------
        Müller, R. D., Zahirovic, S., Williams, S. E., Cannon, J., Seton, M., 
        Bower, D. J., Tetley, M. G., Heine, C., Le Breton, E., Liu, S., Russell, S. H. J., 
        Yang, T., Leonard, J., and Gurnis, M. (2019), A global plate model including 
        lithospheric deformation along major rifts and orogens since the Triassic. 
        Tectonics, vol. 38, https://doi.org/10.1029/2018TC005462.
            

    * __Müller et al. 2016__:

        file_collection = `Muller2016`

        Information
        -----------
        * Downloadable files: a `rotation_model`, `topology_features`, `static_polygons`, `coastlines`, and
        seafloor `age_grids` from 0-230 Ma. 
        * Maximum reconstruction time: 230 Ma

        Citations
        ---------
        * Müller R.D., Seton, M., Zahirovic, S., Williams, S.E., Matthews, K.J.,
        Wright, N.M., Shephard, G.E., Maloney, K.T., Barnett-Moore, N., Hosseinpour, M., 
        Bower, D.J., Cannon, J., InPress. Ocean basin evolution and global-scale plate 
        reorganization events since Pangea breakup, Annual Review of Earth and Planetary 
        Sciences, Vol 44, 107-138. DOI: 10.1146/annurev-earth-060115-012211.


    * __[Merdith et al. 2021](https://zenodo.org/record/4485738#.Yhrm8hNBzA0)__: 

        file_collection = `Merdith2021`

        Information
        -----------
        * Downloadable files: a `rotation_model`, `topology_features`, `static_polygons`, `coastlines`
        and `continents`.
        * Maximum reconstruction time: 1 Ga (however, `PlotTopologies` correctly visualises up to 410 Ma) 

        Citations: 
        ----------
        * Merdith et al. (in review), &#39;A continuous, kinematic full-plate motion model
        from 1 Ga to present&#39;. 
        * Andrew Merdith. (2020). Plate model for &#39;Extending Full-Plate Tectonic Models 
        into Deep Time: Linking the Neoproterozoic and the Phanerozoic &#39; (1.1b) [Data set]. 
        Zenodo. https://doi.org/10.5281/zenodo.4485738


    * __Cao et al. 2020__: 

        file_collection = `Cao2020`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `static_polygons`, `coastlines`
        and `continents`.
        * Maximum reconstruction time: 1 Ga

        Citations
        ---------
        * Toy Billion-year reconstructions from Cao et al (2020). 
        Coupled Evolution of Plate Tectonics and Basal Mantle Structure Tectonics, 
        doi: 10.1029/2020GC009244


    - __Clennett et al. 2020__ : 

        file_collection = `Clennett2020`
        
        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `static_polygons`, `coastlines`
        and `continents`
        * Maximum reconstruction time: 170 Ma

        Citations
        ---------
        * Mather, B., Müller, R.D.,; Alfonso, C.P., Seton, M., 2021, Kimberlite eruption 
        driven by slab flux and subduction angle. DOI: 10.5281/zenodo.5769002


    - __Seton et al. 2012__:

        file_collection = `Seton2012`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `coastlines`,
        `COBs`, and paleo-age grids (0-200 Ma)
        * Maximum reconstruction time: 200 Ma

        Citations
        ---------
        * M. Seton, R.D. Müller, S. Zahirovic, C. Gaina, T.H. Torsvik, G. Shephard, A. Talsma, 
        M. Gurnis, M. Turner, S. Maus, M. Chandler, Global continental and ocean basin reconstructions 
        since 200 Ma, Earth-Science Reviews, Volume 113, Issues 3-4, July 2012, Pages 212-270, 
        ISSN 0012-8252, 10.1016/j.earscirev.2012.03.002.


    - __Matthews et al. 2016__: 

        file_collection = `Matthews2016`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `static_polygons`, `coastlines`,
        and `continents`
        * Maximum reconstruction time(s): 410-250 Ma, 250-0 Ma

        Citations
        ---------
        * Matthews, K.J., Maloney, K.T., Zahirovic, S., Williams, S.E., Seton, M.,
        and Müller, R.D. (2016). Global plate boundary evolution and kinematics since the 
        late Paleozoic, Global and Planetary Change, 146, 226-250. 
        DOI: 10.1016/j.gloplacha.2016.10.002


    - __Merdith et al. 2017__: 

        file_collection = `Merdith2017`

        Information
        -----------
        * Downloadable files: `rotation_files` and `topology_features`
        * Maximum reconstruction time: 410 Ma

        Citations
        ---------
        * Merdith, A., Collins, A., Williams, S., Pisarevskiy, S., Foden, J., Archibald, D. 
        and Blades, M. et al. 2016. A full-plate global reconstruction of the Neoproterozoic. 
        Gondwana Research. 50: pp. 84-134. DOI: 10.1016/j.gr.2017.04.001


    - __Li et al. 2008__: 

        file_collection = `Li2008`

        Information
        -----------
        * Downloadable files: `rotation_model` and `static_polygons`
        * Maximum reconstruction time: 410 Ma

        Citations
        ---------
        * Rodinia reconstruction from Li et al (2008), Assembly, configuration, and break-up 
        history of Rodinia: A synthesis. Precambrian Research. 160. 179-210. 
        DOI: 10.1016/j.precamres.2007.04.021.


    - __Pehrsson et al. 2015__: 

        file_collection = `Pehrsson2015`

        Information
        -----------
        * Downloadable files: `rotation_model` and `static_polygons`
        * Maximum reconstruction time: N/A

        Citations
        ---------
        * Pehrsson, S.J., Eglington, B.M., Evans, D.A.D., Huston, D., and Reddy, S.M., (2015),
        Metallogeny and its link to orogenic style during the Nuna supercontinent cycle. Geological 
        Society, London, Special Publications, 424, 83-94. DOI: https://doi.org/10.1144/SP424.5


    - __Torsvik and Cocks et al. 2017__: 

        file_collection = `TorsvikCocks2017`

        Information
        -----------
        * Downloadable files: `rotation_model`, and `coastlines`
        * Maximum reconstruction time: 410 Ma

        Citations
        ---------
        * Torsvik, T., &amp; Cocks, L. (2016). Earth History and Palaeogeography. Cambridge: 
        Cambridge University Press. doi:10.1017/9781316225523


    - __Young et al. 2019__: 

        file_collection = `Young2019`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `static_polygons`, `coastlines`
        and `continents`.
        * Maximum reconstruction time: 410-250 Ma, 250-0 Ma
        
        Citations
        ---------
        * Young, A., Flament, N., Maloney, K., Williams, S., Matthews, K., Zahirovic, S.,
        Müller, R.D., (2019), Global kinematics of tectonic plates and subduction zones since the late 
        Paleozoic Era, Geoscience Frontiers, Volume 10, Issue 3, pp. 989-1013, ISSN 1674-9871,
        DOI: https://doi.org/10.1016/j.gsf.2018.05.011.


    - __Scotese et al. 2008__: 

        file_collection = `Scotese2008`

        Information
        -----------
        * Downloadable files: `rotation_model`, `static_polygons`, and `continents`
        * Maximum reconstruction time: 
        
        Citations
        ---------
        * Scotese, C.R. 2008. The PALEOMAP Project PaleoAtlas for ArcGIS, Volume 2, Cretaceous 
        paleogeographic and plate tectonic reconstructions. PALEOMAP Project, Arlington, Texas.


    - __Golonka et al. 2007__: 

        file_collection = `Golonka2007`

        Information
        -----------
        * Downloadable files: `rotation_model`, `static_polygons`, and `continents`
        * Maximum reconstruction time: 410 Ma
        
        Citations
        ---------
        * Golonka, J. 2007. Late Triassic and Early Jurassic palaeogeography of the world. 
        Palaeogeography, Palaeoclimatology, Palaeoecology 244(1–4), 297–307.


    - __Clennett et al. 2020 (based on Müller et al. 2019)__: 

        file_collection = `Clennett2020_M2019`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `continents` and `coastlines`
        * Maximum reconstruction time: 250 Ma
        
        Citations
        ---------
        * Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
        Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate 
        Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics, 
        Geosystems, 21, e2020GC009117. DOI: https://doi.org/10.1029/2020GC009117


    - __Clennett et al. 2020 (rigid topological model based on Shephard et al, 2013)__: 

        file_collection = `Clennett2020_S2013`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `continents` and `coastlines`
        * Maximum reconstruction time: 
        
        Citations
        ---------
        * Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
        Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate 
        Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics, 
        Geosystems, 21, e2020GC009117. DOI: https://doi.org/10.1029/2020GC009117

        Parameters
        ----------
        file_collection : str
            name of file collection to use

        verbose : bool, default True
            Toggle print messages regarding server/internet connection status, file availability etc.

    &#34;&#34;&#34;
    def __init__(self, file_collection, verbose=True):

        self.file_collection = file_collection.capitalize()
        self.data_collection = DataCollection(self.file_collection)
        self.verbose = verbose


    def get_plate_reconstruction_files(self):
        &#34;&#34;&#34;Downloads and constructs a `rotation model`, a set of `topology_features` and
        and a set of `static_polygons` needed to call the `PlateReconstruction` object.

        Returns
        -------
        rotation_model : instance of &lt;pygplates.RotationModel&gt;
            A rotation model to query equivalent and/or relative topological plate rotations
            from a time in the past relative to another time in the past or to present day.
        topology_features : instance of &lt;pygplates.FeatureCollection&gt;
            Point, polyline and/or polygon feature data that are reconstructable through 
            geological time.
        static_polygons : instance of &lt;pygplates.FeatureCollection&gt;
            Present-day polygons whose shapes do not change through geological time. They are
            used to cookie-cut dynamic polygons into identifiable topological plates (assigned 
            an ID) according to their present-day locations.

        Notes
        -----
        This method accesses the plate reconstruction model ascribed to the `file_collection` string passed 
        into the `DataServer` object. For example, if the object was called with `&#34;Muller2019&#34;`:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)
            rotation_model, topology_features, static_polygons = gDownload.get_plate_reconstruction_files()

        the method will download a `rotation_model`, `topology_features` and `static_polygons` from the 
        Müller et al. (2019) plate reconstruction model. Once the reconstruction objects are returned, 
        they can be passed into:

            model = gplately.reconstruction.PlateReconstruction(rotation_model, topology_features, static_polygons)

        * Note: If the requested plate model does not have a certain file(s), a message will be printed 
        to alert the user. For example, using `get_plate_reconstruction_files()`
        for the Torsvik and Cocks (2017) plate reconstruction model yields the printed message:

                No topology features in TorsvikCocks2017. No FeatureCollection created - unable to 
                plot trenches, ridges and transforms.
                No continent-ocean boundaries in TorsvikCocks2017.

        &#34;&#34;&#34;

        verbose = self.verbose

        rotation_filenames = []
        rotation_model = []
        topology_filenames = []
        topology_features = _FeatureCollection()
        static_polygons= _FeatureCollection()
        static_polygon_filenames = []

        # Locate all plate reconstruction files from GPlately&#39;s DataCollection
        database = DataCollection.plate_reconstruction_files(self)

        # Set to true if we find the given collection in our database
        found_collection = False
        for collection, url in database.items():

            # Only continue if the user&#39;s chosen collection exists in our database
            if self.file_collection.lower() == collection.lower():
                found_collection = True
                if len(url) == 1:
                    fnames = _collection_sorter(
                        download_from_web(url[0], verbose, model_name=self.file_collection), self.file_collection
                    )
                    rotation_filenames = _collect_file_extension(
                        _str_in_folder(
                            _str_in_filename(fnames,
                                strings_to_ignore=DataCollection.rotation_strings_to_ignore(self)
                            ),
                        strings_to_ignore=DataCollection.rotation_strings_to_ignore(self)
                        ),
                        [&#34;.rot&#34;]
                    )
                    #print(rotation_filenames)
                    rotation_model = _RotationModel(rotation_filenames)

                    topology_filenames = _collect_file_extension(
                        _str_in_folder(
                            _str_in_filename(fnames, 
                                strings_to_include=DataCollection.dynamic_polygon_strings_to_include(self),
                                strings_to_ignore=DataCollection.dynamic_polygon_strings_to_ignore(self)
                            ), 
                            strings_to_ignore=DataCollection.dynamic_polygon_strings_to_ignore(self)
                        ),
                        [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                    )
                    #print(topology_filenames)
                    for file in topology_filenames:
                        topology_features.add(_FeatureCollection(file))

                    static_polygon_filenames = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, 
                                strings_to_include=DataCollection.static_polygon_strings_to_include(self),
                                strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                            ),
                            strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                        )
                    )
                    #print(static_polygon_filenames)
                    for stat in static_polygon_filenames:
                        static_polygons.add(_FeatureCollection(stat))

                else:
                    for file in url[0]:
                        rotation_filenames.append(_collect_file_extension(download_from_web(file, verbose, model_name=self.file_collection), [&#34;.rot&#34;]))
                        rotation_model = _RotationModel(rotation_filenames)

                    for file in url[1]:
                        topology_filenames.append(_collect_file_extension(download_from_web(file, verbose, model_name=self.file_collection), [&#34;.gpml&#34;]))
                        for file in topology_filenames:
                            topology_features.add(_FeatureCollection(file))

                    for file in url[2]:
                        static_polygon_filenames.append(
                            _check_gpml_or_shp(
                                _str_in_folder(
                                    _str_in_filename(download_from_web(url[0], verbose, model_name=self.file_collection), 
                                        strings_to_include=DataCollection.static_polygon_strings_to_include(self)
                                    ),    
                                        strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                                )
                            )   
                        )
                        for stat in static_polygon_filenames:
                            static_polygons.add(_FeatureCollection(stat))
                break

        if found_collection is False:
            raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

        if not rotation_filenames:
            print(&#34;No .rot files in {}. No rotation model created.&#34;.format(self.file_collection))
            rotation_model = []
        if not topology_filenames:
            print(&#34;No topology features in {}. No FeatureCollection created - unable to plot trenches, ridges and transforms.&#34;.format(self.file_collection))
            topology_features = []
        if not static_polygons:
            print(&#34;No static polygons in {}.&#34;.format(self.file_collection))
            static_polygons = []

        # add identifier for setting up DownloadServer independently
        rotation_model.reconstruction_identifier = self.file_collection

        return rotation_model, topology_features, static_polygons


    def get_topology_geometries(self):
        &#34;&#34;&#34;Uses Pooch to download coastline, continent and COB (continent-ocean boundary)
        Shapely geometries from the requested plate model. These are needed to call the `PlotTopologies`
        object and visualise topological plates through time.

        Parameters
        ----------
        verbose : bool, default True
            Toggle print messages regarding server/internet connection status, file availability etc.

        Returns
        -------
        coastlines : instance of &lt;pygplates.FeatureCollection&gt;
            Present-day global coastline Shapely polylines cookie-cut using static polygons. Ready for
            reconstruction to a particular geological time and for plotting.

        continents : instance of &lt;pygplates.FeatureCollection&gt;
            Cookie-cutting Shapely polygons for non-oceanic regions (continents, inta-oceanic arcs, etc.)
            ready for reconstruction to a particular geological time and for plotting.

        COBs : instance of &lt;pygplates.FeatureCollection&gt;
            Shapely polylines resolved from .shp and/or .gpml topology files that represent the 
            locations of the boundaries between oceanic and continental crust.
            Ready for reconstruction to a particular geological time and for plotting.

        Notes
        -----
        This method accesses the plate reconstruction model ascribed to the `file_collection` 
        string passed into the `DataServer` object. For example, if the object was called with
        `&#34;Muller2019&#34;`:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)
            coastlines, continents, COBs = gDownload.get_topology_geometries()

        the method will attempt to download `coastlines`, `continents` and `COBs` from the Müller
        et al. (2019) plate reconstruction model. If found, these files are returned as individual 
        pyGPlates Feature Collections. They can be passed into:

            gPlot = gplately.plot.PlotTopologies(gplately.reconstruction.PlateReconstruction, time, continents, coastlines, COBs)

        to reconstruct features to a certain geological time. The `PlotTopologies`
        object provides simple methods to plot these geometries along with trenches, ridges and 
        transforms (see documentation for more info). Note that the `PlateReconstruction` object 
        is a parameter.

        * Note: If the requested plate model does not have a certain geometry, a
        message will be printed to alert the user. For example, if `get_topology_geometries()` 
        is used with the `&#34;Matthews2016&#34;` plate model, the workflow will print the following 
        message: 

                No continent-ocean boundaries in Matthews2016.
        &#34;&#34;&#34;

        verbose = self.verbose

        # Locate all topology geometries from GPlately&#39;s DataCollection
        database = DataCollection.topology_geometries(self)

        coastlines = []
        continents = []
        COBs = []
        
        # Find the requested plate model data collection
        found_collection = False
        for collection, url in database.items():

            if self.file_collection.lower() == collection.lower():
                found_collection = True

                if len(url) == 1:
                    # Some plate models do not have reconstructable geometries i.e. Li et al. 2008
                    if url[0] is None:
                        break
                    else:
                        fnames = _collection_sorter(
                            download_from_web(url[0], verbose, model_name=self.file_collection), self.file_collection
                        )
                        coastlines = _check_gpml_or_shp(
                            _str_in_folder(
                                _str_in_filename(
                                    fnames,
                                    strings_to_include=DataCollection.coastline_strings_to_include(self),
                                    strings_to_ignore=DataCollection.coastline_strings_to_ignore(self)
                                ), 
                                strings_to_ignore=DataCollection.coastline_strings_to_ignore(self)
                            )
                        )
                        continents = _check_gpml_or_shp(
                            _str_in_folder(
                                _str_in_filename(
                                    fnames, 
                                    strings_to_include=DataCollection.continent_strings_to_include(self),
                                    strings_to_ignore=DataCollection.continent_strings_to_ignore(self)
                                ), 
                                strings_to_ignore=DataCollection.continent_strings_to_ignore(self)
                            )
                        )
                        COBs = _check_gpml_or_shp(
                            _str_in_folder(
                                _str_in_filename(
                                    fnames,
                                    strings_to_include=DataCollection.COB_strings_to_include(self),
                                    strings_to_ignore=DataCollection.COB_strings_to_ignore(self)
                                ), 
                                strings_to_ignore=DataCollection.COB_strings_to_ignore(self)
                            )
                        )
                else:
                    for file in url[0]:
                        if url[0] is not None:
                            coastlines.append(_str_in_filename(
                                download_from_web(file, verbose, model_name=self.file_collection), 
                                strings_to_include=[&#34;coastline&#34;])
                            )
                            coastlines = _check_gpml_or_shp(coastlines)
                        else:
                            coastlines = []

                    for file in url[1]:
                        if url[1] is not None:
                            continents.append(_str_in_filename(
                                download_from_web(file, verbose, model_name=self.file_collection), 
                                strings_to_include=[&#34;continent&#34;])
                            )
                            continents = _check_gpml_or_shp(continents)
                        else:
                            continents = []

                    for file in url[2]:
                        if url[2] is not None:
                            COBs.append(_str_in_filename(
                                download_from_web(file, verbose, model_name=self.file_collection), 
                                strings_to_include=[&#34;cob&#34;])
                            )
                            COBs = _check_gpml_or_shp(COBs)
                        else:
                            COBs = []
                break

        if found_collection is False:
            raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

        if not coastlines:
            print(&#34;No coastlines in {}.&#34;.format(self.file_collection))
            coastlines_featurecollection = []
        else:
            #print(coastlines)
            coastlines_featurecollection = _FeatureCollection()
            for coastline in coastlines:
                coastlines_featurecollection.add(_FeatureCollection(coastline))
        
        if not continents:
            print(&#34;No continents in {}.&#34;.format(self.file_collection))
            continents_featurecollection = []
        else:
            #print(continents)
            continents_featurecollection = _FeatureCollection()
            for continent in continents:
                continents_featurecollection.add(_FeatureCollection(continent))
        
        if not COBs:
            print(&#34;No continent-ocean boundaries in {}.&#34;.format(self.file_collection))
            COBs_featurecollection = []
        else:
            #print(COBs)
            COBs_featurecollection = _FeatureCollection()
            for COB in COBs:
                COBs_featurecollection.add(_FeatureCollection(COB))
        
        geometries = coastlines_featurecollection, continents_featurecollection, COBs_featurecollection
        return geometries


    def get_age_grid(self, time):
        &#34;&#34;&#34;Downloads seafloor and paleo-age grids from the plate reconstruction model (`file_collection`)
        passed into the `DataServer` object. Stores grids in the &#34;gplately&#34; cache.

        Currently, `DataServer` supports the following age grids:

        * __Muller et al. 2019__

            * `file_collection` = `Muller2019`
            * Time range: 0-250 Ma
            * Seafloor age grid rasters in netCDF format.

        * __Muller et al. 2016__
            
            * `file_collection` = `Muller2016`
            * Time range: 0-240 Ma
            * Seafloor age grid rasters in netCDF format. 

        * __Seton et al. 2012__

            * `file_collection` = `Seton2012`
            * Time range: 0-200 Ma
            * Paleo-age grid rasters in netCDF format.

        
        Parameters
        ----------
        time : int, or list of int, default=None
            Request an age grid from one (an integer) or multiple reconstruction times (a
            list of integers).

        Returns
        -------
        raster_array : MaskedArray
            A masked array containing the netCDF4 age grid ready for plotting or for
            passing into GPlately&#39;s `Raster` object for raster manipulation.

        Raises
        -----
        ValueError
            If `time` (a single integer, or a list of integers representing reconstruction
            times to extract the age grids from) is not passed.

        Notes
        -----
        The first time that `get_age_grid` is called for a specific time(s), the age grid(s) 
        will be downloaded into the GPlately cache once. Upon successive calls of `get_age_grid`
        for the same reconstruction time(s), the age grids will not be re-downloaded; rather, 
        they are re-accessed from the same cache provided the age grid(s) have not been moved or deleted. 

        Examples
        --------
        if the `DataServer` object was called with the `Muller2019` `file_collection` string:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        `get_age_grid` will download seafloor age grids from the Müller et al. (2019) plate 
        reconstruction model for the geological time(s) requested in the `time` parameter. 
        If found, these age grids are returned as masked arrays. 

        For example, to download  Müller et al. (2019) seafloor age grids for 0Ma, 1Ma and
        100 Ma:

            age_grids = gDownload.get_age_grid([0, 1, 100])
            
        &#34;&#34;&#34;
        age_grids = []
        age_grid_links = DataCollection.netcdf4_age_grids(self, time)

        if not isinstance(time, list):
            time = [time]

        # For a single time passed that isn&#39;t in the valid time range, 
        if not age_grid_links:
            raise ValueError(
                &#34;{} {}Ma age grids are not on GPlately&#39;s DataServer.&#34;.format(
                    self.file_collection, 
                    time[0]
                )
            )

        # For a list of times passed...
        for i, link in enumerate(age_grid_links):
            if not link:
                raise ValueError(
                    &#34;{} {}Ma age grids are not on GPlately&#39;s DataServer.&#34;.format(
                        self.file_collection,
                        time[i]
                    )
                )
            age_grid_file = download_from_web(
                link, 
                verbose=self.verbose, 
                model_name=self.file_collection
            )
            age_grid = _gplately.grids.read_netcdf_grid(age_grid_file)
            age_grids.append(age_grid)

        # One last check to alert user if the masked array grids were not processed properly
        if not age_grids:
            raise ValueError(&#34;{} netCDF4 age grids not found.&#34;.format(self.file_collection))

        if len(age_grids) == 1:
            return age_grids[0]
        else: 
            return age_grids


    def get_spreading_rate_grid(self, time):
        &#34;&#34;&#34;Downloads seafloor spreading rate grids from the plate reconstruction 
        model (`file_collection`) passed into the `DataServer` object. Stores 
        grids in the &#34;gplately&#34; cache.

        Currently, `DataServer` supports spreading rate grids from the following plate
        models:

        * __Clennett et al. 2020__

            * `file_collection` = `Clennett2020`
            * Time range: 0-250 Ma
            * Seafloor spreading rate grids in netCDF format.

        
        Parameters
        ----------
        time : int, or list of int, default=None
            Request a spreading grid from one (an integer) or multiple reconstruction 
            times (a list of integers).

        Returns
        -------
        raster_array : MaskedArray
            A masked array containing the netCDF4 spreading rate grid ready for 
            plotting or for passing into GPlately&#39;s `Raster` object.

        Raises
        -----
        ValueError
            If `time` (a single integer, or a list of integers representing reconstruction
            times to extract the spreading rate grids from) is not passed.

        Notes
        -----
        The first time that `get_spreading_rate_grid` is called for a specific time(s), 
        the spreading rate grid(s) will be downloaded into the GPlately cache once. 
        Upon successive calls of `get_spreading_rate_grid` for the same reconstruction 
        time(s), the grids will not be re-downloaded; rather, they are re-accessed from 
        the same cache location provided they have not been moved or deleted. 

        Examples
        --------
        if the `DataServer` object was called with the `Clennett2020` `file_collection` string:

            gDownload = gplately.download.DataServer(&#34;Clennett2020&#34;)

        `get_spreading_rate_grid` will download seafloor spreading rate grids from the 
        Clennett et al. (2020) plate reconstruction model for the geological time(s) 
        requested in the `time` parameter. When found, these spreading rate grids are 
        returned as masked arrays. 

        For example, to download Clennett et al. (2020) seafloor spreading rate grids for 
        0Ma, 1Ma and 100 Ma as MaskedArray objects:

            spreading_rate_grids = gDownload.get_spreading_rate_grid([0, 1, 100])
            
        &#34;&#34;&#34;
        spreading_rate_grids = []
        spreading_rate_grid_links = DataCollection.netcdf4_spreading_rate_grids(self, time)

        if not isinstance(time, list):
            time = [time]

        # For a single time passed that isn&#39;t in the valid time range, 
        if not spreading_rate_grid_links:
            raise ValueError(
                &#34;{} {}Ma spreading rate grids are not on GPlately&#39;s DataServer.&#34;.format(
                    self.file_collection,
                    time[0]
                )
            )
        # For a list of times passed...
        for i, link in enumerate(spreading_rate_grid_links):
            if not link:
                raise ValueError(
                    &#34;{} {}Ma spreading rate grids are not on GPlately&#39;s DataServer.&#34;.format(
                        self.file_collection,
                        time[i]
                    )
                )
            spreading_rate_grid_file = download_from_web(
                link, 
                verbose=self.verbose, 
                model_name=self.file_collection
            )
            spreading_rate_grid = _gplately.grids.read_netcdf_grid(spreading_rate_grid_file)
            spreading_rate_grids.append(spreading_rate_grid)

        # One last check to alert user if the masked array grids were not processed properly
        if not spreading_rate_grids:
            raise ValueError(&#34;{} netCDF4 seafloor spreading rate grids not found.&#34;.format(self.file_collection))

        if len(spreading_rate_grids) == 1:
            return spreading_rate_grids[0]
        else: 
            return spreading_rate_grids


    def get_valid_times(self):
        &#34;&#34;&#34;Returns a tuple of the valid plate model time range, (min_time, max_time).
        &#34;&#34;&#34;
        all_model_valid_times = DataCollection.plate_model_valid_reconstruction_times(self)

        min_time = None
        max_time = None
        for plate_model_name, valid_times in list(all_model_valid_times.items()):
            if plate_model_name.lower() == self.file_collection.lower():
                min_time = valid_times[0]
                max_time = valid_times[1]
        if not min_time and not max_time:
            raise ValueError(&#34;Could not find the valid reconstruction time of {}&#34;.format(self.file_collection))

        return (min_time, max_time)


    def get_raster(self, raster_id_string=None):
        &#34;&#34;&#34;Downloads assorted raster data that are not associated with the plate 
        reconstruction models supported by GPlately&#39;s `DataServer`. Stores rasters in the 
        &#34;gplately&#34; cache.

        Currently, `DataServer` supports the following rasters and images:

        * __[ETOPO1](https://www.ngdc.noaa.gov/mgg/global/)__: 
            * Filetypes available : TIF, netCDF (GRD)
            * `raster_id_string` = `&#34;ETOPO1_grd&#34;`, `&#34;ETOPO1_tif&#34;` (depending on the requested format)
            * A 1-arc minute global relief model combining lang topography and ocean bathymetry.
            * Citation: doi:10.7289/V5C8276M


        Parameters
        ----------
        raster_id_string : str, default=None
            A string to identify which raster to download.

        Returns
        -------
        raster_filenames : ndarray or MaskedArray
            An ndarray or MaskedArray of the cached raster. This can be plotted using 
            `matplotlib.pyplot.imshow` on a `cartopy.mpl.GeoAxis` GeoAxesSubplot (see example below).

        Raises
        ------
        ValueError
            * if a `raster_id_string` is not supplied.

        Notes
        -----
        Rasters obtained by this method are (so far) only reconstructed to present-day. 

        Examples
        --------
        To download ETOPO1 and plot it on a Mollweide projection:

            import gplately
            import numpy as np
            import matplotlib.pyplot as plt
            import cartopy.crs as ccrs

            gdownload = gplately.DataServer(&#34;Muller2019&#34;)
            etopo1 = gdownload.get_raster(&#34;ETOPO1_tif&#34;)
            fig = plt.figure(figsize=(18,14), dpi=300)
            ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
            ax2.imshow(etopo1, extent=[-180,180,-90,90], transform=ccrs.PlateCarree()) 

        &#34;&#34;&#34;
        from matplotlib import image
        if raster_id_string is None:
            raise ValueError(
                &#34;Please specify which raster to download.&#34;
            )
        #filetype = &#34;.&#34;+&#34;_&#34;.split(raster_id_string)[-1]

        archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
        grid_extensions = tuple([&#34;.grd&#34;, &#34;.nc&#34;])

        # Set to true if we find the given collection in database
        found_collection = False
        raster_filenames = []
        database = _gplately.data._rasters()

        for collection, zip_url in database.items():
            # Isolate the raster name and the file type
            #raster_name = collection.split(&#34;_&#34;)[0]
            #raster_type = &#34;.&#34;+collection.split(&#34;_&#34;)[-1]
            if (raster_id_string.lower() == collection.lower()):
                raster_filenames = download_from_web(zip_url[0], self.verbose)
                found_collection = True
                break

        if found_collection is False:
            raise ValueError(&#34;{} not in collection database.&#34;.format(raster_id_string))
        else:
            # If the downloaded raster is a grid, process it with the gplately.Raster object
            if any(grid_extension in raster_filenames for grid_extension in grid_extensions):
                raster_matrix = _gplately.grids.Raster(data=raster_filenames).data

            # Otherwise, the raster is an image; use imread to process
            else:
                raster_matrix = image.imread(raster_filenames)
        return raster_matrix


    def get_feature_data(self, feature_data_id_string=None):
        &#34;&#34;&#34;Downloads assorted geological feature data from web servers (i.e. 
        [GPlates 2.3 sample data](https://www.earthbyte.org/gplates-2-3-software-and-data-sets/))
        into the &#34;gplately&#34; cache.

        Currently, `DataServer` supports the following feature data:

        * __Large igneous provinces from Johansson et al. (2018)__

            Information
            -----------
            * Formats: .gpmlz
            * `feature_data_id_string` = `Johansson2018`

            Citations
            ---------
            * Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The 
            interplay between the eruption and weathering of Large Igneous Provinces and 
            the deep-time carbon cycle: Geophysical Research Letters.


        - __Large igneous province products interpreted as plume products from Whittaker 
        et al. (2015)__.

            Information
            -----------
            * Formats: .gpmlz, .shp
            * `feature_data_id_string` = `Whittaker2015`
            
            Citations
            ---------
            * Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D., 
            Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between 
            mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483. 
            doi:10.1038/ngeo2437.


        - __Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures, 
        unclassified V-anomalies, propagating ridge lineations and extinct ridges) from 
        Matthews et al. (2011)__

            Information
            -----------
            * Formats: .gpml
            * `feature_data_id_string` = `SeafloorFabric`

            Citations
            ---------
            * Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The 
            tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12): 
            B12109, DOI: 10.1029/2011JB008413. 


        - __Present day surface hotspot/plume locations from Whittaker et al. (2013)__

            Information
            -----------
            * Formats: .gpmlz
            * `feature_data_id_string` = `Hotspots`

            Citation
            --------
            * Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P., 
            Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and 
            mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.

        
        Parameters
        ----------
        feature_data_id_string : str, default=None
            A string to identify which feature data to download to the cache (see list of supported
            feature data above).

        Returns
        -------
        feature_data_filenames : instance of &lt;pygplates.FeatureCollection&gt;, or list of instance &lt;pygplates.FeatureCollection&gt;
            If a single set of feature data is downloaded, a single pyGPlates `FeatureCollection` 
            object is returned. Otherwise, a list containing multiple pyGPlates `FeatureCollection` 
            objects is returned (like for `SeafloorFabric`). In the latter case, feature reconstruction 
            and plotting may have to be done iteratively.

        Raises
        ------
        ValueError
            If a `feature_data_id_string` is not provided.

        Examples
        --------
        For examples of plotting data downloaded with `get_feature_data`, see GPlately&#39;s sample 
        notebook 05 - Working With Feature Geometries [here](https://github.com/GPlates/gplately/blob/master/Notebooks/05-WorkingWithFeatureGeometries.ipynb).
        &#34;&#34;&#34;
        if feature_data_id_string is None:
            raise ValueError(
                &#34;Please specify which feature data to fetch.&#34;
            )

        database = _gplately.data._feature_data()

        found_collection = False
        for collection, zip_url in database.items():
            if feature_data_id_string.lower() == collection.lower():
                found_collection = True
                feature_data_filenames = _collection_sorter(
                    _collect_file_extension(
                    download_from_web(zip_url[0], self.verbose), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                    ),
                    collection
                )

                break

        if found_collection is False:
            raise ValueError(&#34;{} are not in GPlately&#39;s DataServer.&#34;.format(feature_data_id_string))

        feat_data = _FeatureCollection()
        if len(feature_data_filenames) == 1:
                feat_data.add(_FeatureCollection(feature_data_filenames[0]))
                return feat_data
        else:    
            feat_data=[]
            for file in feature_data_filenames:
                feat_data.append(_FeatureCollection(file))
            return feat_data
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gplately.download.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Caution - when called, this clears the entire gplately cache.
This action cannot be undone.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache():
    &#34;&#34;&#34;Caution - when called, this clears the entire gplately cache. 
    This action cannot be undone.&#34;&#34;&#34;
    cache_path = path_to_cache()
    _shutil.rmtree(str(cache_path))
    _pooch.utils.make_local_storage(str(cache_path))
    return</code></pre>
</details>
</dd>
<dt id="gplately.download.download_from_web"><code class="name flex">
<span>def <span class="ident">download_from_web</span></span>(<span>url, verbose=True, download_changes=True, model_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Download a file from a <code>url</code> into the <code><a title="gplately" href="index.html">gplately</a></code> cache.</p>
<h2 id="notes">Notes</h2>
<p>After the file belonging to the given <code>url</code> is downloaded
to the <code><a title="gplately" href="index.html">gplately</a></code> cache once, subsequent runs of
<code><a title="gplately.download.download_from_web" href="#gplately.download.download_from_web">download_from_web()</a></code> with this <code>url</code> will not redownload
the file as long as:</p>
<ul>
<li>The file has not been updated on the web server,</li>
<li>The file has not been removed from the <code><a title="gplately" href="index.html">gplately</a></code> cache.</li>
</ul>
<p>Instead, the file will be re-accessed from the <code><a title="gplately" href="index.html">gplately</a></code>
cache it was downloaded to. </p>
<p>However, if the file has been updated on the web server,
<code><a title="gplately.download.download_from_web" href="#gplately.download.download_from_web">download_from_web()</a></code> overwrites the cached file with the
updated version. The following messages will be displayed
to the user:</p>
<pre><code>"Checking whether the requested files need to be updated..."
"Yes - updating requested files..."
"Requested files downloaded to the GPlately cache folder!"
</code></pre>
<p>If ever a connection to the web server (and the file(s)) in
<code>url</code> is unsuccessful, this is likely because:</p>
<ul>
<li>An internet connection could not be established; or</li>
<li>The <code>url</code> passed to <code><a title="gplately.download.download_from_web" href="#gplately.download.download_from_web">download_from_web()</a></code> is incorrect</li>
</ul>
<p>In either case, <code><a title="gplately.download.download_from_web" href="#gplately.download.download_from_web">download_from_web()</a></code> attempts to find a version
of the requested file(s) in <code>url</code> already stored in the
<code><a title="gplately" href="index.html">gplately</a></code> cache (assuming it has been downloaded from the same
<code>url</code> once before). This version may not match the one on the web
server. If a copy of the file(s) cannot be found in the <code><a title="gplately" href="index.html">gplately</a></code>
cache, a <code>ConnectionError</code> is raised.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The full URL used to download a file from a public web server
like webDAV.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Choose whether to print user alerts regarding file availability,
data server/internet connection status etc.</dd>
<dt><strong><code>download_changes</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Permit the re-downloading/update of the file from <code>url</code> if
it has been updated on the web server since the last download.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fnames</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of strings representing the full paths to all cached data
downloaded from the given <code>url</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConnectionError</code></dt>
<dd>If a connection to the web server and file(s) in the given <code>url</code> is
unsuccessful (because there is no internet access, and/or the <code>url</code>
is incorrect) and no version of the requested file(s) have been
cached before. In this case, nothing is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_from_web(url, verbose=True, download_changes=True, model_name=None):
    &#34;&#34;&#34;Download a file from a `url` into the `gplately` cache.
    
    Notes
    -----
    After the file belonging to the given `url` is downloaded 
    to the `gplately` cache once, subsequent runs of 
    `download_from_web` with this `url` will not redownload 
    the file as long as:
    
    * The file has not been updated on the web server,
    * The file has not been removed from the `gplately` cache.
    
    Instead, the file will be re-accessed from the `gplately` 
    cache it was downloaded to. 
    
    However, if the file has been updated on the web server,
    `download_from_web` overwrites the cached file with the 
    updated version. The following messages will be displayed 
    to the user:
    
        &#34;Checking whether the requested files need to be updated...&#34;
        &#34;Yes - updating requested files...&#34;
        &#34;Requested files downloaded to the GPlately cache folder!&#34;
    
    If ever a connection to the web server (and the file(s)) in 
    `url` is unsuccessful, this is likely because:

    * An internet connection could not be established; or
    * The `url` passed to `download_from_web` is incorrect

    In either case, `download_from_web` attempts to find a version 
    of the requested file(s) in `url` already stored in the 
    `gplately` cache (assuming it has been downloaded from the same 
    `url` once before). This version may not match the one on the web
    server. If a copy of the file(s) cannot be found in the `gplately`
    cache, a `ConnectionError` is raised.
    
    Parameters
    ----------
    url : str
        The full URL used to download a file from a public web server
        like webDAV.
    verbose : bool
        Choose whether to print user alerts regarding file availability,
        data server/internet connection status etc. 
    download_changes : bool, default=True
        Permit the re-downloading/update of the file from `url` if 
        it has been updated on the web server since the last download.
        
    Returns
    -------
    fnames : list of str
        A list of strings representing the full paths to all cached data
        downloaded from the given `url`.

    Raises
    ------
    ConnectionError
        If a connection to the web server and file(s) in the given `url` is
        unsuccessful (because there is no internet access, and/or the `url`
        is incorrect) and no version of the requested file(s) have been
        cached before. In this case, nothing is returned. 
    &#34;&#34;&#34;


    #   NOTE: We need a way to verify the existence of requested file(s) in the gplately
    #   cache to determine whether a file needs to be installed, updated, or re-accessed 
    #   from the cache. Every time a file is installed for the first time,
    #   DataServer creates a directory called `full_path`. Its existence verifies the 
    #   existence
    #
    #   The nature of `full_path` is dependent on the file-type:
    #
    #   .zip files will be downloaded and expanded in an inside folder:
    #   
    #   /path/to/cache/gplately/fname.zip.unzip/
    #
    #   Thus, for zips, `full_path` is a directory that ends in &#34;.zip.unzip&#34;:
    #
    #   For example: /Users/laurenilano/Library/Caches/gplately/Muller2019.zip.unzip/

    #   Other types of files that need processing, like .gz --&gt; .decomp, aren&#39;t
    #   expanded in an internal folder. This is also the case for files that do not 
    #   need processing, e.g. &#34;.nc&#34; files. In these cases, `full_path` is the exact
    #   directory that the cached file is saved to.
    # 
    #
    #   For example: /Users/laurenilano/Library/Caches/gplately/Muller_etal_2019_Tectonics_v2.0_AgeGrid-100.nc
    #
    #   `full_path` is an empty directory for non-zips, and is the parent directory of
    #   unzipped contents in &#34;.zip&#34; URLs. 
    #
    #   Why do we need `full_path`?
    #   We search the top-level gplately cache directory for the `full_path` directory as it is
    #   installed with the requested files. Its existence verifies the
    #   existence of the requested file(s), and thus to decide whether to install the
    #   files or re-access existing cached versions. This also helps with E-Tag versioning
    #   in instances where the download URL remains the same but its contents may have changed
    #   since the file(s) were last cached. 
    
    full_path, unprocessed_path = path_of_cached_file(url, model_name)

    # If the file required processing (zips make a directory to unzip in, and .gz for example
    # makes a file just saved to the top-level directory), and the directory or file is not 
    # yet on the cache,
    if _determine_processor(url)[1] and not (
        _os.path.isdir(str(full_path)) or _os.path.isfile(str(full_path))
        ):

        # ...and if a connection to the web server can be established,
        # download files from the URL and create a textfile for this URL&#39;s E-Tag
        if _test_internet_connection(url):
            fnames, etag, textfilename, used_fname = _first_time_download_from_web(
                url, 
                model_name=model_name,
                verbose=verbose
            )
            if verbose:
                print(&#34;Requested files downloaded to the GPlately cache folder!&#34;)
            return(fnames)
    
        # ... if a connection to the web server cannot be established
        else:
            raise ConnectionError(
                    &#34;A connection to {} could not be made. Please check your internet connection and/or ensure the URL is correct. No file from the given URL has been cached to {} yet - nothing has been returned.&#34;.format(url, full_path.parent))


    # If the file does not require processing, it did not open up a directory, so check isfile,
    # and if the file is not yet on the cache,
    elif not _determine_processor(url)[1] and not _os.path.isfile(str(full_path)):
        # ...and if a connection to the web server can be established,
        # download files from the URL and create a textfile for this URL&#39;s E-Tag
        if _test_internet_connection(url):
            fnames, etag, textfilename, used_fname = _first_time_download_from_web(
                url, 
                model_name=model_name,
                verbose=verbose
            )
            if verbose:
                print(&#34;Requested files downloaded to the GPlately cache folder!&#34;)
            return(fnames)
    
        # ... if a connection to the web server cannot be established
        else:
            raise ConnectionError(
                    &#34;A connection to {} could not be made. Please check your internet connection and/or ensure the URL is correct. No file from the given URL has been cached to {} yet - nothing has been returned.&#34;.format(url, full_path.parent))


    # If the files have been downloaded before...
    else:
        #... and if a connection to the web server can be made...
        if _test_internet_connection(url):
            
            _, local_etag_txtfile = _get_url_etag(url)

            # If the newest version of the files in `url` must be cached 
            # at all times, perform E-Tag comparisons:
            if download_changes:

                # Walk through the top-level cache directory to find an E-Tag textfile unique to the URL
                etag_exists = False

                cache_path = str(path_to_cache())
                if _os.path.isfile(local_etag_txtfile):
                    etag_exists = True

                # If an e-tag text file does not exist, erase the cached files
                # and download the latest version from the web server. This, in turn,
                # creates an e-tag textfile for this version.
                if not etag_exists:
                    _shutil.rmtree(str(full_path))
                    fnames, etag, local_etag_txtfile, used_fname = _first_time_download_from_web(
                        url, 
                        model_name=model_name,
                        verbose=verbose
                    )
                    return(fnames)

                # If the e-tag textfile exists for the local files,
                else: 
                    if verbose:
                        print(&#34;Checking whether the requested files need to be updated...&#34;)

                    # Determine the local file&#39;s URL e-tag from the textfile
                    with open(local_etag_txtfile) as f:
                        local_etag = str(f.readlines()[0])

                    # Get the e-tag of the web server URL at current time
                    remote_etag, remote_etag_textfile = _get_url_etag(url)

                    # If the local and remote e-tags are unequal, the web-server URL 
                    # contains an updated version of the cached files.
                    if str(remote_etag) != str(local_etag):
                        if verbose:
                            print(&#34;Yes - updating requested files...&#34;)
                        
                        # Update the e-tag textfile with this newly-identified URL e-tag
                        _save_url_etag_to_txt(remote_etag, local_etag_txtfile)

                        # Re-download the file, and process it if need-be.
                        with _pooch.utils.temporary_file(path=str(full_path.parent)) as tmp:
                            downloader = _HTTPDownloader(progressbar=verbose)
                            downloader(url, tmp, _pooch) 
                            _shutil.move(tmp, str(full_path))
                            processor=_determine_processor(url)[0]

                            # If the file to update needs processing, pass the unprocessed file&#39;s
                            # absolute path to the processor
                            if unprocessed_path:
                                processor(str(unprocessed_path), &#34;update&#34;, None)
                            
                        # full_path holds the files to return to the user, irrespective of whether
                        # proceessing was needed
                        if verbose:
                            print(&#34;Requested files downloaded to the GPlately cache folder!&#34;)
                        return(_extract_processed_files(str(full_path)))

                    # If the e-tags are equal, the local and remote files are the same.
                    # Just return the file(s) as-is.
                    else:
                        if verbose:
                            print(&#34;Requested files are up-to-date!&#34;)

                        # If files were processed once, return the processed files.
                        if _determine_processor(url):
                            if str(full_path).endswith(_determine_processor(url)[1]):
                                return(_extract_processed_files((str(full_path))))
                            else:
                                return(_extract_processed_files(
                                    str(full_path)+_determine_processor(url)[1]))
                        # If not, return as-is.
                        else:
                            return(_extract_processed_files(
                                str(full_path)+_match_url_to_extension(url)))

            # If file versioning doesn&#39;t matter, just keep returning the cached files.
            else:
                fnames, etag, local_etag_txtfile = _first_time_download_from_web(url, model_name)
                return(fnames)
                
        # If a connection to the web server could not be made, and the files exist in
        # the GPlately cache, just return the files as-is.
        else:
            print(&#34;No connection to {} established. The requested file(s) (potentially older versions) exist in the GPlately cache ({}) and have been returned.&#34;.format(url, full_path.parent))
            #print(str(full_path)+_determine_processor(url)[1])
            return(_extract_processed_files(
                    str(full_path)))
            # This created zip.unzip.unzip, so i deleted it but not sure if this will affect other files. 
            # return(_extract_processed_files(str(full_path)+_determine_processor(url)[1]))</code></pre>
</details>
</dd>
<dt id="gplately.download.get_feature_data"><code class="name flex">
<span>def <span class="ident">get_feature_data</span></span>(<span>feature_data_id_string=None, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads assorted geological feature data from web servers (i.e.
<a href="https://www.earthbyte.org/gplates-2-3-software-and-data-sets/">GPlates 2.3 sample data</a>)
into the "gplately" cache.</p>
<p>Currently, gplately supports the following feature data:</p>
<ul>
<li>
<p><strong>Large igneous provinces from Johansson et al. (2018)</strong></p>
<h2 id="information">Information</h2>
<ul>
<li>Formats: .gpmlz</li>
<li><code>feature_data_id_string</code> = <code>Johansson2018</code></li>
</ul>
<h2 id="citations">Citations</h2>
<ul>
<li>Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The
interplay between the eruption and weathering of Large Igneous Provinces and
the deep-time carbon cycle: Geophysical Research Letters.</li>
</ul>
</li>
<li>
<p><strong>Large igneous province products interpreted as plume products from Whittaker
et al. (2015)</strong>.</p>
<h2 id="information_1">Information</h2>
<ul>
<li>Formats: .gpmlz, .shp</li>
<li><code>feature_data_id_string</code> = <code>Whittaker2015</code></li>
</ul>
<h2 id="citations_1">Citations</h2>
<ul>
<li>Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D.,
Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between
mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483.
doi:10.1038/ngeo2437.</li>
</ul>
</li>
<li>
<p><strong>Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures,
unclassified V-anomalies, propagating ridge lineations and extinct ridges) from
Matthews et al. (2011)</strong></p>
<h2 id="information_2">Information</h2>
<ul>
<li>Formats: .gpml</li>
<li><code>feature_data_id_string</code> = <code>SeafloorFabric</code></li>
</ul>
<h2 id="citations_2">Citations</h2>
<ul>
<li>Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The
tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12):
B12109, DOI: 10.1029/2011JB008413. </li>
</ul>
</li>
<li>
<p><strong>Present day surface hotspot/plume locations from Whittaker et al. (2013)</strong></p>
<h2 id="information_3">Information</h2>
<ul>
<li>Formats: .gpmlz</li>
<li><code>feature_data_id_string</code> = <code>Hotspots</code></li>
</ul>
<h2 id="citation">Citation</h2>
<ul>
<li>Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P.,
Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and
mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.</li>
</ul>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_data_id_string</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>A string to identify which feature data to download to the cache (see list of supported
feature data above).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>feature_data_filenames</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;,</code> or <code>list</code> of <code>instance &lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>If a single set of feature data is downloaded, a single pyGPlates <code>FeatureCollection</code>
object is returned. Otherwise, a list containing multiple pyGPlates <code>FeatureCollection</code>
objects is returned (like for <code>SeafloorFabric</code>). In the latter case, feature reconstruction
and plotting may have to be done iteratively.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a <code>feature_data_id_string</code> is not provided.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>For examples of plotting data downloaded with <code><a title="gplately.download.get_feature_data" href="#gplately.download.get_feature_data">get_feature_data()</a></code>, see GPlately's sample
notebook 05 - Working With Feature Geometries <a href="https://github.com/GPlates/gplately/blob/master/Notebooks/05-WorkingWithFeatureGeometries.ipynb">here</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_feature_data(feature_data_id_string=None, verbose=True):
    &#34;&#34;&#34;Downloads assorted geological feature data from web servers (i.e. 
    [GPlates 2.3 sample data](https://www.earthbyte.org/gplates-2-3-software-and-data-sets/))
    into the &#34;gplately&#34; cache.

    Currently, gplately supports the following feature data:

    * __Large igneous provinces from Johansson et al. (2018)__

        Information
        -----------
        * Formats: .gpmlz
        * `feature_data_id_string` = `Johansson2018`

        Citations
        ---------
        * Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The 
        interplay between the eruption and weathering of Large Igneous Provinces and 
        the deep-time carbon cycle: Geophysical Research Letters.


    - __Large igneous province products interpreted as plume products from Whittaker 
    et al. (2015)__.

        Information
        -----------
        * Formats: .gpmlz, .shp
        * `feature_data_id_string` = `Whittaker2015`
        
        Citations
        ---------
        * Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D., 
        Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between 
        mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483. 
        doi:10.1038/ngeo2437.


    - __Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures, 
    unclassified V-anomalies, propagating ridge lineations and extinct ridges) from 
    Matthews et al. (2011)__

        Information
        -----------
        * Formats: .gpml
        * `feature_data_id_string` = `SeafloorFabric`

        Citations
        ---------
        * Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The 
        tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12): 
        B12109, DOI: 10.1029/2011JB008413. 


    - __Present day surface hotspot/plume locations from Whittaker et al. (2013)__

        Information
        -----------
        * Formats: .gpmlz
        * `feature_data_id_string` = `Hotspots`

        Citation
        --------
        * Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P., 
        Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and 
        mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.

    
    Parameters
    ----------
    feature_data_id_string : str, default=None
        A string to identify which feature data to download to the cache (see list of supported
        feature data above).

    Returns
    -------
    feature_data_filenames : instance of &lt;pygplates.FeatureCollection&gt;, or list of instance &lt;pygplates.FeatureCollection&gt;
        If a single set of feature data is downloaded, a single pyGPlates `FeatureCollection` 
        object is returned. Otherwise, a list containing multiple pyGPlates `FeatureCollection` 
        objects is returned (like for `SeafloorFabric`). In the latter case, feature reconstruction 
        and plotting may have to be done iteratively.

    Raises
    ------
    ValueError
        If a `feature_data_id_string` is not provided.

    Examples
    --------
    For examples of plotting data downloaded with `get_feature_data`, see GPlately&#39;s sample 
    notebook 05 - Working With Feature Geometries [here](https://github.com/GPlates/gplately/blob/master/Notebooks/05-WorkingWithFeatureGeometries.ipynb).
    &#34;&#34;&#34;
    if feature_data_id_string is None:
        raise ValueError(
            &#34;Please specify which feature data to fetch.&#34;
        )

    database = _gplately.data._feature_data()

    found_collection = False
    for collection, zip_url in database.items():
        if feature_data_id_string.lower() == collection.lower():
            found_collection = True
            feature_data_filenames = _collection_sorter(
                _collect_file_extension(
                download_from_web(zip_url[0], verbose), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                ),
                collection
            )

            break

    if found_collection is False:
        raise ValueError(&#34;{} are not in GPlately&#39;s DataServer.&#34;.format(feature_data_id_string))

    feat_data = _FeatureCollection()
    if len(feature_data_filenames) == 1:
            feat_data.add(_FeatureCollection(feature_data_filenames[0]))
            return feat_data
    else:    
        feat_data=[]
        for file in feature_data_filenames:
            feat_data.append(_FeatureCollection(file))
        return feat_data</code></pre>
</details>
</dd>
<dt id="gplately.download.get_raster"><code class="name flex">
<span>def <span class="ident">get_raster</span></span>(<span>raster_id_string=None, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads assorted raster data that are not associated with the plate
reconstruction models supported by GPlately's <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code>. Stores rasters in the
"gplately" cache.</p>
<p>Currently, gplately supports the following rasters and images:</p>
<ul>
<li><strong><a href="https://www.ngdc.noaa.gov/mgg/global/">ETOPO1</a></strong>: <ul>
<li>Filetypes available : TIF, netCDF (GRD)</li>
<li><code>raster_id_string</code> = <code>"ETOPO1_grd"</code>, <code>"ETOPO1_tif"</code> (depending on the requested format)</li>
<li>A 1-arc minute global relief model combining lang topography and ocean bathymetry.</li>
<li>Citation: doi:10.7289/V5C8276M</li>
</ul>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>raster_id_string</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>A string to identify which raster to download.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>raster_filenames</code></strong> :&ensp;<code>ndarray</code> or <code>MaskedArray</code></dt>
<dd>An ndarray or MaskedArray of the cached raster. This can be plotted using
<code>matplotlib.pyplot.imshow</code> on a <code>cartopy.mpl.GeoAxis</code> GeoAxesSubplot (see example below).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>
<ul>
<li>if a <code>raster_id_string</code> is not supplied.</li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Rasters obtained by this method are (so far) only reconstructed to present-day. </p>
<h2 id="examples">Examples</h2>
<p>To download ETOPO1 and plot it on a Mollweide projection:</p>
<pre><code>import gplately
import numpy as np
import matplotlib.pyplot as plt
import cartopy.crs as ccrs

gdownload = gplately.DataServer("Muller2019")
etopo1 = gdownload.get_raster("ETOPO1_tif")
fig = plt.figure(figsize=(18,14), dpi=300)
ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
ax2.imshow(etopo1, extent=[-180,180,-90,90], transform=ccrs.PlateCarree())
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raster(raster_id_string=None, verbose=True):
    &#34;&#34;&#34;Downloads assorted raster data that are not associated with the plate 
    reconstruction models supported by GPlately&#39;s `DataServer`. Stores rasters in the 
    &#34;gplately&#34; cache.

    Currently, gplately supports the following rasters and images:

    * __[ETOPO1](https://www.ngdc.noaa.gov/mgg/global/)__: 
        * Filetypes available : TIF, netCDF (GRD)
        * `raster_id_string` = `&#34;ETOPO1_grd&#34;`, `&#34;ETOPO1_tif&#34;` (depending on the requested format)
        * A 1-arc minute global relief model combining lang topography and ocean bathymetry.
        * Citation: doi:10.7289/V5C8276M


    Parameters
    ----------
    raster_id_string : str, default=None
        A string to identify which raster to download.

    Returns
    -------
    raster_filenames : ndarray or MaskedArray
        An ndarray or MaskedArray of the cached raster. This can be plotted using 
        `matplotlib.pyplot.imshow` on a `cartopy.mpl.GeoAxis` GeoAxesSubplot (see example below).

    Raises
    ------
    ValueError
        * if a `raster_id_string` is not supplied.

    Notes
    -----
    Rasters obtained by this method are (so far) only reconstructed to present-day. 

    Examples
    --------
    To download ETOPO1 and plot it on a Mollweide projection:

        import gplately
        import numpy as np
        import matplotlib.pyplot as plt
        import cartopy.crs as ccrs

        gdownload = gplately.DataServer(&#34;Muller2019&#34;)
        etopo1 = gdownload.get_raster(&#34;ETOPO1_tif&#34;)
        fig = plt.figure(figsize=(18,14), dpi=300)
        ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
        ax2.imshow(etopo1, extent=[-180,180,-90,90], transform=ccrs.PlateCarree()) 

    &#34;&#34;&#34;
    from matplotlib import image
    if raster_id_string is None:
        raise ValueError(
            &#34;Please specify which raster to download.&#34;
        )
    #filetype = &#34;.&#34;+&#34;_&#34;.split(raster_id_string)[-1]

    archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
    grid_extensions = tuple([&#34;.grd&#34;, &#34;.nc&#34;])

    # Set to true if we find the given collection in database
    found_collection = False
    raster_filenames = []
    database = _gplately.data._rasters()

    for collection, zip_url in database.items():
        # Isolate the raster name and the file type
        #raster_name = collection.split(&#34;_&#34;)[0]
        #raster_type = &#34;.&#34;+collection.split(&#34;_&#34;)[-1]
        if (raster_id_string.lower() == collection.lower()):
            raster_filenames = download_from_web(zip_url[0], verbose)
            found_collection = True
            break

    if found_collection is False:
        raise ValueError(&#34;{} not in collection database.&#34;.format(raster_id_string))
    else:
        # If the downloaded raster is a grid, process it with the gplately.Raster object
        if any(grid_extension in raster_filenames for grid_extension in grid_extensions):
            raster_matrix = _gplately.grids.Raster(data=raster_filenames).data

        # Otherwise, the raster is an image; use imread to process
        else:
            raster_matrix = image.imread(raster_filenames)
    return raster_matrix</code></pre>
</details>
</dd>
<dt id="gplately.download.path_of_cached_file"><code class="name flex">
<span>def <span class="ident">path_of_cached_file</span></span>(<span>url, model_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the full path to the cache where the file in <code>url</code>
will be downloaded to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path_of_cached_file(url, model_name=None):
    &#34;&#34;&#34;Determine the full path to the cache where the file in `url` 
    will be downloaded to.&#34;&#34;&#34;

    cached_filename = _pooch.utils.unique_file_name(url)
    cached_filename = _remove_hash(cached_filename)
    path = path_to_cache()

    processor_to_use, processor_extension = _determine_processor(url)

    # If the requested files need processing (i.e. zip, gz folders)
    if processor_extension:
        # Are they from plate models? These typically are the .zip folders for plate models
        if model_name:
            cached_filename  = str(path) + &#39;/&#39; + model_name + processor_extension+&#39;/&#39;
            unprocessed_path = str(path) + &#39;/&#39; + model_name
            #cached_filename = cached_filename = str(path) + &#39;/&#39; + model_name

        # If not from plate models but need processing, i.e. ETOPO1
        else:
            cached_filename = str(path) + &#39;/&#39; + &#34;gplately_&#34;+_parse_url_for_filenames(url) + processor_extension+&#39;/&#39;
            unprocessed_path = str(path) + &#39;/&#39; + &#34;gplately_&#34;+_parse_url_for_filenames(url)
            #cached_filename = &#34;gplately_&#34;+_parse_url_for_filenames(url) 

    # If the requested files do not need processing, like standalone .nc files:
    else:
        if model_name:
            cached_filename = str(path) + &#39;/&#39; + model_name + &#34;_&#34; + _parse_url_for_filenames(url)
            unprocessed_path = None
        else:
            cached_filename = str(path) + &#39;/&#39; + &#34;gplately_&#34;+_parse_url_for_filenames(url)
            unprocessed_path = None
      
    _pooch.utils.make_local_storage(path)
    full_path = path.resolve() / cached_filename

    return full_path, unprocessed_path</code></pre>
</details>
</dd>
<dt id="gplately.download.path_to_cache"><code class="name flex">
<span>def <span class="ident">path_to_cache</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path_to_cache():
    path = _pooch.utils.cache_location(
        _os_cache(&#39;gplately&#39;), 
        env=None, 
        version=None
    )
    return path</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.download.DataServer"><code class="flex name class">
<span>class <span class="ident">DataServer</span></span>
<span>(</span><span>file_collection, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses <a href="https://www.fatiando.org/pooch/latest/">Pooch</a> to download plate reconstruction
feature data from plate models and other studies that are stored on web servers
(e.g. EarthByte's <a href="https://www.earthbyte.org/webdav/ftp/Data_Collections/">webDAV server</a>). </p>
<p>If the <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> object and its methods are called for the first time, i.e. by:</p>
<pre><code># string identifier to access the Muller et al. 2019 model
gDownload = gplately.download.DataServer("Muller2019")
</code></pre>
<p>all requested files are downloaded into the user's 'gplately' cache folder only <em>once</em>. If the same
object and method(s) are re-run, the files will be re-accessed from the cache provided they have not been
moved or deleted. </p>
<p>Currently, <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> supports a number of plate reconstruction models. To call the object,
supply a <code>file_collection</code> string from one of the following models:</p>
<ul>
<li>
<p><strong><a href="https://www.earthbyte.org/muller-et-al-2019-deforming-plate-reconstruction-and-seafloor-age-grids-tectonics/">Müller et al. 2019</a>:</strong> </p>
<p>file_collection = <code>Muller2019</code></p>
<h2 id="information">Information</h2>
<ul>
<li>Downloadable files: a <code>rotation_model</code>, <code>topology_features</code>, <code>static_polygons</code>, <code>coastlines</code>, <code>continents</code>, <code>COBs</code>, and
seafloor <code>age_grids</code> from 0 to 250 Ma. </li>
<li>Maximum reconstruction time: 250 Ma</li>
</ul>
<h2 id="citations">Citations</h2>
<p>Müller, R. D., Zahirovic, S., Williams, S. E., Cannon, J., Seton, M.,
Bower, D. J., Tetley, M. G., Heine, C., Le Breton, E., Liu, S., Russell, S. H. J.,
Yang, T., Leonard, J., and Gurnis, M. (2019), A global plate model including
lithospheric deformation along major rifts and orogens since the Triassic.
Tectonics, vol. 38, <a href="https://doi.org/10.1029/2018TC005462.">https://doi.org/10.1029/2018TC005462.</a></p>
</li>
<li>
<p><strong>Müller et al. 2016</strong>:</p>
<p>file_collection = <code>Muller2016</code></p>
<h2 id="information_1">Information</h2>
<ul>
<li>Downloadable files: a <code>rotation_model</code>, <code>topology_features</code>, <code>static_polygons</code>, <code>coastlines</code>, and
seafloor <code>age_grids</code> from 0-230 Ma. </li>
<li>Maximum reconstruction time: 230 Ma</li>
</ul>
<h2 id="citations_1">Citations</h2>
<ul>
<li>Müller R.D., Seton, M., Zahirovic, S., Williams, S.E., Matthews, K.J.,
Wright, N.M., Shephard, G.E., Maloney, K.T., Barnett-Moore, N., Hosseinpour, M.,
Bower, D.J., Cannon, J., InPress. Ocean basin evolution and global-scale plate
reorganization events since Pangea breakup, Annual Review of Earth and Planetary
Sciences, Vol 44, 107-138. DOI: 10.1146/annurev-earth-060115-012211.</li>
</ul>
</li>
<li>
<p><strong><a href="https://zenodo.org/record/4485738#.Yhrm8hNBzA0">Merdith et al. 2021</a></strong>: </p>
<p>file_collection = <code>Merdith2021</code></p>
<h2 id="information_2">Information</h2>
<ul>
<li>Downloadable files: a <code>rotation_model</code>, <code>topology_features</code>, <code>static_polygons</code>, <code>coastlines</code>
and <code>continents</code>.</li>
<li>Maximum reconstruction time: 1 Ga (however, <code>PlotTopologies</code> correctly visualises up to 410 Ma) </li>
</ul>
<h2 id="citations_2">Citations:</h2>
<ul>
<li>Merdith et al. (in review), 'A continuous, kinematic full-plate motion model
from 1 Ga to present'. </li>
<li>Andrew Merdith. (2020). Plate model for 'Extending Full-Plate Tectonic Models
into Deep Time: Linking the Neoproterozoic and the Phanerozoic ' (1.1b) [Data set].
Zenodo. <a href="https://doi.org/10.5281/zenodo.4485738">https://doi.org/10.5281/zenodo.4485738</a></li>
</ul>
</li>
<li>
<p><strong>Cao et al. 2020</strong>: </p>
<p>file_collection = <code>Cao2020</code></p>
<h2 id="information_3">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code>, <code>topology_features</code>, <code>static_polygons</code>, <code>coastlines</code>
and <code>continents</code>.</li>
<li>Maximum reconstruction time: 1 Ga</li>
</ul>
<h2 id="citations_3">Citations</h2>
<ul>
<li>Toy Billion-year reconstructions from Cao et al (2020).
Coupled Evolution of Plate Tectonics and Basal Mantle Structure Tectonics,
doi: 10.1029/2020GC009244</li>
</ul>
</li>
<li>
<p><strong>Clennett et al. 2020</strong> : </p>
<p>file_collection = <code>Clennett2020</code></p>
<h2 id="information_4">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code>, <code>topology_features</code>, <code>static_polygons</code>, <code>coastlines</code>
and <code>continents</code></li>
<li>Maximum reconstruction time: 170 Ma</li>
</ul>
<h2 id="citations_4">Citations</h2>
<ul>
<li>Mather, B., Müller, R.D.,; Alfonso, C.P., Seton, M., 2021, Kimberlite eruption
driven by slab flux and subduction angle. DOI: 10.5281/zenodo.5769002</li>
</ul>
</li>
<li>
<p><strong>Seton et al. 2012</strong>:</p>
<p>file_collection = <code>Seton2012</code></p>
<h2 id="information_5">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code>, <code>topology_features</code>, <code>coastlines</code>,
<code>COBs</code>, and paleo-age grids (0-200 Ma)</li>
<li>Maximum reconstruction time: 200 Ma</li>
</ul>
<h2 id="citations_5">Citations</h2>
<ul>
<li>M. Seton, R.D. Müller, S. Zahirovic, C. Gaina, T.H. Torsvik, G. Shephard, A. Talsma,
M. Gurnis, M. Turner, S. Maus, M. Chandler, Global continental and ocean basin reconstructions
since 200 Ma, Earth-Science Reviews, Volume 113, Issues 3-4, July 2012, Pages 212-270,
ISSN 0012-8252, 10.1016/j.earscirev.2012.03.002.</li>
</ul>
</li>
<li>
<p><strong>Matthews et al. 2016</strong>: </p>
<p>file_collection = <code>Matthews2016</code></p>
<h2 id="information_6">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code>, <code>topology_features</code>, <code>static_polygons</code>, <code>coastlines</code>,
and <code>continents</code></li>
<li>Maximum reconstruction time(s): 410-250 Ma, 250-0 Ma</li>
</ul>
<h2 id="citations_6">Citations</h2>
<ul>
<li>Matthews, K.J., Maloney, K.T., Zahirovic, S., Williams, S.E., Seton, M.,
and Müller, R.D. (2016). Global plate boundary evolution and kinematics since the
late Paleozoic, Global and Planetary Change, 146, 226-250.
DOI: 10.1016/j.gloplacha.2016.10.002</li>
</ul>
</li>
<li>
<p><strong>Merdith et al. 2017</strong>: </p>
<p>file_collection = <code>Merdith2017</code></p>
<h2 id="information_7">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_files</code> and <code>topology_features</code></li>
<li>Maximum reconstruction time: 410 Ma</li>
</ul>
<h2 id="citations_7">Citations</h2>
<ul>
<li>Merdith, A., Collins, A., Williams, S., Pisarevskiy, S., Foden, J., Archibald, D.
and Blades, M. et al. 2016. A full-plate global reconstruction of the Neoproterozoic.
Gondwana Research. 50: pp. 84-134. DOI: 10.1016/j.gr.2017.04.001</li>
</ul>
</li>
<li>
<p><strong>Li et al. 2008</strong>: </p>
<p>file_collection = <code>Li2008</code></p>
<h2 id="information_8">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code> and <code>static_polygons</code></li>
<li>Maximum reconstruction time: 410 Ma</li>
</ul>
<h2 id="citations_8">Citations</h2>
<ul>
<li>Rodinia reconstruction from Li et al (2008), Assembly, configuration, and break-up
history of Rodinia: A synthesis. Precambrian Research. 160. 179-210.
DOI: 10.1016/j.precamres.2007.04.021.</li>
</ul>
</li>
<li>
<p><strong>Pehrsson et al. 2015</strong>: </p>
<p>file_collection = <code>Pehrsson2015</code></p>
<h2 id="information_9">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code> and <code>static_polygons</code></li>
<li>Maximum reconstruction time: N/A</li>
</ul>
<h2 id="citations_9">Citations</h2>
<ul>
<li>Pehrsson, S.J., Eglington, B.M., Evans, D.A.D., Huston, D., and Reddy, S.M., (2015),
Metallogeny and its link to orogenic style during the Nuna supercontinent cycle. Geological
Society, London, Special Publications, 424, 83-94. DOI: <a href="https://doi.org/10.1144/SP424.5">https://doi.org/10.1144/SP424.5</a></li>
</ul>
</li>
<li>
<p><strong>Torsvik and Cocks et al. 2017</strong>: </p>
<p>file_collection = <code>TorsvikCocks2017</code></p>
<h2 id="information_10">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code>, and <code>coastlines</code></li>
<li>Maximum reconstruction time: 410 Ma</li>
</ul>
<h2 id="citations_10">Citations</h2>
<ul>
<li>Torsvik, T., &amp; Cocks, L. (2016). Earth History and Palaeogeography. Cambridge:
Cambridge University Press. doi:10.1017/9781316225523</li>
</ul>
</li>
<li>
<p><strong>Young et al. 2019</strong>: </p>
<p>file_collection = <code>Young2019</code></p>
<h2 id="information_11">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code>, <code>topology_features</code>, <code>static_polygons</code>, <code>coastlines</code>
and <code>continents</code>.</li>
<li>Maximum reconstruction time: 410-250 Ma, 250-0 Ma</li>
</ul>
<h2 id="citations_11">Citations</h2>
<ul>
<li>Young, A., Flament, N., Maloney, K., Williams, S., Matthews, K., Zahirovic, S.,
Müller, R.D., (2019), Global kinematics of tectonic plates and subduction zones since the late
Paleozoic Era, Geoscience Frontiers, Volume 10, Issue 3, pp. 989-1013, ISSN 1674-9871,
DOI: <a href="https://doi.org/10.1016/j.gsf.2018.05.011.">https://doi.org/10.1016/j.gsf.2018.05.011.</a></li>
</ul>
</li>
<li>
<p><strong>Scotese et al. 2008</strong>: </p>
<p>file_collection = <code>Scotese2008</code></p>
<h2 id="information_12">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code>, <code>static_polygons</code>, and <code>continents</code></li>
<li>Maximum reconstruction time: </li>
</ul>
<h2 id="citations_12">Citations</h2>
<ul>
<li>Scotese, C.R. 2008. The PALEOMAP Project PaleoAtlas for ArcGIS, Volume 2, Cretaceous
paleogeographic and plate tectonic reconstructions. PALEOMAP Project, Arlington, Texas.</li>
</ul>
</li>
<li>
<p><strong>Golonka et al. 2007</strong>: </p>
<p>file_collection = <code>Golonka2007</code></p>
<h2 id="information_13">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code>, <code>static_polygons</code>, and <code>continents</code></li>
<li>Maximum reconstruction time: 410 Ma</li>
</ul>
<h2 id="citations_13">Citations</h2>
<ul>
<li>Golonka, J. 2007. Late Triassic and Early Jurassic palaeogeography of the world.
Palaeogeography, Palaeoclimatology, Palaeoecology 244(1–4), 297–307.</li>
</ul>
</li>
<li>
<p><strong>Clennett et al. 2020 (based on Müller et al. 2019)</strong>: </p>
<p>file_collection = <code>Clennett2020_M2019</code></p>
<h2 id="information_14">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code>, <code>topology_features</code>, <code>continents</code> and <code>coastlines</code></li>
<li>Maximum reconstruction time: 250 Ma</li>
</ul>
<h2 id="citations_14">Citations</h2>
<ul>
<li>Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate
Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics,
Geosystems, 21, e2020GC009117. DOI: <a href="https://doi.org/10.1029/2020GC009117">https://doi.org/10.1029/2020GC009117</a></li>
</ul>
</li>
<li>
<p><strong>Clennett et al. 2020 (rigid topological model based on Shephard et al, 2013)</strong>: </p>
<p>file_collection = <code>Clennett2020_S2013</code></p>
<h2 id="information_15">Information</h2>
<ul>
<li>Downloadable files: <code>rotation_model</code>, <code>topology_features</code>, <code>continents</code> and <code>coastlines</code></li>
<li>Maximum reconstruction time: </li>
</ul>
<h2 id="citations_15">Citations</h2>
<ul>
<li>Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate
Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics,
Geosystems, 21, e2020GC009117. DOI: <a href="https://doi.org/10.1029/2020GC009117">https://doi.org/10.1029/2020GC009117</a></li>
</ul>
<h2 id="parameters">Parameters</h2>
<p>file_collection : str
name of file collection to use</p>
<p>verbose : bool, default True
Toggle print messages regarding server/internet connection status, file availability etc.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataServer(object):
    &#34;&#34;&#34;Uses [Pooch](https://www.fatiando.org/pooch/latest/) to download plate reconstruction 
    feature data from plate models and other studies that are stored on web servers 
    (e.g. EarthByte&#39;s [webDAV server](https://www.earthbyte.org/webdav/ftp/Data_Collections/)). 
    
    If the `DataServer` object and its methods are called for the first time, i.e. by:

        # string identifier to access the Muller et al. 2019 model
        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    all requested files are downloaded into the user&#39;s &#39;gplately&#39; cache folder only _once_. If the same
    object and method(s) are re-run, the files will be re-accessed from the cache provided they have not been 
    moved or deleted. 

    Currently, `DataServer` supports a number of plate reconstruction models. To call the object,
    supply a `file_collection` string from one of the following models:

    * __[Müller et al. 2019](https://www.earthbyte.org/muller-et-al-2019-deforming-plate-reconstruction-and-seafloor-age-grids-tectonics/):__ 

        file_collection = `Muller2019`
    
        Information
        -----------
        * Downloadable files: a `rotation_model`, `topology_features`, `static_polygons`, `coastlines`, `continents`, `COBs`, and
        seafloor `age_grids` from 0 to 250 Ma. 
        * Maximum reconstruction time: 250 Ma

        Citations
        ---------
        Müller, R. D., Zahirovic, S., Williams, S. E., Cannon, J., Seton, M., 
        Bower, D. J., Tetley, M. G., Heine, C., Le Breton, E., Liu, S., Russell, S. H. J., 
        Yang, T., Leonard, J., and Gurnis, M. (2019), A global plate model including 
        lithospheric deformation along major rifts and orogens since the Triassic. 
        Tectonics, vol. 38, https://doi.org/10.1029/2018TC005462.
            

    * __Müller et al. 2016__:

        file_collection = `Muller2016`

        Information
        -----------
        * Downloadable files: a `rotation_model`, `topology_features`, `static_polygons`, `coastlines`, and
        seafloor `age_grids` from 0-230 Ma. 
        * Maximum reconstruction time: 230 Ma

        Citations
        ---------
        * Müller R.D., Seton, M., Zahirovic, S., Williams, S.E., Matthews, K.J.,
        Wright, N.M., Shephard, G.E., Maloney, K.T., Barnett-Moore, N., Hosseinpour, M., 
        Bower, D.J., Cannon, J., InPress. Ocean basin evolution and global-scale plate 
        reorganization events since Pangea breakup, Annual Review of Earth and Planetary 
        Sciences, Vol 44, 107-138. DOI: 10.1146/annurev-earth-060115-012211.


    * __[Merdith et al. 2021](https://zenodo.org/record/4485738#.Yhrm8hNBzA0)__: 

        file_collection = `Merdith2021`

        Information
        -----------
        * Downloadable files: a `rotation_model`, `topology_features`, `static_polygons`, `coastlines`
        and `continents`.
        * Maximum reconstruction time: 1 Ga (however, `PlotTopologies` correctly visualises up to 410 Ma) 

        Citations: 
        ----------
        * Merdith et al. (in review), &#39;A continuous, kinematic full-plate motion model
        from 1 Ga to present&#39;. 
        * Andrew Merdith. (2020). Plate model for &#39;Extending Full-Plate Tectonic Models 
        into Deep Time: Linking the Neoproterozoic and the Phanerozoic &#39; (1.1b) [Data set]. 
        Zenodo. https://doi.org/10.5281/zenodo.4485738


    * __Cao et al. 2020__: 

        file_collection = `Cao2020`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `static_polygons`, `coastlines`
        and `continents`.
        * Maximum reconstruction time: 1 Ga

        Citations
        ---------
        * Toy Billion-year reconstructions from Cao et al (2020). 
        Coupled Evolution of Plate Tectonics and Basal Mantle Structure Tectonics, 
        doi: 10.1029/2020GC009244


    - __Clennett et al. 2020__ : 

        file_collection = `Clennett2020`
        
        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `static_polygons`, `coastlines`
        and `continents`
        * Maximum reconstruction time: 170 Ma

        Citations
        ---------
        * Mather, B., Müller, R.D.,; Alfonso, C.P., Seton, M., 2021, Kimberlite eruption 
        driven by slab flux and subduction angle. DOI: 10.5281/zenodo.5769002


    - __Seton et al. 2012__:

        file_collection = `Seton2012`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `coastlines`,
        `COBs`, and paleo-age grids (0-200 Ma)
        * Maximum reconstruction time: 200 Ma

        Citations
        ---------
        * M. Seton, R.D. Müller, S. Zahirovic, C. Gaina, T.H. Torsvik, G. Shephard, A. Talsma, 
        M. Gurnis, M. Turner, S. Maus, M. Chandler, Global continental and ocean basin reconstructions 
        since 200 Ma, Earth-Science Reviews, Volume 113, Issues 3-4, July 2012, Pages 212-270, 
        ISSN 0012-8252, 10.1016/j.earscirev.2012.03.002.


    - __Matthews et al. 2016__: 

        file_collection = `Matthews2016`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `static_polygons`, `coastlines`,
        and `continents`
        * Maximum reconstruction time(s): 410-250 Ma, 250-0 Ma

        Citations
        ---------
        * Matthews, K.J., Maloney, K.T., Zahirovic, S., Williams, S.E., Seton, M.,
        and Müller, R.D. (2016). Global plate boundary evolution and kinematics since the 
        late Paleozoic, Global and Planetary Change, 146, 226-250. 
        DOI: 10.1016/j.gloplacha.2016.10.002


    - __Merdith et al. 2017__: 

        file_collection = `Merdith2017`

        Information
        -----------
        * Downloadable files: `rotation_files` and `topology_features`
        * Maximum reconstruction time: 410 Ma

        Citations
        ---------
        * Merdith, A., Collins, A., Williams, S., Pisarevskiy, S., Foden, J., Archibald, D. 
        and Blades, M. et al. 2016. A full-plate global reconstruction of the Neoproterozoic. 
        Gondwana Research. 50: pp. 84-134. DOI: 10.1016/j.gr.2017.04.001


    - __Li et al. 2008__: 

        file_collection = `Li2008`

        Information
        -----------
        * Downloadable files: `rotation_model` and `static_polygons`
        * Maximum reconstruction time: 410 Ma

        Citations
        ---------
        * Rodinia reconstruction from Li et al (2008), Assembly, configuration, and break-up 
        history of Rodinia: A synthesis. Precambrian Research. 160. 179-210. 
        DOI: 10.1016/j.precamres.2007.04.021.


    - __Pehrsson et al. 2015__: 

        file_collection = `Pehrsson2015`

        Information
        -----------
        * Downloadable files: `rotation_model` and `static_polygons`
        * Maximum reconstruction time: N/A

        Citations
        ---------
        * Pehrsson, S.J., Eglington, B.M., Evans, D.A.D., Huston, D., and Reddy, S.M., (2015),
        Metallogeny and its link to orogenic style during the Nuna supercontinent cycle. Geological 
        Society, London, Special Publications, 424, 83-94. DOI: https://doi.org/10.1144/SP424.5


    - __Torsvik and Cocks et al. 2017__: 

        file_collection = `TorsvikCocks2017`

        Information
        -----------
        * Downloadable files: `rotation_model`, and `coastlines`
        * Maximum reconstruction time: 410 Ma

        Citations
        ---------
        * Torsvik, T., &amp; Cocks, L. (2016). Earth History and Palaeogeography. Cambridge: 
        Cambridge University Press. doi:10.1017/9781316225523


    - __Young et al. 2019__: 

        file_collection = `Young2019`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `static_polygons`, `coastlines`
        and `continents`.
        * Maximum reconstruction time: 410-250 Ma, 250-0 Ma
        
        Citations
        ---------
        * Young, A., Flament, N., Maloney, K., Williams, S., Matthews, K., Zahirovic, S.,
        Müller, R.D., (2019), Global kinematics of tectonic plates and subduction zones since the late 
        Paleozoic Era, Geoscience Frontiers, Volume 10, Issue 3, pp. 989-1013, ISSN 1674-9871,
        DOI: https://doi.org/10.1016/j.gsf.2018.05.011.


    - __Scotese et al. 2008__: 

        file_collection = `Scotese2008`

        Information
        -----------
        * Downloadable files: `rotation_model`, `static_polygons`, and `continents`
        * Maximum reconstruction time: 
        
        Citations
        ---------
        * Scotese, C.R. 2008. The PALEOMAP Project PaleoAtlas for ArcGIS, Volume 2, Cretaceous 
        paleogeographic and plate tectonic reconstructions. PALEOMAP Project, Arlington, Texas.


    - __Golonka et al. 2007__: 

        file_collection = `Golonka2007`

        Information
        -----------
        * Downloadable files: `rotation_model`, `static_polygons`, and `continents`
        * Maximum reconstruction time: 410 Ma
        
        Citations
        ---------
        * Golonka, J. 2007. Late Triassic and Early Jurassic palaeogeography of the world. 
        Palaeogeography, Palaeoclimatology, Palaeoecology 244(1–4), 297–307.


    - __Clennett et al. 2020 (based on Müller et al. 2019)__: 

        file_collection = `Clennett2020_M2019`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `continents` and `coastlines`
        * Maximum reconstruction time: 250 Ma
        
        Citations
        ---------
        * Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
        Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate 
        Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics, 
        Geosystems, 21, e2020GC009117. DOI: https://doi.org/10.1029/2020GC009117


    - __Clennett et al. 2020 (rigid topological model based on Shephard et al, 2013)__: 

        file_collection = `Clennett2020_S2013`

        Information
        -----------
        * Downloadable files: `rotation_model`, `topology_features`, `continents` and `coastlines`
        * Maximum reconstruction time: 
        
        Citations
        ---------
        * Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
        Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate 
        Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics, 
        Geosystems, 21, e2020GC009117. DOI: https://doi.org/10.1029/2020GC009117

        Parameters
        ----------
        file_collection : str
            name of file collection to use

        verbose : bool, default True
            Toggle print messages regarding server/internet connection status, file availability etc.

    &#34;&#34;&#34;
    def __init__(self, file_collection, verbose=True):

        self.file_collection = file_collection.capitalize()
        self.data_collection = DataCollection(self.file_collection)
        self.verbose = verbose


    def get_plate_reconstruction_files(self):
        &#34;&#34;&#34;Downloads and constructs a `rotation model`, a set of `topology_features` and
        and a set of `static_polygons` needed to call the `PlateReconstruction` object.

        Returns
        -------
        rotation_model : instance of &lt;pygplates.RotationModel&gt;
            A rotation model to query equivalent and/or relative topological plate rotations
            from a time in the past relative to another time in the past or to present day.
        topology_features : instance of &lt;pygplates.FeatureCollection&gt;
            Point, polyline and/or polygon feature data that are reconstructable through 
            geological time.
        static_polygons : instance of &lt;pygplates.FeatureCollection&gt;
            Present-day polygons whose shapes do not change through geological time. They are
            used to cookie-cut dynamic polygons into identifiable topological plates (assigned 
            an ID) according to their present-day locations.

        Notes
        -----
        This method accesses the plate reconstruction model ascribed to the `file_collection` string passed 
        into the `DataServer` object. For example, if the object was called with `&#34;Muller2019&#34;`:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)
            rotation_model, topology_features, static_polygons = gDownload.get_plate_reconstruction_files()

        the method will download a `rotation_model`, `topology_features` and `static_polygons` from the 
        Müller et al. (2019) plate reconstruction model. Once the reconstruction objects are returned, 
        they can be passed into:

            model = gplately.reconstruction.PlateReconstruction(rotation_model, topology_features, static_polygons)

        * Note: If the requested plate model does not have a certain file(s), a message will be printed 
        to alert the user. For example, using `get_plate_reconstruction_files()`
        for the Torsvik and Cocks (2017) plate reconstruction model yields the printed message:

                No topology features in TorsvikCocks2017. No FeatureCollection created - unable to 
                plot trenches, ridges and transforms.
                No continent-ocean boundaries in TorsvikCocks2017.

        &#34;&#34;&#34;

        verbose = self.verbose

        rotation_filenames = []
        rotation_model = []
        topology_filenames = []
        topology_features = _FeatureCollection()
        static_polygons= _FeatureCollection()
        static_polygon_filenames = []

        # Locate all plate reconstruction files from GPlately&#39;s DataCollection
        database = DataCollection.plate_reconstruction_files(self)

        # Set to true if we find the given collection in our database
        found_collection = False
        for collection, url in database.items():

            # Only continue if the user&#39;s chosen collection exists in our database
            if self.file_collection.lower() == collection.lower():
                found_collection = True
                if len(url) == 1:
                    fnames = _collection_sorter(
                        download_from_web(url[0], verbose, model_name=self.file_collection), self.file_collection
                    )
                    rotation_filenames = _collect_file_extension(
                        _str_in_folder(
                            _str_in_filename(fnames,
                                strings_to_ignore=DataCollection.rotation_strings_to_ignore(self)
                            ),
                        strings_to_ignore=DataCollection.rotation_strings_to_ignore(self)
                        ),
                        [&#34;.rot&#34;]
                    )
                    #print(rotation_filenames)
                    rotation_model = _RotationModel(rotation_filenames)

                    topology_filenames = _collect_file_extension(
                        _str_in_folder(
                            _str_in_filename(fnames, 
                                strings_to_include=DataCollection.dynamic_polygon_strings_to_include(self),
                                strings_to_ignore=DataCollection.dynamic_polygon_strings_to_ignore(self)
                            ), 
                            strings_to_ignore=DataCollection.dynamic_polygon_strings_to_ignore(self)
                        ),
                        [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                    )
                    #print(topology_filenames)
                    for file in topology_filenames:
                        topology_features.add(_FeatureCollection(file))

                    static_polygon_filenames = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, 
                                strings_to_include=DataCollection.static_polygon_strings_to_include(self),
                                strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                            ),
                            strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                        )
                    )
                    #print(static_polygon_filenames)
                    for stat in static_polygon_filenames:
                        static_polygons.add(_FeatureCollection(stat))

                else:
                    for file in url[0]:
                        rotation_filenames.append(_collect_file_extension(download_from_web(file, verbose, model_name=self.file_collection), [&#34;.rot&#34;]))
                        rotation_model = _RotationModel(rotation_filenames)

                    for file in url[1]:
                        topology_filenames.append(_collect_file_extension(download_from_web(file, verbose, model_name=self.file_collection), [&#34;.gpml&#34;]))
                        for file in topology_filenames:
                            topology_features.add(_FeatureCollection(file))

                    for file in url[2]:
                        static_polygon_filenames.append(
                            _check_gpml_or_shp(
                                _str_in_folder(
                                    _str_in_filename(download_from_web(url[0], verbose, model_name=self.file_collection), 
                                        strings_to_include=DataCollection.static_polygon_strings_to_include(self)
                                    ),    
                                        strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                                )
                            )   
                        )
                        for stat in static_polygon_filenames:
                            static_polygons.add(_FeatureCollection(stat))
                break

        if found_collection is False:
            raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

        if not rotation_filenames:
            print(&#34;No .rot files in {}. No rotation model created.&#34;.format(self.file_collection))
            rotation_model = []
        if not topology_filenames:
            print(&#34;No topology features in {}. No FeatureCollection created - unable to plot trenches, ridges and transforms.&#34;.format(self.file_collection))
            topology_features = []
        if not static_polygons:
            print(&#34;No static polygons in {}.&#34;.format(self.file_collection))
            static_polygons = []

        # add identifier for setting up DownloadServer independently
        rotation_model.reconstruction_identifier = self.file_collection

        return rotation_model, topology_features, static_polygons


    def get_topology_geometries(self):
        &#34;&#34;&#34;Uses Pooch to download coastline, continent and COB (continent-ocean boundary)
        Shapely geometries from the requested plate model. These are needed to call the `PlotTopologies`
        object and visualise topological plates through time.

        Parameters
        ----------
        verbose : bool, default True
            Toggle print messages regarding server/internet connection status, file availability etc.

        Returns
        -------
        coastlines : instance of &lt;pygplates.FeatureCollection&gt;
            Present-day global coastline Shapely polylines cookie-cut using static polygons. Ready for
            reconstruction to a particular geological time and for plotting.

        continents : instance of &lt;pygplates.FeatureCollection&gt;
            Cookie-cutting Shapely polygons for non-oceanic regions (continents, inta-oceanic arcs, etc.)
            ready for reconstruction to a particular geological time and for plotting.

        COBs : instance of &lt;pygplates.FeatureCollection&gt;
            Shapely polylines resolved from .shp and/or .gpml topology files that represent the 
            locations of the boundaries between oceanic and continental crust.
            Ready for reconstruction to a particular geological time and for plotting.

        Notes
        -----
        This method accesses the plate reconstruction model ascribed to the `file_collection` 
        string passed into the `DataServer` object. For example, if the object was called with
        `&#34;Muller2019&#34;`:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)
            coastlines, continents, COBs = gDownload.get_topology_geometries()

        the method will attempt to download `coastlines`, `continents` and `COBs` from the Müller
        et al. (2019) plate reconstruction model. If found, these files are returned as individual 
        pyGPlates Feature Collections. They can be passed into:

            gPlot = gplately.plot.PlotTopologies(gplately.reconstruction.PlateReconstruction, time, continents, coastlines, COBs)

        to reconstruct features to a certain geological time. The `PlotTopologies`
        object provides simple methods to plot these geometries along with trenches, ridges and 
        transforms (see documentation for more info). Note that the `PlateReconstruction` object 
        is a parameter.

        * Note: If the requested plate model does not have a certain geometry, a
        message will be printed to alert the user. For example, if `get_topology_geometries()` 
        is used with the `&#34;Matthews2016&#34;` plate model, the workflow will print the following 
        message: 

                No continent-ocean boundaries in Matthews2016.
        &#34;&#34;&#34;

        verbose = self.verbose

        # Locate all topology geometries from GPlately&#39;s DataCollection
        database = DataCollection.topology_geometries(self)

        coastlines = []
        continents = []
        COBs = []
        
        # Find the requested plate model data collection
        found_collection = False
        for collection, url in database.items():

            if self.file_collection.lower() == collection.lower():
                found_collection = True

                if len(url) == 1:
                    # Some plate models do not have reconstructable geometries i.e. Li et al. 2008
                    if url[0] is None:
                        break
                    else:
                        fnames = _collection_sorter(
                            download_from_web(url[0], verbose, model_name=self.file_collection), self.file_collection
                        )
                        coastlines = _check_gpml_or_shp(
                            _str_in_folder(
                                _str_in_filename(
                                    fnames,
                                    strings_to_include=DataCollection.coastline_strings_to_include(self),
                                    strings_to_ignore=DataCollection.coastline_strings_to_ignore(self)
                                ), 
                                strings_to_ignore=DataCollection.coastline_strings_to_ignore(self)
                            )
                        )
                        continents = _check_gpml_or_shp(
                            _str_in_folder(
                                _str_in_filename(
                                    fnames, 
                                    strings_to_include=DataCollection.continent_strings_to_include(self),
                                    strings_to_ignore=DataCollection.continent_strings_to_ignore(self)
                                ), 
                                strings_to_ignore=DataCollection.continent_strings_to_ignore(self)
                            )
                        )
                        COBs = _check_gpml_or_shp(
                            _str_in_folder(
                                _str_in_filename(
                                    fnames,
                                    strings_to_include=DataCollection.COB_strings_to_include(self),
                                    strings_to_ignore=DataCollection.COB_strings_to_ignore(self)
                                ), 
                                strings_to_ignore=DataCollection.COB_strings_to_ignore(self)
                            )
                        )
                else:
                    for file in url[0]:
                        if url[0] is not None:
                            coastlines.append(_str_in_filename(
                                download_from_web(file, verbose, model_name=self.file_collection), 
                                strings_to_include=[&#34;coastline&#34;])
                            )
                            coastlines = _check_gpml_or_shp(coastlines)
                        else:
                            coastlines = []

                    for file in url[1]:
                        if url[1] is not None:
                            continents.append(_str_in_filename(
                                download_from_web(file, verbose, model_name=self.file_collection), 
                                strings_to_include=[&#34;continent&#34;])
                            )
                            continents = _check_gpml_or_shp(continents)
                        else:
                            continents = []

                    for file in url[2]:
                        if url[2] is not None:
                            COBs.append(_str_in_filename(
                                download_from_web(file, verbose, model_name=self.file_collection), 
                                strings_to_include=[&#34;cob&#34;])
                            )
                            COBs = _check_gpml_or_shp(COBs)
                        else:
                            COBs = []
                break

        if found_collection is False:
            raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

        if not coastlines:
            print(&#34;No coastlines in {}.&#34;.format(self.file_collection))
            coastlines_featurecollection = []
        else:
            #print(coastlines)
            coastlines_featurecollection = _FeatureCollection()
            for coastline in coastlines:
                coastlines_featurecollection.add(_FeatureCollection(coastline))
        
        if not continents:
            print(&#34;No continents in {}.&#34;.format(self.file_collection))
            continents_featurecollection = []
        else:
            #print(continents)
            continents_featurecollection = _FeatureCollection()
            for continent in continents:
                continents_featurecollection.add(_FeatureCollection(continent))
        
        if not COBs:
            print(&#34;No continent-ocean boundaries in {}.&#34;.format(self.file_collection))
            COBs_featurecollection = []
        else:
            #print(COBs)
            COBs_featurecollection = _FeatureCollection()
            for COB in COBs:
                COBs_featurecollection.add(_FeatureCollection(COB))
        
        geometries = coastlines_featurecollection, continents_featurecollection, COBs_featurecollection
        return geometries


    def get_age_grid(self, time):
        &#34;&#34;&#34;Downloads seafloor and paleo-age grids from the plate reconstruction model (`file_collection`)
        passed into the `DataServer` object. Stores grids in the &#34;gplately&#34; cache.

        Currently, `DataServer` supports the following age grids:

        * __Muller et al. 2019__

            * `file_collection` = `Muller2019`
            * Time range: 0-250 Ma
            * Seafloor age grid rasters in netCDF format.

        * __Muller et al. 2016__
            
            * `file_collection` = `Muller2016`
            * Time range: 0-240 Ma
            * Seafloor age grid rasters in netCDF format. 

        * __Seton et al. 2012__

            * `file_collection` = `Seton2012`
            * Time range: 0-200 Ma
            * Paleo-age grid rasters in netCDF format.

        
        Parameters
        ----------
        time : int, or list of int, default=None
            Request an age grid from one (an integer) or multiple reconstruction times (a
            list of integers).

        Returns
        -------
        raster_array : MaskedArray
            A masked array containing the netCDF4 age grid ready for plotting or for
            passing into GPlately&#39;s `Raster` object for raster manipulation.

        Raises
        -----
        ValueError
            If `time` (a single integer, or a list of integers representing reconstruction
            times to extract the age grids from) is not passed.

        Notes
        -----
        The first time that `get_age_grid` is called for a specific time(s), the age grid(s) 
        will be downloaded into the GPlately cache once. Upon successive calls of `get_age_grid`
        for the same reconstruction time(s), the age grids will not be re-downloaded; rather, 
        they are re-accessed from the same cache provided the age grid(s) have not been moved or deleted. 

        Examples
        --------
        if the `DataServer` object was called with the `Muller2019` `file_collection` string:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        `get_age_grid` will download seafloor age grids from the Müller et al. (2019) plate 
        reconstruction model for the geological time(s) requested in the `time` parameter. 
        If found, these age grids are returned as masked arrays. 

        For example, to download  Müller et al. (2019) seafloor age grids for 0Ma, 1Ma and
        100 Ma:

            age_grids = gDownload.get_age_grid([0, 1, 100])
            
        &#34;&#34;&#34;
        age_grids = []
        age_grid_links = DataCollection.netcdf4_age_grids(self, time)

        if not isinstance(time, list):
            time = [time]

        # For a single time passed that isn&#39;t in the valid time range, 
        if not age_grid_links:
            raise ValueError(
                &#34;{} {}Ma age grids are not on GPlately&#39;s DataServer.&#34;.format(
                    self.file_collection, 
                    time[0]
                )
            )

        # For a list of times passed...
        for i, link in enumerate(age_grid_links):
            if not link:
                raise ValueError(
                    &#34;{} {}Ma age grids are not on GPlately&#39;s DataServer.&#34;.format(
                        self.file_collection,
                        time[i]
                    )
                )
            age_grid_file = download_from_web(
                link, 
                verbose=self.verbose, 
                model_name=self.file_collection
            )
            age_grid = _gplately.grids.read_netcdf_grid(age_grid_file)
            age_grids.append(age_grid)

        # One last check to alert user if the masked array grids were not processed properly
        if not age_grids:
            raise ValueError(&#34;{} netCDF4 age grids not found.&#34;.format(self.file_collection))

        if len(age_grids) == 1:
            return age_grids[0]
        else: 
            return age_grids


    def get_spreading_rate_grid(self, time):
        &#34;&#34;&#34;Downloads seafloor spreading rate grids from the plate reconstruction 
        model (`file_collection`) passed into the `DataServer` object. Stores 
        grids in the &#34;gplately&#34; cache.

        Currently, `DataServer` supports spreading rate grids from the following plate
        models:

        * __Clennett et al. 2020__

            * `file_collection` = `Clennett2020`
            * Time range: 0-250 Ma
            * Seafloor spreading rate grids in netCDF format.

        
        Parameters
        ----------
        time : int, or list of int, default=None
            Request a spreading grid from one (an integer) or multiple reconstruction 
            times (a list of integers).

        Returns
        -------
        raster_array : MaskedArray
            A masked array containing the netCDF4 spreading rate grid ready for 
            plotting or for passing into GPlately&#39;s `Raster` object.

        Raises
        -----
        ValueError
            If `time` (a single integer, or a list of integers representing reconstruction
            times to extract the spreading rate grids from) is not passed.

        Notes
        -----
        The first time that `get_spreading_rate_grid` is called for a specific time(s), 
        the spreading rate grid(s) will be downloaded into the GPlately cache once. 
        Upon successive calls of `get_spreading_rate_grid` for the same reconstruction 
        time(s), the grids will not be re-downloaded; rather, they are re-accessed from 
        the same cache location provided they have not been moved or deleted. 

        Examples
        --------
        if the `DataServer` object was called with the `Clennett2020` `file_collection` string:

            gDownload = gplately.download.DataServer(&#34;Clennett2020&#34;)

        `get_spreading_rate_grid` will download seafloor spreading rate grids from the 
        Clennett et al. (2020) plate reconstruction model for the geological time(s) 
        requested in the `time` parameter. When found, these spreading rate grids are 
        returned as masked arrays. 

        For example, to download Clennett et al. (2020) seafloor spreading rate grids for 
        0Ma, 1Ma and 100 Ma as MaskedArray objects:

            spreading_rate_grids = gDownload.get_spreading_rate_grid([0, 1, 100])
            
        &#34;&#34;&#34;
        spreading_rate_grids = []
        spreading_rate_grid_links = DataCollection.netcdf4_spreading_rate_grids(self, time)

        if not isinstance(time, list):
            time = [time]

        # For a single time passed that isn&#39;t in the valid time range, 
        if not spreading_rate_grid_links:
            raise ValueError(
                &#34;{} {}Ma spreading rate grids are not on GPlately&#39;s DataServer.&#34;.format(
                    self.file_collection,
                    time[0]
                )
            )
        # For a list of times passed...
        for i, link in enumerate(spreading_rate_grid_links):
            if not link:
                raise ValueError(
                    &#34;{} {}Ma spreading rate grids are not on GPlately&#39;s DataServer.&#34;.format(
                        self.file_collection,
                        time[i]
                    )
                )
            spreading_rate_grid_file = download_from_web(
                link, 
                verbose=self.verbose, 
                model_name=self.file_collection
            )
            spreading_rate_grid = _gplately.grids.read_netcdf_grid(spreading_rate_grid_file)
            spreading_rate_grids.append(spreading_rate_grid)

        # One last check to alert user if the masked array grids were not processed properly
        if not spreading_rate_grids:
            raise ValueError(&#34;{} netCDF4 seafloor spreading rate grids not found.&#34;.format(self.file_collection))

        if len(spreading_rate_grids) == 1:
            return spreading_rate_grids[0]
        else: 
            return spreading_rate_grids


    def get_valid_times(self):
        &#34;&#34;&#34;Returns a tuple of the valid plate model time range, (min_time, max_time).
        &#34;&#34;&#34;
        all_model_valid_times = DataCollection.plate_model_valid_reconstruction_times(self)

        min_time = None
        max_time = None
        for plate_model_name, valid_times in list(all_model_valid_times.items()):
            if plate_model_name.lower() == self.file_collection.lower():
                min_time = valid_times[0]
                max_time = valid_times[1]
        if not min_time and not max_time:
            raise ValueError(&#34;Could not find the valid reconstruction time of {}&#34;.format(self.file_collection))

        return (min_time, max_time)


    def get_raster(self, raster_id_string=None):
        &#34;&#34;&#34;Downloads assorted raster data that are not associated with the plate 
        reconstruction models supported by GPlately&#39;s `DataServer`. Stores rasters in the 
        &#34;gplately&#34; cache.

        Currently, `DataServer` supports the following rasters and images:

        * __[ETOPO1](https://www.ngdc.noaa.gov/mgg/global/)__: 
            * Filetypes available : TIF, netCDF (GRD)
            * `raster_id_string` = `&#34;ETOPO1_grd&#34;`, `&#34;ETOPO1_tif&#34;` (depending on the requested format)
            * A 1-arc minute global relief model combining lang topography and ocean bathymetry.
            * Citation: doi:10.7289/V5C8276M


        Parameters
        ----------
        raster_id_string : str, default=None
            A string to identify which raster to download.

        Returns
        -------
        raster_filenames : ndarray or MaskedArray
            An ndarray or MaskedArray of the cached raster. This can be plotted using 
            `matplotlib.pyplot.imshow` on a `cartopy.mpl.GeoAxis` GeoAxesSubplot (see example below).

        Raises
        ------
        ValueError
            * if a `raster_id_string` is not supplied.

        Notes
        -----
        Rasters obtained by this method are (so far) only reconstructed to present-day. 

        Examples
        --------
        To download ETOPO1 and plot it on a Mollweide projection:

            import gplately
            import numpy as np
            import matplotlib.pyplot as plt
            import cartopy.crs as ccrs

            gdownload = gplately.DataServer(&#34;Muller2019&#34;)
            etopo1 = gdownload.get_raster(&#34;ETOPO1_tif&#34;)
            fig = plt.figure(figsize=(18,14), dpi=300)
            ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
            ax2.imshow(etopo1, extent=[-180,180,-90,90], transform=ccrs.PlateCarree()) 

        &#34;&#34;&#34;
        from matplotlib import image
        if raster_id_string is None:
            raise ValueError(
                &#34;Please specify which raster to download.&#34;
            )
        #filetype = &#34;.&#34;+&#34;_&#34;.split(raster_id_string)[-1]

        archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
        grid_extensions = tuple([&#34;.grd&#34;, &#34;.nc&#34;])

        # Set to true if we find the given collection in database
        found_collection = False
        raster_filenames = []
        database = _gplately.data._rasters()

        for collection, zip_url in database.items():
            # Isolate the raster name and the file type
            #raster_name = collection.split(&#34;_&#34;)[0]
            #raster_type = &#34;.&#34;+collection.split(&#34;_&#34;)[-1]
            if (raster_id_string.lower() == collection.lower()):
                raster_filenames = download_from_web(zip_url[0], self.verbose)
                found_collection = True
                break

        if found_collection is False:
            raise ValueError(&#34;{} not in collection database.&#34;.format(raster_id_string))
        else:
            # If the downloaded raster is a grid, process it with the gplately.Raster object
            if any(grid_extension in raster_filenames for grid_extension in grid_extensions):
                raster_matrix = _gplately.grids.Raster(data=raster_filenames).data

            # Otherwise, the raster is an image; use imread to process
            else:
                raster_matrix = image.imread(raster_filenames)
        return raster_matrix


    def get_feature_data(self, feature_data_id_string=None):
        &#34;&#34;&#34;Downloads assorted geological feature data from web servers (i.e. 
        [GPlates 2.3 sample data](https://www.earthbyte.org/gplates-2-3-software-and-data-sets/))
        into the &#34;gplately&#34; cache.

        Currently, `DataServer` supports the following feature data:

        * __Large igneous provinces from Johansson et al. (2018)__

            Information
            -----------
            * Formats: .gpmlz
            * `feature_data_id_string` = `Johansson2018`

            Citations
            ---------
            * Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The 
            interplay between the eruption and weathering of Large Igneous Provinces and 
            the deep-time carbon cycle: Geophysical Research Letters.


        - __Large igneous province products interpreted as plume products from Whittaker 
        et al. (2015)__.

            Information
            -----------
            * Formats: .gpmlz, .shp
            * `feature_data_id_string` = `Whittaker2015`
            
            Citations
            ---------
            * Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D., 
            Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between 
            mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483. 
            doi:10.1038/ngeo2437.


        - __Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures, 
        unclassified V-anomalies, propagating ridge lineations and extinct ridges) from 
        Matthews et al. (2011)__

            Information
            -----------
            * Formats: .gpml
            * `feature_data_id_string` = `SeafloorFabric`

            Citations
            ---------
            * Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The 
            tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12): 
            B12109, DOI: 10.1029/2011JB008413. 


        - __Present day surface hotspot/plume locations from Whittaker et al. (2013)__

            Information
            -----------
            * Formats: .gpmlz
            * `feature_data_id_string` = `Hotspots`

            Citation
            --------
            * Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P., 
            Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and 
            mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.

        
        Parameters
        ----------
        feature_data_id_string : str, default=None
            A string to identify which feature data to download to the cache (see list of supported
            feature data above).

        Returns
        -------
        feature_data_filenames : instance of &lt;pygplates.FeatureCollection&gt;, or list of instance &lt;pygplates.FeatureCollection&gt;
            If a single set of feature data is downloaded, a single pyGPlates `FeatureCollection` 
            object is returned. Otherwise, a list containing multiple pyGPlates `FeatureCollection` 
            objects is returned (like for `SeafloorFabric`). In the latter case, feature reconstruction 
            and plotting may have to be done iteratively.

        Raises
        ------
        ValueError
            If a `feature_data_id_string` is not provided.

        Examples
        --------
        For examples of plotting data downloaded with `get_feature_data`, see GPlately&#39;s sample 
        notebook 05 - Working With Feature Geometries [here](https://github.com/GPlates/gplately/blob/master/Notebooks/05-WorkingWithFeatureGeometries.ipynb).
        &#34;&#34;&#34;
        if feature_data_id_string is None:
            raise ValueError(
                &#34;Please specify which feature data to fetch.&#34;
            )

        database = _gplately.data._feature_data()

        found_collection = False
        for collection, zip_url in database.items():
            if feature_data_id_string.lower() == collection.lower():
                found_collection = True
                feature_data_filenames = _collection_sorter(
                    _collect_file_extension(
                    download_from_web(zip_url[0], self.verbose), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                    ),
                    collection
                )

                break

        if found_collection is False:
            raise ValueError(&#34;{} are not in GPlately&#39;s DataServer.&#34;.format(feature_data_id_string))

        feat_data = _FeatureCollection()
        if len(feature_data_filenames) == 1:
                feat_data.add(_FeatureCollection(feature_data_filenames[0]))
                return feat_data
        else:    
            feat_data=[]
            for file in feature_data_filenames:
                feat_data.append(_FeatureCollection(file))
            return feat_data</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gplately.download.DataServer.get_age_grid"><code class="name flex">
<span>def <span class="ident">get_age_grid</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads seafloor and paleo-age grids from the plate reconstruction model (<code>file_collection</code>)
passed into the <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> object. Stores grids in the "gplately" cache.</p>
<p>Currently, <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> supports the following age grids:</p>
<ul>
<li>
<p><strong>Muller et al. 2019</strong></p>
<ul>
<li><code>file_collection</code> = <code>Muller2019</code></li>
<li>Time range: 0-250 Ma</li>
<li>Seafloor age grid rasters in netCDF format.</li>
</ul>
</li>
<li>
<p><strong>Muller et al. 2016</strong></p>
<ul>
<li><code>file_collection</code> = <code>Muller2016</code></li>
<li>Time range: 0-240 Ma</li>
<li>Seafloor age grid rasters in netCDF format. </li>
</ul>
</li>
<li>
<p><strong>Seton et al. 2012</strong></p>
<ul>
<li><code>file_collection</code> = <code>Seton2012</code></li>
<li>Time range: 0-200 Ma</li>
<li>Paleo-age grid rasters in netCDF format.</li>
</ul>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>int,</code> or <code>list</code> of <code>int</code>, default=<code>None</code></dt>
<dd>Request an age grid from one (an integer) or multiple reconstruction times (a
list of integers).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>raster_array</code></strong> :&ensp;<code>MaskedArray</code></dt>
<dd>A masked array containing the netCDF4 age grid ready for plotting or for
passing into GPlately's <code>Raster</code> object for raster manipulation.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>time</code> (a single integer, or a list of integers representing reconstruction
times to extract the age grids from) is not passed.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The first time that <code>get_age_grid</code> is called for a specific time(s), the age grid(s)
will be downloaded into the GPlately cache once. Upon successive calls of <code>get_age_grid</code>
for the same reconstruction time(s), the age grids will not be re-downloaded; rather,
they are re-accessed from the same cache provided the age grid(s) have not been moved or deleted. </p>
<h2 id="examples">Examples</h2>
<p>if the <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> object was called with the <code>Muller2019</code> <code>file_collection</code> string:</p>
<pre><code>gDownload = gplately.download.DataServer("Muller2019")
</code></pre>
<p><code>get_age_grid</code> will download seafloor age grids from the Müller et al. (2019) plate
reconstruction model for the geological time(s) requested in the <code>time</code> parameter.
If found, these age grids are returned as masked arrays. </p>
<p>For example, to download
Müller et al. (2019) seafloor age grids for 0Ma, 1Ma and
100 Ma:</p>
<pre><code>age_grids = gDownload.get_age_grid([0, 1, 100])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_age_grid(self, time):
    &#34;&#34;&#34;Downloads seafloor and paleo-age grids from the plate reconstruction model (`file_collection`)
    passed into the `DataServer` object. Stores grids in the &#34;gplately&#34; cache.

    Currently, `DataServer` supports the following age grids:

    * __Muller et al. 2019__

        * `file_collection` = `Muller2019`
        * Time range: 0-250 Ma
        * Seafloor age grid rasters in netCDF format.

    * __Muller et al. 2016__
        
        * `file_collection` = `Muller2016`
        * Time range: 0-240 Ma
        * Seafloor age grid rasters in netCDF format. 

    * __Seton et al. 2012__

        * `file_collection` = `Seton2012`
        * Time range: 0-200 Ma
        * Paleo-age grid rasters in netCDF format.

    
    Parameters
    ----------
    time : int, or list of int, default=None
        Request an age grid from one (an integer) or multiple reconstruction times (a
        list of integers).

    Returns
    -------
    raster_array : MaskedArray
        A masked array containing the netCDF4 age grid ready for plotting or for
        passing into GPlately&#39;s `Raster` object for raster manipulation.

    Raises
    -----
    ValueError
        If `time` (a single integer, or a list of integers representing reconstruction
        times to extract the age grids from) is not passed.

    Notes
    -----
    The first time that `get_age_grid` is called for a specific time(s), the age grid(s) 
    will be downloaded into the GPlately cache once. Upon successive calls of `get_age_grid`
    for the same reconstruction time(s), the age grids will not be re-downloaded; rather, 
    they are re-accessed from the same cache provided the age grid(s) have not been moved or deleted. 

    Examples
    --------
    if the `DataServer` object was called with the `Muller2019` `file_collection` string:

        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    `get_age_grid` will download seafloor age grids from the Müller et al. (2019) plate 
    reconstruction model for the geological time(s) requested in the `time` parameter. 
    If found, these age grids are returned as masked arrays. 

    For example, to download  Müller et al. (2019) seafloor age grids for 0Ma, 1Ma and
    100 Ma:

        age_grids = gDownload.get_age_grid([0, 1, 100])
        
    &#34;&#34;&#34;
    age_grids = []
    age_grid_links = DataCollection.netcdf4_age_grids(self, time)

    if not isinstance(time, list):
        time = [time]

    # For a single time passed that isn&#39;t in the valid time range, 
    if not age_grid_links:
        raise ValueError(
            &#34;{} {}Ma age grids are not on GPlately&#39;s DataServer.&#34;.format(
                self.file_collection, 
                time[0]
            )
        )

    # For a list of times passed...
    for i, link in enumerate(age_grid_links):
        if not link:
            raise ValueError(
                &#34;{} {}Ma age grids are not on GPlately&#39;s DataServer.&#34;.format(
                    self.file_collection,
                    time[i]
                )
            )
        age_grid_file = download_from_web(
            link, 
            verbose=self.verbose, 
            model_name=self.file_collection
        )
        age_grid = _gplately.grids.read_netcdf_grid(age_grid_file)
        age_grids.append(age_grid)

    # One last check to alert user if the masked array grids were not processed properly
    if not age_grids:
        raise ValueError(&#34;{} netCDF4 age grids not found.&#34;.format(self.file_collection))

    if len(age_grids) == 1:
        return age_grids[0]
    else: 
        return age_grids</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_feature_data"><code class="name flex">
<span>def <span class="ident">get_feature_data</span></span>(<span>self, feature_data_id_string=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads assorted geological feature data from web servers (i.e.
<a href="https://www.earthbyte.org/gplates-2-3-software-and-data-sets/">GPlates 2.3 sample data</a>)
into the "gplately" cache.</p>
<p>Currently, <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> supports the following feature data:</p>
<ul>
<li>
<p><strong>Large igneous provinces from Johansson et al. (2018)</strong></p>
<h2 id="information">Information</h2>
<ul>
<li>Formats: .gpmlz</li>
<li><code>feature_data_id_string</code> = <code>Johansson2018</code></li>
</ul>
<h2 id="citations">Citations</h2>
<ul>
<li>Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The
interplay between the eruption and weathering of Large Igneous Provinces and
the deep-time carbon cycle: Geophysical Research Letters.</li>
</ul>
</li>
<li>
<p><strong>Large igneous province products interpreted as plume products from Whittaker
et al. (2015)</strong>.</p>
<h2 id="information_1">Information</h2>
<ul>
<li>Formats: .gpmlz, .shp</li>
<li><code>feature_data_id_string</code> = <code>Whittaker2015</code></li>
</ul>
<h2 id="citations_1">Citations</h2>
<ul>
<li>Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D.,
Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between
mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483.
doi:10.1038/ngeo2437.</li>
</ul>
</li>
<li>
<p><strong>Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures,
unclassified V-anomalies, propagating ridge lineations and extinct ridges) from
Matthews et al. (2011)</strong></p>
<h2 id="information_2">Information</h2>
<ul>
<li>Formats: .gpml</li>
<li><code>feature_data_id_string</code> = <code>SeafloorFabric</code></li>
</ul>
<h2 id="citations_2">Citations</h2>
<ul>
<li>Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The
tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12):
B12109, DOI: 10.1029/2011JB008413. </li>
</ul>
</li>
<li>
<p><strong>Present day surface hotspot/plume locations from Whittaker et al. (2013)</strong></p>
<h2 id="information_3">Information</h2>
<ul>
<li>Formats: .gpmlz</li>
<li><code>feature_data_id_string</code> = <code>Hotspots</code></li>
</ul>
<h2 id="citation">Citation</h2>
<ul>
<li>Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P.,
Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and
mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.</li>
</ul>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_data_id_string</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>A string to identify which feature data to download to the cache (see list of supported
feature data above).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>feature_data_filenames</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;,</code> or <code>list</code> of <code>instance &lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>If a single set of feature data is downloaded, a single pyGPlates <code>FeatureCollection</code>
object is returned. Otherwise, a list containing multiple pyGPlates <code>FeatureCollection</code>
objects is returned (like for <code>SeafloorFabric</code>). In the latter case, feature reconstruction
and plotting may have to be done iteratively.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a <code>feature_data_id_string</code> is not provided.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>For examples of plotting data downloaded with <code><a title="gplately.download.get_feature_data" href="#gplately.download.get_feature_data">get_feature_data()</a></code>, see GPlately's sample
notebook 05 - Working With Feature Geometries <a href="https://github.com/GPlates/gplately/blob/master/Notebooks/05-WorkingWithFeatureGeometries.ipynb">here</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_feature_data(self, feature_data_id_string=None):
    &#34;&#34;&#34;Downloads assorted geological feature data from web servers (i.e. 
    [GPlates 2.3 sample data](https://www.earthbyte.org/gplates-2-3-software-and-data-sets/))
    into the &#34;gplately&#34; cache.

    Currently, `DataServer` supports the following feature data:

    * __Large igneous provinces from Johansson et al. (2018)__

        Information
        -----------
        * Formats: .gpmlz
        * `feature_data_id_string` = `Johansson2018`

        Citations
        ---------
        * Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The 
        interplay between the eruption and weathering of Large Igneous Provinces and 
        the deep-time carbon cycle: Geophysical Research Letters.


    - __Large igneous province products interpreted as plume products from Whittaker 
    et al. (2015)__.

        Information
        -----------
        * Formats: .gpmlz, .shp
        * `feature_data_id_string` = `Whittaker2015`
        
        Citations
        ---------
        * Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D., 
        Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between 
        mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483. 
        doi:10.1038/ngeo2437.


    - __Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures, 
    unclassified V-anomalies, propagating ridge lineations and extinct ridges) from 
    Matthews et al. (2011)__

        Information
        -----------
        * Formats: .gpml
        * `feature_data_id_string` = `SeafloorFabric`

        Citations
        ---------
        * Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The 
        tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12): 
        B12109, DOI: 10.1029/2011JB008413. 


    - __Present day surface hotspot/plume locations from Whittaker et al. (2013)__

        Information
        -----------
        * Formats: .gpmlz
        * `feature_data_id_string` = `Hotspots`

        Citation
        --------
        * Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P., 
        Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and 
        mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.

    
    Parameters
    ----------
    feature_data_id_string : str, default=None
        A string to identify which feature data to download to the cache (see list of supported
        feature data above).

    Returns
    -------
    feature_data_filenames : instance of &lt;pygplates.FeatureCollection&gt;, or list of instance &lt;pygplates.FeatureCollection&gt;
        If a single set of feature data is downloaded, a single pyGPlates `FeatureCollection` 
        object is returned. Otherwise, a list containing multiple pyGPlates `FeatureCollection` 
        objects is returned (like for `SeafloorFabric`). In the latter case, feature reconstruction 
        and plotting may have to be done iteratively.

    Raises
    ------
    ValueError
        If a `feature_data_id_string` is not provided.

    Examples
    --------
    For examples of plotting data downloaded with `get_feature_data`, see GPlately&#39;s sample 
    notebook 05 - Working With Feature Geometries [here](https://github.com/GPlates/gplately/blob/master/Notebooks/05-WorkingWithFeatureGeometries.ipynb).
    &#34;&#34;&#34;
    if feature_data_id_string is None:
        raise ValueError(
            &#34;Please specify which feature data to fetch.&#34;
        )

    database = _gplately.data._feature_data()

    found_collection = False
    for collection, zip_url in database.items():
        if feature_data_id_string.lower() == collection.lower():
            found_collection = True
            feature_data_filenames = _collection_sorter(
                _collect_file_extension(
                download_from_web(zip_url[0], self.verbose), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                ),
                collection
            )

            break

    if found_collection is False:
        raise ValueError(&#34;{} are not in GPlately&#39;s DataServer.&#34;.format(feature_data_id_string))

    feat_data = _FeatureCollection()
    if len(feature_data_filenames) == 1:
            feat_data.add(_FeatureCollection(feature_data_filenames[0]))
            return feat_data
    else:    
        feat_data=[]
        for file in feature_data_filenames:
            feat_data.append(_FeatureCollection(file))
        return feat_data</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_plate_reconstruction_files"><code class="name flex">
<span>def <span class="ident">get_plate_reconstruction_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads and constructs a <code>rotation model</code>, a set of <code>topology_features</code> and
and a set of <code>static_polygons</code> needed to call the <code>PlateReconstruction</code> object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rotation_model</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.RotationModel&gt;</code></dt>
<dd>A rotation model to query equivalent and/or relative topological plate rotations
from a time in the past relative to another time in the past or to present day.</dd>
<dt><strong><code>topology_features</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>Point, polyline and/or polygon feature data that are reconstructable through
geological time.</dd>
<dt><strong><code>static_polygons</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>Present-day polygons whose shapes do not change through geological time. They are
used to cookie-cut dynamic polygons into identifiable topological plates (assigned
an ID) according to their present-day locations.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This method accesses the plate reconstruction model ascribed to the <code>file_collection</code> string passed
into the <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> object. For example, if the object was called with <code>"Muller2019"</code>:</p>
<pre><code>gDownload = gplately.download.DataServer("Muller2019")
rotation_model, topology_features, static_polygons = gDownload.get_plate_reconstruction_files()
</code></pre>
<p>the method will download a <code>rotation_model</code>, <code>topology_features</code> and <code>static_polygons</code> from the
Müller et al. (2019) plate reconstruction model. Once the reconstruction objects are returned,
they can be passed into:</p>
<pre><code>model = gplately.reconstruction.PlateReconstruction(rotation_model, topology_features, static_polygons)
</code></pre>
<ul>
<li>Note: If the requested plate model does not have a certain file(s), a message will be printed
to alert the user. For example, using <code>get_plate_reconstruction_files()</code>
for the Torsvik and Cocks (2017) plate reconstruction model yields the printed message:<pre><code>No topology features in TorsvikCocks2017. No FeatureCollection created - unable to 
plot trenches, ridges and transforms.
No continent-ocean boundaries in TorsvikCocks2017.
</code></pre>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plate_reconstruction_files(self):
    &#34;&#34;&#34;Downloads and constructs a `rotation model`, a set of `topology_features` and
    and a set of `static_polygons` needed to call the `PlateReconstruction` object.

    Returns
    -------
    rotation_model : instance of &lt;pygplates.RotationModel&gt;
        A rotation model to query equivalent and/or relative topological plate rotations
        from a time in the past relative to another time in the past or to present day.
    topology_features : instance of &lt;pygplates.FeatureCollection&gt;
        Point, polyline and/or polygon feature data that are reconstructable through 
        geological time.
    static_polygons : instance of &lt;pygplates.FeatureCollection&gt;
        Present-day polygons whose shapes do not change through geological time. They are
        used to cookie-cut dynamic polygons into identifiable topological plates (assigned 
        an ID) according to their present-day locations.

    Notes
    -----
    This method accesses the plate reconstruction model ascribed to the `file_collection` string passed 
    into the `DataServer` object. For example, if the object was called with `&#34;Muller2019&#34;`:

        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)
        rotation_model, topology_features, static_polygons = gDownload.get_plate_reconstruction_files()

    the method will download a `rotation_model`, `topology_features` and `static_polygons` from the 
    Müller et al. (2019) plate reconstruction model. Once the reconstruction objects are returned, 
    they can be passed into:

        model = gplately.reconstruction.PlateReconstruction(rotation_model, topology_features, static_polygons)

    * Note: If the requested plate model does not have a certain file(s), a message will be printed 
    to alert the user. For example, using `get_plate_reconstruction_files()`
    for the Torsvik and Cocks (2017) plate reconstruction model yields the printed message:

            No topology features in TorsvikCocks2017. No FeatureCollection created - unable to 
            plot trenches, ridges and transforms.
            No continent-ocean boundaries in TorsvikCocks2017.

    &#34;&#34;&#34;

    verbose = self.verbose

    rotation_filenames = []
    rotation_model = []
    topology_filenames = []
    topology_features = _FeatureCollection()
    static_polygons= _FeatureCollection()
    static_polygon_filenames = []

    # Locate all plate reconstruction files from GPlately&#39;s DataCollection
    database = DataCollection.plate_reconstruction_files(self)

    # Set to true if we find the given collection in our database
    found_collection = False
    for collection, url in database.items():

        # Only continue if the user&#39;s chosen collection exists in our database
        if self.file_collection.lower() == collection.lower():
            found_collection = True
            if len(url) == 1:
                fnames = _collection_sorter(
                    download_from_web(url[0], verbose, model_name=self.file_collection), self.file_collection
                )
                rotation_filenames = _collect_file_extension(
                    _str_in_folder(
                        _str_in_filename(fnames,
                            strings_to_ignore=DataCollection.rotation_strings_to_ignore(self)
                        ),
                    strings_to_ignore=DataCollection.rotation_strings_to_ignore(self)
                    ),
                    [&#34;.rot&#34;]
                )
                #print(rotation_filenames)
                rotation_model = _RotationModel(rotation_filenames)

                topology_filenames = _collect_file_extension(
                    _str_in_folder(
                        _str_in_filename(fnames, 
                            strings_to_include=DataCollection.dynamic_polygon_strings_to_include(self),
                            strings_to_ignore=DataCollection.dynamic_polygon_strings_to_ignore(self)
                        ), 
                        strings_to_ignore=DataCollection.dynamic_polygon_strings_to_ignore(self)
                    ),
                    [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                )
                #print(topology_filenames)
                for file in topology_filenames:
                    topology_features.add(_FeatureCollection(file))

                static_polygon_filenames = _check_gpml_or_shp(
                    _str_in_folder(
                        _str_in_filename(fnames, 
                            strings_to_include=DataCollection.static_polygon_strings_to_include(self),
                            strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                        ),
                        strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                    )
                )
                #print(static_polygon_filenames)
                for stat in static_polygon_filenames:
                    static_polygons.add(_FeatureCollection(stat))

            else:
                for file in url[0]:
                    rotation_filenames.append(_collect_file_extension(download_from_web(file, verbose, model_name=self.file_collection), [&#34;.rot&#34;]))
                    rotation_model = _RotationModel(rotation_filenames)

                for file in url[1]:
                    topology_filenames.append(_collect_file_extension(download_from_web(file, verbose, model_name=self.file_collection), [&#34;.gpml&#34;]))
                    for file in topology_filenames:
                        topology_features.add(_FeatureCollection(file))

                for file in url[2]:
                    static_polygon_filenames.append(
                        _check_gpml_or_shp(
                            _str_in_folder(
                                _str_in_filename(download_from_web(url[0], verbose, model_name=self.file_collection), 
                                    strings_to_include=DataCollection.static_polygon_strings_to_include(self)
                                ),    
                                    strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                            )
                        )   
                    )
                    for stat in static_polygon_filenames:
                        static_polygons.add(_FeatureCollection(stat))
            break

    if found_collection is False:
        raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

    if not rotation_filenames:
        print(&#34;No .rot files in {}. No rotation model created.&#34;.format(self.file_collection))
        rotation_model = []
    if not topology_filenames:
        print(&#34;No topology features in {}. No FeatureCollection created - unable to plot trenches, ridges and transforms.&#34;.format(self.file_collection))
        topology_features = []
    if not static_polygons:
        print(&#34;No static polygons in {}.&#34;.format(self.file_collection))
        static_polygons = []

    # add identifier for setting up DownloadServer independently
    rotation_model.reconstruction_identifier = self.file_collection

    return rotation_model, topology_features, static_polygons</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_raster"><code class="name flex">
<span>def <span class="ident">get_raster</span></span>(<span>self, raster_id_string=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads assorted raster data that are not associated with the plate
reconstruction models supported by GPlately's <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code>. Stores rasters in the
"gplately" cache.</p>
<p>Currently, <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> supports the following rasters and images:</p>
<ul>
<li><strong><a href="https://www.ngdc.noaa.gov/mgg/global/">ETOPO1</a></strong>: <ul>
<li>Filetypes available : TIF, netCDF (GRD)</li>
<li><code>raster_id_string</code> = <code>"ETOPO1_grd"</code>, <code>"ETOPO1_tif"</code> (depending on the requested format)</li>
<li>A 1-arc minute global relief model combining lang topography and ocean bathymetry.</li>
<li>Citation: doi:10.7289/V5C8276M</li>
</ul>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>raster_id_string</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>A string to identify which raster to download.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>raster_filenames</code></strong> :&ensp;<code>ndarray</code> or <code>MaskedArray</code></dt>
<dd>An ndarray or MaskedArray of the cached raster. This can be plotted using
<code>matplotlib.pyplot.imshow</code> on a <code>cartopy.mpl.GeoAxis</code> GeoAxesSubplot (see example below).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>
<ul>
<li>if a <code>raster_id_string</code> is not supplied.</li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Rasters obtained by this method are (so far) only reconstructed to present-day. </p>
<h2 id="examples">Examples</h2>
<p>To download ETOPO1 and plot it on a Mollweide projection:</p>
<pre><code>import gplately
import numpy as np
import matplotlib.pyplot as plt
import cartopy.crs as ccrs

gdownload = gplately.DataServer("Muller2019")
etopo1 = gdownload.get_raster("ETOPO1_tif")
fig = plt.figure(figsize=(18,14), dpi=300)
ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
ax2.imshow(etopo1, extent=[-180,180,-90,90], transform=ccrs.PlateCarree())
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raster(self, raster_id_string=None):
    &#34;&#34;&#34;Downloads assorted raster data that are not associated with the plate 
    reconstruction models supported by GPlately&#39;s `DataServer`. Stores rasters in the 
    &#34;gplately&#34; cache.

    Currently, `DataServer` supports the following rasters and images:

    * __[ETOPO1](https://www.ngdc.noaa.gov/mgg/global/)__: 
        * Filetypes available : TIF, netCDF (GRD)
        * `raster_id_string` = `&#34;ETOPO1_grd&#34;`, `&#34;ETOPO1_tif&#34;` (depending on the requested format)
        * A 1-arc minute global relief model combining lang topography and ocean bathymetry.
        * Citation: doi:10.7289/V5C8276M


    Parameters
    ----------
    raster_id_string : str, default=None
        A string to identify which raster to download.

    Returns
    -------
    raster_filenames : ndarray or MaskedArray
        An ndarray or MaskedArray of the cached raster. This can be plotted using 
        `matplotlib.pyplot.imshow` on a `cartopy.mpl.GeoAxis` GeoAxesSubplot (see example below).

    Raises
    ------
    ValueError
        * if a `raster_id_string` is not supplied.

    Notes
    -----
    Rasters obtained by this method are (so far) only reconstructed to present-day. 

    Examples
    --------
    To download ETOPO1 and plot it on a Mollweide projection:

        import gplately
        import numpy as np
        import matplotlib.pyplot as plt
        import cartopy.crs as ccrs

        gdownload = gplately.DataServer(&#34;Muller2019&#34;)
        etopo1 = gdownload.get_raster(&#34;ETOPO1_tif&#34;)
        fig = plt.figure(figsize=(18,14), dpi=300)
        ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
        ax2.imshow(etopo1, extent=[-180,180,-90,90], transform=ccrs.PlateCarree()) 

    &#34;&#34;&#34;
    from matplotlib import image
    if raster_id_string is None:
        raise ValueError(
            &#34;Please specify which raster to download.&#34;
        )
    #filetype = &#34;.&#34;+&#34;_&#34;.split(raster_id_string)[-1]

    archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
    grid_extensions = tuple([&#34;.grd&#34;, &#34;.nc&#34;])

    # Set to true if we find the given collection in database
    found_collection = False
    raster_filenames = []
    database = _gplately.data._rasters()

    for collection, zip_url in database.items():
        # Isolate the raster name and the file type
        #raster_name = collection.split(&#34;_&#34;)[0]
        #raster_type = &#34;.&#34;+collection.split(&#34;_&#34;)[-1]
        if (raster_id_string.lower() == collection.lower()):
            raster_filenames = download_from_web(zip_url[0], self.verbose)
            found_collection = True
            break

    if found_collection is False:
        raise ValueError(&#34;{} not in collection database.&#34;.format(raster_id_string))
    else:
        # If the downloaded raster is a grid, process it with the gplately.Raster object
        if any(grid_extension in raster_filenames for grid_extension in grid_extensions):
            raster_matrix = _gplately.grids.Raster(data=raster_filenames).data

        # Otherwise, the raster is an image; use imread to process
        else:
            raster_matrix = image.imread(raster_filenames)
    return raster_matrix</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_spreading_rate_grid"><code class="name flex">
<span>def <span class="ident">get_spreading_rate_grid</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads seafloor spreading rate grids from the plate reconstruction
model (<code>file_collection</code>) passed into the <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> object. Stores
grids in the "gplately" cache.</p>
<p>Currently, <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> supports spreading rate grids from the following plate
models:</p>
<ul>
<li>
<p><strong>Clennett et al. 2020</strong></p>
<ul>
<li><code>file_collection</code> = <code>Clennett2020</code></li>
<li>Time range: 0-250 Ma</li>
<li>Seafloor spreading rate grids in netCDF format.</li>
</ul>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>int,</code> or <code>list</code> of <code>int</code>, default=<code>None</code></dt>
<dd>Request a spreading grid from one (an integer) or multiple reconstruction
times (a list of integers).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>raster_array</code></strong> :&ensp;<code>MaskedArray</code></dt>
<dd>A masked array containing the netCDF4 spreading rate grid ready for
plotting or for passing into GPlately's <code>Raster</code> object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>time</code> (a single integer, or a list of integers representing reconstruction
times to extract the spreading rate grids from) is not passed.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The first time that <code>get_spreading_rate_grid</code> is called for a specific time(s),
the spreading rate grid(s) will be downloaded into the GPlately cache once.
Upon successive calls of <code>get_spreading_rate_grid</code> for the same reconstruction
time(s), the grids will not be re-downloaded; rather, they are re-accessed from
the same cache location provided they have not been moved or deleted. </p>
<h2 id="examples">Examples</h2>
<p>if the <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> object was called with the <code>Clennett2020</code> <code>file_collection</code> string:</p>
<pre><code>gDownload = gplately.download.DataServer("Clennett2020")
</code></pre>
<p><code>get_spreading_rate_grid</code> will download seafloor spreading rate grids from the
Clennett et al. (2020) plate reconstruction model for the geological time(s)
requested in the <code>time</code> parameter. When found, these spreading rate grids are
returned as masked arrays. </p>
<p>For example, to download Clennett et al. (2020) seafloor spreading rate grids for
0Ma, 1Ma and 100 Ma as MaskedArray objects:</p>
<pre><code>spreading_rate_grids = gDownload.get_spreading_rate_grid([0, 1, 100])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_spreading_rate_grid(self, time):
    &#34;&#34;&#34;Downloads seafloor spreading rate grids from the plate reconstruction 
    model (`file_collection`) passed into the `DataServer` object. Stores 
    grids in the &#34;gplately&#34; cache.

    Currently, `DataServer` supports spreading rate grids from the following plate
    models:

    * __Clennett et al. 2020__

        * `file_collection` = `Clennett2020`
        * Time range: 0-250 Ma
        * Seafloor spreading rate grids in netCDF format.

    
    Parameters
    ----------
    time : int, or list of int, default=None
        Request a spreading grid from one (an integer) or multiple reconstruction 
        times (a list of integers).

    Returns
    -------
    raster_array : MaskedArray
        A masked array containing the netCDF4 spreading rate grid ready for 
        plotting or for passing into GPlately&#39;s `Raster` object.

    Raises
    -----
    ValueError
        If `time` (a single integer, or a list of integers representing reconstruction
        times to extract the spreading rate grids from) is not passed.

    Notes
    -----
    The first time that `get_spreading_rate_grid` is called for a specific time(s), 
    the spreading rate grid(s) will be downloaded into the GPlately cache once. 
    Upon successive calls of `get_spreading_rate_grid` for the same reconstruction 
    time(s), the grids will not be re-downloaded; rather, they are re-accessed from 
    the same cache location provided they have not been moved or deleted. 

    Examples
    --------
    if the `DataServer` object was called with the `Clennett2020` `file_collection` string:

        gDownload = gplately.download.DataServer(&#34;Clennett2020&#34;)

    `get_spreading_rate_grid` will download seafloor spreading rate grids from the 
    Clennett et al. (2020) plate reconstruction model for the geological time(s) 
    requested in the `time` parameter. When found, these spreading rate grids are 
    returned as masked arrays. 

    For example, to download Clennett et al. (2020) seafloor spreading rate grids for 
    0Ma, 1Ma and 100 Ma as MaskedArray objects:

        spreading_rate_grids = gDownload.get_spreading_rate_grid([0, 1, 100])
        
    &#34;&#34;&#34;
    spreading_rate_grids = []
    spreading_rate_grid_links = DataCollection.netcdf4_spreading_rate_grids(self, time)

    if not isinstance(time, list):
        time = [time]

    # For a single time passed that isn&#39;t in the valid time range, 
    if not spreading_rate_grid_links:
        raise ValueError(
            &#34;{} {}Ma spreading rate grids are not on GPlately&#39;s DataServer.&#34;.format(
                self.file_collection,
                time[0]
            )
        )
    # For a list of times passed...
    for i, link in enumerate(spreading_rate_grid_links):
        if not link:
            raise ValueError(
                &#34;{} {}Ma spreading rate grids are not on GPlately&#39;s DataServer.&#34;.format(
                    self.file_collection,
                    time[i]
                )
            )
        spreading_rate_grid_file = download_from_web(
            link, 
            verbose=self.verbose, 
            model_name=self.file_collection
        )
        spreading_rate_grid = _gplately.grids.read_netcdf_grid(spreading_rate_grid_file)
        spreading_rate_grids.append(spreading_rate_grid)

    # One last check to alert user if the masked array grids were not processed properly
    if not spreading_rate_grids:
        raise ValueError(&#34;{} netCDF4 seafloor spreading rate grids not found.&#34;.format(self.file_collection))

    if len(spreading_rate_grids) == 1:
        return spreading_rate_grids[0]
    else: 
        return spreading_rate_grids</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_topology_geometries"><code class="name flex">
<span>def <span class="ident">get_topology_geometries</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses Pooch to download coastline, continent and COB (continent-ocean boundary)
Shapely geometries from the requested plate model. These are needed to call the <code>PlotTopologies</code>
object and visualise topological plates through time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Toggle print messages regarding server/internet connection status, file availability etc.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>coastlines</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>Present-day global coastline Shapely polylines cookie-cut using static polygons. Ready for
reconstruction to a particular geological time and for plotting.</dd>
<dt><strong><code>continents</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>Cookie-cutting Shapely polygons for non-oceanic regions (continents, inta-oceanic arcs, etc.)
ready for reconstruction to a particular geological time and for plotting.</dd>
<dt><strong><code>COBs</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>Shapely polylines resolved from .shp and/or .gpml topology files that represent the
locations of the boundaries between oceanic and continental crust.
Ready for reconstruction to a particular geological time and for plotting.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This method accesses the plate reconstruction model ascribed to the <code>file_collection</code>
string passed into the <code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code> object. For example, if the object was called with
<code>"Muller2019"</code>:</p>
<pre><code>gDownload = gplately.download.DataServer("Muller2019")
coastlines, continents, COBs = gDownload.get_topology_geometries()
</code></pre>
<p>the method will attempt to download <code>coastlines</code>, <code>continents</code> and <code>COBs</code> from the Müller
et al. (2019) plate reconstruction model. If found, these files are returned as individual
pyGPlates Feature Collections. They can be passed into:</p>
<pre><code>gPlot = gplately.plot.PlotTopologies(gplately.reconstruction.PlateReconstruction, time, continents, coastlines, COBs)
</code></pre>
<p>to reconstruct features to a certain geological time. The <code>PlotTopologies</code>
object provides simple methods to plot these geometries along with trenches, ridges and
transforms (see documentation for more info). Note that the <code>PlateReconstruction</code> object
is a parameter.</p>
<ul>
<li>Note: If the requested plate model does not have a certain geometry, a
message will be printed to alert the user. For example, if <code>get_topology_geometries()</code>
is used with the <code>"Matthews2016"</code> plate model, the workflow will print the following
message: <pre><code>No continent-ocean boundaries in Matthews2016.
</code></pre>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_topology_geometries(self):
    &#34;&#34;&#34;Uses Pooch to download coastline, continent and COB (continent-ocean boundary)
    Shapely geometries from the requested plate model. These are needed to call the `PlotTopologies`
    object and visualise topological plates through time.

    Parameters
    ----------
    verbose : bool, default True
        Toggle print messages regarding server/internet connection status, file availability etc.

    Returns
    -------
    coastlines : instance of &lt;pygplates.FeatureCollection&gt;
        Present-day global coastline Shapely polylines cookie-cut using static polygons. Ready for
        reconstruction to a particular geological time and for plotting.

    continents : instance of &lt;pygplates.FeatureCollection&gt;
        Cookie-cutting Shapely polygons for non-oceanic regions (continents, inta-oceanic arcs, etc.)
        ready for reconstruction to a particular geological time and for plotting.

    COBs : instance of &lt;pygplates.FeatureCollection&gt;
        Shapely polylines resolved from .shp and/or .gpml topology files that represent the 
        locations of the boundaries between oceanic and continental crust.
        Ready for reconstruction to a particular geological time and for plotting.

    Notes
    -----
    This method accesses the plate reconstruction model ascribed to the `file_collection` 
    string passed into the `DataServer` object. For example, if the object was called with
    `&#34;Muller2019&#34;`:

        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)
        coastlines, continents, COBs = gDownload.get_topology_geometries()

    the method will attempt to download `coastlines`, `continents` and `COBs` from the Müller
    et al. (2019) plate reconstruction model. If found, these files are returned as individual 
    pyGPlates Feature Collections. They can be passed into:

        gPlot = gplately.plot.PlotTopologies(gplately.reconstruction.PlateReconstruction, time, continents, coastlines, COBs)

    to reconstruct features to a certain geological time. The `PlotTopologies`
    object provides simple methods to plot these geometries along with trenches, ridges and 
    transforms (see documentation for more info). Note that the `PlateReconstruction` object 
    is a parameter.

    * Note: If the requested plate model does not have a certain geometry, a
    message will be printed to alert the user. For example, if `get_topology_geometries()` 
    is used with the `&#34;Matthews2016&#34;` plate model, the workflow will print the following 
    message: 

            No continent-ocean boundaries in Matthews2016.
    &#34;&#34;&#34;

    verbose = self.verbose

    # Locate all topology geometries from GPlately&#39;s DataCollection
    database = DataCollection.topology_geometries(self)

    coastlines = []
    continents = []
    COBs = []
    
    # Find the requested plate model data collection
    found_collection = False
    for collection, url in database.items():

        if self.file_collection.lower() == collection.lower():
            found_collection = True

            if len(url) == 1:
                # Some plate models do not have reconstructable geometries i.e. Li et al. 2008
                if url[0] is None:
                    break
                else:
                    fnames = _collection_sorter(
                        download_from_web(url[0], verbose, model_name=self.file_collection), self.file_collection
                    )
                    coastlines = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(
                                fnames,
                                strings_to_include=DataCollection.coastline_strings_to_include(self),
                                strings_to_ignore=DataCollection.coastline_strings_to_ignore(self)
                            ), 
                            strings_to_ignore=DataCollection.coastline_strings_to_ignore(self)
                        )
                    )
                    continents = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(
                                fnames, 
                                strings_to_include=DataCollection.continent_strings_to_include(self),
                                strings_to_ignore=DataCollection.continent_strings_to_ignore(self)
                            ), 
                            strings_to_ignore=DataCollection.continent_strings_to_ignore(self)
                        )
                    )
                    COBs = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(
                                fnames,
                                strings_to_include=DataCollection.COB_strings_to_include(self),
                                strings_to_ignore=DataCollection.COB_strings_to_ignore(self)
                            ), 
                            strings_to_ignore=DataCollection.COB_strings_to_ignore(self)
                        )
                    )
            else:
                for file in url[0]:
                    if url[0] is not None:
                        coastlines.append(_str_in_filename(
                            download_from_web(file, verbose, model_name=self.file_collection), 
                            strings_to_include=[&#34;coastline&#34;])
                        )
                        coastlines = _check_gpml_or_shp(coastlines)
                    else:
                        coastlines = []

                for file in url[1]:
                    if url[1] is not None:
                        continents.append(_str_in_filename(
                            download_from_web(file, verbose, model_name=self.file_collection), 
                            strings_to_include=[&#34;continent&#34;])
                        )
                        continents = _check_gpml_or_shp(continents)
                    else:
                        continents = []

                for file in url[2]:
                    if url[2] is not None:
                        COBs.append(_str_in_filename(
                            download_from_web(file, verbose, model_name=self.file_collection), 
                            strings_to_include=[&#34;cob&#34;])
                        )
                        COBs = _check_gpml_or_shp(COBs)
                    else:
                        COBs = []
            break

    if found_collection is False:
        raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

    if not coastlines:
        print(&#34;No coastlines in {}.&#34;.format(self.file_collection))
        coastlines_featurecollection = []
    else:
        #print(coastlines)
        coastlines_featurecollection = _FeatureCollection()
        for coastline in coastlines:
            coastlines_featurecollection.add(_FeatureCollection(coastline))
    
    if not continents:
        print(&#34;No continents in {}.&#34;.format(self.file_collection))
        continents_featurecollection = []
    else:
        #print(continents)
        continents_featurecollection = _FeatureCollection()
        for continent in continents:
            continents_featurecollection.add(_FeatureCollection(continent))
    
    if not COBs:
        print(&#34;No continent-ocean boundaries in {}.&#34;.format(self.file_collection))
        COBs_featurecollection = []
    else:
        #print(COBs)
        COBs_featurecollection = _FeatureCollection()
        for COB in COBs:
            COBs_featurecollection.add(_FeatureCollection(COB))
    
    geometries = coastlines_featurecollection, continents_featurecollection, COBs_featurecollection
    return geometries</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_valid_times"><code class="name flex">
<span>def <span class="ident">get_valid_times</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple of the valid plate model time range, (min_time, max_time).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_times(self):
    &#34;&#34;&#34;Returns a tuple of the valid plate model time range, (min_time, max_time).
    &#34;&#34;&#34;
    all_model_valid_times = DataCollection.plate_model_valid_reconstruction_times(self)

    min_time = None
    max_time = None
    for plate_model_name, valid_times in list(all_model_valid_times.items()):
        if plate_model_name.lower() == self.file_collection.lower():
            min_time = valid_times[0]
            max_time = valid_times[1]
    if not min_time and not max_time:
        raise ValueError(&#34;Could not find the valid reconstruction time of {}&#34;.format(self.file_collection))

    return (min_time, max_time)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GPlately Home" href="https://gplates.github.io/gplately/">
<img src="https://raw.githubusercontent.com/GPlates/gplately/master/Notebooks/NotebookFiles/ReadMe_Files/GPlately_Main_logo.png" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="gplately.download.clear_cache" href="#gplately.download.clear_cache">clear_cache</a></code></li>
<li><code><a title="gplately.download.download_from_web" href="#gplately.download.download_from_web">download_from_web</a></code></li>
<li><code><a title="gplately.download.get_feature_data" href="#gplately.download.get_feature_data">get_feature_data</a></code></li>
<li><code><a title="gplately.download.get_raster" href="#gplately.download.get_raster">get_raster</a></code></li>
<li><code><a title="gplately.download.path_of_cached_file" href="#gplately.download.path_of_cached_file">path_of_cached_file</a></code></li>
<li><code><a title="gplately.download.path_to_cache" href="#gplately.download.path_to_cache">path_to_cache</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code></h4>
<ul class="">
<li><code><a title="gplately.download.DataServer.get_age_grid" href="#gplately.download.DataServer.get_age_grid">get_age_grid</a></code></li>
<li><code><a title="gplately.download.DataServer.get_feature_data" href="#gplately.download.DataServer.get_feature_data">get_feature_data</a></code></li>
<li><code><a title="gplately.download.DataServer.get_plate_reconstruction_files" href="#gplately.download.DataServer.get_plate_reconstruction_files">get_plate_reconstruction_files</a></code></li>
<li><code><a title="gplately.download.DataServer.get_raster" href="#gplately.download.DataServer.get_raster">get_raster</a></code></li>
<li><code><a title="gplately.download.DataServer.get_spreading_rate_grid" href="#gplately.download.DataServer.get_spreading_rate_grid">get_spreading_rate_grid</a></code></li>
<li><code><a title="gplately.download.DataServer.get_topology_geometries" href="#gplately.download.DataServer.get_topology_geometries">get_topology_geometries</a></code></li>
<li><code><a title="gplately.download.DataServer.get_valid_times" href="#gplately.download.DataServer.get_valid_times">get_valid_times</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>