<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gplately.download API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.download</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pooch as _pooch
from pooch import os_cache as _os_cache
from pooch import retrieve as _retrieve
from pooch import HTTPDownloader as _HTTPDownloader
from pooch import Unzip as _Unzip
from pooch import Decompress as _Decompress
import pygplates as _pygplates
import re as _re
import numpy as _np

def _fetch_from_web(url):
    &#34;&#34;&#34;Download file(s) in a given url to the &#39;gplately&#39; cache folder. Processes
    compressed files using either Pooch&#39;s Unzip (if .zip) or Decompress (if .gz, 
    .xz or .bz2).&#34;&#34;&#34;
    def pooch_retrieve(url, processor):
        &#34;&#34;&#34;Downloads file(s) from a URL using Pooch.&#34;&#34;&#34;
        fnames = _retrieve(
            url=url,
            known_hash=None,  
            downloader=_HTTPDownloader(progressbar=True),
            path=_os_cache(&#39;gplately&#39;),
            processor=processor)
        return fnames

    archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
    if url.endswith(&#34;.zip&#34;):
        fnames = pooch_retrieve(url, processor=_Unzip())
    elif url.endswith(archive_formats):
        fnames = pooch_retrieve(url, processor=_Decompress())
    else:
        fnames = pooch_retrieve(url, processor=None)
    return fnames


def _collect_file_extension(fnames, file_extension):
    &#34;&#34;&#34;Searches cached directory for filenames with a specified extension(s).&#34;&#34;&#34;
    sorted_fnames = []
    file_extension=tuple(file_extension)
    for file in fnames:
        if file.endswith(file_extension):
            sorted_fnames.append(file)
    return sorted_fnames


def _str_in_folder(fnames, strings_to_include=None, strings_to_ignore=None):
    &#34;&#34;&#34;Filter though files with/without &#34;&#34;&#34;
    sorted_fnames = []
    for i, fname in enumerate(fnames):
        parent_directory = fname.split(&#34;/&#34;)[:-1]
        if strings_to_ignore is not None:
            check = [s for s in strings_to_ignore if s in parent_directory]
            if check:
                continue
        if strings_to_include is not None:
            if any(x.lower() in fname.lower() for x in strings_to_include):
                sorted_fnames.append(fname)
        else:
            sorted_fnames.append(fname)
    #if sorted_fnames:
        #return sorted_fnames
    #else:
    return sorted_fnames
    

def _str_in_filename(fnames, strings_to_include=None, strings_to_ignore=None):
    sorted_fnames = []
    if strings_to_ignore is not None:
        for f in fnames:
            f = f.split(&#34;/&#34;)[-1]
            check = [s for s in strings_to_ignore if s.lower() in f.lower()]
    if strings_to_include is not None:
        for s in strings_to_include:
            for f in fnames:
                fname = f.split(&#34;/&#34;)[-1]
                if s.lower() in fname.lower():
                    sorted_fnames.append(f)
            if sorted_fnames:
                break
    #if sorted_fnames:
        #return sorted_fnames
    #else:
    return sorted_fnames


def _check_gpml_or_shp(fnames):
    &#34;&#34;&#34;For topology features, returns GPML by default. Searches for ESRI Shapefiles 
    instead if GPML files not found.&#34;&#34;&#34;
    sorted_fnames = []
    for file in fnames:
        if file.endswith(&#34;.gpml&#34;):
            sorted_fnames.append(file)
    if not sorted_fnames:
        for file in fnames:
            if file.endswith(&#34;.shp&#34;):
                sorted_fnames.append(file)
    return sorted_fnames


def _remove_hash(fname):
    &#34;&#34;&#34;Removes hashes (32 character file IDs) from cached filenames.&#34;&#34;&#34;
    split_paths = fname.split(&#34;-&#34;)
    cache_path = split_paths[0][:-32]
    new_path = cache_path + &#34;-&#34;.join(split_paths[1:])
    return new_path


def _order_filenames_by_time(fnames):
    &#34;&#34;&#34;Orders filenames in a list from present day to deeper geological time if they
    are labelled by time.&#34;&#34;&#34;
    # Collect all digits in each filename.
    filepath_digits=[]
    for i, file in enumerate(fnames):
        digits = []
        for element in _re.split(&#39;([0-9]+)&#39;, _remove_hash(file)):
            if element.isdigit():
                digits.append(int(str(element)))
        filepath_digits.append(digits)

    # Ignore digits common to all full file paths. This leaves behind the files&#39; 
    # geological time label.
    geological_times = []
    filepath_digits = _np.array(filepath_digits).T
    for digit_array in filepath_digits:
        if not all(digit == digit_array[0] for digit in digit_array):
            geological_times.append(digit_array)

    # If files have geological time labels, allocate indices to the current filename order, 
    # and sort files from recent to deep geological time.
    if geological_times:
        sorted_geological_times = sorted(
            enumerate(geological_times[0]), 
            key=lambda x: x[1]
        )
        sorted_geological_time_indices = [geo_time[0] for geo_time in sorted_geological_times]
        filenames_sorted = [fnames[index] for index in sorted_geological_time_indices]
    else:
        # If given filenames do not have a time label, return them as is.
        filenames_sorted = fnames
    return filenames_sorted


def _collection_sorter(fnames, string_identifier):
    &#34;&#34;&#34;If multiple file collections or plate reconstruction models are downloaded from
    a single zip folder, only return the needed model.&#34;&#34;&#34;
    studyname = _re.findall(r&#39;[A-Za-z]+|\d+&#39;, string_identifier)[0]
    newfnames = []
    for files in fnames:
        if studyname not in files:
            continue
        newfnames.append(files)
    return newfnames


def _ignore_macOSX(fnames):
    &#34;&#34;&#34;For Mac users: filters out duplicate filenames extracted from the __MACOSX folder.&#34;&#34;&#34;
    for fname in fnames:
        if fname.find(&#34;__MACOSX&#34;) != -1:
            fnames.remove(fname)
    return fnames


class DataServer(object):
    &#34;&#34;&#34;Uses Pooch to download geological feature data from plate reconstruction models and other studies
    that are stored on web servers (e.g. EarthByte&#39;s webDAV server). Downloaded files are kept in
    a &#39;gplately&#39; cache folder. 

    Currently,DataServer supports the following plate reconstruction models:
    +-----------------------+-----------------------------------------------------------+-------------------+
    | Plate reconstruction  | Paper citation                                            | String identifier |
    | model                 |                                                           |                   |
    +-----------------------+-----------------------------------------------------------+-------------------+
    | Muller et al. 2019    | Müller, R. D., Zahirovic, S., Williams, S. E.,            | &#34;Muller2019&#34;      |
    |                       | Cannon, J., Seton, M., Bower, D. J., Tetley, M. G.,       |                   |
    |                       | Heine, C., Le Breton, E., Liu, S., Russell, S. H. J.,     |                   |
    |                       | Yang, T., Leonard, J., and Gurnis, M. (2019),             |                   |
    |                       | A global plate model including lithospheric deformation   |                   |
    |                       | along major rifts and orogens since the Triassic.         |                   |
    |                       | Tectonics, vol. 38, https://doi.org/10.1029/2018TC005462. |                   |
    +-----------------------+-----------------------------------------------------------+-------------------+
    | Merdith et al. 2021   | Andrew S. Merdith, Simon E. Williams, Alan S. Collins,    | &#34;Merdith2021&#34;     |
    |                       | Michael G. Tetley, Jacob A. Mulder, Morgan L. Blades,     |                   |
    |                       | Alexander Young, Sheree E. Armistead, John Cannon,        |                   |
    |                       | Sabin Zahirovic, R. Dietmar Müller, (2021).               |                   |
    |                       | Extending full-plate tectonic models into deep time:      |                   |
    |                       | Linking the Neoproterozoic and the Phanerozoic,           |                   |
    |                       | Earth-Science Reviews, Volume 214, 2021, 103477,          |                   |
    |                       | ISSN 0012-8252,                                           |                   |
    |                       | https://doi.org/10.1016/j.earscirev.2020.103477.          |                   |
    +-----------------------+-----------------------------------------------------------+-------------------+
    |                       |                                                           |                   |
    +-----------------------+-----------------------------------------------------------+-------------------+


    Methods
    -------
    get_plate_reconstruction_files
        Downloads the `rotation_model`, `topology_features`, and `static_polygons` needed to create an
        instance of the gplately.reconstruct.PlateReconstruction object.
    get_topology_geometries
        Downloads the `coastlines`, `continents` and `COBs` needed to create an instance of the
        gplately.plot.PlotTopologies object.
    get_netcdf_rasters
        Downloads netCDF (.nc) and .grd rasters, as well as .tif images

    Examples
    --------
    Calling the object: 
        # string identifier to access the Muller et al. 2019 model
        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    &#34;&#34;&#34;
    def __init__(self, file_collection=None):
        if file_collection is None:
            raise ValueError(
                &#34;Please supply a file collection to fetch.&#34;
            )
        self.file_collection = file_collection

    def get_plate_reconstruction_files(self):
        &#34;&#34;&#34;Downloads and constructs a rotation model, a pygplates.FeatureCollection and a set of 
        static polygons needed to call the gplately.PlateReconstruction object.

        Notes
        -----
        This method accesses the plate reconstruction model requested in the gplately.DataServer
        object. For example, if the object was called as:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        the method will download:
            - a rotation file
            - GPML topology features
            - static polygons
        from the Muller et al. (2019) plate reconstruction model.
        &#34;&#34;&#34;
        database = {

            &#34;Muller2019&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_PlateMotionModel/Muller_etal_2019_PlateMotionModel_v2.0_Tectonics.zip&#34;], 
            &#34;Muller2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2016_AREPS/Muller_etal_2016_AREPS_Supplement/Muller_etal_2016_AREPS_Supplement_v1.17.zip&#34;],
            &#34;Seton2012&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Rotations/Seton_etal_ESR2012_2012.1.rot&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Plate_polygons/Seton_etal_ESR2012_PP_2012.1.gpml&#34;,
                          None], 
            &#34;Merdith2021&#34; : [&#34;https://zenodo.org/record/4485738/files/SM2_4485738_V2.zip&#34;],
            &#34;Matthews2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Matthews_etal_2016_Global_Plate_Model_GPC.zip&#34;], 
            &#34;Merdith2017&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Merdith_etal_2017_GR.zip&#34;], 

        }

        # Set to true if we find the given collection in our database
        found_collection = False
        for collection, url in database.items():

            # Only continue if the user&#39;s chosen collection exists in our database
            if self.file_collection.lower() == collection.lower():
                found_collection = True
                rotation_filenames = []
                topology_features = _pygplates.FeatureCollection()
                static_polygons = []

                if len(url) == 1:
                    fnames = _collection_sorter(
                        _fetch_from_web(url[0]), self.file_collection
                    )
                    rotation_filenames = _collect_file_extension(
                        fnames, [&#34;.rot&#34;]
                    )
                    rotation_model = _pygplates.RotationModel(rotation_filenames)

                    topology_filenames = _collect_file_extension(
                        _str_in_folder(fnames, strings_to_ignore=[&#34;__MACOSX&#34;]),
                        [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                    )
                    for file in topology_filenames:
                        topology_features.add(_pygplates.FeatureCollection(file))

                    static_polygons = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, 
                                strings_to_include=[&#34;Static&#34;, &#34;StaticPolygon&#34;, &#34;Static_Polygon&#34;]
                            ),
                            strings_to_ignore=[&#34;__MACOSX&#34;]
                        )
                    )
                else:
                    for file in url[0]:
                        rotation_filenames.append(
                            _collect_file_extension(
                                _fetch_from_web(file), [&#34;.rot&#34;])
                        )
                        rotation_model = _pygplates.RotationModel(rotation_filenames)

                    for file in url[1]:
                        topology_filenames.append(
                            _collect_file_extension(
                                _fetch_from_web(file), [&#34;.gpml&#34;])
                        )
                        for file in topology_filenames:
                            topology_features.add(
                                _pygplates.FeatureCollection(file)
                            )

                    for file in url[2]:
                        static_polygons.append(
                            _check_gpml_or_shp(
                                _str_in_folder(
                                    _str_in_filename(_fetch_from_web(url[0]), 
                                        strings_to_include=[&#34;Static&#34;, &#34;StaticPolygon&#34;, &#34;Static_Polygon&#34;]
                                    ),    
                                        strings_to_ignore=[&#34;__MACOSX&#34;]
                                )
                            )   
                        )
                break

        if not rotation_filenames:
            print(&#34;No .rot files in %s. No rotation model created.&#34; %self.file_collection)
        if not topology_filenames:
            print(&#34;No topology features in %s. No FeatureCollection created.&#34; %self.file_collection)
        if not static_polygons:
            print(&#34;No static polygons in %s.&#34; %self.file_collection)

        return rotation_model, topology_features, static_polygons


    def get_topology_geometries(self):
        &#34;&#34;&#34;Downloads coastline, continent and continent-ocean boundary geometries needed to call
        the gplately.PlotTopologies object.

        Notes
        -----
        This method accesses the plate reconstruction model requested in the gplately.DataServer
        object. For example, if the object was called as:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        the method will download:
            - Coastlines: present-day coastlines cookie-cut using static polygons
            - Continents: cookie-cutting polygons for non-oceanic regions (continents, 
                          intra-oceanic arcs, etc.)
            - COBs: COB line segments
        from the Muller et al. (2019) plate reconstruction model.
        &#34;&#34;&#34;
        database = {

            &#34;Muller2019&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_PlateMotionModel/Muller_etal_2019_PlateMotionModel_v2.0_Tectonics.zip&#34;], 
            &#34;Muller2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2016_AREPS/Muller_etal_2016_AREPS_Supplement/Muller_etal_2016_AREPS_Supplement_v1.17.zip&#34;],
            &#34;Seton2012&#34; : [[&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1.gpml&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.dbf&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.kml&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.prj&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.shp&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.shx&#34;],
                           None,
                           [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.dbf&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.gpml&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.kml&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.prj&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.shp&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.shx&#34;]], 
            &#34;Merdith2021&#34; : [&#34;https://zenodo.org/record/4485738/files/SM2_4485738_V2.zip&#34;],
            &#34;Matthews2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Matthews_etal_2016_Global_Plate_Model_GPC.zip&#34;], 
            &#34;Merdith2017&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Merdith_etal_2017_GR.zip&#34;],              
        }

        # Set to true if we find the given collection in our database
        found_collection = False
        for collection, url in database.items():

            # Only continue if the user&#39;s chosen collection exists in our database
            if self.file_collection.lower() == collection.lower():
                found_collection = True
                coastlines = []
                continents = []
                COBs = []

                if len(url) == 1:
                    fnames = _fetch_from_web(url[0])
                    coastlines = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, strings_to_include=[&#34;coastline&#34;]), 
                            strings_to_ignore=[&#34;__MACOSX&#34;]
                        )
                    )
                    continents = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, strings_to_include=[&#34;continent&#34;]), 
                            strings_to_ignore=[&#34;__MACOSX&#34;]
                        )
                    )
                    COBs = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, strings_to_include=[&#34;cob&#34;, &#34;boundaries&#34;]), 
                            strings_to_ignore=[&#34;__MACOSX&#34;]
                        )
                    )
                    files = coastlines, continents, COBs

                else:
                    for file in url[0]:
                        coastlines.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;coastline&#34;])
                        )
                        coastlines = _check_gpml_or_shp(coastlines)

                    for file in url[1]:
                        continents.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;continent&#34;])
                        )
                        continents = _check_gpml_or_shp(continents)

                    for file in url[2]:
                        COBs.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;cob&#34;])
                        )
                        COBs = _check_gpml_or_shp(COBs)

                    files = coastlines, continents, COBs
                break

        if not coastlines:
            print(&#34;No coastlines in %s.&#34; %self.file_collection)
        if not continents:
            print(&#34;No continents in %s.&#34; %self.file_collection)
        if not COBs:
            print(&#34;No continent-ocean boundaries in %s.&#34; %self.file_collection)
            
        return files


    def get_rasters(self, raster_id_string=None, time=None):
        &#34;&#34;&#34;Downloads rasters and images from the web into the &#34;gplately&#34; cache.

        Currently supports the following rasters and images:
        +--------------+------------------------+---------------------------------------+-------------------+
        | Raster/image | Description            | Citation                              | String identifier |
        | name         |                        |                                       |                   |
        +--------------+------------------------+---------------------------------------+-------------------+
        | Muller et    | Seafloor age grid      | Müller, R. D., Zahirovic, S.,         | &#34;Muller2019_nc&#34;   |
        | al. 2019     | netCDF (.nc) rasters,  | Williams, S. E., Cannon, J.,          |                   |
        |              | as well as JPEG (.jpg) | Seton, M., Bower, D. J.,              | &#34;Muller2019_jpg&#34;  |
        |              | and PNG (.png) image   | Tetley, M. G., Heine, C.,             |                   |
        |              | equivalents.           | Le Breton, E., Liu, S.,               | &#34;Muller2019_png&#34;  |
        |              |                        | Russell, S. H. J., Yang, T.,          |                   |
        |              |                        | Leonard, J., and Gurnis, M. (2019),   |                   |
        |              |                        | A global plate model including        |                   |
        |              |                        | lithospheric deformation along major  |                   |
        |              |                        | rifts and orogens since the Triassic. |                   |
        |              |                        | Tectonics, vol. 38,                   |                   |
        |              |                        | https://doi.org/10.1029/2018TC005462. |                   |
        +--------------+------------------------+---------------------------------------+-------------------+
        | ETOPO1       | A 1-arc minute global  | doi:10.7289/V5C8276M                  | &#34;ETOPO1_grd&#34;      |
        |              | relief model combining |                                       |                   |
        |              | land topography and    |                                       | &#34;ETOPO1_tif&#34;      |
        |              | ocean bathymetry.      |                                       |                   |
        |              | Available in           |                                       |                   |
        |              | netCDF (.grd) and TIFF |                                       |                   |
        |              | (.tif)                 |                                       |                   |
        +--------------+------------------------+---------------------------------------+-------------------+
        |              |                        |                                       |                   |
        +--------------+------------------------+---------------------------------------+-------------------+

        Parameters
        ----------
        raster_id_string : str, default=None
            A string to identify which raster to download.
        time : int, default=None
            For time-reconstructed rasters, specify which time to extract.

        Returns
        -------
        raster_filenames : list of str
            A list containing the full path to the cached raster(s).

        Raises
        ------
        ValueError
            if a raster_id_string is not supplied.

        Notes
        -----
        By default, if rasters exist for each timestep (typically every 1 Ma), get_netcdf_rasters will return
        the full list of all rasters. For example, Muller et al. 2019 has 251 rasters for 0-250Ma. If the
        `time` parameter is passed, only the raster for that timestep is returned. This will be useful in time
        for loops.

        Examples
        --------
        1) Downloading the Muller et al. 2019 netCDF raster for 0-10 Ma:

                gdownload = gplately.download.DataServer(&#34;Muller2019&#34;)
                for time in arange(0,10):
                    time_raster = gdownload.get_raster(&#34;Muller2019_nc&#34;, time=time)

        2) Plotting a TIF global relief model on a GeoAxis instance

                etopo = gdownload.get_rasters(&#34;ETOPO1_tif&#34;)
                etopo_tif_img = image.imread(etopo)
                fig = plt.figure(figsize=(18,14), dpi=600)
                ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
                ax.imshow(etopo_tif_img, extent=[-180,180,-90,90], transform=ccrs.PlateCarree())

        &#34;&#34;&#34;
        if raster_id_string is None:
            raise ValueError(
                &#34;Please specify which raster data to fetch.&#34;
            )

        database = {

            &#34;Muller2019_nc&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_Agegrids/Muller_etal_2019_Tectonics_v2.0_netCDF.zip&#34;],
            &#34;Muller2019_jpeg&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_Agegrids/Muller_etal_2019_Tectonics_v2.0_jpgs.zip&#34;],
            &#34;Muller2019_png&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_Agegrids/Muller_etal_2019_Tectonics_v2.0_pngs.zip&#34;],
            &#34;ETOPO1_grd&#34; : [&#34;https://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/data/ice_surface/grid_registered/netcdf/ETOPO1_Ice_g_gmt4.grd.gz&#34;],
            &#34;ETOPO1_tif&#34; : [&#34;https://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/image/color_etopo1_ice_low.tif.gz&#34;]
        }

        archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
        # Set to true if we find the given collection in database
        found_collection = False
        raster_filenames = []

        for collection, zip_url in database.items():
            if raster_id_string.lower() == collection.lower():
                found_collection = True
                raster_filenames = _fetch_from_web(zip_url[0])
                if collection.endswith(&#34;nc&#34;):
                    raster_filenames = _order_filenames_by_time(
                        _collect_file_extension(
                            raster_filenames, [&#34;.nc&#34;, &#34;.grd&#34;])
                    )
                elif collection.endswith(&#34;jpeg&#34;):
                    raster_filenames = _order_filenames_by_time(
                        _collect_file_extension(
                            raster_filenames, [&#34;.jpg&#34;])
                    )
                elif collection.endswith(&#34;png&#34;):
                    raster_filenames = _order_filenames_by_time(
                        _collect_file_extension(
                            raster_filenames, [&#34;.png&#34;])
                    )
                if time is not None:
                    raster_filenames = _order_filenames_by_time(raster_filenames)[time]
                break

        if found_collection is False:
            raise ValueError(&#34;%s not in collection database.&#34; % (raster_id_string))
        return raster_filenames


    def get_feature_data(self, feature_data_id_string=None):
        &#34;&#34;&#34;Downloads geological feature data from the web into the &#34;gplately&#34; cache.

        Currently supports the following feature data:
        +-------------------+---------+------------------------------------+-------------------------+
        | Feature data type | Formats | Paper citation                     | String identifier       |
        +-------------------+---------+------------------------------------+-------------------------+
        | Large Igneous     | .gpmlz  | Johansson, L., Zahirovic, S.,      | &#34;LIP_VolcanicProvinces&#34; |
        | Province products |         | and Müller, R. D., In Prep,        |                         |
        | from Johansson    |         | The interplay between the          |                         |
        | et al. (2018)     |         | eruption and weathering of         |                         |
        |                   |         | Large Igneous Provinces and        |                         |
        |                   |         | the deep-time carbon cycle:        |                         |
        |                   |         | Geophysical Research Letters.      |                         |
        +-------------------+---------+------------------------------------+-------------------------+
        | Large Igneous     | .gpmlz  | Whittaker, J. M., Afonso, J. C.,   | &#34;LIP_VolcanicProvinces&#34; |
        | Provinces         | .shp    | Masterton, S., Müller, R. D.,      |                         |
        | interpreted to    |         | Wessel, P., Williams, S. E.,       |                         |
        | be plume products |         | &amp; Seton, M. (2015).                |                         |
        | from Whittaker    |         |  Long-term interaction between     |                         |
        | et al. (2015).    |         | mid-ocean ridges and mantle        |                         |
        |                   |         | plumes. Nature Geoscience, 8(6),   |                         |
        |                   |         | 479-483. doi:10.1038/ngeo2437.     |                         |
        +-------------------+---------+------------------------------------+-------------------------+
        | Seafloor tectonic | .gpml   | Matthews, K.J., M¸ller, R.D.,      | &#34;SeafloorFabric&#34;        |
        | fabric (fracture  |         | Wessel, P. and Whittaker, J.M.,    |                         |
        | zones, discordant |         | 2011. The tectonic fabric of the   |                         |
        | zones, V-shaped   |         | ocean basins. Journal of           |                         |
        | structures,       |         | Geophysical Research, 116(B12):    |                         |
        | unclassified      |         | B12109, DOI: 10.1029/2011JB008413. |                         |
        | V-anomalies,      |         |                                    |                         |
        | propagating ridge |         |                                    |                         |
        | lineations and    |         |                                    |                         |
        | extinct ridges)   |         |                                    |                         |
        | from Matthews     |         |                                    |                         |
        | et al. (2011)     |         |                                    |                         |
        +-------------------+---------+------------------------------------+-------------------------+
        | Present day       | .gpmlz  | Whittaker, J., Afonso, J.,         | &#34;Hotspots&#34;              |
        | surface hotspot/  |         | Masterton, S., Müller, R., Wessel, |                         |
        | plume locations   |         | P., Williams, S., and Seton, M.,   |                         | 
        | from Whittaker et |         | 2015, Long-term interaction between|                         |
        | al. (2013)        |         | mid-ocean ridges and mantle plumes:|                         |
        |                   |         | Nature Geoscience, v. 8, no. 6,    |                         |
        |                   |         | p. 479-483, doi:10.1038/ngeo2437.  |                         |
        +-------------------+---------+------------------------------------+-------------------------+
        
        Parameters
        ----------
        feature_data_id_string : str, default=None
            A string to identify which feature data to download to the cache. See table above.

        Returns
        -------
        feature_data_filenames : list of str
            A list containing the full path to the requested feature data. This is ready to be turned
            into a pygplates.FeatureCollection.

        Raises
        ------
        ValueError
            If a feature_data_id_string is not provided.
        &#34;&#34;&#34;
        if feature_data_id_string is None:
            raise ValueError(
                &#34;Please specify which feature data to fetch.&#34;
            )

        database = {

            &#34;SeafloorFabric&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/GPlates2.3_GeoData/Individual/SeafloorFabric.zip&#34;],
            &#34;LIP_VolcanicProvinces&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/GPlates2.3_GeoData/Individual/IgneousProvinces.zip&#34;],
            &#34;Hotspots&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/GPlates2.3_GeoData/Individual/Hotspots.zip&#34;]
        }

        found_collection = False
        for collection, zip_url in database.items():
            if feature_data_id_string.lower() == collection.lower():
                found_collection = True
                feature_data_filenames = _collect_file_extension(
                    _fetch_from_web(zip_url[0]), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                )
                break
        return feature_data_filenames
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.download.DataServer"><code class="flex name class">
<span>class <span class="ident">DataServer</span></span>
<span>(</span><span>file_collection=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses Pooch to download geological feature data from plate reconstruction models and other studies
that are stored on web servers (e.g. EarthByte's webDAV server). Downloaded files are kept in
a 'gplately' cache folder. </p>
<p>Currently,DataServer supports the following plate reconstruction models:
+-----------------------+-----------------------------------------------------------+-------------------+
| Plate reconstruction
| Paper citation
| String identifier |
| model
|
|
|
+-----------------------+-----------------------------------------------------------+-------------------+
| Muller et al. 2019
| Müller, R. D., Zahirovic, S., Williams, S. E.,
| "Muller2019"
|
|
| Cannon, J., Seton, M., Bower, D. J., Tetley, M. G.,
|
|
|
| Heine, C., Le Breton, E., Liu, S., Russell, S. H. J.,
|
|
|
| Yang, T., Leonard, J., and Gurnis, M. (2019),
|
|
|
| A global plate model including lithospheric deformation
|
|
|
| along major rifts and orogens since the Triassic.
|
|
|
| Tectonics, vol. 38, <a href="https://doi.org/10.1029/2018TC005462.">https://doi.org/10.1029/2018TC005462.</a> |
|
+-----------------------+-----------------------------------------------------------+-------------------+
| Merdith et al. 2021
| Andrew S. Merdith, Simon E. Williams, Alan S. Collins,
| "Merdith2021"
|
|
| Michael G. Tetley, Jacob A. Mulder, Morgan L. Blades,
|
|
|
| Alexander Young, Sheree E. Armistead, John Cannon,
|
|
|
| Sabin Zahirovic, R. Dietmar Müller, (2021).
|
|
|
| Extending full-plate tectonic models into deep time:
|
|
|
| Linking the Neoproterozoic and the Phanerozoic,
|
|
|
| Earth-Science Reviews, Volume 214, 2021, 103477,
|
|
|
| ISSN 0012-8252,
|
|
|
| <a href="https://doi.org/10.1016/j.earscirev.2020.103477.">https://doi.org/10.1016/j.earscirev.2020.103477.</a>
|
|
+-----------------------+-----------------------------------------------------------+-------------------+
|
|
|
|
+-----------------------+-----------------------------------------------------------+-------------------+</p>
<h2 id="methods">Methods</h2>
<p>get_plate_reconstruction_files
Downloads the <code>rotation_model</code>, <code>topology_features</code>, and <code>static_polygons</code> needed to create an
instance of the gplately.reconstruct.PlateReconstruction object.
get_topology_geometries
Downloads the <code>coastlines</code>, <code>continents</code> and <code>COBs</code> needed to create an instance of the
gplately.plot.PlotTopologies object.
get_netcdf_rasters
Downloads netCDF (.nc) and .grd rasters, as well as .tif images</p>
<h2 id="examples">Examples</h2>
<p>Calling the object:
# string identifier to access the Muller et al. 2019 model
gDownload = gplately.download.DataServer("Muller2019")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataServer(object):
    &#34;&#34;&#34;Uses Pooch to download geological feature data from plate reconstruction models and other studies
    that are stored on web servers (e.g. EarthByte&#39;s webDAV server). Downloaded files are kept in
    a &#39;gplately&#39; cache folder. 

    Currently,DataServer supports the following plate reconstruction models:
    +-----------------------+-----------------------------------------------------------+-------------------+
    | Plate reconstruction  | Paper citation                                            | String identifier |
    | model                 |                                                           |                   |
    +-----------------------+-----------------------------------------------------------+-------------------+
    | Muller et al. 2019    | Müller, R. D., Zahirovic, S., Williams, S. E.,            | &#34;Muller2019&#34;      |
    |                       | Cannon, J., Seton, M., Bower, D. J., Tetley, M. G.,       |                   |
    |                       | Heine, C., Le Breton, E., Liu, S., Russell, S. H. J.,     |                   |
    |                       | Yang, T., Leonard, J., and Gurnis, M. (2019),             |                   |
    |                       | A global plate model including lithospheric deformation   |                   |
    |                       | along major rifts and orogens since the Triassic.         |                   |
    |                       | Tectonics, vol. 38, https://doi.org/10.1029/2018TC005462. |                   |
    +-----------------------+-----------------------------------------------------------+-------------------+
    | Merdith et al. 2021   | Andrew S. Merdith, Simon E. Williams, Alan S. Collins,    | &#34;Merdith2021&#34;     |
    |                       | Michael G. Tetley, Jacob A. Mulder, Morgan L. Blades,     |                   |
    |                       | Alexander Young, Sheree E. Armistead, John Cannon,        |                   |
    |                       | Sabin Zahirovic, R. Dietmar Müller, (2021).               |                   |
    |                       | Extending full-plate tectonic models into deep time:      |                   |
    |                       | Linking the Neoproterozoic and the Phanerozoic,           |                   |
    |                       | Earth-Science Reviews, Volume 214, 2021, 103477,          |                   |
    |                       | ISSN 0012-8252,                                           |                   |
    |                       | https://doi.org/10.1016/j.earscirev.2020.103477.          |                   |
    +-----------------------+-----------------------------------------------------------+-------------------+
    |                       |                                                           |                   |
    +-----------------------+-----------------------------------------------------------+-------------------+


    Methods
    -------
    get_plate_reconstruction_files
        Downloads the `rotation_model`, `topology_features`, and `static_polygons` needed to create an
        instance of the gplately.reconstruct.PlateReconstruction object.
    get_topology_geometries
        Downloads the `coastlines`, `continents` and `COBs` needed to create an instance of the
        gplately.plot.PlotTopologies object.
    get_netcdf_rasters
        Downloads netCDF (.nc) and .grd rasters, as well as .tif images

    Examples
    --------
    Calling the object: 
        # string identifier to access the Muller et al. 2019 model
        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    &#34;&#34;&#34;
    def __init__(self, file_collection=None):
        if file_collection is None:
            raise ValueError(
                &#34;Please supply a file collection to fetch.&#34;
            )
        self.file_collection = file_collection

    def get_plate_reconstruction_files(self):
        &#34;&#34;&#34;Downloads and constructs a rotation model, a pygplates.FeatureCollection and a set of 
        static polygons needed to call the gplately.PlateReconstruction object.

        Notes
        -----
        This method accesses the plate reconstruction model requested in the gplately.DataServer
        object. For example, if the object was called as:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        the method will download:
            - a rotation file
            - GPML topology features
            - static polygons
        from the Muller et al. (2019) plate reconstruction model.
        &#34;&#34;&#34;
        database = {

            &#34;Muller2019&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_PlateMotionModel/Muller_etal_2019_PlateMotionModel_v2.0_Tectonics.zip&#34;], 
            &#34;Muller2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2016_AREPS/Muller_etal_2016_AREPS_Supplement/Muller_etal_2016_AREPS_Supplement_v1.17.zip&#34;],
            &#34;Seton2012&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Rotations/Seton_etal_ESR2012_2012.1.rot&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Plate_polygons/Seton_etal_ESR2012_PP_2012.1.gpml&#34;,
                          None], 
            &#34;Merdith2021&#34; : [&#34;https://zenodo.org/record/4485738/files/SM2_4485738_V2.zip&#34;],
            &#34;Matthews2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Matthews_etal_2016_Global_Plate_Model_GPC.zip&#34;], 
            &#34;Merdith2017&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Merdith_etal_2017_GR.zip&#34;], 

        }

        # Set to true if we find the given collection in our database
        found_collection = False
        for collection, url in database.items():

            # Only continue if the user&#39;s chosen collection exists in our database
            if self.file_collection.lower() == collection.lower():
                found_collection = True
                rotation_filenames = []
                topology_features = _pygplates.FeatureCollection()
                static_polygons = []

                if len(url) == 1:
                    fnames = _collection_sorter(
                        _fetch_from_web(url[0]), self.file_collection
                    )
                    rotation_filenames = _collect_file_extension(
                        fnames, [&#34;.rot&#34;]
                    )
                    rotation_model = _pygplates.RotationModel(rotation_filenames)

                    topology_filenames = _collect_file_extension(
                        _str_in_folder(fnames, strings_to_ignore=[&#34;__MACOSX&#34;]),
                        [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                    )
                    for file in topology_filenames:
                        topology_features.add(_pygplates.FeatureCollection(file))

                    static_polygons = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, 
                                strings_to_include=[&#34;Static&#34;, &#34;StaticPolygon&#34;, &#34;Static_Polygon&#34;]
                            ),
                            strings_to_ignore=[&#34;__MACOSX&#34;]
                        )
                    )
                else:
                    for file in url[0]:
                        rotation_filenames.append(
                            _collect_file_extension(
                                _fetch_from_web(file), [&#34;.rot&#34;])
                        )
                        rotation_model = _pygplates.RotationModel(rotation_filenames)

                    for file in url[1]:
                        topology_filenames.append(
                            _collect_file_extension(
                                _fetch_from_web(file), [&#34;.gpml&#34;])
                        )
                        for file in topology_filenames:
                            topology_features.add(
                                _pygplates.FeatureCollection(file)
                            )

                    for file in url[2]:
                        static_polygons.append(
                            _check_gpml_or_shp(
                                _str_in_folder(
                                    _str_in_filename(_fetch_from_web(url[0]), 
                                        strings_to_include=[&#34;Static&#34;, &#34;StaticPolygon&#34;, &#34;Static_Polygon&#34;]
                                    ),    
                                        strings_to_ignore=[&#34;__MACOSX&#34;]
                                )
                            )   
                        )
                break

        if not rotation_filenames:
            print(&#34;No .rot files in %s. No rotation model created.&#34; %self.file_collection)
        if not topology_filenames:
            print(&#34;No topology features in %s. No FeatureCollection created.&#34; %self.file_collection)
        if not static_polygons:
            print(&#34;No static polygons in %s.&#34; %self.file_collection)

        return rotation_model, topology_features, static_polygons


    def get_topology_geometries(self):
        &#34;&#34;&#34;Downloads coastline, continent and continent-ocean boundary geometries needed to call
        the gplately.PlotTopologies object.

        Notes
        -----
        This method accesses the plate reconstruction model requested in the gplately.DataServer
        object. For example, if the object was called as:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        the method will download:
            - Coastlines: present-day coastlines cookie-cut using static polygons
            - Continents: cookie-cutting polygons for non-oceanic regions (continents, 
                          intra-oceanic arcs, etc.)
            - COBs: COB line segments
        from the Muller et al. (2019) plate reconstruction model.
        &#34;&#34;&#34;
        database = {

            &#34;Muller2019&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_PlateMotionModel/Muller_etal_2019_PlateMotionModel_v2.0_Tectonics.zip&#34;], 
            &#34;Muller2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2016_AREPS/Muller_etal_2016_AREPS_Supplement/Muller_etal_2016_AREPS_Supplement_v1.17.zip&#34;],
            &#34;Seton2012&#34; : [[&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1.gpml&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.dbf&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.kml&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.prj&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.shp&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.shx&#34;],
                           None,
                           [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.dbf&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.gpml&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.kml&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.prj&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.shp&#34;,
                           &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.shx&#34;]], 
            &#34;Merdith2021&#34; : [&#34;https://zenodo.org/record/4485738/files/SM2_4485738_V2.zip&#34;],
            &#34;Matthews2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Matthews_etal_2016_Global_Plate_Model_GPC.zip&#34;], 
            &#34;Merdith2017&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Merdith_etal_2017_GR.zip&#34;],              
        }

        # Set to true if we find the given collection in our database
        found_collection = False
        for collection, url in database.items():

            # Only continue if the user&#39;s chosen collection exists in our database
            if self.file_collection.lower() == collection.lower():
                found_collection = True
                coastlines = []
                continents = []
                COBs = []

                if len(url) == 1:
                    fnames = _fetch_from_web(url[0])
                    coastlines = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, strings_to_include=[&#34;coastline&#34;]), 
                            strings_to_ignore=[&#34;__MACOSX&#34;]
                        )
                    )
                    continents = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, strings_to_include=[&#34;continent&#34;]), 
                            strings_to_ignore=[&#34;__MACOSX&#34;]
                        )
                    )
                    COBs = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, strings_to_include=[&#34;cob&#34;, &#34;boundaries&#34;]), 
                            strings_to_ignore=[&#34;__MACOSX&#34;]
                        )
                    )
                    files = coastlines, continents, COBs

                else:
                    for file in url[0]:
                        coastlines.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;coastline&#34;])
                        )
                        coastlines = _check_gpml_or_shp(coastlines)

                    for file in url[1]:
                        continents.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;continent&#34;])
                        )
                        continents = _check_gpml_or_shp(continents)

                    for file in url[2]:
                        COBs.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;cob&#34;])
                        )
                        COBs = _check_gpml_or_shp(COBs)

                    files = coastlines, continents, COBs
                break

        if not coastlines:
            print(&#34;No coastlines in %s.&#34; %self.file_collection)
        if not continents:
            print(&#34;No continents in %s.&#34; %self.file_collection)
        if not COBs:
            print(&#34;No continent-ocean boundaries in %s.&#34; %self.file_collection)
            
        return files


    def get_rasters(self, raster_id_string=None, time=None):
        &#34;&#34;&#34;Downloads rasters and images from the web into the &#34;gplately&#34; cache.

        Currently supports the following rasters and images:
        +--------------+------------------------+---------------------------------------+-------------------+
        | Raster/image | Description            | Citation                              | String identifier |
        | name         |                        |                                       |                   |
        +--------------+------------------------+---------------------------------------+-------------------+
        | Muller et    | Seafloor age grid      | Müller, R. D., Zahirovic, S.,         | &#34;Muller2019_nc&#34;   |
        | al. 2019     | netCDF (.nc) rasters,  | Williams, S. E., Cannon, J.,          |                   |
        |              | as well as JPEG (.jpg) | Seton, M., Bower, D. J.,              | &#34;Muller2019_jpg&#34;  |
        |              | and PNG (.png) image   | Tetley, M. G., Heine, C.,             |                   |
        |              | equivalents.           | Le Breton, E., Liu, S.,               | &#34;Muller2019_png&#34;  |
        |              |                        | Russell, S. H. J., Yang, T.,          |                   |
        |              |                        | Leonard, J., and Gurnis, M. (2019),   |                   |
        |              |                        | A global plate model including        |                   |
        |              |                        | lithospheric deformation along major  |                   |
        |              |                        | rifts and orogens since the Triassic. |                   |
        |              |                        | Tectonics, vol. 38,                   |                   |
        |              |                        | https://doi.org/10.1029/2018TC005462. |                   |
        +--------------+------------------------+---------------------------------------+-------------------+
        | ETOPO1       | A 1-arc minute global  | doi:10.7289/V5C8276M                  | &#34;ETOPO1_grd&#34;      |
        |              | relief model combining |                                       |                   |
        |              | land topography and    |                                       | &#34;ETOPO1_tif&#34;      |
        |              | ocean bathymetry.      |                                       |                   |
        |              | Available in           |                                       |                   |
        |              | netCDF (.grd) and TIFF |                                       |                   |
        |              | (.tif)                 |                                       |                   |
        +--------------+------------------------+---------------------------------------+-------------------+
        |              |                        |                                       |                   |
        +--------------+------------------------+---------------------------------------+-------------------+

        Parameters
        ----------
        raster_id_string : str, default=None
            A string to identify which raster to download.
        time : int, default=None
            For time-reconstructed rasters, specify which time to extract.

        Returns
        -------
        raster_filenames : list of str
            A list containing the full path to the cached raster(s).

        Raises
        ------
        ValueError
            if a raster_id_string is not supplied.

        Notes
        -----
        By default, if rasters exist for each timestep (typically every 1 Ma), get_netcdf_rasters will return
        the full list of all rasters. For example, Muller et al. 2019 has 251 rasters for 0-250Ma. If the
        `time` parameter is passed, only the raster for that timestep is returned. This will be useful in time
        for loops.

        Examples
        --------
        1) Downloading the Muller et al. 2019 netCDF raster for 0-10 Ma:

                gdownload = gplately.download.DataServer(&#34;Muller2019&#34;)
                for time in arange(0,10):
                    time_raster = gdownload.get_raster(&#34;Muller2019_nc&#34;, time=time)

        2) Plotting a TIF global relief model on a GeoAxis instance

                etopo = gdownload.get_rasters(&#34;ETOPO1_tif&#34;)
                etopo_tif_img = image.imread(etopo)
                fig = plt.figure(figsize=(18,14), dpi=600)
                ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
                ax.imshow(etopo_tif_img, extent=[-180,180,-90,90], transform=ccrs.PlateCarree())

        &#34;&#34;&#34;
        if raster_id_string is None:
            raise ValueError(
                &#34;Please specify which raster data to fetch.&#34;
            )

        database = {

            &#34;Muller2019_nc&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_Agegrids/Muller_etal_2019_Tectonics_v2.0_netCDF.zip&#34;],
            &#34;Muller2019_jpeg&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_Agegrids/Muller_etal_2019_Tectonics_v2.0_jpgs.zip&#34;],
            &#34;Muller2019_png&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_Agegrids/Muller_etal_2019_Tectonics_v2.0_pngs.zip&#34;],
            &#34;ETOPO1_grd&#34; : [&#34;https://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/data/ice_surface/grid_registered/netcdf/ETOPO1_Ice_g_gmt4.grd.gz&#34;],
            &#34;ETOPO1_tif&#34; : [&#34;https://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/image/color_etopo1_ice_low.tif.gz&#34;]
        }

        archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
        # Set to true if we find the given collection in database
        found_collection = False
        raster_filenames = []

        for collection, zip_url in database.items():
            if raster_id_string.lower() == collection.lower():
                found_collection = True
                raster_filenames = _fetch_from_web(zip_url[0])
                if collection.endswith(&#34;nc&#34;):
                    raster_filenames = _order_filenames_by_time(
                        _collect_file_extension(
                            raster_filenames, [&#34;.nc&#34;, &#34;.grd&#34;])
                    )
                elif collection.endswith(&#34;jpeg&#34;):
                    raster_filenames = _order_filenames_by_time(
                        _collect_file_extension(
                            raster_filenames, [&#34;.jpg&#34;])
                    )
                elif collection.endswith(&#34;png&#34;):
                    raster_filenames = _order_filenames_by_time(
                        _collect_file_extension(
                            raster_filenames, [&#34;.png&#34;])
                    )
                if time is not None:
                    raster_filenames = _order_filenames_by_time(raster_filenames)[time]
                break

        if found_collection is False:
            raise ValueError(&#34;%s not in collection database.&#34; % (raster_id_string))
        return raster_filenames


    def get_feature_data(self, feature_data_id_string=None):
        &#34;&#34;&#34;Downloads geological feature data from the web into the &#34;gplately&#34; cache.

        Currently supports the following feature data:
        +-------------------+---------+------------------------------------+-------------------------+
        | Feature data type | Formats | Paper citation                     | String identifier       |
        +-------------------+---------+------------------------------------+-------------------------+
        | Large Igneous     | .gpmlz  | Johansson, L., Zahirovic, S.,      | &#34;LIP_VolcanicProvinces&#34; |
        | Province products |         | and Müller, R. D., In Prep,        |                         |
        | from Johansson    |         | The interplay between the          |                         |
        | et al. (2018)     |         | eruption and weathering of         |                         |
        |                   |         | Large Igneous Provinces and        |                         |
        |                   |         | the deep-time carbon cycle:        |                         |
        |                   |         | Geophysical Research Letters.      |                         |
        +-------------------+---------+------------------------------------+-------------------------+
        | Large Igneous     | .gpmlz  | Whittaker, J. M., Afonso, J. C.,   | &#34;LIP_VolcanicProvinces&#34; |
        | Provinces         | .shp    | Masterton, S., Müller, R. D.,      |                         |
        | interpreted to    |         | Wessel, P., Williams, S. E.,       |                         |
        | be plume products |         | &amp; Seton, M. (2015).                |                         |
        | from Whittaker    |         |  Long-term interaction between     |                         |
        | et al. (2015).    |         | mid-ocean ridges and mantle        |                         |
        |                   |         | plumes. Nature Geoscience, 8(6),   |                         |
        |                   |         | 479-483. doi:10.1038/ngeo2437.     |                         |
        +-------------------+---------+------------------------------------+-------------------------+
        | Seafloor tectonic | .gpml   | Matthews, K.J., M¸ller, R.D.,      | &#34;SeafloorFabric&#34;        |
        | fabric (fracture  |         | Wessel, P. and Whittaker, J.M.,    |                         |
        | zones, discordant |         | 2011. The tectonic fabric of the   |                         |
        | zones, V-shaped   |         | ocean basins. Journal of           |                         |
        | structures,       |         | Geophysical Research, 116(B12):    |                         |
        | unclassified      |         | B12109, DOI: 10.1029/2011JB008413. |                         |
        | V-anomalies,      |         |                                    |                         |
        | propagating ridge |         |                                    |                         |
        | lineations and    |         |                                    |                         |
        | extinct ridges)   |         |                                    |                         |
        | from Matthews     |         |                                    |                         |
        | et al. (2011)     |         |                                    |                         |
        +-------------------+---------+------------------------------------+-------------------------+
        | Present day       | .gpmlz  | Whittaker, J., Afonso, J.,         | &#34;Hotspots&#34;              |
        | surface hotspot/  |         | Masterton, S., Müller, R., Wessel, |                         |
        | plume locations   |         | P., Williams, S., and Seton, M.,   |                         | 
        | from Whittaker et |         | 2015, Long-term interaction between|                         |
        | al. (2013)        |         | mid-ocean ridges and mantle plumes:|                         |
        |                   |         | Nature Geoscience, v. 8, no. 6,    |                         |
        |                   |         | p. 479-483, doi:10.1038/ngeo2437.  |                         |
        +-------------------+---------+------------------------------------+-------------------------+
        
        Parameters
        ----------
        feature_data_id_string : str, default=None
            A string to identify which feature data to download to the cache. See table above.

        Returns
        -------
        feature_data_filenames : list of str
            A list containing the full path to the requested feature data. This is ready to be turned
            into a pygplates.FeatureCollection.

        Raises
        ------
        ValueError
            If a feature_data_id_string is not provided.
        &#34;&#34;&#34;
        if feature_data_id_string is None:
            raise ValueError(
                &#34;Please specify which feature data to fetch.&#34;
            )

        database = {

            &#34;SeafloorFabric&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/GPlates2.3_GeoData/Individual/SeafloorFabric.zip&#34;],
            &#34;LIP_VolcanicProvinces&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/GPlates2.3_GeoData/Individual/IgneousProvinces.zip&#34;],
            &#34;Hotspots&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/GPlates2.3_GeoData/Individual/Hotspots.zip&#34;]
        }

        found_collection = False
        for collection, zip_url in database.items():
            if feature_data_id_string.lower() == collection.lower():
                found_collection = True
                feature_data_filenames = _collect_file_extension(
                    _fetch_from_web(zip_url[0]), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                )
                break
        return feature_data_filenames</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gplately.download.DataServer.get_feature_data"><code class="name flex">
<span>def <span class="ident">get_feature_data</span></span>(<span>self, feature_data_id_string=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads geological feature data from the web into the "gplately" cache.</p>
<p>Currently supports the following feature data:
+-------------------+---------+------------------------------------+-------------------------+
| Feature data type | Formats | Paper citation
| String identifier
|
+-------------------+---------+------------------------------------+-------------------------+
| Large Igneous
| .gpmlz
| Johansson, L., Zahirovic, S.,
| "LIP_VolcanicProvinces" |
| Province products |
| and Müller, R. D., In Prep,
|
|
| from Johansson
|
| The interplay between the
|
|
| et al. (2018)
|
| eruption and weathering of
|
|
|
|
| Large Igneous Provinces and
|
|
|
|
| the deep-time carbon cycle:
|
|
|
|
| Geophysical Research Letters.
|
|
+-------------------+---------+------------------------------------+-------------------------+
| Large Igneous
| .gpmlz
| Whittaker, J. M., Afonso, J. C.,
| "LIP_VolcanicProvinces" |
| Provinces
| .shp
| Masterton, S., Müller, R. D.,
|
|
| interpreted to
|
| Wessel, P., Williams, S. E.,
|
|
| be plume products |
| &amp; Seton, M. (2015).
|
|
| from Whittaker
|
|
Long-term interaction between
|
|
| et al. (2015).
|
| mid-ocean ridges and mantle
|
|
|
|
| plumes. Nature Geoscience, 8(6),
|
|
|
|
| 479-483. doi:10.1038/ngeo2437.
|
|
+-------------------+---------+------------------------------------+-------------------------+
| Seafloor tectonic | .gpml
| Matthews, K.J., M¸ller, R.D.,
| "SeafloorFabric"
|
| fabric (fracture
|
| Wessel, P. and Whittaker, J.M.,
|
|
| zones, discordant |
| 2011. The tectonic fabric of the
|
|
| zones, V-shaped
|
| ocean basins. Journal of
|
|
| structures,
|
| Geophysical Research, 116(B12):
|
|
| unclassified
|
| B12109, DOI: 10.1029/2011JB008413. |
|
| V-anomalies,
|
|
|
|
| propagating ridge |
|
|
|
| lineations and
|
|
|
|
| extinct ridges)
|
|
|
|
| from Matthews
|
|
|
|
| et al. (2011)
|
|
|
|
+-------------------+---------+------------------------------------+-------------------------+
| Present day
| .gpmlz
| Whittaker, J., Afonso, J.,
| "Hotspots"
|
| surface hotspot/
|
| Masterton, S., Müller, R., Wessel, |
|
| plume locations
|
| P., Williams, S., and Seton, M.,
|
|
| from Whittaker et |
| 2015, Long-term interaction between|
|
| al. (2013)
|
| mid-ocean ridges and mantle plumes:|
|
|
|
| Nature Geoscience, v. 8, no. 6,
|
|
|
|
| p. 479-483, doi:10.1038/ngeo2437.
|
|
+-------------------+---------+------------------------------------+-------------------------+</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_data_id_string</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>A string to identify which feature data to download to the cache. See table above.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>feature_data_filenames</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list containing the full path to the requested feature data. This is ready to be turned
into a pygplates.FeatureCollection.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a feature_data_id_string is not provided.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_feature_data(self, feature_data_id_string=None):
    &#34;&#34;&#34;Downloads geological feature data from the web into the &#34;gplately&#34; cache.

    Currently supports the following feature data:
    +-------------------+---------+------------------------------------+-------------------------+
    | Feature data type | Formats | Paper citation                     | String identifier       |
    +-------------------+---------+------------------------------------+-------------------------+
    | Large Igneous     | .gpmlz  | Johansson, L., Zahirovic, S.,      | &#34;LIP_VolcanicProvinces&#34; |
    | Province products |         | and Müller, R. D., In Prep,        |                         |
    | from Johansson    |         | The interplay between the          |                         |
    | et al. (2018)     |         | eruption and weathering of         |                         |
    |                   |         | Large Igneous Provinces and        |                         |
    |                   |         | the deep-time carbon cycle:        |                         |
    |                   |         | Geophysical Research Letters.      |                         |
    +-------------------+---------+------------------------------------+-------------------------+
    | Large Igneous     | .gpmlz  | Whittaker, J. M., Afonso, J. C.,   | &#34;LIP_VolcanicProvinces&#34; |
    | Provinces         | .shp    | Masterton, S., Müller, R. D.,      |                         |
    | interpreted to    |         | Wessel, P., Williams, S. E.,       |                         |
    | be plume products |         | &amp; Seton, M. (2015).                |                         |
    | from Whittaker    |         |  Long-term interaction between     |                         |
    | et al. (2015).    |         | mid-ocean ridges and mantle        |                         |
    |                   |         | plumes. Nature Geoscience, 8(6),   |                         |
    |                   |         | 479-483. doi:10.1038/ngeo2437.     |                         |
    +-------------------+---------+------------------------------------+-------------------------+
    | Seafloor tectonic | .gpml   | Matthews, K.J., M¸ller, R.D.,      | &#34;SeafloorFabric&#34;        |
    | fabric (fracture  |         | Wessel, P. and Whittaker, J.M.,    |                         |
    | zones, discordant |         | 2011. The tectonic fabric of the   |                         |
    | zones, V-shaped   |         | ocean basins. Journal of           |                         |
    | structures,       |         | Geophysical Research, 116(B12):    |                         |
    | unclassified      |         | B12109, DOI: 10.1029/2011JB008413. |                         |
    | V-anomalies,      |         |                                    |                         |
    | propagating ridge |         |                                    |                         |
    | lineations and    |         |                                    |                         |
    | extinct ridges)   |         |                                    |                         |
    | from Matthews     |         |                                    |                         |
    | et al. (2011)     |         |                                    |                         |
    +-------------------+---------+------------------------------------+-------------------------+
    | Present day       | .gpmlz  | Whittaker, J., Afonso, J.,         | &#34;Hotspots&#34;              |
    | surface hotspot/  |         | Masterton, S., Müller, R., Wessel, |                         |
    | plume locations   |         | P., Williams, S., and Seton, M.,   |                         | 
    | from Whittaker et |         | 2015, Long-term interaction between|                         |
    | al. (2013)        |         | mid-ocean ridges and mantle plumes:|                         |
    |                   |         | Nature Geoscience, v. 8, no. 6,    |                         |
    |                   |         | p. 479-483, doi:10.1038/ngeo2437.  |                         |
    +-------------------+---------+------------------------------------+-------------------------+
    
    Parameters
    ----------
    feature_data_id_string : str, default=None
        A string to identify which feature data to download to the cache. See table above.

    Returns
    -------
    feature_data_filenames : list of str
        A list containing the full path to the requested feature data. This is ready to be turned
        into a pygplates.FeatureCollection.

    Raises
    ------
    ValueError
        If a feature_data_id_string is not provided.
    &#34;&#34;&#34;
    if feature_data_id_string is None:
        raise ValueError(
            &#34;Please specify which feature data to fetch.&#34;
        )

    database = {

        &#34;SeafloorFabric&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/GPlates2.3_GeoData/Individual/SeafloorFabric.zip&#34;],
        &#34;LIP_VolcanicProvinces&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/GPlates2.3_GeoData/Individual/IgneousProvinces.zip&#34;],
        &#34;Hotspots&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/earthbyte/GPlates/GPlates2.3_GeoData/Individual/Hotspots.zip&#34;]
    }

    found_collection = False
    for collection, zip_url in database.items():
        if feature_data_id_string.lower() == collection.lower():
            found_collection = True
            feature_data_filenames = _collect_file_extension(
                _fetch_from_web(zip_url[0]), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
            )
            break
    return feature_data_filenames</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_plate_reconstruction_files"><code class="name flex">
<span>def <span class="ident">get_plate_reconstruction_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads and constructs a rotation model, a pygplates.FeatureCollection and a set of
static polygons needed to call the gplately.PlateReconstruction object.</p>
<h2 id="notes">Notes</h2>
<p>This method accesses the plate reconstruction model requested in the gplately.DataServer
object. For example, if the object was called as:</p>
<pre><code>gDownload = gplately.download.DataServer("Muller2019")
</code></pre>
<p>the method will download:
- a rotation file
- GPML topology features
- static polygons
from the Muller et al. (2019) plate reconstruction model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plate_reconstruction_files(self):
    &#34;&#34;&#34;Downloads and constructs a rotation model, a pygplates.FeatureCollection and a set of 
    static polygons needed to call the gplately.PlateReconstruction object.

    Notes
    -----
    This method accesses the plate reconstruction model requested in the gplately.DataServer
    object. For example, if the object was called as:

        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    the method will download:
        - a rotation file
        - GPML topology features
        - static polygons
    from the Muller et al. (2019) plate reconstruction model.
    &#34;&#34;&#34;
    database = {

        &#34;Muller2019&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_PlateMotionModel/Muller_etal_2019_PlateMotionModel_v2.0_Tectonics.zip&#34;], 
        &#34;Muller2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2016_AREPS/Muller_etal_2016_AREPS_Supplement/Muller_etal_2016_AREPS_Supplement_v1.17.zip&#34;],
        &#34;Seton2012&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Rotations/Seton_etal_ESR2012_2012.1.rot&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Plate_polygons/Seton_etal_ESR2012_PP_2012.1.gpml&#34;,
                      None], 
        &#34;Merdith2021&#34; : [&#34;https://zenodo.org/record/4485738/files/SM2_4485738_V2.zip&#34;],
        &#34;Matthews2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Matthews_etal_2016_Global_Plate_Model_GPC.zip&#34;], 
        &#34;Merdith2017&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Merdith_etal_2017_GR.zip&#34;], 

    }

    # Set to true if we find the given collection in our database
    found_collection = False
    for collection, url in database.items():

        # Only continue if the user&#39;s chosen collection exists in our database
        if self.file_collection.lower() == collection.lower():
            found_collection = True
            rotation_filenames = []
            topology_features = _pygplates.FeatureCollection()
            static_polygons = []

            if len(url) == 1:
                fnames = _collection_sorter(
                    _fetch_from_web(url[0]), self.file_collection
                )
                rotation_filenames = _collect_file_extension(
                    fnames, [&#34;.rot&#34;]
                )
                rotation_model = _pygplates.RotationModel(rotation_filenames)

                topology_filenames = _collect_file_extension(
                    _str_in_folder(fnames, strings_to_ignore=[&#34;__MACOSX&#34;]),
                    [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                )
                for file in topology_filenames:
                    topology_features.add(_pygplates.FeatureCollection(file))

                static_polygons = _check_gpml_or_shp(
                    _str_in_folder(
                        _str_in_filename(fnames, 
                            strings_to_include=[&#34;Static&#34;, &#34;StaticPolygon&#34;, &#34;Static_Polygon&#34;]
                        ),
                        strings_to_ignore=[&#34;__MACOSX&#34;]
                    )
                )
            else:
                for file in url[0]:
                    rotation_filenames.append(
                        _collect_file_extension(
                            _fetch_from_web(file), [&#34;.rot&#34;])
                    )
                    rotation_model = _pygplates.RotationModel(rotation_filenames)

                for file in url[1]:
                    topology_filenames.append(
                        _collect_file_extension(
                            _fetch_from_web(file), [&#34;.gpml&#34;])
                    )
                    for file in topology_filenames:
                        topology_features.add(
                            _pygplates.FeatureCollection(file)
                        )

                for file in url[2]:
                    static_polygons.append(
                        _check_gpml_or_shp(
                            _str_in_folder(
                                _str_in_filename(_fetch_from_web(url[0]), 
                                    strings_to_include=[&#34;Static&#34;, &#34;StaticPolygon&#34;, &#34;Static_Polygon&#34;]
                                ),    
                                    strings_to_ignore=[&#34;__MACOSX&#34;]
                            )
                        )   
                    )
            break

    if not rotation_filenames:
        print(&#34;No .rot files in %s. No rotation model created.&#34; %self.file_collection)
    if not topology_filenames:
        print(&#34;No topology features in %s. No FeatureCollection created.&#34; %self.file_collection)
    if not static_polygons:
        print(&#34;No static polygons in %s.&#34; %self.file_collection)

    return rotation_model, topology_features, static_polygons</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_rasters"><code class="name flex">
<span>def <span class="ident">get_rasters</span></span>(<span>self, raster_id_string=None, time=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads rasters and images from the web into the "gplately" cache.</p>
<p>Currently supports the following rasters and images:
+--------------+------------------------+---------------------------------------+-------------------+
| Raster/image | Description
| Citation
| String identifier |
| name
|
|
|
|
+--------------+------------------------+---------------------------------------+-------------------+
| Muller et
| Seafloor age grid
| Müller, R. D., Zahirovic, S.,
| "Muller2019_nc"
|
| al. 2019
| netCDF (.nc) rasters,
| Williams, S. E., Cannon, J.,
|
|
|
| as well as JPEG (.jpg) | Seton, M., Bower, D. J.,
| "Muller2019_jpg"
|
|
| and PNG (.png) image
| Tetley, M. G., Heine, C.,
|
|
|
| equivalents.
| Le Breton, E., Liu, S.,
| "Muller2019_png"
|
|
|
| Russell, S. H. J., Yang, T.,
|
|
|
|
| Leonard, J., and Gurnis, M. (2019),
|
|
|
|
| A global plate model including
|
|
|
|
| lithospheric deformation along major
|
|
|
|
| rifts and orogens since the Triassic. |
|
|
|
| Tectonics, vol. 38,
|
|
|
|
| <a href="https://doi.org/10.1029/2018TC005462.">https://doi.org/10.1029/2018TC005462.</a> |
|
+--------------+------------------------+---------------------------------------+-------------------+
| ETOPO1
| A 1-arc minute global
| doi:10.7289/V5C8276M
| "ETOPO1_grd"
|
|
| relief model combining |
|
|
|
| land topography and
|
| "ETOPO1_tif"
|
|
| ocean bathymetry.
|
|
|
|
| Available in
|
|
|
|
| netCDF (.grd) and TIFF |
|
|
|
| (.tif)
|
|
|
+--------------+------------------------+---------------------------------------+-------------------+
|
|
|
|
|
+--------------+------------------------+---------------------------------------+-------------------+</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>raster_id_string</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>A string to identify which raster to download.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>int</code>, default=<code>None</code></dt>
<dd>For time-reconstructed rasters, specify which time to extract.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>raster_filenames</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list containing the full path to the cached raster(s).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if a raster_id_string is not supplied.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>By default, if rasters exist for each timestep (typically every 1 Ma), get_netcdf_rasters will return
the full list of all rasters. For example, Muller et al. 2019 has 251 rasters for 0-250Ma. If the
<code>time</code> parameter is passed, only the raster for that timestep is returned. This will be useful in time
for loops.</p>
<h2 id="examples">Examples</h2>
<p>1) Downloading the Muller et al. 2019 netCDF raster for 0-10 Ma:</p>
<pre><code>    gdownload = gplately.download.DataServer("Muller2019")
    for time in arange(0,10):
        time_raster = gdownload.get_raster("Muller2019_nc", time=time)
</code></pre>
<p>2) Plotting a TIF global relief model on a GeoAxis instance</p>
<pre><code>    etopo = gdownload.get_rasters("ETOPO1_tif")
    etopo_tif_img = image.imread(etopo)
    fig = plt.figure(figsize=(18,14), dpi=600)
    ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
    ax.imshow(etopo_tif_img, extent=[-180,180,-90,90], transform=ccrs.PlateCarree())
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rasters(self, raster_id_string=None, time=None):
    &#34;&#34;&#34;Downloads rasters and images from the web into the &#34;gplately&#34; cache.

    Currently supports the following rasters and images:
    +--------------+------------------------+---------------------------------------+-------------------+
    | Raster/image | Description            | Citation                              | String identifier |
    | name         |                        |                                       |                   |
    +--------------+------------------------+---------------------------------------+-------------------+
    | Muller et    | Seafloor age grid      | Müller, R. D., Zahirovic, S.,         | &#34;Muller2019_nc&#34;   |
    | al. 2019     | netCDF (.nc) rasters,  | Williams, S. E., Cannon, J.,          |                   |
    |              | as well as JPEG (.jpg) | Seton, M., Bower, D. J.,              | &#34;Muller2019_jpg&#34;  |
    |              | and PNG (.png) image   | Tetley, M. G., Heine, C.,             |                   |
    |              | equivalents.           | Le Breton, E., Liu, S.,               | &#34;Muller2019_png&#34;  |
    |              |                        | Russell, S. H. J., Yang, T.,          |                   |
    |              |                        | Leonard, J., and Gurnis, M. (2019),   |                   |
    |              |                        | A global plate model including        |                   |
    |              |                        | lithospheric deformation along major  |                   |
    |              |                        | rifts and orogens since the Triassic. |                   |
    |              |                        | Tectonics, vol. 38,                   |                   |
    |              |                        | https://doi.org/10.1029/2018TC005462. |                   |
    +--------------+------------------------+---------------------------------------+-------------------+
    | ETOPO1       | A 1-arc minute global  | doi:10.7289/V5C8276M                  | &#34;ETOPO1_grd&#34;      |
    |              | relief model combining |                                       |                   |
    |              | land topography and    |                                       | &#34;ETOPO1_tif&#34;      |
    |              | ocean bathymetry.      |                                       |                   |
    |              | Available in           |                                       |                   |
    |              | netCDF (.grd) and TIFF |                                       |                   |
    |              | (.tif)                 |                                       |                   |
    +--------------+------------------------+---------------------------------------+-------------------+
    |              |                        |                                       |                   |
    +--------------+------------------------+---------------------------------------+-------------------+

    Parameters
    ----------
    raster_id_string : str, default=None
        A string to identify which raster to download.
    time : int, default=None
        For time-reconstructed rasters, specify which time to extract.

    Returns
    -------
    raster_filenames : list of str
        A list containing the full path to the cached raster(s).

    Raises
    ------
    ValueError
        if a raster_id_string is not supplied.

    Notes
    -----
    By default, if rasters exist for each timestep (typically every 1 Ma), get_netcdf_rasters will return
    the full list of all rasters. For example, Muller et al. 2019 has 251 rasters for 0-250Ma. If the
    `time` parameter is passed, only the raster for that timestep is returned. This will be useful in time
    for loops.

    Examples
    --------
    1) Downloading the Muller et al. 2019 netCDF raster for 0-10 Ma:

            gdownload = gplately.download.DataServer(&#34;Muller2019&#34;)
            for time in arange(0,10):
                time_raster = gdownload.get_raster(&#34;Muller2019_nc&#34;, time=time)

    2) Plotting a TIF global relief model on a GeoAxis instance

            etopo = gdownload.get_rasters(&#34;ETOPO1_tif&#34;)
            etopo_tif_img = image.imread(etopo)
            fig = plt.figure(figsize=(18,14), dpi=600)
            ax = fig.add_subplot(111, projection=ccrs.Mollweide(central_longitude = -150))
            ax.imshow(etopo_tif_img, extent=[-180,180,-90,90], transform=ccrs.PlateCarree())

    &#34;&#34;&#34;
    if raster_id_string is None:
        raise ValueError(
            &#34;Please specify which raster data to fetch.&#34;
        )

    database = {

        &#34;Muller2019_nc&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_Agegrids/Muller_etal_2019_Tectonics_v2.0_netCDF.zip&#34;],
        &#34;Muller2019_jpeg&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_Agegrids/Muller_etal_2019_Tectonics_v2.0_jpgs.zip&#34;],
        &#34;Muller2019_png&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_Agegrids/Muller_etal_2019_Tectonics_v2.0_pngs.zip&#34;],
        &#34;ETOPO1_grd&#34; : [&#34;https://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/data/ice_surface/grid_registered/netcdf/ETOPO1_Ice_g_gmt4.grd.gz&#34;],
        &#34;ETOPO1_tif&#34; : [&#34;https://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/image/color_etopo1_ice_low.tif.gz&#34;]
    }

    archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
    # Set to true if we find the given collection in database
    found_collection = False
    raster_filenames = []

    for collection, zip_url in database.items():
        if raster_id_string.lower() == collection.lower():
            found_collection = True
            raster_filenames = _fetch_from_web(zip_url[0])
            if collection.endswith(&#34;nc&#34;):
                raster_filenames = _order_filenames_by_time(
                    _collect_file_extension(
                        raster_filenames, [&#34;.nc&#34;, &#34;.grd&#34;])
                )
            elif collection.endswith(&#34;jpeg&#34;):
                raster_filenames = _order_filenames_by_time(
                    _collect_file_extension(
                        raster_filenames, [&#34;.jpg&#34;])
                )
            elif collection.endswith(&#34;png&#34;):
                raster_filenames = _order_filenames_by_time(
                    _collect_file_extension(
                        raster_filenames, [&#34;.png&#34;])
                )
            if time is not None:
                raster_filenames = _order_filenames_by_time(raster_filenames)[time]
            break

    if found_collection is False:
        raise ValueError(&#34;%s not in collection database.&#34; % (raster_id_string))
    return raster_filenames</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_topology_geometries"><code class="name flex">
<span>def <span class="ident">get_topology_geometries</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads coastline, continent and continent-ocean boundary geometries needed to call
the gplately.PlotTopologies object.</p>
<h2 id="notes">Notes</h2>
<p>This method accesses the plate reconstruction model requested in the gplately.DataServer
object. For example, if the object was called as:</p>
<pre><code>gDownload = gplately.download.DataServer("Muller2019")
</code></pre>
<p>the method will download:
- Coastlines: present-day coastlines cookie-cut using static polygons
- Continents: cookie-cutting polygons for non-oceanic regions (continents,
intra-oceanic arcs, etc.)
- COBs: COB line segments
from the Muller et al. (2019) plate reconstruction model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_topology_geometries(self):
    &#34;&#34;&#34;Downloads coastline, continent and continent-ocean boundary geometries needed to call
    the gplately.PlotTopologies object.

    Notes
    -----
    This method accesses the plate reconstruction model requested in the gplately.DataServer
    object. For example, if the object was called as:

        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    the method will download:
        - Coastlines: present-day coastlines cookie-cut using static polygons
        - Continents: cookie-cutting polygons for non-oceanic regions (continents, 
                      intra-oceanic arcs, etc.)
        - COBs: COB line segments
    from the Muller et al. (2019) plate reconstruction model.
    &#34;&#34;&#34;
    database = {

        &#34;Muller2019&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2019_Tectonics/Muller_etal_2019_PlateMotionModel/Muller_etal_2019_PlateMotionModel_v2.0_Tectonics.zip&#34;], 
        &#34;Muller2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Muller_etal_2016_AREPS/Muller_etal_2016_AREPS_Supplement/Muller_etal_2016_AREPS_Supplement_v1.17.zip&#34;],
        &#34;Seton2012&#34; : [[&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1.gpml&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.dbf&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.kml&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.prj&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.shp&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Coastlines/Seton_etal_ESR2012_Coastline_2012.1_polyline.shx&#34;],
                       None,
                       [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.dbf&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.gpml&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.kml&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.prj&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.shp&#34;,
                       &#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Seton_etal_2012_ESR/Continent-ocean_boundaries/Seton_etal_ESR2012_ContinentOceanBoundaries_2012.1.shx&#34;]], 
        &#34;Merdith2021&#34; : [&#34;https://zenodo.org/record/4485738/files/SM2_4485738_V2.zip&#34;],
        &#34;Matthews2016&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Matthews_etal_2016_Global_Plate_Model_GPC.zip&#34;], 
        &#34;Merdith2017&#34; : [&#34;https://www.earthbyte.org/webdav/ftp/Data_Collections/Merdith_etal_2017_GR.zip&#34;],              
    }

    # Set to true if we find the given collection in our database
    found_collection = False
    for collection, url in database.items():

        # Only continue if the user&#39;s chosen collection exists in our database
        if self.file_collection.lower() == collection.lower():
            found_collection = True
            coastlines = []
            continents = []
            COBs = []

            if len(url) == 1:
                fnames = _fetch_from_web(url[0])
                coastlines = _check_gpml_or_shp(
                    _str_in_folder(
                        _str_in_filename(fnames, strings_to_include=[&#34;coastline&#34;]), 
                        strings_to_ignore=[&#34;__MACOSX&#34;]
                    )
                )
                continents = _check_gpml_or_shp(
                    _str_in_folder(
                        _str_in_filename(fnames, strings_to_include=[&#34;continent&#34;]), 
                        strings_to_ignore=[&#34;__MACOSX&#34;]
                    )
                )
                COBs = _check_gpml_or_shp(
                    _str_in_folder(
                        _str_in_filename(fnames, strings_to_include=[&#34;cob&#34;, &#34;boundaries&#34;]), 
                        strings_to_ignore=[&#34;__MACOSX&#34;]
                    )
                )
                files = coastlines, continents, COBs

            else:
                for file in url[0]:
                    coastlines.append(_str_in_filename(
                        _fetch_from_web(file), 
                        strings_to_include=[&#34;coastline&#34;])
                    )
                    coastlines = _check_gpml_or_shp(coastlines)

                for file in url[1]:
                    continents.append(_str_in_filename(
                        _fetch_from_web(file), 
                        strings_to_include=[&#34;continent&#34;])
                    )
                    continents = _check_gpml_or_shp(continents)

                for file in url[2]:
                    COBs.append(_str_in_filename(
                        _fetch_from_web(file), 
                        strings_to_include=[&#34;cob&#34;])
                    )
                    COBs = _check_gpml_or_shp(COBs)

                files = coastlines, continents, COBs
            break

    if not coastlines:
        print(&#34;No coastlines in %s.&#34; %self.file_collection)
    if not continents:
        print(&#34;No continents in %s.&#34; %self.file_collection)
    if not COBs:
        print(&#34;No continent-ocean boundaries in %s.&#34; %self.file_collection)
        
    return files</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code></h4>
<ul class="">
<li><code><a title="gplately.download.DataServer.get_feature_data" href="#gplately.download.DataServer.get_feature_data">get_feature_data</a></code></li>
<li><code><a title="gplately.download.DataServer.get_plate_reconstruction_files" href="#gplately.download.DataServer.get_plate_reconstruction_files">get_plate_reconstruction_files</a></code></li>
<li><code><a title="gplately.download.DataServer.get_rasters" href="#gplately.download.DataServer.get_rasters">get_rasters</a></code></li>
<li><code><a title="gplately.download.DataServer.get_topology_geometries" href="#gplately.download.DataServer.get_topology_geometries">get_topology_geometries</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>