<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gplately.download API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gplately.download</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pooch as _pooch
from pooch import os_cache as _os_cache
from pooch import retrieve as _retrieve
from pooch import HTTPDownloader as _HTTPDownloader
from pooch import Unzip as _Unzip
from pooch import Decompress as _Decompress
from matplotlib import image as _image
from .data import DataCollection
import gplately as _gplately
import pygplates as _pygplates
import re as _re
import numpy as _np

def _fetch_from_web(url):
    &#34;&#34;&#34;Download file(s) in a given url to the &#39;gplately&#39; cache folder. Processes
    compressed files using either Pooch&#39;s Unzip (if .zip) or Decompress (if .gz, 
    .xz or .bz2).&#34;&#34;&#34;
    def pooch_retrieve(url, processor):
        &#34;&#34;&#34;Downloads file(s) from a URL using Pooch.&#34;&#34;&#34;
        fnames = _retrieve(
            url=url,
            known_hash=None,  
            downloader=_HTTPDownloader(progressbar=True),
            path=_os_cache(&#39;gplately&#39;),
            processor=processor)
        return fnames

    archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
    if url.endswith(&#34;.zip&#34;):
        fnames = pooch_retrieve(url, processor=_Unzip())
    elif url.endswith(archive_formats):
        fnames = pooch_retrieve(url, processor=_Decompress())
    else:
        fnames = pooch_retrieve(url, processor=None)
    return fnames


def _collect_file_extension(fnames, file_extension):
    &#34;&#34;&#34;Searches cached directory for filenames with a specified extension(s).&#34;&#34;&#34;
    sorted_fnames = []
    file_extension=tuple(file_extension)
    for file in fnames:
        if file.endswith(file_extension):
            sorted_fnames.append(file)
    return sorted_fnames


def _str_in_folder(fnames, strings_to_include=None, strings_to_ignore=None):
    fnames_to_ignore = []
    fnames_to_include = []
    sorted_fnames = []
    for i, fname in enumerate(fnames):
        parent_directory = &#39;/&#39;.join(fname.split(&#34;/&#34;)[:-1])
        if strings_to_ignore is not None:
            for s in strings_to_ignore:
                if s in parent_directory:
                    fnames_to_ignore.append(fname)
            sorted_fnames = list(set(fnames) - set(fnames_to_ignore))

    if strings_to_include is not None:
        for fname in sorted_fnames:
            parent_directory = &#39;/&#39;.join(fname.split(&#34;/&#34;)[:-1])
            for s in strings_to_include:
                if s in parent_directory:
                    fnames_to_include.append(fname)
        sorted_fnames = list(set(sorted_fnames).intersection(set(fnames_to_include)))
    return sorted_fnames


def _str_in_filename(fnames, strings_to_include=None, strings_to_ignore=None):
    sorted_fnames = []
    if strings_to_ignore is not None:
        for f in fnames:
            f = f.split(&#34;/&#34;)[-1]
            check = [s for s in strings_to_ignore if s.lower() in f.lower()]
    if strings_to_include is not None:
        for s in strings_to_include:
            for f in fnames:
                fname = f.split(&#34;/&#34;)[-1]
                if s.lower() in fname.lower():
                    sorted_fnames.append(f)
    return sorted_fnames


def _check_gpml_or_shp(fnames):
    &#34;&#34;&#34;For topology features, returns GPML by default. Searches for ESRI Shapefiles 
    instead if GPML files not found.&#34;&#34;&#34;
    sorted_fnames = []
    for file in fnames:
        if file.endswith(&#34;.gpml&#34;):
            sorted_fnames.append(file)
        elif file.endswith(&#34;.shp&#34;):
            sorted_fnames.append(file)
    return sorted_fnames


def _remove_hash(fname):
    &#34;&#34;&#34;Removes hashes (32 character file IDs) from cached filenames.&#34;&#34;&#34;
    split_paths = fname.split(&#34;-&#34;)
    cache_path = split_paths[0][:-32]
    new_path = cache_path + &#34;-&#34;.join(split_paths[1:])
    return new_path


def _order_filenames_by_time(fnames):
    &#34;&#34;&#34;Orders filenames in a list from present day to deeper geological time if they
    are labelled by time.&#34;&#34;&#34;
    # Collect all digits in each filename.
    filepath_digits=[]
    for i, file in enumerate(fnames):
        digits = []
        for element in _re.split(&#39;([0-9]+)&#39;, _remove_hash(file)):
            if element.isdigit():
                digits.append(int(str(element)))
        filepath_digits.append(digits)

    # Ignore digits common to all full file paths. This leaves behind the files&#39; 
    # geological time label.
    geological_times = []
    filepath_digits = _np.array(filepath_digits).T
    for digit_array in filepath_digits:
        if not all(digit == digit_array[0] for digit in digit_array):
            geological_times.append(digit_array)

    # If files have geological time labels, allocate indices to the current filename order, 
    # and sort files from recent to deep geological time.
    if geological_times:
        sorted_geological_times = sorted(
            enumerate(geological_times[0]), 
            key=lambda x: x[1]
        )
        sorted_geological_time_indices = [geo_time[0] for geo_time in sorted_geological_times]
        filenames_sorted = [fnames[index] for index in sorted_geological_time_indices]
    else:
        # If given filenames do not have a time label, return them as is.
        filenames_sorted = fnames
    return filenames_sorted


def _collection_sorter(fnames, string_identifier):
    &#34;&#34;&#34;If multiple file collections or plate reconstruction models are downloaded from
    a single zip folder, only return the needed model. 

    The plate models that need separating are listed.&#34;&#34;&#34;

    needs_sorting = [
        &#34;merdith2021&#34;,
        &#34;scotese2008&#34;,
        &#34;golonka2007&#34;,
        &#34;clennett2020&#34;,
        &#34;johansson2018&#34;,
        &#34;whittaker2015&#34;
    ]
    if string_identifier.lower() in needs_sorting:
        studyname = _re.findall(r&#39;[A-Za-z]+|\d+&#39;, string_identifier)[0]
        newfnames = []
        for files in fnames:
            if studyname not in files:
                continue
            newfnames.append(files)
        return newfnames
    else:
        return fnames


def _match_filetype_to_extension(filetype):
    extensions = []
    if filetype == &#34;netCDF&#34;:
        extensions.append(&#34;.nc&#34;)
    elif filetype == &#34;jpeg&#34;:
        extensions.append(&#34;.jpg&#34;)
    elif filetype == &#34;png&#34;:
        extensions.append(&#34;.png&#34;)
    elif filetype == &#34;TIFF&#34;:
        extensions.append(&#34;.tif&#34;)
    return extensions


class DataServer(object):
    &#34;&#34;&#34;Uses Pooch to download plate reconstruction feature data from plate models 
    and other studies that are stored on web servers (e.g. EarthByte&#39;s webDAV server). 
    
    All requested files are downloaded once into a &#39;gplately&#39; cache folder. When 
    workflows requiring these files are rerun, they will be accessed from the cache. 

    Currently, DataServer supports the following plate reconstruction models:

        - Muller et al. 2019 : string identifier &#34;Muller2019&#34;
            Citation: Müller, R. D., Zahirovic, S., Williams, S. E., Cannon, J., Seton, M., 
            Bower, D. J., Tetley, M. G., Heine, C., Le Breton, E., Liu, S., Russell, S. H. J., 
            Yang, T., Leonard, J., and Gurnis, M., 2019, A global plate model including 
            lithospheric deformation along major rifts and orogens since the Triassic: 
            Tectonics, v. 38, no. Fifty Years of Plate Tectonics: Then, Now, and Beyond.
                
        - Muller et al. 2016 : string identifier &#34;Muller2016&#34;
            Citation: Müller R.D., Seton, M., Zahirovic, S., Williams, S.E., Matthews, K.J.,
             Wright, N.M., Shephard, G.E., Maloney, K.T., Barnett-Moore, N., Hosseinpour, M., 
             Bower, D.J., Cannon, J., InPress. Ocean basin evolution and global-scale plate 
             reorganization events since Pangea breakup, Annual Review of Earth and Planetary 
             Sciences, Vol 44, 107-138. DOI: 10.1146/annurev-earth-060115-012211.

        - Merdith et al. 2021 : string identifier &#34;Merdith2021&#34;
            Citation: Merdith et al. (in review), &#39;A continuous, kinematic full-plate motion model
             from 1 Ga to present&#39;

        - Cao et al. 2020 : string identifier &#34;Cao2020&#34;
            Citation: Toy Billion-year reconstructions from Cao et al (2020). 
            Coupled Evolution of Plate Tectonics and Basal Mantle Structure Tectonics, 
            doi: 10.1029/2020GC009244

        - Mather et al. 2021 : string identifier &#34;Mather2021&#34;
            Citation: Mather, B., Müller, R.D.,; Alfonso, C.P., Seton, M., 2021, Kimberlite eruption 
            driven by slab flux and subduction angle. DOI: 10.5281/zenodo.5769002

        - Seton et al. 2012 : string identifier &#34;Seton2012&#34;
            Citation: M. Seton, R.D. Müller, S. Zahirovic, C. Gaina, T.H. Torsvik, G. Shephard, A. Talsma, 
            M. Gurnis, M. Turner, S. Maus, M. Chandler, Global continental and ocean basin reconstructions 
            since 200 Ma, Earth-Science Reviews, Volume 113, Issues 3-4, July 2012, Pages 212-270, 
            ISSN 0012-8252, 10.1016/j.earscirev.2012.03.002.

        - Matthews et al. 2016 : string identifier &#34;Matthews2016&#34;
            Citation: Matthews, K.J., Maloney, K.T., Zahirovic, S., Williams, S.E., Seton, M.,
            and Müller, R.D. (2016). Global plate boundary evolution and kinematics since the 
            late Paleozoic, Global and Planetary Change, 146, 226-250. 
            DOI: 10.1016/j.gloplacha.2016.10.002

        - Merdith et al. 2017 : string identifier &#34;Merdith2017&#34;
            Citation: Merdith, A., Collins, A., Williams, S., Pisarevskiy, S., Foden, J., Archibald, D. 
            and Blades, M. et al. 2016. A full-plate global reconstruction of the Neoproterozoic. 
            Gondwana Research. 50: pp. 84-134. DOI: 10.1016/j.gr.2017.04.001

        - Li et al. 2008 : string identifier &#34;Li2008&#34;
            Citation: Rodinia reconstruction from Li et al (2008), Assembly, configuration, and break-up 
            history of Rodinia: A synthesis. Precambrian Research. 160. 179-210. 
            DOI: 10.1016/j.precamres.2007.04.021.

        - Pehrsson et al. 2015 : string identifier &#34;Pehrsson2015&#34;
            Citation: Pehrsson, S.J., Eglington, B.M., Evans, D.A.D., Huston, D., and Reddy, S.M., (2015),
            Metallogeny and its link to orogenic style during the Nuna supercontinent cycle. Geological 
            Society, London, Special Publications, 424, 83-94. DOI: https://doi.org/10.1144/SP424.5

        - Torsvik and Cocks et al. 2017 : string identifier &#34;TorsvikCocks2017&#34;
            Citation: Torsvik, T., &amp; Cocks, L. (2016). Earth History and Palaeogeography. Cambridge: 
            Cambridge University Press. doi:10.1017/9781316225523

        - Young et al. 2019 : string identifier &#34;Young2019&#34;
            Citation: Young, A., Flament, N., Maloney, K., Williams, S., Matthews, K., Zahirovic, S.,
            Müller, R.D., (2019), Global kinematics of tectonic plates and subduction zones since the late 
            Paleozoic Era, Geoscience Frontiers, Volume 10, Issue 3, pp. 989-1013, ISSN 1674-9871,
            DOI: https://doi.org/10.1016/j.gsf.2018.05.011.

        - Scotese et al. 2008 : string identifier &#34;Scotese2008&#34;
            Citation: Scotese, C.R. 2008. The PALEOMAP Project PaleoAtlas for ArcGIS, Volume 2, Cretaceous 
            paleogeographic and plate tectonic reconstructions. PALEOMAP Project, Arlington, Texas.

        - Golonka et al. 2007 : string identifier &#34;Golonka2007&#34;
            Citation: Golonka, J. 2007. Late Triassic and Early Jurassic palaeogeography of the world. 
            Palaeogeography, Palaeoclimatology, Palaeoecology 244(1–4), 297–307.

        - Clennett et al. 2020 (based on Muller et al. 2019) : string identifier &#34;Clennett2020_M2019&#34;
            Citation: Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
            Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate 
            Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics, 
            Geosystems, 21, e2020GC009117. DOI: https://doi.org/10.1029/2020GC009117

        - Clennett et al. 2020 (rigid topological model based on Shephard et al, 2013) : string identifier &#34;Clennett2020_S2013&#34;
            Citation: Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
            Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate 
            Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics, 
            Geosystems, 21, e2020GC009117. DOI: https://doi.org/10.1029/2020GC009117


    When calling the object, just supply one of these string identifiers. The object
    will look through the requested plate model when calling the following methods:

    Methods
    -------
    get_plate_reconstruction_files
        Downloads the `rotation_model`, `topology_features`, and `static_polygons` 
        needed to create an instance of the &lt;gplately.reconstruction.PlateReconstruction&gt; 
        object. Returns them as &lt;pygplates.RotationModel&gt; and &lt;pygplates.FeatureCollection&gt; 
        instances respectively.
    get_topology_geometries
        Downloads the `coastlines`, `continents` and `COBs` needed to create an instance of the
        &lt;gplately.plot.PlotTopologies&gt; object. These geometries are returned as 
        &lt;pygplates.FeatureCollection&gt; objects.
    get_age_grids
        Downloads netCDF (.nc) and .grd rasters, as well as .tif images

    Examples
    --------
    Calling the object: 
        # string identifier to access the Muller et al. 2019 model
        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    &#34;&#34;&#34;
    def __init__(self, file_collection):

        self.file_collection = file_collection
        self.data_collection = DataCollection(self.file_collection)


    def get_plate_reconstruction_files(self):
        &#34;&#34;&#34;Downloads and constructs a rotation model, a set of dynamic polygons and
        and a set of static polygons needed to call the gplately.PlateReconstruction 
        object.

        Returns
        -------
        rotation_model : instance of &lt;pygplates.RotationModel&gt;
            A rotation model to query equivalent and/or relative topological plate rotations
            from a time in the past relative to another time in the past or to present day.
        topology_features : instance of &lt;pygplates.FeatureCollection&gt;
            Point, polyline and/or polygon feature data in motion through geological time.
        static_polygons : instance of &lt;pygplates.FeatureCollection&gt;
            Present-day polygons whose shapes do not change through geological time. They are
            used to cookie-cut dynamic polygons into identifiable topological plates (assigned 
            an ID) according to their present-day locations.

        Notes
        -----
        This method accesses the plate reconstruction model requested in the 
        gplately.DataServer object. For example, if the object was called as:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        the method will download:
            - a rotation file
                returned as a &lt;pygplates.RotationModel&gt;
            - GPML topology features
                returned as a &lt;pygplates.FeatureCollection&gt;
            - static polygons
                returned as a &lt;pygplates.FeatureCollection&gt;

        from the Muller et al. (2019) plate reconstruction model. If the requested plate 
        model does not have a certain files, say `static_polygons`, a message will be printed 
        to alert the user. 

        Once the reconstruction objects are returned, they can be passed into:

            model = gplately.reconstruction.PlateReconstruction(
                rotation_model
                topology_features,
                coastlines,
                COBs)

        the &lt;gplately.reconstruction.PlateReconstruction&gt; object reconstructs features
        to certain geological times (see documentation for more info).
        &#34;&#34;&#34;

        rotation_filenames = []
        rotation_model = []
        topology_filenames = []
        topology_features = _pygplates.FeatureCollection()
        static_polygons = []

        # Locate all plate reconstruction files from GPlately&#39;s DataCollection
        database = DataCollection.plate_reconstruction_files(self)

        # Set to true if we find the given collection in our database
        found_collection = False
        for collection, url in database.items():

            # Only continue if the user&#39;s chosen collection exists in our database
            if self.file_collection.lower() == collection.lower():
                found_collection = True
                if len(url) == 1:
                    fnames = _collection_sorter(
                        _fetch_from_web(url[0]), self.file_collection
                    )
                    rotation_filenames = _str_in_folder(
                        _collect_file_extension(fnames, [&#34;.rot&#34;]),
                        strings_to_ignore=DataCollection.rotation_strings_to_ignore(self)
                    )

                    #print(rotation_filenames)
                    rotation_model = _pygplates.RotationModel(rotation_filenames)

                    topology_filenames = _collect_file_extension(
                        _str_in_folder(
                            _str_in_filename(fnames, 
                                strings_to_include=DataCollection.dynamic_polygon_strings_to_include(self)
                            ), 
                            strings_to_ignore=DataCollection.dynamic_polygon_strings_to_ignore(self)
                        ),
                        [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                    )
                    #print(topology_filenames)
                    for file in topology_filenames:
                        topology_features.add(_pygplates.FeatureCollection(file))

                    static_polygons = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, 
                                strings_to_include=DataCollection.static_polygon_strings_to_include(self)
                            ),
                            strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                        )
                    )
                    #print(static_polygons)
                else:
                    for file in url[0]:
                        rotation_filenames.append(
                            _collect_file_extension(
                                _fetch_from_web(file), [&#34;.rot&#34;])
                        )
                        rotation_model = _pygplates.RotationModel(rotation_filenames)

                    for file in url[1]:
                        topology_filenames.append(
                            _collect_file_extension(
                                _fetch_from_web(file), [&#34;.gpml&#34;])
                        )
                        for file in topology_filenames:
                            topology_features.add(
                                _pygplates.FeatureCollection(file)
                            )

                    for file in url[2]:
                        static_polygons.append(
                            _check_gpml_or_shp(
                                _str_in_folder(
                                    _str_in_filename(_fetch_from_web(url[0]), 
                                        strings_to_include=DataCollection.static_polygon_strings_to_include(self)
                                    ),    
                                        strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                                )
                            )   
                        )
                break

        if found_collection is False:
            raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

        if not rotation_filenames:
            print(&#34;No .rot files in {}. No rotation model created.&#34;.format(self.file_collection))
        if not topology_filenames:
            print(&#34;No topology features in {}. No FeatureCollection created - unable to plot trenches, ridges and transforms.&#34;.format(self.file_collection))
        if not static_polygons:
            print(&#34;No static polygons in {}.&#34;.format(self.file_collection))

        return rotation_model, topology_features, static_polygons


    def get_topology_geometries(self):
        &#34;&#34;&#34;Downloads coastline, continent and continent-ocean boundary geometries from the 
        requested plate model. These are needed to call the &lt;gplately.plot.PlotTopologies&gt; 
        object.

        Returns
        -------
        continents, coastlines, COBs : instance of &lt;pygplates.FeatureCollection&gt;
            Shapely polygons and polylines resolved from .shp and/or .gpml topology files,
            ready for reconstruction to a particular geological time and plotting.

        Notes
        -----
        This function searches for the plate model requested when calling the 
        &lt;gplately.data.DataServer&gt; object. For example, if the object was called as:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        the method will attempt to download:
            - Coastlines: present-day coastlines cookie-cut using static polygons
            - Continents: cookie-cutting polygons for non-oceanic regions (continents, 
                          intra-oceanic arcs, etc.)
            - COBs: COB line segments
        from the Muller et al. (2019) plate reconstruction model. If found, these files are 
        returned as individual pyGPlates Feature Collections. 

        If the requested plate model does not have a certain geometry, say `continents`, a
        message will be printed to alert the user. 

        Once the continents, coastlines and COBs Feature Collections are returned, they can 
        be passed into:

            gPlot = gplately.plot.PlotTopologies(
                &lt;gplately.reconstruction.PlateReconstruction&gt;,
                time,
                continents,
                coastlines,
                COBs)

        to reconstruct features to a certain geological time. The &lt;gplately.plot.PlotTopologies&gt; 
        object provides simple methods to plot these geometries along with trenches, ridges and 
        transforms (see documentation for more info).
        &#34;&#34;&#34;

        # Locate all topology geometries from GPlately&#39;s DataCollection
        database = DataCollection.topology_geometries(self)

        coastlines = []
        continents = []
        COBs = []
        
        # Find the requested plate model data collection
        found_collection = False
        for collection, url in database.items():

            if self.file_collection.lower() == collection.lower():
                found_collection = True

                if len(url) == 1:
                    fnames = _collection_sorter(
                        _fetch_from_web(url[0]), self.file_collection
                    )
                    coastlines = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(
                                fnames,
                                strings_to_include=DataCollection.coastline_strings_to_include(self)
                            ), 
                            strings_to_ignore=DataCollection.coastline_strings_to_ignore(self)
                        )
                    )
                    continents = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(
                                fnames, 
                                strings_to_include=DataCollection.continent_strings_to_include(self)
                            ), 
                            strings_to_ignore=DataCollection.continent_strings_to_ignore(self)
                        )
                    )
                    COBs = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(
                                fnames,
                                strings_to_include=DataCollection.COB_strings_to_include(self)
                            ), 
                            strings_to_ignore=DataCollection.COB_strings_to_ignore(self)
                        )
                    )
                else:
                    for file in url[0]:
                        coastlines.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;coastline&#34;])
                        )
                        coastlines = _check_gpml_or_shp(coastlines)

                    for file in url[1]:
                        continents.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;continent&#34;])
                        )
                        continents = _check_gpml_or_shp(continents)

                    for file in url[2]:
                        COBs.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;cob&#34;])
                        )
                        COBs = _check_gpml_or_shp(COBs)
                break

        if found_collection is False:
            raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

        if not coastlines:
            print(&#34;No coastlines in {}.&#34;.format(self.file_collection))
        else:
            #print(coastlines)
            coastlines_featurecollection = _pygplates.FeatureCollection()
            for coastline in coastlines:
                coastlines_featurecollection.add(_pygplates.FeatureCollection(coastline))
        
        if not continents:
            print(&#34;No continents in {}.&#34;.format(self.file_collection))
        else:
            #print(continents)
            continents_featurecollection = _pygplates.FeatureCollection()
            for continent in continents:
                continents_featurecollection.add(_pygplates.FeatureCollection(continent))
        
        if not COBs:
            print(&#34;No continent-ocean boundaries in {}.&#34;.format(self.file_collection))
        else:
            #print(COBs)
            COBs_featurecollection = _pygplates.FeatureCollection()
            for COB in COBs:
                COBs_featurecollection.add(_pygplates.FeatureCollection(COB))
        
        geometries = coastlines, continents, COBs
        return geometries


    def get_age_grid(self, time):
        &#34;&#34;&#34;Downloads age grids from plate reconstruction files on GPlately&#39;s DataServer 
        into the &#34;gplately&#34; cache.

        Currently, DataServer supports the following rasters and images:

        - Muller et al. 2019
            Time range: 0-250 Ma
            Seafloor age grid rasters in netCDF format.

        - Muller et al. 2016
            Time range: 0-240 Ma
            Seafloor age grid rasters in netCDF format. 

        Note that this function will download the age grid(s) from the plate model 
        requested via the string identifer passed into the DataServer object. For example, 
        if the object was called as:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        the method will attempt to download age grid(s) from the Muller et al. (2019) plate
        reconstruction model from the geological time(s) requested in the `times` parameter. 
        If found, these age grids are returned as masked arrays. 
        
        Parameters
        ----------
        times : int, or list of int, default=None
            Request an age grid from one or more reconstruction times, e.g. from 0-5 Ma
            requires times=np.arange(0,5). If a single integer is passed, a single raster
            masked array is returned. If a list of integers is passed, a list of raster
            masked arrays is returned.

        Returns
        -------
        raster_array : ndarray
            A masked array containing the read netCDF4 grid, ready for plotting or for
            passing into the &lt;gplately.grid.Raster&gt; object for raster manipulation.

        Raises
        -----
        ValueError
            If `times` (a list of reconstruction times to extract the age grids from) is 
            not passed.

        Notes
        -----
        Once requested age grid(s) are downloaded to the gplately cache once, they are not 
        re-downloaded if the same workflow (or even a different one!) requires them. Rather,
        DataServer fetches them from the cache.
        &#34;&#34;&#34;
        age_grids = []
        age_grid_links = DataCollection.netcdf4_age_grids(self, time)
        for link in age_grid_links:
            age_grid_file = _fetch_from_web(link)
            age_grid = _gplately.grids.read_netcdf_grid(age_grid_file)
            age_grids.append(age_grid)

        if not age_grids:
            raise ValueError(&#34;{} netCDF4 age grids not found.&#34;.format())

        if len(age_grids) == 1:
            return age_grids[0]
        else: 
            return age_grids


    def get_raster(self, raster_id_string=None):
        &#34;&#34;&#34;Downloads assorted rasters and images from the web that are not associated with
        a plate reconstruction model in DataServer into the &#34;gplately&#34; cache.

        Currently supports the following rasters and images:

        - ETOPO1 
            Filetypes available : TIF, netCDF (GRD)
            string identifiers : &#34;ETOPO1_grd&#34;, &#34;ETOPO1_tif&#34;
            A 1-arc minute global relief model combining lang topography and ocean bathymetry.
            Available in netCDF (in .grd) and TIFF (.tif) format. 


        Parameters
        ----------
        raster_id_string : str, default=None
            A string to identify which raster to download.
        filetype : str, default None
            A string to request an age grid of a particular filetype. Currently supports
                - netCDF
                - JPEG
                - PNG

        Returns
        -------
        raster_filenames : list of str
            A list containing the full path to the cached raster(s).

        Raises
        ------
        ValueError
            if a raster_id_string is not supplied.
            if a filetype is not supplied.

        Notes
        -----
        Rasters obtained by this method are (so far) only reconstructed to present-day. 
        &#34;&#34;&#34;
        from matplotlib import image
        if raster_id_string is None:
            raise ValueError(
                &#34;Please specify which raster to download.&#34;
            )
        #filetype = &#34;.&#34;+&#34;_&#34;.split(raster_id_string)[-1]

        archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
        # Set to true if we find the given collection in database
        found_collection = False
        raster_filenames = []
        database = DataCollection.rasters(self)

        for collection, zip_url in database.items():
            # Isolate the raster name and the file type
            #raster_name = collection.split(&#34;_&#34;)[0]
            #raster_type = &#34;.&#34;+collection.split(&#34;_&#34;)[-1]
            if (raster_id_string.lower() == collection.lower()):
                raster_filenames = _fetch_from_web(zip_url[0])
                found_collection = True
                break

        if found_collection is False:
            raise ValueError(&#34;{} not in collection database.&#34;.format(raster_id_string))
        else:
            raster_matrix = image.imread(raster_filenames)
        return raster_matrix


    def get_feature_data(self, feature_data_id_string=None):
        &#34;&#34;&#34;Downloads geological feature data from the web into the &#34;gplately&#34; cache.

        Currently supports the following feature data:

        - Large igneous provinces from Johansson et al. (2018)
            Formats: .gpmlz
            String identifier: &#34;Johansson2018&#34;
            Citation: Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The 
            interplay between the eruption and weathering of Large Igneous Provinces and 
            the deep-time carbon cycle: Geophysical Research Letters.

        - Large igneous province products interpreted as plume products from Whittaker 
        et al. (2015).
            Formats: .gpmlz, .shp
            String identifier: &#34;Whittaker2015&#34;
            Citation: Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D., 
            Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between 
            mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483. 
            doi:10.1038/ngeo2437.

        - Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures, 
        unclassified V-anomalies, propagating ridge lineations and extinct ridges) from 
        Matthews et al. (2011)
            Formats: .gpml
            String identifier: &#34;SeafloorFabric&#34;
            Citation: Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The 
            tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12): 
            B12109, DOI: 10.1029/2011JB008413. 

        - Present day surface hotspot/plume locations from Whittaker et al, (2013)
            Formats: .gpmlz
            String identifier: &#34;Hotspots&#34;
            Citation: Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P., 
            Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and 
            mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.

        
        Parameters
        ----------
        feature_data_id_string : str, default=None
            A string to identify which feature data to download to the cache. See table above.

        Returns
        -------
        feature_data_filenames : list of str
            A list containing the full path to the requested feature data. This is ready to be turned
            into a pygplates.FeatureCollection.

        Raises
        ------
        ValueError
            If a feature_data_id_string is not provided.
        &#34;&#34;&#34;
        if feature_data_id_string is None:
            raise ValueError(
                &#34;Please specify which feature data to fetch.&#34;
            )

        database = DataCollection.feature_data(self)

        found_collection = False
        for collection, zip_url in database.items():
            if feature_data_id_string.lower() == collection.lower():
                found_collection = True
                feature_data_filenames = _collection_sorter(
                    _collect_file_extension(
                    _fetch_from_web(zip_url[0]), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                    ),
                    collection
                )

                break

        feat_data = _pygplates.FeatureCollection()
        if len(feature_data_filenames) == 1:
                feat_data.add(_pygplates.FeatureCollection(feature_data_filenames[0]))
                return feat_data
        else:    
            feat_data=[]
            for file in feature_data_filenames:
                feat_data.append(_pygplates.FeatureCollection(file))
            return feat_data
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gplately.download.DataServer"><code class="flex name class">
<span>class <span class="ident">DataServer</span></span>
<span>(</span><span>file_collection)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses Pooch to download plate reconstruction feature data from plate models
and other studies that are stored on web servers (e.g. EarthByte's webDAV server). </p>
<p>All requested files are downloaded once into a 'gplately' cache folder. When
workflows requiring these files are rerun, they will be accessed from the cache. </p>
<p>Currently, DataServer supports the following plate reconstruction models:</p>
<pre><code>- Muller et al. 2019 : string identifier "Muller2019"
    Citation: Müller, R. D., Zahirovic, S., Williams, S. E., Cannon, J., Seton, M., 
    Bower, D. J., Tetley, M. G., Heine, C., Le Breton, E., Liu, S., Russell, S. H. J., 
    Yang, T., Leonard, J., and Gurnis, M., 2019, A global plate model including 
    lithospheric deformation along major rifts and orogens since the Triassic: 
    Tectonics, v. 38, no. Fifty Years of Plate Tectonics: Then, Now, and Beyond.

- Muller et al. 2016 : string identifier "Muller2016"
    Citation: Müller R.D., Seton, M., Zahirovic, S., Williams, S.E., Matthews, K.J.,
     Wright, N.M., Shephard, G.E., Maloney, K.T., Barnett-Moore, N., Hosseinpour, M., 
     Bower, D.J., Cannon, J., InPress. Ocean basin evolution and global-scale plate 
     reorganization events since Pangea breakup, Annual Review of Earth and Planetary 
     Sciences, Vol 44, 107-138. DOI: 10.1146/annurev-earth-060115-012211.

- Merdith et al. 2021 : string identifier "Merdith2021"
    Citation: Merdith et al. (in review), 'A continuous, kinematic full-plate motion model
     from 1 Ga to present'

- Cao et al. 2020 : string identifier "Cao2020"
    Citation: Toy Billion-year reconstructions from Cao et al (2020). 
    Coupled Evolution of Plate Tectonics and Basal Mantle Structure Tectonics, 
    doi: 10.1029/2020GC009244

- Mather et al. 2021 : string identifier "Mather2021"
    Citation: Mather, B., Müller, R.D.,; Alfonso, C.P., Seton, M., 2021, Kimberlite eruption 
    driven by slab flux and subduction angle. DOI: 10.5281/zenodo.5769002

- Seton et al. 2012 : string identifier "Seton2012"
    Citation: M. Seton, R.D. Müller, S. Zahirovic, C. Gaina, T.H. Torsvik, G. Shephard, A. Talsma, 
    M. Gurnis, M. Turner, S. Maus, M. Chandler, Global continental and ocean basin reconstructions 
    since 200 Ma, Earth-Science Reviews, Volume 113, Issues 3-4, July 2012, Pages 212-270, 
    ISSN 0012-8252, 10.1016/j.earscirev.2012.03.002.

- Matthews et al. 2016 : string identifier "Matthews2016"
    Citation: Matthews, K.J., Maloney, K.T., Zahirovic, S., Williams, S.E., Seton, M.,
    and Müller, R.D. (2016). Global plate boundary evolution and kinematics since the 
    late Paleozoic, Global and Planetary Change, 146, 226-250. 
    DOI: 10.1016/j.gloplacha.2016.10.002

- Merdith et al. 2017 : string identifier "Merdith2017"
    Citation: Merdith, A., Collins, A., Williams, S., Pisarevskiy, S., Foden, J., Archibald, D. 
    and Blades, M. et al. 2016. A full-plate global reconstruction of the Neoproterozoic. 
    Gondwana Research. 50: pp. 84-134. DOI: 10.1016/j.gr.2017.04.001

- Li et al. 2008 : string identifier "Li2008"
    Citation: Rodinia reconstruction from Li et al (2008), Assembly, configuration, and break-up 
    history of Rodinia: A synthesis. Precambrian Research. 160. 179-210. 
    DOI: 10.1016/j.precamres.2007.04.021.

- Pehrsson et al. 2015 : string identifier "Pehrsson2015"
    Citation: Pehrsson, S.J., Eglington, B.M., Evans, D.A.D., Huston, D., and Reddy, S.M., (2015),
    Metallogeny and its link to orogenic style during the Nuna supercontinent cycle. Geological 
    Society, London, Special Publications, 424, 83-94. DOI: &lt;https://doi.org/10.1144/SP424.5&gt;

- Torsvik and Cocks et al. 2017 : string identifier "TorsvikCocks2017"
    Citation: Torsvik, T., &amp; Cocks, L. (2016). Earth History and Palaeogeography. Cambridge: 
    Cambridge University Press. doi:10.1017/9781316225523

- Young et al. 2019 : string identifier "Young2019"
    Citation: Young, A., Flament, N., Maloney, K., Williams, S., Matthews, K., Zahirovic, S.,
    Müller, R.D., (2019), Global kinematics of tectonic plates and subduction zones since the late 
    Paleozoic Era, Geoscience Frontiers, Volume 10, Issue 3, pp. 989-1013, ISSN 1674-9871,
    DOI: &lt;https://doi.org/10.1016/j.gsf.2018.05.011.&gt;

- Scotese et al. 2008 : string identifier "Scotese2008"
    Citation: Scotese, C.R. 2008. The PALEOMAP Project PaleoAtlas for ArcGIS, Volume 2, Cretaceous 
    paleogeographic and plate tectonic reconstructions. PALEOMAP Project, Arlington, Texas.

- Golonka et al. 2007 : string identifier "Golonka2007"
    Citation: Golonka, J. 2007. Late Triassic and Early Jurassic palaeogeography of the world. 
    Palaeogeography, Palaeoclimatology, Palaeoecology 244(1–4), 297–307.

- Clennett et al. 2020 (based on Muller et al. 2019) : string identifier "Clennett2020_M2019"
    Citation: Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
    Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate 
    Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics, 
    Geosystems, 21, e2020GC009117. DOI: &lt;https://doi.org/10.1029/2020GC009117&gt;

- Clennett et al. 2020 (rigid topological model based on Shephard et al, 2013) : string identifier "Clennett2020_S2013"
    Citation: Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
    Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate 
    Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics, 
    Geosystems, 21, e2020GC009117. DOI: &lt;https://doi.org/10.1029/2020GC009117&gt;
</code></pre>
<p>When calling the object, just supply one of these string identifiers. The object
will look through the requested plate model when calling the following methods:</p>
<h2 id="methods">Methods</h2>
<p>get_plate_reconstruction_files
Downloads the <code>rotation_model</code>, <code>topology_features</code>, and <code>static_polygons</code>
needed to create an instance of the <gplately.reconstruction.PlateReconstruction>
object. Returns them as <pygplates.RotationModel> and <pygplates.FeatureCollection>
instances respectively.
get_topology_geometries
Downloads the <code>coastlines</code>, <code>continents</code> and <code>COBs</code> needed to create an instance of the
<gplately.plot.PlotTopologies> object. These geometries are returned as
<pygplates.FeatureCollection> objects.
get_age_grids
Downloads netCDF (.nc) and .grd rasters, as well as .tif images</p>
<h2 id="examples">Examples</h2>
<p>Calling the object:
# string identifier to access the Muller et al. 2019 model
gDownload = gplately.download.DataServer("Muller2019")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataServer(object):
    &#34;&#34;&#34;Uses Pooch to download plate reconstruction feature data from plate models 
    and other studies that are stored on web servers (e.g. EarthByte&#39;s webDAV server). 
    
    All requested files are downloaded once into a &#39;gplately&#39; cache folder. When 
    workflows requiring these files are rerun, they will be accessed from the cache. 

    Currently, DataServer supports the following plate reconstruction models:

        - Muller et al. 2019 : string identifier &#34;Muller2019&#34;
            Citation: Müller, R. D., Zahirovic, S., Williams, S. E., Cannon, J., Seton, M., 
            Bower, D. J., Tetley, M. G., Heine, C., Le Breton, E., Liu, S., Russell, S. H. J., 
            Yang, T., Leonard, J., and Gurnis, M., 2019, A global plate model including 
            lithospheric deformation along major rifts and orogens since the Triassic: 
            Tectonics, v. 38, no. Fifty Years of Plate Tectonics: Then, Now, and Beyond.
                
        - Muller et al. 2016 : string identifier &#34;Muller2016&#34;
            Citation: Müller R.D., Seton, M., Zahirovic, S., Williams, S.E., Matthews, K.J.,
             Wright, N.M., Shephard, G.E., Maloney, K.T., Barnett-Moore, N., Hosseinpour, M., 
             Bower, D.J., Cannon, J., InPress. Ocean basin evolution and global-scale plate 
             reorganization events since Pangea breakup, Annual Review of Earth and Planetary 
             Sciences, Vol 44, 107-138. DOI: 10.1146/annurev-earth-060115-012211.

        - Merdith et al. 2021 : string identifier &#34;Merdith2021&#34;
            Citation: Merdith et al. (in review), &#39;A continuous, kinematic full-plate motion model
             from 1 Ga to present&#39;

        - Cao et al. 2020 : string identifier &#34;Cao2020&#34;
            Citation: Toy Billion-year reconstructions from Cao et al (2020). 
            Coupled Evolution of Plate Tectonics and Basal Mantle Structure Tectonics, 
            doi: 10.1029/2020GC009244

        - Mather et al. 2021 : string identifier &#34;Mather2021&#34;
            Citation: Mather, B., Müller, R.D.,; Alfonso, C.P., Seton, M., 2021, Kimberlite eruption 
            driven by slab flux and subduction angle. DOI: 10.5281/zenodo.5769002

        - Seton et al. 2012 : string identifier &#34;Seton2012&#34;
            Citation: M. Seton, R.D. Müller, S. Zahirovic, C. Gaina, T.H. Torsvik, G. Shephard, A. Talsma, 
            M. Gurnis, M. Turner, S. Maus, M. Chandler, Global continental and ocean basin reconstructions 
            since 200 Ma, Earth-Science Reviews, Volume 113, Issues 3-4, July 2012, Pages 212-270, 
            ISSN 0012-8252, 10.1016/j.earscirev.2012.03.002.

        - Matthews et al. 2016 : string identifier &#34;Matthews2016&#34;
            Citation: Matthews, K.J., Maloney, K.T., Zahirovic, S., Williams, S.E., Seton, M.,
            and Müller, R.D. (2016). Global plate boundary evolution and kinematics since the 
            late Paleozoic, Global and Planetary Change, 146, 226-250. 
            DOI: 10.1016/j.gloplacha.2016.10.002

        - Merdith et al. 2017 : string identifier &#34;Merdith2017&#34;
            Citation: Merdith, A., Collins, A., Williams, S., Pisarevskiy, S., Foden, J., Archibald, D. 
            and Blades, M. et al. 2016. A full-plate global reconstruction of the Neoproterozoic. 
            Gondwana Research. 50: pp. 84-134. DOI: 10.1016/j.gr.2017.04.001

        - Li et al. 2008 : string identifier &#34;Li2008&#34;
            Citation: Rodinia reconstruction from Li et al (2008), Assembly, configuration, and break-up 
            history of Rodinia: A synthesis. Precambrian Research. 160. 179-210. 
            DOI: 10.1016/j.precamres.2007.04.021.

        - Pehrsson et al. 2015 : string identifier &#34;Pehrsson2015&#34;
            Citation: Pehrsson, S.J., Eglington, B.M., Evans, D.A.D., Huston, D., and Reddy, S.M., (2015),
            Metallogeny and its link to orogenic style during the Nuna supercontinent cycle. Geological 
            Society, London, Special Publications, 424, 83-94. DOI: https://doi.org/10.1144/SP424.5

        - Torsvik and Cocks et al. 2017 : string identifier &#34;TorsvikCocks2017&#34;
            Citation: Torsvik, T., &amp; Cocks, L. (2016). Earth History and Palaeogeography. Cambridge: 
            Cambridge University Press. doi:10.1017/9781316225523

        - Young et al. 2019 : string identifier &#34;Young2019&#34;
            Citation: Young, A., Flament, N., Maloney, K., Williams, S., Matthews, K., Zahirovic, S.,
            Müller, R.D., (2019), Global kinematics of tectonic plates and subduction zones since the late 
            Paleozoic Era, Geoscience Frontiers, Volume 10, Issue 3, pp. 989-1013, ISSN 1674-9871,
            DOI: https://doi.org/10.1016/j.gsf.2018.05.011.

        - Scotese et al. 2008 : string identifier &#34;Scotese2008&#34;
            Citation: Scotese, C.R. 2008. The PALEOMAP Project PaleoAtlas for ArcGIS, Volume 2, Cretaceous 
            paleogeographic and plate tectonic reconstructions. PALEOMAP Project, Arlington, Texas.

        - Golonka et al. 2007 : string identifier &#34;Golonka2007&#34;
            Citation: Golonka, J. 2007. Late Triassic and Early Jurassic palaeogeography of the world. 
            Palaeogeography, Palaeoclimatology, Palaeoecology 244(1–4), 297–307.

        - Clennett et al. 2020 (based on Muller et al. 2019) : string identifier &#34;Clennett2020_M2019&#34;
            Citation: Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
            Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate 
            Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics, 
            Geosystems, 21, e2020GC009117. DOI: https://doi.org/10.1029/2020GC009117

        - Clennett et al. 2020 (rigid topological model based on Shephard et al, 2013) : string identifier &#34;Clennett2020_S2013&#34;
            Citation: Clennett, E.J., Sigloch, K., Mihalynuk, M.G., Seton, M., Henderson, M.A., Hosseini, K.,
            Mohammadzaheri, A., Johnston, S.T., Müller, R.D., (2020), A Quantitative Tomotectonic Plate 
            Reconstruction of Western North America and the Eastern Pacific Basin. Geochemistry, Geophysics, 
            Geosystems, 21, e2020GC009117. DOI: https://doi.org/10.1029/2020GC009117


    When calling the object, just supply one of these string identifiers. The object
    will look through the requested plate model when calling the following methods:

    Methods
    -------
    get_plate_reconstruction_files
        Downloads the `rotation_model`, `topology_features`, and `static_polygons` 
        needed to create an instance of the &lt;gplately.reconstruction.PlateReconstruction&gt; 
        object. Returns them as &lt;pygplates.RotationModel&gt; and &lt;pygplates.FeatureCollection&gt; 
        instances respectively.
    get_topology_geometries
        Downloads the `coastlines`, `continents` and `COBs` needed to create an instance of the
        &lt;gplately.plot.PlotTopologies&gt; object. These geometries are returned as 
        &lt;pygplates.FeatureCollection&gt; objects.
    get_age_grids
        Downloads netCDF (.nc) and .grd rasters, as well as .tif images

    Examples
    --------
    Calling the object: 
        # string identifier to access the Muller et al. 2019 model
        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    &#34;&#34;&#34;
    def __init__(self, file_collection):

        self.file_collection = file_collection
        self.data_collection = DataCollection(self.file_collection)


    def get_plate_reconstruction_files(self):
        &#34;&#34;&#34;Downloads and constructs a rotation model, a set of dynamic polygons and
        and a set of static polygons needed to call the gplately.PlateReconstruction 
        object.

        Returns
        -------
        rotation_model : instance of &lt;pygplates.RotationModel&gt;
            A rotation model to query equivalent and/or relative topological plate rotations
            from a time in the past relative to another time in the past or to present day.
        topology_features : instance of &lt;pygplates.FeatureCollection&gt;
            Point, polyline and/or polygon feature data in motion through geological time.
        static_polygons : instance of &lt;pygplates.FeatureCollection&gt;
            Present-day polygons whose shapes do not change through geological time. They are
            used to cookie-cut dynamic polygons into identifiable topological plates (assigned 
            an ID) according to their present-day locations.

        Notes
        -----
        This method accesses the plate reconstruction model requested in the 
        gplately.DataServer object. For example, if the object was called as:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        the method will download:
            - a rotation file
                returned as a &lt;pygplates.RotationModel&gt;
            - GPML topology features
                returned as a &lt;pygplates.FeatureCollection&gt;
            - static polygons
                returned as a &lt;pygplates.FeatureCollection&gt;

        from the Muller et al. (2019) plate reconstruction model. If the requested plate 
        model does not have a certain files, say `static_polygons`, a message will be printed 
        to alert the user. 

        Once the reconstruction objects are returned, they can be passed into:

            model = gplately.reconstruction.PlateReconstruction(
                rotation_model
                topology_features,
                coastlines,
                COBs)

        the &lt;gplately.reconstruction.PlateReconstruction&gt; object reconstructs features
        to certain geological times (see documentation for more info).
        &#34;&#34;&#34;

        rotation_filenames = []
        rotation_model = []
        topology_filenames = []
        topology_features = _pygplates.FeatureCollection()
        static_polygons = []

        # Locate all plate reconstruction files from GPlately&#39;s DataCollection
        database = DataCollection.plate_reconstruction_files(self)

        # Set to true if we find the given collection in our database
        found_collection = False
        for collection, url in database.items():

            # Only continue if the user&#39;s chosen collection exists in our database
            if self.file_collection.lower() == collection.lower():
                found_collection = True
                if len(url) == 1:
                    fnames = _collection_sorter(
                        _fetch_from_web(url[0]), self.file_collection
                    )
                    rotation_filenames = _str_in_folder(
                        _collect_file_extension(fnames, [&#34;.rot&#34;]),
                        strings_to_ignore=DataCollection.rotation_strings_to_ignore(self)
                    )

                    #print(rotation_filenames)
                    rotation_model = _pygplates.RotationModel(rotation_filenames)

                    topology_filenames = _collect_file_extension(
                        _str_in_folder(
                            _str_in_filename(fnames, 
                                strings_to_include=DataCollection.dynamic_polygon_strings_to_include(self)
                            ), 
                            strings_to_ignore=DataCollection.dynamic_polygon_strings_to_ignore(self)
                        ),
                        [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                    )
                    #print(topology_filenames)
                    for file in topology_filenames:
                        topology_features.add(_pygplates.FeatureCollection(file))

                    static_polygons = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(fnames, 
                                strings_to_include=DataCollection.static_polygon_strings_to_include(self)
                            ),
                            strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                        )
                    )
                    #print(static_polygons)
                else:
                    for file in url[0]:
                        rotation_filenames.append(
                            _collect_file_extension(
                                _fetch_from_web(file), [&#34;.rot&#34;])
                        )
                        rotation_model = _pygplates.RotationModel(rotation_filenames)

                    for file in url[1]:
                        topology_filenames.append(
                            _collect_file_extension(
                                _fetch_from_web(file), [&#34;.gpml&#34;])
                        )
                        for file in topology_filenames:
                            topology_features.add(
                                _pygplates.FeatureCollection(file)
                            )

                    for file in url[2]:
                        static_polygons.append(
                            _check_gpml_or_shp(
                                _str_in_folder(
                                    _str_in_filename(_fetch_from_web(url[0]), 
                                        strings_to_include=DataCollection.static_polygon_strings_to_include(self)
                                    ),    
                                        strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                                )
                            )   
                        )
                break

        if found_collection is False:
            raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

        if not rotation_filenames:
            print(&#34;No .rot files in {}. No rotation model created.&#34;.format(self.file_collection))
        if not topology_filenames:
            print(&#34;No topology features in {}. No FeatureCollection created - unable to plot trenches, ridges and transforms.&#34;.format(self.file_collection))
        if not static_polygons:
            print(&#34;No static polygons in {}.&#34;.format(self.file_collection))

        return rotation_model, topology_features, static_polygons


    def get_topology_geometries(self):
        &#34;&#34;&#34;Downloads coastline, continent and continent-ocean boundary geometries from the 
        requested plate model. These are needed to call the &lt;gplately.plot.PlotTopologies&gt; 
        object.

        Returns
        -------
        continents, coastlines, COBs : instance of &lt;pygplates.FeatureCollection&gt;
            Shapely polygons and polylines resolved from .shp and/or .gpml topology files,
            ready for reconstruction to a particular geological time and plotting.

        Notes
        -----
        This function searches for the plate model requested when calling the 
        &lt;gplately.data.DataServer&gt; object. For example, if the object was called as:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        the method will attempt to download:
            - Coastlines: present-day coastlines cookie-cut using static polygons
            - Continents: cookie-cutting polygons for non-oceanic regions (continents, 
                          intra-oceanic arcs, etc.)
            - COBs: COB line segments
        from the Muller et al. (2019) plate reconstruction model. If found, these files are 
        returned as individual pyGPlates Feature Collections. 

        If the requested plate model does not have a certain geometry, say `continents`, a
        message will be printed to alert the user. 

        Once the continents, coastlines and COBs Feature Collections are returned, they can 
        be passed into:

            gPlot = gplately.plot.PlotTopologies(
                &lt;gplately.reconstruction.PlateReconstruction&gt;,
                time,
                continents,
                coastlines,
                COBs)

        to reconstruct features to a certain geological time. The &lt;gplately.plot.PlotTopologies&gt; 
        object provides simple methods to plot these geometries along with trenches, ridges and 
        transforms (see documentation for more info).
        &#34;&#34;&#34;

        # Locate all topology geometries from GPlately&#39;s DataCollection
        database = DataCollection.topology_geometries(self)

        coastlines = []
        continents = []
        COBs = []
        
        # Find the requested plate model data collection
        found_collection = False
        for collection, url in database.items():

            if self.file_collection.lower() == collection.lower():
                found_collection = True

                if len(url) == 1:
                    fnames = _collection_sorter(
                        _fetch_from_web(url[0]), self.file_collection
                    )
                    coastlines = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(
                                fnames,
                                strings_to_include=DataCollection.coastline_strings_to_include(self)
                            ), 
                            strings_to_ignore=DataCollection.coastline_strings_to_ignore(self)
                        )
                    )
                    continents = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(
                                fnames, 
                                strings_to_include=DataCollection.continent_strings_to_include(self)
                            ), 
                            strings_to_ignore=DataCollection.continent_strings_to_ignore(self)
                        )
                    )
                    COBs = _check_gpml_or_shp(
                        _str_in_folder(
                            _str_in_filename(
                                fnames,
                                strings_to_include=DataCollection.COB_strings_to_include(self)
                            ), 
                            strings_to_ignore=DataCollection.COB_strings_to_ignore(self)
                        )
                    )
                else:
                    for file in url[0]:
                        coastlines.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;coastline&#34;])
                        )
                        coastlines = _check_gpml_or_shp(coastlines)

                    for file in url[1]:
                        continents.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;continent&#34;])
                        )
                        continents = _check_gpml_or_shp(continents)

                    for file in url[2]:
                        COBs.append(_str_in_filename(
                            _fetch_from_web(file), 
                            strings_to_include=[&#34;cob&#34;])
                        )
                        COBs = _check_gpml_or_shp(COBs)
                break

        if found_collection is False:
            raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

        if not coastlines:
            print(&#34;No coastlines in {}.&#34;.format(self.file_collection))
        else:
            #print(coastlines)
            coastlines_featurecollection = _pygplates.FeatureCollection()
            for coastline in coastlines:
                coastlines_featurecollection.add(_pygplates.FeatureCollection(coastline))
        
        if not continents:
            print(&#34;No continents in {}.&#34;.format(self.file_collection))
        else:
            #print(continents)
            continents_featurecollection = _pygplates.FeatureCollection()
            for continent in continents:
                continents_featurecollection.add(_pygplates.FeatureCollection(continent))
        
        if not COBs:
            print(&#34;No continent-ocean boundaries in {}.&#34;.format(self.file_collection))
        else:
            #print(COBs)
            COBs_featurecollection = _pygplates.FeatureCollection()
            for COB in COBs:
                COBs_featurecollection.add(_pygplates.FeatureCollection(COB))
        
        geometries = coastlines, continents, COBs
        return geometries


    def get_age_grid(self, time):
        &#34;&#34;&#34;Downloads age grids from plate reconstruction files on GPlately&#39;s DataServer 
        into the &#34;gplately&#34; cache.

        Currently, DataServer supports the following rasters and images:

        - Muller et al. 2019
            Time range: 0-250 Ma
            Seafloor age grid rasters in netCDF format.

        - Muller et al. 2016
            Time range: 0-240 Ma
            Seafloor age grid rasters in netCDF format. 

        Note that this function will download the age grid(s) from the plate model 
        requested via the string identifer passed into the DataServer object. For example, 
        if the object was called as:

            gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

        the method will attempt to download age grid(s) from the Muller et al. (2019) plate
        reconstruction model from the geological time(s) requested in the `times` parameter. 
        If found, these age grids are returned as masked arrays. 
        
        Parameters
        ----------
        times : int, or list of int, default=None
            Request an age grid from one or more reconstruction times, e.g. from 0-5 Ma
            requires times=np.arange(0,5). If a single integer is passed, a single raster
            masked array is returned. If a list of integers is passed, a list of raster
            masked arrays is returned.

        Returns
        -------
        raster_array : ndarray
            A masked array containing the read netCDF4 grid, ready for plotting or for
            passing into the &lt;gplately.grid.Raster&gt; object for raster manipulation.

        Raises
        -----
        ValueError
            If `times` (a list of reconstruction times to extract the age grids from) is 
            not passed.

        Notes
        -----
        Once requested age grid(s) are downloaded to the gplately cache once, they are not 
        re-downloaded if the same workflow (or even a different one!) requires them. Rather,
        DataServer fetches them from the cache.
        &#34;&#34;&#34;
        age_grids = []
        age_grid_links = DataCollection.netcdf4_age_grids(self, time)
        for link in age_grid_links:
            age_grid_file = _fetch_from_web(link)
            age_grid = _gplately.grids.read_netcdf_grid(age_grid_file)
            age_grids.append(age_grid)

        if not age_grids:
            raise ValueError(&#34;{} netCDF4 age grids not found.&#34;.format())

        if len(age_grids) == 1:
            return age_grids[0]
        else: 
            return age_grids


    def get_raster(self, raster_id_string=None):
        &#34;&#34;&#34;Downloads assorted rasters and images from the web that are not associated with
        a plate reconstruction model in DataServer into the &#34;gplately&#34; cache.

        Currently supports the following rasters and images:

        - ETOPO1 
            Filetypes available : TIF, netCDF (GRD)
            string identifiers : &#34;ETOPO1_grd&#34;, &#34;ETOPO1_tif&#34;
            A 1-arc minute global relief model combining lang topography and ocean bathymetry.
            Available in netCDF (in .grd) and TIFF (.tif) format. 


        Parameters
        ----------
        raster_id_string : str, default=None
            A string to identify which raster to download.
        filetype : str, default None
            A string to request an age grid of a particular filetype. Currently supports
                - netCDF
                - JPEG
                - PNG

        Returns
        -------
        raster_filenames : list of str
            A list containing the full path to the cached raster(s).

        Raises
        ------
        ValueError
            if a raster_id_string is not supplied.
            if a filetype is not supplied.

        Notes
        -----
        Rasters obtained by this method are (so far) only reconstructed to present-day. 
        &#34;&#34;&#34;
        from matplotlib import image
        if raster_id_string is None:
            raise ValueError(
                &#34;Please specify which raster to download.&#34;
            )
        #filetype = &#34;.&#34;+&#34;_&#34;.split(raster_id_string)[-1]

        archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
        # Set to true if we find the given collection in database
        found_collection = False
        raster_filenames = []
        database = DataCollection.rasters(self)

        for collection, zip_url in database.items():
            # Isolate the raster name and the file type
            #raster_name = collection.split(&#34;_&#34;)[0]
            #raster_type = &#34;.&#34;+collection.split(&#34;_&#34;)[-1]
            if (raster_id_string.lower() == collection.lower()):
                raster_filenames = _fetch_from_web(zip_url[0])
                found_collection = True
                break

        if found_collection is False:
            raise ValueError(&#34;{} not in collection database.&#34;.format(raster_id_string))
        else:
            raster_matrix = image.imread(raster_filenames)
        return raster_matrix


    def get_feature_data(self, feature_data_id_string=None):
        &#34;&#34;&#34;Downloads geological feature data from the web into the &#34;gplately&#34; cache.

        Currently supports the following feature data:

        - Large igneous provinces from Johansson et al. (2018)
            Formats: .gpmlz
            String identifier: &#34;Johansson2018&#34;
            Citation: Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The 
            interplay between the eruption and weathering of Large Igneous Provinces and 
            the deep-time carbon cycle: Geophysical Research Letters.

        - Large igneous province products interpreted as plume products from Whittaker 
        et al. (2015).
            Formats: .gpmlz, .shp
            String identifier: &#34;Whittaker2015&#34;
            Citation: Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D., 
            Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between 
            mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483. 
            doi:10.1038/ngeo2437.

        - Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures, 
        unclassified V-anomalies, propagating ridge lineations and extinct ridges) from 
        Matthews et al. (2011)
            Formats: .gpml
            String identifier: &#34;SeafloorFabric&#34;
            Citation: Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The 
            tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12): 
            B12109, DOI: 10.1029/2011JB008413. 

        - Present day surface hotspot/plume locations from Whittaker et al, (2013)
            Formats: .gpmlz
            String identifier: &#34;Hotspots&#34;
            Citation: Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P., 
            Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and 
            mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.

        
        Parameters
        ----------
        feature_data_id_string : str, default=None
            A string to identify which feature data to download to the cache. See table above.

        Returns
        -------
        feature_data_filenames : list of str
            A list containing the full path to the requested feature data. This is ready to be turned
            into a pygplates.FeatureCollection.

        Raises
        ------
        ValueError
            If a feature_data_id_string is not provided.
        &#34;&#34;&#34;
        if feature_data_id_string is None:
            raise ValueError(
                &#34;Please specify which feature data to fetch.&#34;
            )

        database = DataCollection.feature_data(self)

        found_collection = False
        for collection, zip_url in database.items():
            if feature_data_id_string.lower() == collection.lower():
                found_collection = True
                feature_data_filenames = _collection_sorter(
                    _collect_file_extension(
                    _fetch_from_web(zip_url[0]), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                    ),
                    collection
                )

                break

        feat_data = _pygplates.FeatureCollection()
        if len(feature_data_filenames) == 1:
                feat_data.add(_pygplates.FeatureCollection(feature_data_filenames[0]))
                return feat_data
        else:    
            feat_data=[]
            for file in feature_data_filenames:
                feat_data.append(_pygplates.FeatureCollection(file))
            return feat_data</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gplately.download.DataServer.get_age_grid"><code class="name flex">
<span>def <span class="ident">get_age_grid</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads age grids from plate reconstruction files on GPlately's DataServer
into the "gplately" cache.</p>
<p>Currently, DataServer supports the following rasters and images:</p>
<ul>
<li>
<p>Muller et al. 2019
Time range: 0-250 Ma
Seafloor age grid rasters in netCDF format.</p>
</li>
<li>
<p>Muller et al. 2016
Time range: 0-240 Ma
Seafloor age grid rasters in netCDF format. </p>
</li>
</ul>
<p>Note that this function will download the age grid(s) from the plate model
requested via the string identifer passed into the DataServer object. For example,
if the object was called as:</p>
<pre><code>gDownload = gplately.download.DataServer("Muller2019")
</code></pre>
<p>the method will attempt to download age grid(s) from the Muller et al. (2019) plate
reconstruction model from the geological time(s) requested in the <code>times</code> parameter.
If found, these age grids are returned as masked arrays. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>times</code></strong> :&ensp;<code>int,</code> or <code>list</code> of <code>int</code>, default=<code>None</code></dt>
<dd>Request an age grid from one or more reconstruction times, e.g. from 0-5 Ma
requires times=np.arange(0,5). If a single integer is passed, a single raster
masked array is returned. If a list of integers is passed, a list of raster
masked arrays is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>raster_array</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>A masked array containing the read netCDF4 grid, ready for plotting or for
passing into the <gplately.grid.Raster> object for raster manipulation.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>times</code> (a list of reconstruction times to extract the age grids from) is
not passed.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Once requested age grid(s) are downloaded to the gplately cache once, they are not
re-downloaded if the same workflow (or even a different one!) requires them. Rather,
DataServer fetches them from the cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_age_grid(self, time):
    &#34;&#34;&#34;Downloads age grids from plate reconstruction files on GPlately&#39;s DataServer 
    into the &#34;gplately&#34; cache.

    Currently, DataServer supports the following rasters and images:

    - Muller et al. 2019
        Time range: 0-250 Ma
        Seafloor age grid rasters in netCDF format.

    - Muller et al. 2016
        Time range: 0-240 Ma
        Seafloor age grid rasters in netCDF format. 

    Note that this function will download the age grid(s) from the plate model 
    requested via the string identifer passed into the DataServer object. For example, 
    if the object was called as:

        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    the method will attempt to download age grid(s) from the Muller et al. (2019) plate
    reconstruction model from the geological time(s) requested in the `times` parameter. 
    If found, these age grids are returned as masked arrays. 
    
    Parameters
    ----------
    times : int, or list of int, default=None
        Request an age grid from one or more reconstruction times, e.g. from 0-5 Ma
        requires times=np.arange(0,5). If a single integer is passed, a single raster
        masked array is returned. If a list of integers is passed, a list of raster
        masked arrays is returned.

    Returns
    -------
    raster_array : ndarray
        A masked array containing the read netCDF4 grid, ready for plotting or for
        passing into the &lt;gplately.grid.Raster&gt; object for raster manipulation.

    Raises
    -----
    ValueError
        If `times` (a list of reconstruction times to extract the age grids from) is 
        not passed.

    Notes
    -----
    Once requested age grid(s) are downloaded to the gplately cache once, they are not 
    re-downloaded if the same workflow (or even a different one!) requires them. Rather,
    DataServer fetches them from the cache.
    &#34;&#34;&#34;
    age_grids = []
    age_grid_links = DataCollection.netcdf4_age_grids(self, time)
    for link in age_grid_links:
        age_grid_file = _fetch_from_web(link)
        age_grid = _gplately.grids.read_netcdf_grid(age_grid_file)
        age_grids.append(age_grid)

    if not age_grids:
        raise ValueError(&#34;{} netCDF4 age grids not found.&#34;.format())

    if len(age_grids) == 1:
        return age_grids[0]
    else: 
        return age_grids</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_feature_data"><code class="name flex">
<span>def <span class="ident">get_feature_data</span></span>(<span>self, feature_data_id_string=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads geological feature data from the web into the "gplately" cache.</p>
<p>Currently supports the following feature data:</p>
<ul>
<li>
<p>Large igneous provinces from Johansson et al. (2018)
Formats: .gpmlz
String identifier: "Johansson2018"
Citation: Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The
interplay between the eruption and weathering of Large Igneous Provinces and
the deep-time carbon cycle: Geophysical Research Letters.</p>
</li>
<li>
<p>Large igneous province products interpreted as plume products from Whittaker
et al. (2015).
Formats: .gpmlz, .shp
String identifier: "Whittaker2015"
Citation: Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D.,
Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between
mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483.
doi:10.1038/ngeo2437.</p>
</li>
<li>
<p>Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures,
unclassified V-anomalies, propagating ridge lineations and extinct ridges) from
Matthews et al. (2011)
Formats: .gpml
String identifier: "SeafloorFabric"
Citation: Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The
tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12):
B12109, DOI: 10.1029/2011JB008413. </p>
</li>
<li>
<p>Present day surface hotspot/plume locations from Whittaker et al, (2013)
Formats: .gpmlz
String identifier: "Hotspots"
Citation: Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P.,
Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and
mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_data_id_string</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>A string to identify which feature data to download to the cache. See table above.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>feature_data_filenames</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list containing the full path to the requested feature data. This is ready to be turned
into a pygplates.FeatureCollection.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a feature_data_id_string is not provided.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_feature_data(self, feature_data_id_string=None):
    &#34;&#34;&#34;Downloads geological feature data from the web into the &#34;gplately&#34; cache.

    Currently supports the following feature data:

    - Large igneous provinces from Johansson et al. (2018)
        Formats: .gpmlz
        String identifier: &#34;Johansson2018&#34;
        Citation: Johansson, L., Zahirovic, S., and Müller, R. D., In Prep, The 
        interplay between the eruption and weathering of Large Igneous Provinces and 
        the deep-time carbon cycle: Geophysical Research Letters.

    - Large igneous province products interpreted as plume products from Whittaker 
    et al. (2015).
        Formats: .gpmlz, .shp
        String identifier: &#34;Whittaker2015&#34;
        Citation: Whittaker, J. M., Afonso, J. C., Masterton, S., Müller, R. D., 
        Wessel, P., Williams, S. E., &amp; Seton, M. (2015). Long-term interaction between 
        mid-ocean ridges and mantle plumes. Nature Geoscience, 8(6), 479-483. 
        doi:10.1038/ngeo2437.

    - Seafloor tectonic fabric (fracture zones, discordant zones, V-shaped structures, 
    unclassified V-anomalies, propagating ridge lineations and extinct ridges) from 
    Matthews et al. (2011)
        Formats: .gpml
        String identifier: &#34;SeafloorFabric&#34;
        Citation: Matthews, K.J., Müller, R.D., Wessel, P. and Whittaker, J.M., 2011. The 
        tectonic fabric of the ocean basins. Journal of Geophysical Research, 116(B12): 
        B12109, DOI: 10.1029/2011JB008413. 

    - Present day surface hotspot/plume locations from Whittaker et al, (2013)
        Formats: .gpmlz
        String identifier: &#34;Hotspots&#34;
        Citation: Whittaker, J., Afonso, J., Masterton, S., Müller, R., Wessel, P., 
        Williams, S., and Seton, M., 2015, Long-term interaction between mid-ocean ridges and 
        mantle plumes: Nature Geoscience, v. 8, no. 6, p. 479-483, doi:10.1038/ngeo2437.

    
    Parameters
    ----------
    feature_data_id_string : str, default=None
        A string to identify which feature data to download to the cache. See table above.

    Returns
    -------
    feature_data_filenames : list of str
        A list containing the full path to the requested feature data. This is ready to be turned
        into a pygplates.FeatureCollection.

    Raises
    ------
    ValueError
        If a feature_data_id_string is not provided.
    &#34;&#34;&#34;
    if feature_data_id_string is None:
        raise ValueError(
            &#34;Please specify which feature data to fetch.&#34;
        )

    database = DataCollection.feature_data(self)

    found_collection = False
    for collection, zip_url in database.items():
        if feature_data_id_string.lower() == collection.lower():
            found_collection = True
            feature_data_filenames = _collection_sorter(
                _collect_file_extension(
                _fetch_from_web(zip_url[0]), [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                ),
                collection
            )

            break

    feat_data = _pygplates.FeatureCollection()
    if len(feature_data_filenames) == 1:
            feat_data.add(_pygplates.FeatureCollection(feature_data_filenames[0]))
            return feat_data
    else:    
        feat_data=[]
        for file in feature_data_filenames:
            feat_data.append(_pygplates.FeatureCollection(file))
        return feat_data</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_plate_reconstruction_files"><code class="name flex">
<span>def <span class="ident">get_plate_reconstruction_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads and constructs a rotation model, a set of dynamic polygons and
and a set of static polygons needed to call the gplately.PlateReconstruction
object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rotation_model</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.RotationModel&gt;</code></dt>
<dd>A rotation model to query equivalent and/or relative topological plate rotations
from a time in the past relative to another time in the past or to present day.</dd>
<dt><strong><code>topology_features</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>Point, polyline and/or polygon feature data in motion through geological time.</dd>
<dt><strong><code>static_polygons</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>Present-day polygons whose shapes do not change through geological time. They are
used to cookie-cut dynamic polygons into identifiable topological plates (assigned
an ID) according to their present-day locations.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This method accesses the plate reconstruction model requested in the
gplately.DataServer object. For example, if the object was called as:</p>
<pre><code>gDownload = gplately.download.DataServer("Muller2019")
</code></pre>
<p>the method will download:
- a rotation file
returned as a <pygplates.RotationModel>
- GPML topology features
returned as a <pygplates.FeatureCollection>
- static polygons
returned as a <pygplates.FeatureCollection></p>
<p>from the Muller et al. (2019) plate reconstruction model. If the requested plate
model does not have a certain files, say <code>static_polygons</code>, a message will be printed
to alert the user. </p>
<p>Once the reconstruction objects are returned, they can be passed into:</p>
<pre><code>model = gplately.reconstruction.PlateReconstruction(
    rotation_model
    topology_features,
    coastlines,
    COBs)
</code></pre>
<p>the <gplately.reconstruction.PlateReconstruction> object reconstructs features
to certain geological times (see documentation for more info).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plate_reconstruction_files(self):
    &#34;&#34;&#34;Downloads and constructs a rotation model, a set of dynamic polygons and
    and a set of static polygons needed to call the gplately.PlateReconstruction 
    object.

    Returns
    -------
    rotation_model : instance of &lt;pygplates.RotationModel&gt;
        A rotation model to query equivalent and/or relative topological plate rotations
        from a time in the past relative to another time in the past or to present day.
    topology_features : instance of &lt;pygplates.FeatureCollection&gt;
        Point, polyline and/or polygon feature data in motion through geological time.
    static_polygons : instance of &lt;pygplates.FeatureCollection&gt;
        Present-day polygons whose shapes do not change through geological time. They are
        used to cookie-cut dynamic polygons into identifiable topological plates (assigned 
        an ID) according to their present-day locations.

    Notes
    -----
    This method accesses the plate reconstruction model requested in the 
    gplately.DataServer object. For example, if the object was called as:

        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    the method will download:
        - a rotation file
            returned as a &lt;pygplates.RotationModel&gt;
        - GPML topology features
            returned as a &lt;pygplates.FeatureCollection&gt;
        - static polygons
            returned as a &lt;pygplates.FeatureCollection&gt;

    from the Muller et al. (2019) plate reconstruction model. If the requested plate 
    model does not have a certain files, say `static_polygons`, a message will be printed 
    to alert the user. 

    Once the reconstruction objects are returned, they can be passed into:

        model = gplately.reconstruction.PlateReconstruction(
            rotation_model
            topology_features,
            coastlines,
            COBs)

    the &lt;gplately.reconstruction.PlateReconstruction&gt; object reconstructs features
    to certain geological times (see documentation for more info).
    &#34;&#34;&#34;

    rotation_filenames = []
    rotation_model = []
    topology_filenames = []
    topology_features = _pygplates.FeatureCollection()
    static_polygons = []

    # Locate all plate reconstruction files from GPlately&#39;s DataCollection
    database = DataCollection.plate_reconstruction_files(self)

    # Set to true if we find the given collection in our database
    found_collection = False
    for collection, url in database.items():

        # Only continue if the user&#39;s chosen collection exists in our database
        if self.file_collection.lower() == collection.lower():
            found_collection = True
            if len(url) == 1:
                fnames = _collection_sorter(
                    _fetch_from_web(url[0]), self.file_collection
                )
                rotation_filenames = _str_in_folder(
                    _collect_file_extension(fnames, [&#34;.rot&#34;]),
                    strings_to_ignore=DataCollection.rotation_strings_to_ignore(self)
                )

                #print(rotation_filenames)
                rotation_model = _pygplates.RotationModel(rotation_filenames)

                topology_filenames = _collect_file_extension(
                    _str_in_folder(
                        _str_in_filename(fnames, 
                            strings_to_include=DataCollection.dynamic_polygon_strings_to_include(self)
                        ), 
                        strings_to_ignore=DataCollection.dynamic_polygon_strings_to_ignore(self)
                    ),
                    [&#34;.gpml&#34;, &#34;.gpmlz&#34;]
                )
                #print(topology_filenames)
                for file in topology_filenames:
                    topology_features.add(_pygplates.FeatureCollection(file))

                static_polygons = _check_gpml_or_shp(
                    _str_in_folder(
                        _str_in_filename(fnames, 
                            strings_to_include=DataCollection.static_polygon_strings_to_include(self)
                        ),
                        strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                    )
                )
                #print(static_polygons)
            else:
                for file in url[0]:
                    rotation_filenames.append(
                        _collect_file_extension(
                            _fetch_from_web(file), [&#34;.rot&#34;])
                    )
                    rotation_model = _pygplates.RotationModel(rotation_filenames)

                for file in url[1]:
                    topology_filenames.append(
                        _collect_file_extension(
                            _fetch_from_web(file), [&#34;.gpml&#34;])
                    )
                    for file in topology_filenames:
                        topology_features.add(
                            _pygplates.FeatureCollection(file)
                        )

                for file in url[2]:
                    static_polygons.append(
                        _check_gpml_or_shp(
                            _str_in_folder(
                                _str_in_filename(_fetch_from_web(url[0]), 
                                    strings_to_include=DataCollection.static_polygon_strings_to_include(self)
                                ),    
                                    strings_to_ignore=DataCollection.static_polygon_strings_to_ignore(self)
                            )
                        )   
                    )
            break

    if found_collection is False:
        raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

    if not rotation_filenames:
        print(&#34;No .rot files in {}. No rotation model created.&#34;.format(self.file_collection))
    if not topology_filenames:
        print(&#34;No topology features in {}. No FeatureCollection created - unable to plot trenches, ridges and transforms.&#34;.format(self.file_collection))
    if not static_polygons:
        print(&#34;No static polygons in {}.&#34;.format(self.file_collection))

    return rotation_model, topology_features, static_polygons</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_raster"><code class="name flex">
<span>def <span class="ident">get_raster</span></span>(<span>self, raster_id_string=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads assorted rasters and images from the web that are not associated with
a plate reconstruction model in DataServer into the "gplately" cache.</p>
<p>Currently supports the following rasters and images:</p>
<ul>
<li>ETOPO1
Filetypes available : TIF, netCDF (GRD)
string identifiers : "ETOPO1_grd", "ETOPO1_tif"
A 1-arc minute global relief model combining lang topography and ocean bathymetry.
Available in netCDF (in .grd) and TIFF (.tif) format. </li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>raster_id_string</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>A string to identify which raster to download.</dd>
<dt><strong><code>filetype</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A string to request an age grid of a particular filetype. Currently supports
- netCDF
- JPEG
- PNG</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>raster_filenames</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list containing the full path to the cached raster(s).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if a raster_id_string is not supplied.
if a filetype is not supplied.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Rasters obtained by this method are (so far) only reconstructed to present-day.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raster(self, raster_id_string=None):
    &#34;&#34;&#34;Downloads assorted rasters and images from the web that are not associated with
    a plate reconstruction model in DataServer into the &#34;gplately&#34; cache.

    Currently supports the following rasters and images:

    - ETOPO1 
        Filetypes available : TIF, netCDF (GRD)
        string identifiers : &#34;ETOPO1_grd&#34;, &#34;ETOPO1_tif&#34;
        A 1-arc minute global relief model combining lang topography and ocean bathymetry.
        Available in netCDF (in .grd) and TIFF (.tif) format. 


    Parameters
    ----------
    raster_id_string : str, default=None
        A string to identify which raster to download.
    filetype : str, default None
        A string to request an age grid of a particular filetype. Currently supports
            - netCDF
            - JPEG
            - PNG

    Returns
    -------
    raster_filenames : list of str
        A list containing the full path to the cached raster(s).

    Raises
    ------
    ValueError
        if a raster_id_string is not supplied.
        if a filetype is not supplied.

    Notes
    -----
    Rasters obtained by this method are (so far) only reconstructed to present-day. 
    &#34;&#34;&#34;
    from matplotlib import image
    if raster_id_string is None:
        raise ValueError(
            &#34;Please specify which raster to download.&#34;
        )
    #filetype = &#34;.&#34;+&#34;_&#34;.split(raster_id_string)[-1]

    archive_formats = tuple([&#34;.gz&#34;, &#34;.xz&#34;, &#34;.bz2&#34;])
    # Set to true if we find the given collection in database
    found_collection = False
    raster_filenames = []
    database = DataCollection.rasters(self)

    for collection, zip_url in database.items():
        # Isolate the raster name and the file type
        #raster_name = collection.split(&#34;_&#34;)[0]
        #raster_type = &#34;.&#34;+collection.split(&#34;_&#34;)[-1]
        if (raster_id_string.lower() == collection.lower()):
            raster_filenames = _fetch_from_web(zip_url[0])
            found_collection = True
            break

    if found_collection is False:
        raise ValueError(&#34;{} not in collection database.&#34;.format(raster_id_string))
    else:
        raster_matrix = image.imread(raster_filenames)
    return raster_matrix</code></pre>
</details>
</dd>
<dt id="gplately.download.DataServer.get_topology_geometries"><code class="name flex">
<span>def <span class="ident">get_topology_geometries</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads coastline, continent and continent-ocean boundary geometries from the
requested plate model. These are needed to call the <gplately.plot.PlotTopologies>
object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>continents</code></strong>, <strong><code>coastlines</code></strong>, <strong><code>COBs</code></strong> :&ensp;<code>instance</code> of <code>&lt;pygplates.FeatureCollection&gt;</code></dt>
<dd>Shapely polygons and polylines resolved from .shp and/or .gpml topology files,
ready for reconstruction to a particular geological time and plotting.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function searches for the plate model requested when calling the
<gplately.data.DataServer> object. For example, if the object was called as:</p>
<pre><code>gDownload = gplately.download.DataServer("Muller2019")
</code></pre>
<p>the method will attempt to download:
- Coastlines: present-day coastlines cookie-cut using static polygons
- Continents: cookie-cutting polygons for non-oceanic regions (continents,
intra-oceanic arcs, etc.)
- COBs: COB line segments
from the Muller et al. (2019) plate reconstruction model. If found, these files are
returned as individual pyGPlates Feature Collections. </p>
<p>If the requested plate model does not have a certain geometry, say <code>continents</code>, a
message will be printed to alert the user. </p>
<p>Once the continents, coastlines and COBs Feature Collections are returned, they can
be passed into:</p>
<pre><code>gPlot = gplately.plot.PlotTopologies(
    &lt;gplately.reconstruction.PlateReconstruction&gt;,
    time,
    continents,
    coastlines,
    COBs)
</code></pre>
<p>to reconstruct features to a certain geological time. The <gplately.plot.PlotTopologies>
object provides simple methods to plot these geometries along with trenches, ridges and
transforms (see documentation for more info).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_topology_geometries(self):
    &#34;&#34;&#34;Downloads coastline, continent and continent-ocean boundary geometries from the 
    requested plate model. These are needed to call the &lt;gplately.plot.PlotTopologies&gt; 
    object.

    Returns
    -------
    continents, coastlines, COBs : instance of &lt;pygplates.FeatureCollection&gt;
        Shapely polygons and polylines resolved from .shp and/or .gpml topology files,
        ready for reconstruction to a particular geological time and plotting.

    Notes
    -----
    This function searches for the plate model requested when calling the 
    &lt;gplately.data.DataServer&gt; object. For example, if the object was called as:

        gDownload = gplately.download.DataServer(&#34;Muller2019&#34;)

    the method will attempt to download:
        - Coastlines: present-day coastlines cookie-cut using static polygons
        - Continents: cookie-cutting polygons for non-oceanic regions (continents, 
                      intra-oceanic arcs, etc.)
        - COBs: COB line segments
    from the Muller et al. (2019) plate reconstruction model. If found, these files are 
    returned as individual pyGPlates Feature Collections. 

    If the requested plate model does not have a certain geometry, say `continents`, a
    message will be printed to alert the user. 

    Once the continents, coastlines and COBs Feature Collections are returned, they can 
    be passed into:

        gPlot = gplately.plot.PlotTopologies(
            &lt;gplately.reconstruction.PlateReconstruction&gt;,
            time,
            continents,
            coastlines,
            COBs)

    to reconstruct features to a certain geological time. The &lt;gplately.plot.PlotTopologies&gt; 
    object provides simple methods to plot these geometries along with trenches, ridges and 
    transforms (see documentation for more info).
    &#34;&#34;&#34;

    # Locate all topology geometries from GPlately&#39;s DataCollection
    database = DataCollection.topology_geometries(self)

    coastlines = []
    continents = []
    COBs = []
    
    # Find the requested plate model data collection
    found_collection = False
    for collection, url in database.items():

        if self.file_collection.lower() == collection.lower():
            found_collection = True

            if len(url) == 1:
                fnames = _collection_sorter(
                    _fetch_from_web(url[0]), self.file_collection
                )
                coastlines = _check_gpml_or_shp(
                    _str_in_folder(
                        _str_in_filename(
                            fnames,
                            strings_to_include=DataCollection.coastline_strings_to_include(self)
                        ), 
                        strings_to_ignore=DataCollection.coastline_strings_to_ignore(self)
                    )
                )
                continents = _check_gpml_or_shp(
                    _str_in_folder(
                        _str_in_filename(
                            fnames, 
                            strings_to_include=DataCollection.continent_strings_to_include(self)
                        ), 
                        strings_to_ignore=DataCollection.continent_strings_to_ignore(self)
                    )
                )
                COBs = _check_gpml_or_shp(
                    _str_in_folder(
                        _str_in_filename(
                            fnames,
                            strings_to_include=DataCollection.COB_strings_to_include(self)
                        ), 
                        strings_to_ignore=DataCollection.COB_strings_to_ignore(self)
                    )
                )
            else:
                for file in url[0]:
                    coastlines.append(_str_in_filename(
                        _fetch_from_web(file), 
                        strings_to_include=[&#34;coastline&#34;])
                    )
                    coastlines = _check_gpml_or_shp(coastlines)

                for file in url[1]:
                    continents.append(_str_in_filename(
                        _fetch_from_web(file), 
                        strings_to_include=[&#34;continent&#34;])
                    )
                    continents = _check_gpml_or_shp(continents)

                for file in url[2]:
                    COBs.append(_str_in_filename(
                        _fetch_from_web(file), 
                        strings_to_include=[&#34;cob&#34;])
                    )
                    COBs = _check_gpml_or_shp(COBs)
            break

    if found_collection is False:
        raise ValueError(&#34;{} is not in GPlately&#39;s DataServer.&#34;.format(self.file_collection))

    if not coastlines:
        print(&#34;No coastlines in {}.&#34;.format(self.file_collection))
    else:
        #print(coastlines)
        coastlines_featurecollection = _pygplates.FeatureCollection()
        for coastline in coastlines:
            coastlines_featurecollection.add(_pygplates.FeatureCollection(coastline))
    
    if not continents:
        print(&#34;No continents in {}.&#34;.format(self.file_collection))
    else:
        #print(continents)
        continents_featurecollection = _pygplates.FeatureCollection()
        for continent in continents:
            continents_featurecollection.add(_pygplates.FeatureCollection(continent))
    
    if not COBs:
        print(&#34;No continent-ocean boundaries in {}.&#34;.format(self.file_collection))
    else:
        #print(COBs)
        COBs_featurecollection = _pygplates.FeatureCollection()
        for COB in COBs:
            COBs_featurecollection.add(_pygplates.FeatureCollection(COB))
    
    geometries = coastlines, continents, COBs
    return geometries</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gplately" href="index.html">gplately</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gplately.download.DataServer" href="#gplately.download.DataServer">DataServer</a></code></h4>
<ul class="">
<li><code><a title="gplately.download.DataServer.get_age_grid" href="#gplately.download.DataServer.get_age_grid">get_age_grid</a></code></li>
<li><code><a title="gplately.download.DataServer.get_feature_data" href="#gplately.download.DataServer.get_feature_data">get_feature_data</a></code></li>
<li><code><a title="gplately.download.DataServer.get_plate_reconstruction_files" href="#gplately.download.DataServer.get_plate_reconstruction_files">get_plate_reconstruction_files</a></code></li>
<li><code><a title="gplately.download.DataServer.get_raster" href="#gplately.download.DataServer.get_raster">get_raster</a></code></li>
<li><code><a title="gplately.download.DataServer.get_topology_geometries" href="#gplately.download.DataServer.get_topology_geometries">get_topology_geometries</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>